

alter session set nls_Language='ENGLISH';
set serveroutput on FORMAT TRUNCATED;
spool spool.txt append;

CREATE OR REPLACE PACKAGE                    MIGR_GVAR AS
 TYPE PropertyAddressRecTyp IS RECORD (
      r_addressId   NUMBER,
      r_address     VARCHAR2(2000),
      r_postCode    VARCHAR2(100),
      r_city        VARCHAR2(100),
      r_countryCode VARCHAR2(50)
    );
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160223

  TYPE PropertyAddressTabTyp IS TABLE OF PropertyAddressRecTyp
    INDEX BY BINARY_INTEGER;
  PropertyAddressTab PropertyAddressTabTyp;

  --Log Record
  TYPE LogRecTyp IS RECORD (
      mig_batch_id MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
      migrArea     MIGR_API_DETAIL_LOG.MIGRATION_AREA % TYPE,
      migrStep     MIGR_API_DETAIL_LOG.MIGRATION_STEP % TYPE,
      migrRelTbl   VARCHAR2(32000),
      migrRelKey   VARCHAR2(32000),
      logMsg       VARCHAR2(32000)

    );

-- +++ anb 2018-11-11  CLOB recording
    --Log Record
  TYPE CLOBRecTyp IS RECORD (
      mig_batch_id MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
      migrArea     MIGR_API_DETAIL_LOG.MIGRATION_AREA % TYPE,
      migrStep     MIGR_API_DETAIL_LOG.MIGRATION_STEP % TYPE,
      migrRelTbl   VARCHAR2(32000),
      migrRelKey   VARCHAR2(32000),
      EVENT_CLOB   CLOB

    );
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  TYPE PolicyRecTyp IS RECORD (
      insr_type          VARCHAR2(50),
      client_id          MIGR_CLIENT.client_id % TYPE,
      MAN_ID             MIGR_CLIENT.MAN_ID% TYPE,
      agent_id            INSIS_PEOPLE_V10.P_AGENTS.agent_id % TYPE,
      agent_belongsTo  INSIS_PEOPLE_V10.P_AGENTS.agent_id % TYPE,
      agent_sales2       INSIS_PEOPLE_V10.P_AGENTS.agent_id % TYPE,
      office_id          NUMBER(30, 0),
      policy_id          POLICY.policy_id % TYPE,
      policy_idpl        NUMBER,
      policy_idplps      NUMBER,
      policy_ref         VARCHAR2(50),
      ia_object_id       VARCHAR2(400),
      mig_batch_id       MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
      parent_objectId    O_OBJECTS.object_id % TYPE,
      object_id          O_OBJECTS.object_id % TYPE,
      object_type        VARCHAR2(50),
      insured_object_id  INSURED_OBJECT.INSURED_OBJ_ID % TYPE,
      insr_begin         DATE,
      migrArea           MIGR_API_DETAIL_LOG.MIGRATION_AREA % TYPE,
      migrRelTbl         MIGR_API_DETAIL_LOG.RELATED_TABLE % TYPE,
      ia_coversTbl       VARCHAR2(30),
      ia_coversInsValTbl VARCHAR2(50),
      ia_questionsTbl    VARCHAR2(30),
      ia_deductiblesTbl  VARCHAR2(30),
      ia_policyTbl       VARCHAR2(30),
      ia_endorsementsTbl VARCHAR2(30),
      ia_participantsTbl VARCHAR2(30),
      IA_PAYM_WAY        VARCHAR2(30),
      IA_BANK_ID         VARCHAR2(100),
      IA_INVOICE         VARCHAR2(100),
      IA_DISTR_METHOD    NUMBER(1),

      ia_discountsTbl    VARCHAR2(30),
      IA_DISCOUNT_TYPE   VARCHAR2(30),

      AGENT_NO           NUMBER,
      migrTbl            VARCHAR2(30),
      insrprd            VARCHAR2(100),
      logMsg             MIGR_API_DETAIL_LOG.EVENT_MESSAGE % TYPE,
      migrStep           MIGR_API_DETAIL_LOG.MIGRATION_STEP % TYPE,
      numInstalments     POLICY.NUM_INSTALMENTS % TYPE,
      property_id        NUMBER,
      policyYear         NUMBER(3, 0),
      productLabel       VARCHAR2(50),
      egn                VARCHAR2(50),
      object_fail_log    VARCHAR2(2000),
      continue_migr      BOOLEAN,
      deduct_val         VARCHAR2(10),
      objDeduct_val      VARCHAR2(10)  ,
      client_migrated  MIGR_CLIENT.MIGRATED%TYPE,
      -- pl 20161027 offering code is the new insr_type
      parent_insr_type   VARCHAR2(50) ,
      --FA.20161118 Checkif product requires property
      require_property   CHAR(1)  ,
      policy_final_step  MIGR_POLICY.POLICY_STEP % TYPE  ,
      product_group      ETL_IA_INSRPRD_CONFIG.PRODUCT_GROUP%TYPE ,
      has_discount       BOOLEAN,
      process_steps      MIGR_GVAR.steps_tab_t,
      api_steps_order    MIGR_GVAR.api_steps_orde_tab_t,
      -----  ia_rec      IA_POLICY%ROWTYPE
      mig_flag           PLS_INTEGER  ,
      require_pinsured   CHAR(1),
      require_documents  CHAR(1),
      require_quest      CHAR(1),
      set_doc_values     CHAR(1),     -- EZ 6/11/2018
      set_special_obj_values CHAR(1)  -- EZ 12/03/2019
  );

  TYPE steps_tab_t IS TABLE OF BOOLEAN INDEX BY VARCHAR2(100);
  steps_tab   steps_tab_t;

  TYPE api_steps_orde_tab_t IS TABLE OF NUMBER INDEX BY VARCHAR2(100);
  api_steps_orde_tab   api_steps_orde_tab_t;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  GV_ANNEX_ID CONSTANT PLS_INTEGER := 0;
  GV_DEBUG CONSTANT VARCHAR2(10)   := 'FALSE';

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --PL.20170126 MIG MIGRATION INFO - STATUS
  GV_STATUS_PENDING    CONSTANT VARCHAR2(50) := 'Pending';
  GV_STATUS_RUNNING    CONSTANT VARCHAR2(50) := 'Running';
  GV_STATUS_FINISHED   CONSTANT VARCHAR2(50) := 'Finished';
  GV_STATUS_FAILED     CONSTANT VARCHAR2(50) := 'Failed';
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --PL.20161221 MIG MIGRATION INFO - BATCH STATUSES
  GV_BATCH_STATUS_RUNNING      CONSTANT VARCHAR2(50) := 'Running';
  GV_BATCH_STATUS_RUNNING_DISC CONSTANT VARCHAR2(50) := 'Running_Discounts';
  GV_BATCH_STATUS_RUNNING_CL CONSTANT VARCHAR2(50) := 'Running_Clients';
  GV_BATCH_STATUS_QUEUED       CONSTANT VARCHAR2(50) := 'Queued';
  GV_BATCH_STATUS_QUEUED_DISC  CONSTANT VARCHAR2(50) := 'Queued_Discounts';
  GV_BATCH_STATUS_WAIT_DISC    CONSTANT VARCHAR2(50) := 'Wait_Discounts';
  GV_BATCH_STATUS_FINISHED     CONSTANT VARCHAR2(50) := 'Finished';
  GV_BATCH_STATUS_FINISHED_CL     CONSTANT VARCHAR2(50) := 'Finished_Clients';
  GV_BATCH_STATUS_FAILED       CONSTANT VARCHAR2(50) := 'Failed';
  GV_BATCH_STATUS_INCOMPLETE   CONSTANT VARCHAR2(50) := 'Incomplete';
  GV_BATCH_STATUS_REJECTED     CONSTANT VARCHAR2(50) := 'Rejected';
  GV_BATCH_STATUS_STOPPED      CONSTANT VARCHAR2(50) := 'Stopped';

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160705 MIG_FLAG STATUSES
  GV_MIG_FLAG_PENDING           CONSTANT PLS_INTEGER :=  0;
  GV_MIG_FLAG_SUCCESS           CONSTANT PLS_INTEGER :=  1;
  GV_MIG_FLAG_DUPLICATE         CONSTANT PLS_INTEGER :=  2;
  GV_MIG_FLAG_RULES_EXCLUSION   CONSTANT PLS_INTEGER :=  3;
  GV_MIG_FLAG_UNDEFINED_PRD     CONSTANT PLS_INTEGER :=  4;
  GV_MIG_FLAG_FAILED            CONSTANT PLS_INTEGER :=  5;
  GV_MIG_FLAG_RUNNING           CONSTANT PLS_INTEGER :=  6;
  GV_MIG_FLAG_SKIPPED           CONSTANT PLS_INTEGER :=  7;
  GV_MIG_FLAG_WAIT_DISCOUNTS    CONSTANT PLS_INTEGER :=  8;
  GV_MIG_FLAG_RUNNING_DISCOUNTS CONSTANT PLS_INTEGER :=  9;
  GV_MIG_FLAG_FAILED_DISCOUNTS  CONSTANT PLS_INTEGER := 10;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160407 Event Result Status
  GV_EVRES_SUCCESS   CONSTANT PLS_INTEGER :=  1;
  GV_EVRES_WARNING   CONSTANT PLS_INTEGER :=  0;
  GV_EVRES_ERROR     CONSTANT PLS_INTEGER := -1;
  GV_EVRES_UNDEFINED CONSTANT PLS_INTEGER := -2;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160418 DEFAULT VALUES
  GV_DEFAULT_AGENT_NO  VARCHAR2(100);
  GV_DEFAULT_AGENT_ID  VARCHAR2(100);
  --GV_DEFAULT_OFFICE_ID  VARCHAR2(100);
  --GV_DEFAULT_MIGR_USER  ETL_SETUP_INFO.MIGRATION_USER % TYPE;
  GV_DEFAULT_MIGRATE_CLIENT  ETL_SETUP_INFO.MIGRATE_CLIENTS  % TYPE;
  GV_MIGRATION_METHOD        ETL_SETUP_INFO.MIGRATION_METHOD % TYPE;
  GV_DEFAULT_EVENT CHAR(1);
  GV_DEFAULT_AGENT CHAR(1);

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Declare Log Constants
  C_ERR_INFO      CONSTANT VARCHAR2(20) := 'Information';
  C_ERR_EXCEPTION CONSTANT VARCHAR2(20) := 'EXCEPTION';
  C_ERR_ERROR     CONSTANT VARCHAR2(20) := 'ERROR';
  C_ERR_WARN      CONSTANT VARCHAR2(20) := 'WARNING';

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --PL.20170406 RUN LA-SA-IA STATUS
  GV_MD_DISC_STATUS_COMPLETE    CONSTANT VARCHAR2(20) := 'COMPLETE';
  GV_MD_DISC_STATUS_INCOMPLETE  CONSTANT VARCHAR2(20) := 'INCOMPLETE';
  GV_MD_DISC_STATUS_FAILED_DISC CONSTANT VARCHAR2(20) := 'FAILED_DISC';

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA.20170918 Iteration Status;
  GV_ITERATION_COMPLETED CONSTANT VARCHAR2(20) :='Completed';
  -- Email Notification GVs
  --------------------------
  -- Declare Email Notification Log Constants
  GV_MSG_CODE_MIGR_STARTED       CONSTANT VARCHAR2(10 BYTE) := 'M00001';
  GV_MSG_CODE_MIGR_PHASE_2       CONSTANT VARCHAR2(10 BYTE) := 'M00003';
  GV_MSG_CODE_MIGR_COMPLETED     CONSTANT VARCHAR2(10 BYTE) := 'M00005';
  GV_MSG_CODE_RESUMED            CONSTANT VARCHAR2(10 BYTE) := 'M00010';
  GV_MSG_CODE_MIGR_INCOMPLETE    CONSTANT VARCHAR2(10 BYTE) := 'M00015';
  GV_MSG_CODE_MIGR_FAILED        CONSTANT VARCHAR2(10 BYTE) := 'M00020';
  GV_MSG_CODE_MIGR_FAILED_DISC   CONSTANT VARCHAR2(10 BYTE) := 'M00021';
  GV_MSG_CODE_MIGR_FAILED_API    CONSTANT VARCHAR2(10 BYTE) := 'M00022';
  GV_MSG_CODE_MIGR_REJECTED      CONSTANT VARCHAR2(10 BYTE) := 'M00025';
  GV_MSG_CODE_MIGR_TXT_REMINDER  CONSTANT VARCHAR2(10 BYTE) := 'M00030';
  GV_MSG_CODE_MIGR_DISC_REMINDER CONSTANT VARCHAR2(10 BYTE) := 'M00035';
  GV_MSG_CODE_MIGR_MISSING_TXT   CONSTANT VARCHAR2(10 BYTE) := 'M00040';
  GV_MSG_CODE_MIGR_MISSING_DISC  CONSTANT VARCHAR2(10 BYTE) := 'M00045';
  GV_MSG_CODE_MIGR_DEFAULT_DISC  CONSTANT VARCHAR2(10 BYTE) := 'M00048';
  GV_MSG_CODE_MIGR_WAIT_DISC     CONSTANT VARCHAR2(10 BYTE) := 'M00050';
  GV_MSG_CODE_MIGR_DISC_REPORT   CONSTANT VARCHAR2(10 BYTE) := 'M00051';
  GV_MSG_CODE_MIGR_FINAL_REPORT  CONSTANT VARCHAR2(10 BYTE) := 'M00052';
  GV_MSG_CODE_MIGR_SIGNAL_POSTP  CONSTANT VARCHAR2(10 BYTE) := 'M00055';
  GV_MSG_CODE_MIGR_DAILY_PROGRSS CONSTANT VARCHAR2(10 BYTE) := 'M00080';
  GV_MSG_CODE_MIGR_TBL_SPC_ERR   CONSTANT VARCHAR2(10 BYTE) := 'M10001';
  GV_MSG_CODE_MIGR_MIG_FLAG_ERR  CONSTANT VARCHAR2(10 BYTE) := 'M10005';
  GV_MSG_CODE_PROCESS_DELAY      CONSTANT VARCHAR2(10 BYTE) := 'M10010';
  GV_MSG_CODE_ENVIRONMENT_ERR    CONSTANT VARCHAR2(10 BYTE) := 'M10025';
  GV_MSG_CODE_FAIL_ARCHIVE_DATA   CONSTANT VARCHAR2(10 BYTE) := 'M10030';
  GV_MSG_CODE_MIGR_CLIENT_START  CONSTANT VARCHAR2(10 BYTE) := 'M80000';
  GV_MSG_CODE_MIGR_CL_CLEANUP    CONSTANT VARCHAR2(10 BYTE) := 'M80005';
  GV_MSG_CODE_MIGR_CLIENT_END    CONSTANT VARCHAR2(10 BYTE) := 'M80010';
  GV_MSG_CODE_MIGR_END           CONSTANT VARCHAR2(10 BYTE) := 'M99999';
  GV_MSG_CODE_FAIL_GET_DEF_DISC  CONSTANT VARCHAR2(10 BYTE) := 'M00049';
  -- Email Notification Statuses
  GV_MSG_STATUS_NEW       CONSTANT VARCHAR2(20 BYTE) := 'New';
  GV_MSG_STATUS_SENT      CONSTANT VARCHAR2(20 BYTE) := 'Sent';
  GV_MSG_STATUS_FAILED    CONSTANT VARCHAR2(20 BYTE) := 'Failed';
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Declare Log Level: EXCEPTION - ERROR  messages should  always be registered in log table
  GV_DEBUG_INFO    CONSTANT BOOLEAN := TRUE;
  GV_DEBUG_WARNING CONSTANT BOOLEAN := TRUE;
  GV_LOG_TIMER     CONSTANT BOOLEAN := TRUE;

END MIGR_GVAR;
/

CREATE OR REPLACE PACKAGE               MIGR_MAPS
  AS

PROCEDURE RUN_MAPS;

END MIGR_MAPS;
/

CREATE OR REPLACE PACKAGE                   MIGR_SYSTEM
--------------------------------------------------------------------------------
-- Purpose: Contains procedures for migrating People info into INSIS
--          Reads all People info from TEST_CLIENT table and attempts to post them in INSIS
--
-- MODIFICATION HISTORY
-- Person               Date         Comments
-- ---------            ------       ------------------------------------------
-- Andreas Boyatzoglou  13.05.2015   Initial version
---------------------------------------------------------------------------------------------------------------------------------------------------------------
IS
----------------------------------------------------------------------------------
---- Setup dummy data
----------------------------------------------------------------------------------
--PROCEDURE MIGR_SETUPDUMMY
--      (pi_MaxUniqID   IN     VARCHAR2
--);
----------------------------------------------------------------------------------
--
----------------------------------------------------------------------------------
---- Main Routine
----------------------------------------------------------------------------------
--
--PROCEDURE MIGR_MAIN (
--                p_debug in VARCHAR2
--);
--
----------------------------------------------------------------------------------
-- +++ anb 2016-01-18 for MIGR_LOG_LINE_R('TRUE', LogLine
  --FA.20161221 Use one log mechanism- Avoid package state invalidation
  /*TYPE LogLineRecTyp IS RECORD (
       MIGRATION_BATCH_ID MIG_MIGRATION_INFO.MIGRATION_BATCH_ID%TYPE    --VARCHAR2(50)
     , MIGRATION_AREA     VARCHAR2(50)
     , EVENT_TYPE         VARCHAR2(50)          --    , ERROR_TYPE          VARCHAR2
     , EVENT_MESSAGE      VARCHAR2(2000)        --    , ERROR_MESSAGE       VARCHAR2
     , MIGRATION_STEP     VARCHAR2(256)
     , RELATED_TABLE      VARCHAR2(2000)
     , RELATED_KEY        VARCHAR2(2000)
    );  */
--  TYPE LogLineTabTyp IS TABLE OF LogLineRecTyp
--    INDEX BY BINARY_INTEGER;
--  LogLineTab   LogLineTabTyp;
--------------------------------------------------------------------------------
-- Log in MIGR_API_DETAIL_LOG and Print in DBMS_OUTPUT based on Debug param
--------------------------------------------------------------------------------
  --FA.20161221 Use one log mechanism- Avoid package state invalidation
/*PROCEDURE MIGR_LOG_LINE_R (
    P_DEBUG             IN VARCHAR2
  , rLogLine            IN MIGR_SYSTEM.LogLineRecTyp
);     */
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Invoke INSIS Service Bus Events
--------------------------------------------------------------------------------
PROCEDURE CALL_EVENT (
    EVENT_NAME      IN  VARCHAR2
  , IN_CONTEXT      IN  SRVCONTEXT
  , DEBUG_ON        IN  VARCHAR2
  , OUT_CONTEXT     OUT SRVCONTEXT
  , PIO_ERR         IN OUT SRVERR
);

--------------------------------------------------------------------------------
---PROCEDURE DELETE_INSIS_POLICY;        --v.alex.29/7/16

  ---PROCEDURE DELETE_INSIS_POLICY(p_policy_id IN MIGR_POLICY.POLICY_ID % TYPE); --v.alex.9/9/16
---------------------------------------------------------------------------------


PROCEDURE CALL_EVENT (
    EVENT_NAME      IN  VARCHAR2
  , IN_CONTEXT      IN  SRVCONTEXT
  , DEBUG_ON        IN  VARCHAR2
  , OUT_CONTEXT     OUT SRVCONTEXT
  , PIO_ERR         IN OUT SRVERR
  , LOG_ERR         IN  VARCHAR2            -- overloading , log errors -- +++ anb 2016-05-20
);

--------------------------------------------------------------------------------
--FA. 20160105 DECLARE ERROR TYPE CONSTANTS
    C_ERR_INFO          CONSTANT  VARCHAR2(20) :='Information';
    C_ERR_EXCEPTION     CONSTANT  VARCHAR2(10) :='ERROR';
    C_ERR_ERROR         CONSTANT  VARCHAR2(20) :='EXCEPTION';
    C_ERR_WARN          CONSTANT  VARCHAR2(20) :='WARNING';
--------------------------------------------------------------------------------
-- Print in DBMS_OUTPUT based on Debug param
--------------------------------------------------------------------------------
PROCEDURE PRINT_LINE (
    P_DEBUG     VARCHAR2
  , MSG_LINE IN VARCHAR2
);
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Print PIO_ERR in DBMS_OUTPUT based on Debug param
--------------------------------------------------------------------------------
PROCEDURE PRINT_ERR (
    P_DEBUG     VARCHAR2
  , PIO_ERR     IN OUT SRVERR
);
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Print CONTEXT in DBMS_OUTPUT based on Debug param
--------------------------------------------------------------------------------
PROCEDURE PRINT_CONTEXT (
    DEBUG_ON        IN  VARCHAR2
  , IN_MSG          IN  VARCHAR2
  , IN_CONTEXT      IN  SRVCONTEXT
);
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Print Exception Msg and PIO_ERR          +++ anb 2015-09-18
--------------------------------------------------------------------------------
PROCEDURE PRINT_EXCEPTION (
    P_DEBUG     IN VARCHAR2
  , MSG_LINE    IN VARCHAR2
  , PIO_ERR     IN OUT SRVERR);
--------------------------------------------------------------------------------
-- Log in MIGR_API_DETAIL_LOG and Print in DBMS_OUTPUT based on Debug param
--------------------------------------------------------------------------------
  --FA.20161221 Use one log mechanism
/*PROCEDURE MIGR_LOG_LINE (
    P_DEBUG             IN VARCHAR2
  , MIGRATION_BATCH_ID  IN VARCHAR2
  , MIGRATION_AREA      IN VARCHAR2
  , MIGRATION_STEP      IN VARCHAR2
  , ERROR_TYPE          IN VARCHAR2
  , ERROR_MESSAGE       IN VARCHAR2
  , RELATED_TABLE       IN VARCHAR2
  , RELATED_KEY         IN VARCHAR2
);     */
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Log PIO_ERR in MIGR_API_DETAIL_LOG and Print in DBMS_OUTPUT based on Debug param
--------------------------------------------------------------------------------
  --FA.20161221 Use one log mechanism- Avoid package state invalidation
/*PROCEDURE MIGR_LOG_ERR (
    P_DEBUG     VARCHAR2
  , P_EVENT     IN VARCHAR2
  , PIO_ERR     IN OUT SRVERR
);    */
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
---FA. 20151117 Log migr_volume_log
PROCEDURE MIGR_LOG_VOLUME (
      p_MIGRATION_BATCH_ID  IN VARCHAR2
    , p_MIGRATION_AREA      IN VARCHAR2
    , p_RELATED_TABLE       IN VARCHAR2
    , p_beginTimer          TIMESTAMP WITH TIME ZONE
    , p_EndTimer            TIMESTAMP WITH TIME ZONE
    , p_status              IN VARCHAR2
    , p_TotRows             PLS_INTEGER
    , p_RowsSuccess         PLS_INTEGER
    , p_RowsSkipped         PLS_INTEGER
    , p_RowsErrors          PLS_INTEGER
) ;

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Function for timing events
--------------------------------------------------------------------------------
FUNCTION fn_ELAPSEDms (
                p_end IN TIMESTAMP WITH TIME ZONE
              , p_start  IN TIMESTAMP WITH TIME ZONE)
RETURN  NUMBER ;
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- Init sequences

PROCEDURE INIT_SYSTEM ;

  PROCEDURE batch_steps_duration (batch_id in varchar2);

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

  PROCEDURE CANCEL_INSIS_POLICY(p_policy_id IN MIGR_POLICY.POLICY_ID % TYPE,p_bolag_id IN VARCHAR2 );

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

/*
-- flow diagram

  initialize();

  open cursor with people infor

      for each person (
           INSIS_PEOPLE_V10.srv_people_bo.InsertClient (
                                            given_name;
                                            family_name;
                                            sex;
                                            egn;
                                            birth_date;
           )
           returns MAN_ID, CLIENT_ID

           INSIS_PEOPLE_V10.srv_people_dm.UpdatePeople (
                                            MAN_ID,
--                                      - MAN_COMP - Flag, point if the record      HST-PEOPLE_MAN_COMP.
--                                        is for a physical entity or for a
--                                        legal one;
--                                      - EGN - PID of the person or unique ID
--                                        for Commercial customers;
--                                      - NAME - Name (for persons it is
--                                        constructed from GNAME, SNAME, FNAME);
--                                      - GNAME - First name (for persons only);
--                                      - SNAME - Surname name (for persons only);
--                                      - FNAME - Family name (for persons only);
--                                      - BIRTH_DATE - burth date (for persons
--                                        only);
--                                      - SEX - Gender.(For legal entities 0 is
--                                        used); N/A
--                                      - NOTES - Notes (free text0;
--                                      - NATIONALITY - Nationality N/A;    HT_NATIONALITY.
--                                      - COMP_TYPE - When the entity  is           HT_PEOPLE_COMPANY_TYPES.
--                                        commercial the field contains type of
--                                        commercial entity (Limited company,
--                                        Public Limited company, etc)
--                                       (Commercial customers only);
--                                      - NAME_SUFFIX - Name suffix (Jr. etc.);
--                                      - NAME_PREFIX - Name preffix (Prof., Dr.
--                                        etc);
--                                      - DATA_SOURCE - Information source          HT_PEOPLE_DATA_SOURCE.
--                                        (INSIS) or other System;
--                                      - LANGUAGE - Preferred language for         HT_LANGUAGE.
--                                        commuincation; N/A
--                                      - HOME_COUNTRY - Two letter country code    HT_COUNTRIES.
--                                        for person home country; N/A
--                                      - REGISTRATION_DATE - Date of
--                                        registration;
--                                      - INDUSTRY_CODE - Company main industry     HT_PEOPLE_OCCUP_SUBCODE.
--                                        code (Commercial customers only);
--                                      - SUB_INDUSTRY_CODE - Company sub           HT_PEOPLE_OCCUP_SUBCODE.
--                                        industry code (Commercial customers
--                                        only);
--                                      - FISCAL_PERIOD - N/A
--                                      - CLASS_CODE - Classification code          HT_PEOPLE_CLASS_CODE.
--                                        (Usefull when two level definition is needed)
--                                      - CLASS_SUB_CODE - Classification subcode   HT_PEOPLE_CLASS_CODE.
--                                        (Usefull when two level definition is needed)
--                                      - ATTR1 - Userdefined info                  H_PEOPLE_ATTR1.
--                                      - ATTR2 - Userdefined info                  H_PEOPLE_ATTR2.
--                                      - ATTR3 - Userdefined info                  H_PEOPLE_ATTR3.
--                                      - ATTR4 - Userdefined info                  H_PEOPLE_ATTR4.
--                                      - ATTR5 - Userdefined info                  H_PEOPLE_ATTR5.
           )

           for each address (
                srv_people_dm.InsertAddress ( MAN_ID
                                        - ADDRESS_ID is returned in context <--------!!!!!
--                                      - ADDRESS_TYPE - Type of the address.
--                                        Possible list of values is stored in
--                                        HT_ADDRESS_TYPE table (mandatory);
--                                      - COUNTRY - Country name;
--                                      - CITY - City name;
--                                      - ADDRESS - Address constructed(mandatory)
--                                      - POST_CODE - Pstal/ZIP code;
--                                      - ADDRESS_NOTE _ Free text note;
--                                      - COUNTRY_CODE - Code of country.
--                                        Possible list of values is sotred in
--                                        HT_COUNTRIES table;
      --                                      - ADDRESS_ID - Address unique number
      --                                        (mandatory);
--                                      - COUNTRY_STATE -  State;
--                                      - MAIL_YN -  Do person wahts this
--                                        address to be used for delivery of
--                                        mail;
--                                      - INVOICE_YN - -  Do person wahts this
--                                        address to be used for delivery of
--                                        ivoices;
--                                      - STATE_REGION -  Region;
--                                      - TERRITORY_CLASS - Class of territory;
--                                      - CITY_CODE -  City code;
--                                      - STREET_ID -  Street ID;
--                                      - STREET_NUMBER - Street number;
--                                      - BLOCK_NUMBER -  Block number;
--                                      - ENTRANCE_NUMBER - Entarance number;
--                                      - FLOOR_NUMBER - floor number;
--                                      - APARTMENT_NUMBER
--                                      - QUARTER_ID -  Code of quarter;
--                                      - STATE_NAME -  N/A;
--                                      - REGION_NAME - Region name;
--                                      - QUARTER_NAME - Quarter code;
--                                      - STREET_NAME - Street name;
--                                      - VALID_FROM - The field contains the
--                                         date from which the address details
--                                         are valid;
--                                      - VALID_TO - The Address is not in use
--                                         after  the date entered in the field;
--                                      - USAGE_DATE_FROM - For seasonal usage:
--                                         contain the season begin (Day-Month)
--                                      - USAGE_DATE_TO - For seasonal usage:-
--                                         contain the season end  (Day-Month)
--                                      - PRIMARY_FLAG - Identifier whether the
--                                         respective address is the main
--                                         (primary) one.

                )
           )   (end for each address)
      )  (end for each person)
)

*/

---------------------------------------------------------------------------------------------------------------------
END MIGR_SYSTEM;
/

CREATE OR REPLACE PACKAGE                   MIGR_API
  AS
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE GET_NEXT_BATCH(vMigrationBatchId OUT MIGR_POLICY.MIG_BATCH_ID % TYPE, vStatus OUT VARCHAR2);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE GET_NEXT_IDPL(vNextIDPL OUT MIGR_POLICY.POLICY_IDPL % TYPE, vMigrationBatchId IN MIGR_POLICY.MIG_BATCH_ID % TYPE, vStatus IN VARCHAR2);

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE TRUNCATE_MIGR_TABLES;
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE WAIT_ANY_API_ALERT (vCOUNTER IN OUT PLS_INTEGER, vEXCEPTION_COUNTER IN OUT PLS_INTEGER);

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE STATE_MACHINE_RUN_API;
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_API;
/

CREATE OR REPLACE PACKAGE               MIGR_API_LEISURE_HOME
  AS

  FUNCTION  MIGRATE_LEISURE_HOME(p_policyRec IN  MIGR_GVAR.PolicyRecTyp) RETURN  MIGR_GVAR.PolicyRecTyp;

END MIGR_API_LEISURE_HOME;
/

CREATE OR REPLACE package                    as_read_xlsx
is
/**********************************************
**
** Author: Anton Scheffer
** Date: 19-01-2013
** Website: http://technology.amis.nl/blog
**
** Changelog:
** 18-02-2013 - Ralph Bieber
                Handle cell type "str" to prevent ORA-06502
                if cell content is a string calculated by formula,
                then cell type is "str" instead of "s" and value is inside <v> tag
** 19-02-2013 - Ralph Bieber
                Add column formula in tp_one_cell record, to show, if value is calculated by formula
** 20-02-2013 - Anton Scheffer
                Handle cell types 'inlineStr' and 'e' to prevent ORA-06502
** 19-03-2013 - Anton Scheffer
                Support for formatted and empty strings
                Handle columns per row to prevent ORA-31186: Document contains too many nodes
** 12-06-2013 - Anton Scheffer
                Handle sharedStrings.xml on older Oracle database versions
** 18-09-2013 - Anton Scheffer
                Fix for LPX-00200 could not convert from encoding UTF-8 to ...
                (Note, this is an error I can't reproduce myself, maybe depending on database version and characterset)
                Thank you Stanislav Safonov for this solution
                Handle numbers with scientific notation
** 20-01-2014 - Anton Scheffer
                Fix for a large number (60000+) of strings
** 16-05-2014 - Anton Scheffer
                round to 15 digits

******************************************************************************
******************************************************************************
Copyright (C) 2013 by Anton Scheffer

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

******************************************************************************
*************************************************************************** */
/*
**
** Some examples
**
--
-- every sheet and every cell
    select *
    from table( as_read_xlsx.read( as_read_xlsx.file2blob( 'DOC', 'Book1.xlsx' ) ) )
--
-- cell A3 from the first and the second sheet
    select *
    from table( as_read_xlsx.read( as_read_xlsx.file2blob( 'DOC', 'Book1.xlsx' ), '1:2', 'A3' ) )
--
-- every cell from the sheet with the name "Sheet3"
    select *
    from table( as_read_xlsx.read( as_read_xlsx.file2blob( 'DOC', 'Book1.xlsx' ), 'Sheet3' ) )
--
*/
  type tp_one_cell is record
    ( sheet_nr number(2)
    , sheet_name varchar(4000)
    , row_nr number(10)
    , col_nr number(10)
    , cell varchar2(100)
    , cell_type varchar2(1)
    , string_val varchar2(4000)
    , number_val number
    , date_val date
    , formula varchar2(4000)
  );
  type tp_all_cells is table of tp_one_cell;
--
  function read( p_xlsx blob, p_sheets varchar2 := null, p_cell varchar2 := null )
  return tp_all_cells pipelined;
--
  function file2blob
    ( p_dir varchar2
    , p_file_name varchar2
    )
  return blob;
--
end as_read_xlsx;
/

CREATE OR REPLACE PACKAGE                    MIGR_LOCK_UTILS
  AS

  FUNCTION  GET_HANDLE(p_lock_name IN VARCHAR2)  RETURN VARCHAR2;

 FUNCTION REQUEST_LOCK(p_lock_handle IN VARCHAR2,p_lock_name IN VARCHAR2) RETURN BOOLEAN;

  PROCEDURE RELEASE_LOCK(p_lock_name IN VARCHAR2);

END MIGR_LOCK_UTILS;
/

CREATE OR REPLACE PACKAGE                   MIGR_SIGNAL IS

  --PARAM1: file directory
  --PARAM2: file name
  FUNCTION  IS_FILE_EXISTS
  ( DIR IN VARCHAR2,
    FILE_NAME IN VARCHAR2) RETURN PLS_INTEGER;
---------------------------------------------
---------------------------------------------
  PROCEDURE CLOSE_PREVIOUS_BATCH_JOBS(vBOLAG_ID IN PLS_INTEGER);
---------------------------------------------
---------------------------------------------
  --Queue batch   -- step10 from demo
  FUNCTION INIT_BATCH2(vBOLAG_ID IN PLS_INTEGER,p_queued_flag IN VARCHAR2) RETURN VARCHAR2;
---------------------------------------------
---------------------------------------------
--Get next Queued batch and make it runnable
FUNCTION GET_NEXT_QUEUED(P_BOLAG IN NUMBER) RETURN VARCHAR2 ;
  FUNCTION GET_NEXT_QUEUED RETURN VARCHAR2 ;
---------------------------------------------
---------------------------------------------
--Make a batch runnable
PROCEDURE MAKE_RUNNABLE(vMigrationBatchID IN VARCHAR2, v_status IN VARCHAR2);
---------------------------------------------
---------------------------------------------
PROCEDURE CLOSE_BATCH(vMigrationBatchID IN VARCHAR2, pStatus in varchar2);
---------------------------------------------
---------------------------------------------
PROCEDURE RUN_SIGNAL(p_queued_flag IN VARCHAR2);
---------------------------------------------
---------------------------------------------
FUNCTION INSERT_BATCH_JOB(vBOLAG_ID IN PLS_INTEGER, p_status IN VARCHAR2) RETURN VARCHAR2;
 ---------------------------------------------
---------------------------------------------
PROCEDURE LOG_NOT_MIGRATED_BOLAGS(p_id IN PLS_INTEGER, p_applicable_bolags IN VARCHAR2);
---------------------------------------------
---------------------------------------------
PROCEDURE MIGRATION_SCHEDULE(v_id OUT PLS_INTEGER, v_scan_for_completed OUT BOOLEAN, v_scan_for_discounts OUT boolean);
---------------------------------------------
---------------------------------------------
PROCEDURE CHECK_FILES(p_queued_flag IN VARCHAR2) ;
---------------------------------------------
---------------------------------------------
PROCEDURE LOG_NOT_MIGRATED_BOLAGS_DISC(p_id IN PLS_INTEGER, p_applicable_bolags IN VARCHAR2);
---------------------------------------------
---------------------------------------------
PROCEDURE TXT_NOT_FOUND_REMINDER(p_id IN PLS_INTEGER, p_applicable_bolags IN VARCHAR2, p_status IN VARCHAR2);
---------------------------------------------
---------------------------------------------


END MIGR_SIGNAL;
/

CREATE OR REPLACE PACKAGE                   MIGR_SETUP
  AS
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  -- This is to be placed between READ_EXCEL and CREATE_TABLES in MIGR_SETUP.RUN_SETUP
  -- Returns FALSE if problems were found; TRUE if no problems/errors

  FUNCTION VERIFY_ETL_TABLES
    RETURN BOOLEAN;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE THAT Truncates statistics tables
  PROCEDURE TRUNCATE_STATS;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE THAT CREATES LA,SA AND DF TABLES
  PROCEDURE CREATE_TABLES;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --function that returns the attribute fields based on file name
  FUNCTION FETCH_ATTR(FILE_NAME    IN VARCHAR2,
                      NO_TYPES     IN BOOLEAN,
                      IS_SA        IN BOOLEAN,
                      W_ADD_FIELDS IN BOOLEAN,
                      ADDTNL       IN BOOLEAN)
    RETURN VARCHAR2;

    FUNCTION FETCH_ATTR_ext(FILE_NAME    IN VARCHAR2,
                      NO_TYPES     IN BOOLEAN,
                      IS_SA        IN BOOLEAN,
                      W_ADD_FIELDS IN BOOLEAN,
                      ADDTNL       IN BOOLEAN)
    RETURN VARCHAR2;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE THAT DROPS ALL DIRECTORY OBJECTS
  PROCEDURE DROP_DIR_OBJS;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE THAT DROPS ALL TABLE OBJECTS (T_SA,T_LA,T_DF)
  PROCEDURE DROP_TABLES_OBJS;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDUERE THAT INITIALIZES DIRECTORY OBJECTS
  PROCEDURE INIT_DIRECTORY_OBJECTS;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --MAIN SETUP PROCEDURE
  PROCEDURE RUN_SETUP(p_schema IN VARCHAR2);

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  -- PROCEDURE THAT READS MIGG EXCEL FILE    AND INSERTS CONTENTS INTO ETL_MIGG_SOURCES
  PROCEDURE READ_EXCEL;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  -- PROCEDURE THAT CREATES ETL ENGINE
  PROCEDURE REBUILD_ETL;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE THAT CREATES,DROP AND TRUNCATES SA TABLES
  PROCEDURE TBL_OPERATION_SA(OPERATION IN VARCHAR2);

  PROCEDURE TBL_OPERATION_SA_clustering(OPERATION IN VARCHAR2);

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE THAT CREATES,DROP AND TRUNCATES LA TABLES
  PROCEDURE TBL_OPERATION_LA(OPERATION IN VARCHAR2);

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE TBL_OPERATION_EXT(OPERATION IN VARCHAR2);

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE CLIENT_TBL_OPERATION_EXT(OPERATION IN VARCHAR2) ;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE CHECK_SID (p_flag IN PLS_INTEGER);

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE lob_replace(p_lob IN OUT CLOB,p_what IN VARCHAR2,p_with IN VARCHAR2,p_occur in number := 1, p_case in varchar2 := 'ci');

END MIGR_SETUP;
/

CREATE OR REPLACE PACKAGE                   MIGR_PROCESS_RESUME  aS
 PROCEDURE DELETE_SA(p_migration_batch_id IN VARCHAR2, SA_status OUT varchar2);
  PROCEDURE DELETE_LA(p_migration_batch_id IN VARCHAR2, LA_Status  OUT VARCHAR2);
  PROCEDURE DELETE_IA(p_migration_batch_id IN VARCHAR2, IA_status OUT varchar2);
  PROCEDURE RESUME_MAIN (P_BOLAG_ID IN NUMBER);
  PROCEDURE RESUME_MAIN ;
  PROCEDURE CHECK_PROCESS_STATUS(p_migration_batch_id IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,  resume_step OUT VARCHAR2);
  PROCEDURE initialize_Running_policies;
  PROCEDURE DELETE_LA_to_IA_DISCOUNTS(p_migration_batch_id IN VARCHAR2, Status  OUT VARCHAR2);
END MIGR_PROCESS_RESUME;
/

CREATE OR REPLACE PACKAGE                   MIGR_RULES
  AS

  -------------------------------------------------------------------------------------------------------------
  -- +++ anb 2015-10-20 mark SA_KF100F records with appropriate Product definition
  PROCEDURE MARK_PRODUCTS(VMigrationBatchId IN VARCHAR2, p_status OUT VARCHAR2);

  PROCEDURE MARK_OFFERINGS(VMigrationBatchId IN VARCHAR2, p_status OUT VARCHAR2);

  ------------------------------------------------------------------------------------------------------
  PROCEDURE RUN_EXCLUDE_PRODUCTS(VMigrationBatchId IN VARCHAR2, p_status OUT varchar2);

  ------------------------------------------------------------------------------------------------------
  PROCEDURE RUN_EXCLUSION_RULES(VMigrationBatchId IN VARCHAR2, p_status OUT varchar2);
  ------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_EXCLUSION_RULES_FLD(VMigrationBatchId IN VARCHAR2, p_status OUT varchar2);
  ------------------------------------------------------------------------------------------------------

  PROCEDURE UPDATE_SA_TABLES(p_MigrationId IN VARCHAR2,
                             vSTEP_AREA    IN VARCHAR2, p_status OUT varchar2);

  ------------------------------------------------------------------------------------------------------
  PROCEDURE RUN_RULES(vMigrationBatchId IN VARCHAR2, Rules_Status  OUT VARCHAR2);

  ------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_COVER_UPDATE_RULES (p_migrBatchId IN VARCHAR2);

  PROCEDURE UPDATE_COVER_ON_DEDUCT_RULES (p_migrBatchId IN VARCHAR2);

  PROCEDURE RUN_TRANSLATION_RULES (p_migrBatchId IN VARCHAR2);

  PROCEDURE UPDATE_MAP_OUTHOUSE_LABEL (p_migrBatchId IN VARCHAR2);

  PROCEDURE UPDATE_SPECIFIED_DESCRIPTION (p_migrBatchId IN VARCHAR2);
  ------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------
  PROCEDURE RUN_OBJ_EXCLUSION_RULES;
-- Incorporated into new RUN_EXCLUSION_RULES
--PROCEDURE RUN_EXCLUSION_RULES_TST(VMigrationBatchId IN VARCHAR2);
--
--PROCEDURE GET_VALUES_FROM_RULE_STRING(vRuleAsString IN VARCHAR2, vRuleNo OUT VARCHAR2
--      , vRuleEnabled OUT VARCHAR2, vRecordsExcluded OUT VARCHAR2);



---- new procedure 20150914 AM - combines: unpackaged procedure TEST_DYN_MIGR_RULES_TST with RUN_EXCLUSION_RULES_TST
-- UPDATE: On Sep-14-2015 this procecure has been renamed to the main one: RUN_EXCLUSION_RULES
-- PROCEDURE DYNAMIC_RULES_EXEC_TST(vMigrationBatchID IN VARCHAR2);


-------- LEGACY CODE FROM HERE ONWARDS -----
------ PROCEDURE PERFORM_VALIDATION
---- This procedure performs the necessary Referential Integrity and Data Validation Rules
---- based on the MIGRATION_RULES table
--PROCEDURE PERFORM_VALIDATION;
--
--  -- 3 Aug ---
--PROCEDURE VALIDATE_POLICY_DATE_LA(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
--PROCEDURE VALID_POLICY_END_DATE_LA(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
--PROCEDURE VALID_AGENT(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
--PROCEDURE VALIDATE_POLICY_NUMBER(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
---- 4 Aug ---
--PROCEDURE VALIDATE_AGENT(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
--PROCEDURE VALIDATE_CLIENT(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
--PROCEDURE VALIDATE_SITE(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
--PROCEDURE VALIDATE_SITE_ADDRESS(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
--PROCEDURE VALIDATE_POLICY_POS_TYPE(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
--PROCEDURE VALIDATE_CLIENT_ADDRESS(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
--PROCEDURE VALIDATE_SHIP_OBJECT(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
--PROCEDURE VALIDATE_ENGINE(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);
--
--PROCEDURE VALIDATE_EXTENDED_PROTECTION(bolagID IN PLS_INTEGER, tableName IN NVARCHAR2);


END MIGR_RULES;
/

CREATE OR REPLACE PACKAGE                   MIGR_API_BOAT
  AS

  FUNCTION  MIGRATE_BOAT(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)  RETURN  MIGR_GVAR.PolicyRecTyp;

END;
/

CREATE OR REPLACE PACKAGE                   MIGR_API_CLIENTS
  AS

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------

   PROCEDURE SETUP_CLIENT(p_migrationBatchId IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE);
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
   PROCEDURE SETUP_CLIENT_ADDRESS(p_migrationBatchId MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE);
 ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
   PROCEDURE MIGRATE_CLIENT_ADDRESS(vEGN               IN  P_PEOPLE.EGN % TYPE,
                                    vMAN_ID            IN  P_PEOPLE.MAN_ID % TYPE,
                                    vMADDRESS          IN  VARCHAR2,
                                    vADDRESS_ID        OUT P_ADDRESS.ADDRESS_ID % TYPE,
                                    p_migrationBatchId IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE);
---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
   PROCEDURE MIGRATE_CLIENT(
                           --v_ID_EGN           IN  SA_KF100F.PENR % TYPE,    +++ anb 2016-05-31 use only IA_ tables
                           --v_ID_EGN           IN  IA_CLIENT.IA_EGN % TYPE,
                           v_ID_EGN           IN  MIGR_CLIENT.EGN % TYPE,
                           v_MAN_ID           OUT P_PEOPLE.MAN_ID % TYPE,
                           v_CLIENT_ID        OUT P_CLIENTS.CLIENT_ID % TYPE,
                           p_migrationBatchId IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE); --,
  -- p_IDPL             IN  IA_CLIENT.IA_IDPL % TYPE);
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
   FUNCTION ADD_PRIV_INS_PARTICIPANTS(p_policyRec IN MIGR_GVAR.PolicyRecTyp,l_man_id IN NUMBER)
    RETURN BOOLEAN;
  PROCEDURE GET_CUSTOMER_FROM_INSIS(P_PID       IN  VARCHAR2,
                                    L_CLIENT_ID OUT P_CLIENTS.CLIENT_ID % TYPE,
                                    L_MAN_ID    OUT P_PEOPLE.MAN_ID % TYPE);

---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------

  FUNCTION GET_PEOPLE_BY_PID(p_Pid IN VARCHAR2)
    RETURN P_PEOPLE.MAN_ID % TYPE;
---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------

  FUNCTION INSERT_CLIENT(p_gname      IN VARCHAR2,
                         p_sname      IN VARCHAR2,
                         p_fname      IN VARCHAR2,
                         p_pid        IN VARCHAR2,
                         p_gender     IN NUMBER,
                         p_birth_date IN DATE)
    RETURN P_PEOPLE.MAN_ID % TYPE;
---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------


  FUNCTION ADD_POL_PARTICIPANTS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN BOOLEAN;
---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------


  --FA.20160520 For insured objects: private accident insured person insert person in p_people.No need for client role
  FUNCTION INSERT_PEOPLE(p_gname      IN VARCHAR2,
                         p_sname      IN VARCHAR2,
                         p_fname      IN VARCHAR2,
                         p_pid        IN VARCHAR2,
                         p_gender     IN NUMBER,
                         p_birth_date IN DATE)

    RETURN P_PEOPLE.MAN_ID % TYPE ;
---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------


END MIGR_API_CLIENTS;
/

CREATE OR REPLACE PACKAGE                   MIGR_IA
  AS

  ---- IA stage --------------------------------------------------------------
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  -- +++ anb 2016-04-18 no need for parameter passing
  --  PROCEDURE REBUILD_SA_IA(p_schema IN VARCHAR2);        -- Initialize SetupOperation
  PROCEDURE REBUILD_SA_IA;                                 -- Initialize SetupOperation
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------

  ----------------------------------------------------------------------------
  PROCEDURE RUN_IA_SETUP;        -- SetupOperation
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  PROCEDURE IA_LOG_VOL(Migration_area    IN VARCHAR2,
                       Step_message      IN VARCHAR2,
                       Status            IN VARCHAR2,
                       TableName         IN VARCHAR2,
                       vMigrationBatchId IN VARCHAR2);

  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  PROCEDURE IA_CLEAN_UP_XFER(vMigrationBatchId IN VARCHAR2);
     PROCEDURE TRUNCATE_IA_TABLES;
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  PROCEDURE IA_MAIN(p_migrBatchId IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                    O_STATUS      OUT VARCHAR2);

  PROCEDURE IA_MAIN_TBL (p_LogRec     MIGR_GVAR.LogRecTyp,
                         O_STATUS OUT VARCHAR2,
                         p_status IN  VARCHAR2);

  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  PROCEDURE UPDATE_SA_IA(p_MigrationId IN VARCHAR2);
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  PROCEDURE RUN_IA(p_migrBatchId IN  VARCHAR2,
                      IA_Status  OUT VARCHAR2);

END MIGR_IA;
/

CREATE OR REPLACE PACKAGE                   MIGR_LA_SA
  AS

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE fill_SA_B_PRSN(p_migrBatchId IN  VARCHAR2);
  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE fill_SA_B_address(p_migrBatchId IN  VARCHAR2);

  --------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(p_LogRec MIGR_GVAR.LogRecTyp);

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2); -- PL 20161221

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_ROW_COUNT(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2); -- PL 20161221

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_MATCHING(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2); -- PL 20161221

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_NON_MATCH(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2); -- PL 20161221

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_MATCHING_RECORDS(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2); -- PL 20161221

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
   FUNCTION INSERT_RECORDS_IN_HISTORY(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2, p_renewal in date) RETURN BOOLEAN;

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE TRUNCATE_ALL;

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(steparea          IN VARCHAR2,
                                           stepmessage       IN VARCHAR2,
                                           vMigrationBatchId IN VARCHAR2,
                                           vtablename        IN VARCHAR2);

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  FUNCTION INSERT_RECORDS_IN_HISTORY_SA(p_LogRec MIGR_GVAR.LogRecTyp, p_Status in varchar2) RETURN BOOLEAN; -- PL 20161221
  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LA_MIG_FLAG(p_LogRec MIGR_GVAR.LogRecTyp);
  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_LA(p_migrBatchId IN  VARCHAR2, LA_Status  OUT VARCHAR2);
  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_SA(p_migrBatchId IN  VARCHAR2, SA_Status  OUT VARCHAR2);
 --------------------------------------------------------------------------------------------------------------------------------------------------
 --------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION landing_extra_where(p_LogRec MIGR_GVAR.LogRecTyp) RETURN VARCHAR2;
  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_RECORDS_NOT_IN_MASTER_FILE(p_LogRec IN MIGR_GVAR.LogRecTyp, p_renewal in date);
 --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_LA_SA;
/

CREATE OR REPLACE PACKAGE                   MIGR_API_POLICY
  AS

    PROCEDURE MIGRATE_POLICY(P_MIGRBATCHID IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,P_IDPL        IN VARCHAR2);

    PROCEDURE CONVERT_APPLICATION (p_policyrec   IN OUT MIGR_GVAR.PolicyRecTyp);

END MIGR_API_POLICY;
/

CREATE OR REPLACE PACKAGE               MIGR_API_VILLAHEM
  AS

  FUNCTION MIGRATE_VILLAHEM(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp;

END MIGR_API_VILLAHEM;
/

CREATE OR REPLACE PACKAGE               MIGR_API_TRAVEL
  AS


  FUNCTION  MIGRATE_TRAVEL(p_policyRec IN  MIGR_GVAR.PolicyRecTyp) RETURN MIGR_GVAR.PolicyRecTyp;


END;
/

CREATE OR REPLACE PACKAGE                   MIGR_API_COVERS
  AS



 -------------------------------------------------------------------------------------------------------------------------------
 -------------------------------------------------------------------------------------------------------------------------------
  FUNCTION GET_COVER_INSURED_VALUE(p_statement     IN VARCHAR2,
                                   p_num_of_params IN NUMBER,
                                   p_idpl             NUMBER,
                                   p_idplps           NUMBER,
                                   p_ia_object_id  IN VARCHAR2,
                                   p_mig_batch_id  IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE)
    RETURN NUMBER;
  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  PROCEDURE  MIGRATE_DEDUCTIBLES(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp)  ;

  ------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------

  FUNCTION MIGRATE_COVERS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)  RETURN MIGR_GVAR.PolicyRecTyp;
  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------

  FUNCTION FILL_COVERS_FOR_SELECT(p_policyRec IN MIGR_GVAR.PolicyRecTyp)   RETURN BOOLEAN;
  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------
  --Del_Cover Events isn't working in devmig -Let's check when syt and dev mig are synchronized

  FUNCTION DELETE_INSR_OBJ_COVERS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)  RETURN BOOLEAN;

  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------

  FUNCTION APPLY_SELECTED_COVER(p_policyRec IN MIGR_GVAR.PolicyRecTyp)  RETURN BOOLEAN;
  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------

 FUNCTION UPDATE_INSR_OBJ_COVERS(p_policyRec  MIGR_GVAR.PolicyRecTyp)   RETURN  MIGR_GVAR.PolicyRecTyp;

  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------
  FUNCTION UPDATE_COVER_INSURED_VAL(p_policyRec   IN MIGR_GVAR.PolicyRecTyp, p_coverType   IN VARCHAR2, p_insured_val IN NUMBER)  RETURN MIGR_GVAR.PolicyRecTyp;
  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------

END MIGR_API_COVERS;
/

CREATE OR REPLACE PACKAGE               MIGR_API_QUESTIONS
  AS

  --PROCEDURE MIGRATE_QUESTIONS(p_policyRec IN MIGR_GVAR.PolicyRecTyp);
  ---------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------
     PROCEDURE MIGRATE_POLICY_QUESTIONS(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp);
   --- PROCEDURE MIGRATE_POLICY_QUESTIONS_NEW(p_policyRec IN MIGR_API_COMMON.PolicyRecTyp);

END MIGR_API_QUESTIONS;
/

CREATE OR REPLACE PACKAGE                   MIGR_SCHEDULED_JOBS
  AS
  PROCEDURE START_JOBS;
  PROCEDURE STOP_MIGR_RUNNING_JOB(p_job_name IN VARCHAR2);
  PROCEDURE DROP_MIGR_JOB(p_job_name IN VARCHAR2);
  PROCEDURE DISABLE_MIGR_JOB(p_job_name IN VARCHAR2);
  PROCEDURE RUN_PARALLEL;
    PROCEDURE CREATE_MIGR_JOBS(p_job_name        IN VARCHAR2,
                             p_job_action      IN VARCHAR2,
                             p_repeat_interval IN VARCHAR2,
                             p_start_date      IN TIMESTAMP,
                             p_end_date        IN TIMESTAMP);

  PROCEDURE ENABLE_MIGR_JOB(p_job_name IN VARCHAR2);



  -- +++ anb 2016-04-28     called from RUN_MIGRATION().
  PROCEDURE CREATE_PROGRAM;

    ---PROCEDURE RUN_PARALLEL_DISCOUNTS;

END MIGR_SCHEDULED_JOBS;
/

CREATE OR REPLACE PACKAGE                   MIGR_ARCHIVE AS

PROCEDURE ARCHIVE_MUTUAL; --valex.12/9/2016 - vSchema was not used, as the procedure scans all batches, so it is removed

FUNCTION ARCHIVE_MUTUAL_DATA( vBatchID IN VARCHAR2)   RETURN BOOLEAN;

PROCEDURE ARCHIVE_COMPLETED_FILE(vBatchID IN VARCHAR2);

PROCEDURE ARCHIVE_MD_DISCOUNTS_FILE(vBatchID IN VARCHAR2);

  -- PROCEDURE THAT CREATES MIG% TABLES
  PROCEDURE BUILD_MIG_ARCHIVE_TBL(ARCHIVE_SCHEMA IN VARCHAR2);

  --PROCEDURE THAT CREATES, DROP AND TRUNCATES LA ARCHIVE TABLES
  PROCEDURE TBL_OPERATION_LA_ARCHIVE(OPERATION IN VARCHAR2, ARCHIVE_SCHEMA IN VARCHAR2);

  --PROCEDURE THAT CREATES, DROP AND TRUNCATES SA ARCHIVE TABLES
  PROCEDURE TBL_OPERATION_SA_ARCHIVE(OPERATION IN VARCHAR2, ARCHIVE_SCHEMA IN VARCHAR2);

  --PROCEDURE THAT CREATES, DROP AND TRUNCATES IA ARCHIVE TABLES
  PROCEDURE TBL_OPERATION_IA_ARCHIVE(ARCHIVE_SCHEMA IN VARCHAR2);

  --PROCEDURE THAT CREATES LA, SA AND DF TABLES
  PROCEDURE CREATE_ARCHIVE_TABLES(ARCHIVE_SCHEMA IN VARCHAR2);

  --PROCEDURE THAT DROPS ALL ARCHIVE TABLE OBJECTS (T_SA,T_LA,T_DF)
  PROCEDURE DROP_ARCHIVE_TABLES_OBJS(ARCHIVE_SCHEMA IN VARCHAR2);

  PROCEDURE GRANT_ARCHIVE_SCHEMA (ARCHIVE_SCHEMA IN VARCHAR2);

  --MAIN ARCHIVE SETUP PROCEDURE
  PROCEDURE RUN_SETUP_ARCHIVE(ARCHIVE_SCHEMA IN VARCHAR2);

 PROCEDURE  MOVE_TO_ARCHIVE_SCHEMA
    ;


END MIGR_ARCHIVE;
/

CREATE OR REPLACE PACKAGE                   MIGR_PROCESS
  AS

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------
  --
  -- MIGR_MAIN
  --      Main procedure for migrating data by MigrationBatchId
  --
  -- Purpose: Invokes procedures for migrating  into INSIS
  --          Reads all info from LA_xxxxx_LOAD tables, saves them in LA_Myy_KFxxxx, combines them in SA_KFxxx, transforms them with SA_IA MAPS
  --                and finally it attempts to post Policy Applications in INSIS
  --
  -- MODIFICATION HISTORY
  -- Person               Date         Comments
  -- ---------            ------       ------------------------------------------
  -- Andreas Boyatzoglou  15.06.2015   Initial version
  -- Andreas Boyatzoglou  24.09.2015   Full version
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE MIGR_MAIN(  P_DEBUG        IN VARCHAR2 );
--  PROCEDURE MIGR_MAIN_RUN_IA(P_BATCH_ID IN VARCHAR2);
-----------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 FUNCTION GET_API_STEPS_ORDER   RETURN MIGR_GVAR.api_steps_orde_tab_t;
  --valex.27/4/16 check step or products that are planned to run for bolag
  function PROCESS_STEPS(pmig_batch in varchar2, pstep in varchar2, pproduct in varchar2)
  return VARCHAR2;
-- LM 20170119 - Check if specific product should be migrated or skipped: 1 = migrate, 0 = skip
 FUNCTION SKIP_INSIS_REG (pmig_batch in varchar2, pflag in varchar2, pproduct in varchar2)  return VARCHAR2;

   FUNCTION GET_API_PROCESS_PLAN(pmig_batch IN VARCHAR2, pproduct   IN VARCHAR2,p_migr_flag IN VARCHAR2)
    RETURN MIGR_GVAR.steps_tab_t;


END MIGR_PROCESS;
/

CREATE OR REPLACE PACKAGE                   MIGR_INTERMEDIATE_OBJECTS
  AS

  PROCEDURE CREATE_INTERMEDIATE_TABLES(p_table_type IN VARCHAR2);
  FUNCTION POPULATE_INTERMEDIATE_TABLES(p_mig_batch_id IN VARCHAR2)
    RETURN BOOLEAN;
  FUNCTION POPULATE_INTERMEDIATE_TABLE(p_LogRec IN MIGR_GVAR.LogRecTyp)
    RETURN BOOLEAN;
  PROCEDURE DROP_INTERMEDIATE_OBJECTS;
  PROCEDURE CREATE_INTERMEDIATE_VIEWS;

END MIGR_INTERMEDIATE_OBJECTS;
/

CREATE OR REPLACE PACKAGE               MIGR_API_LEISURE_MOBILE_HOME
  AS

  FUNCTION  MIGRATE_LEISURE_MOBILE_HOME(p_policyRec IN  MIGR_GVAR.PolicyRecTyp) RETURN  MIGR_GVAR.PolicyRecTyp;
END MIGR_API_LEISURE_MOBILE_HOME;
/

CREATE OR REPLACE PACKAGE               MIGR_API_CONTENT_COOP
  AS


  FUNCTION  MIGRATE_CONTENT_COOP(p_policyRec IN  MIGR_GVAR.PolicyRecTyp) RETURN  MIGR_GVAR.PolicyRecTyp;


END;
/

CREATE OR REPLACE PACKAGE                    MIGR_API_COMMON
  AS

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE SET_DEFAULT_VALUES(MIG_BOLAG_ID IN MIG_MIGRATION_INFO.BOLAG_ID % TYPE);
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION CALCULATE_RECONSTRUCTION_COST(p_policyRec IN MIGR_GVAR.PolicyRecTyp)   RETURN MIGR_GVAR.PolicyRecTyp;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION MIGRATE_OBJECT(p_policyRec MIGR_GVAR.PolicyRecTyp)  RETURN MIGR_GVAR.PolicyRecTyp;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE SET_OBJECT_DEDUCTIBLES(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp);

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE SET_DEFAULT_AGENT_ID(P_agent_no IN VARCHAR2);
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE GET_INSURED_OBJ(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp);

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PROCEDURE UPDATE_IA_POLICY_MIG_FLAG(p_idpl   IN NUMBER,p_status IN NUMBER, p_migrBatchId in VARCHAR2);

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE ADD_ADDRESS_ID(p_addressTab      IN OUT MIGR_GVAR.PropertyAddressTabTyp,
                           p_address_id      IN     NUMBER,
                           p_ia_address      IN     NVARCHAR2,
                           p_ia_post_code    IN     NVARCHAR2,
                           p_ia_city         IN     NVARCHAR2,
                           p_ia_country_code IN     NVARCHAR2);
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  FUNCTION GET_ADDRESS_ID(p_addressTab      IN MIGR_GVAR.PropertyAddressTabTyp,
                          p_ia_address      IN NVARCHAR2,
                          p_ia_post_code    IN NVARCHAR2,
                          p_ia_city         IN NVARCHAR2,
                          p_ia_country_code IN NVARCHAR2)
    RETURN NUMBER;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION GET_EVENT_RESULT(PIO_ERR IN SRVERR, L_RESULT   VARCHAR2)  RETURN PLS_INTEGER;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE REGISTER_PROPERTY_ID(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp) ;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION GET_IA_CONFIGURATION(p_policyRec IN MIGR_GVAR.PolicyRecTyp)   RETURN MIGR_GVAR.PolicyRecTyp;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION INSERT_INSURED_OBJ(p_policyRec MIGR_GVAR.PolicyRecTyp)  RETURN MIGR_GVAR.PolicyRecTyp  ;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION LOAD_POLICY_DOCUMENTS(p_policyRec IN MIGR_GVAR.PolicyRecTyp, P_DOC_LEVEL IN VARCHAR2)  RETURN MIGR_GVAR.PolicyRecTyp;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -- +++ anb 2018-11-27  do not use !!!!!!
--  FUNCTION LOAD_INSIS_POL_DOC(p_policyRec IN MIGR_GVAR.PolicyRecTyp, P_DOC_LEVEL IN VARCHAR2)  RETURN PLS_INTEGER;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION GET_INSIS_EVENT (p_event_key IN VARCHAR2)  RETURN VARCHAR2;
 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_CUST_CORRESPONDENCE(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp);
  PROCEDURE UPDATE_ENG_BILLING(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp);
  FUNCTION MIGRATE_ENDORSMENTS(p_policyRec IN MIGR_GVAR.PolicyRecTyp) RETURN MIGR_GVAR.PolicyRecTyp;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    PROCEDURE SUSPEND_MIGRATION (p_LogMsg VARCHAR2,p_Msg_Code IN VARCHAR2 );
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--++ 20170802 New procedure to handle failed policies
PROCEDURE  MIGR_UPD_FAILED_POL_FOR_PHASE2(p_policyId IN MIGR_POLICY.POLICY_ID % TYPE)  ;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   --FA.20170807 Restore INSIS log level values as when prior to migraition
 PROCEDURE RESTORE_INSIS_LOG_LEVEL;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 --++ 20170802 New procedure to handle failed policies
 PROCEDURE  MIGR_PHASE2_POL_PROCESS;
 --FA.20170807 Configure to lower INSIS log level and prevent tablespace issues caused by extensive logging
 PROCEDURE DISABLE_INSIS_LOG_LEVEL;
 PROCEDURE  STORE_INSIS_LOG_LEVEL;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_API_COMMON;
/

CREATE OR REPLACE PACKAGE               MIGR_API_INDIVIDUAL_COVERS
  AS
  FUNCTION  MIGRATE_INDIVIDUAL_COVERS(p_policyRec IN  MIGR_GVAR.PolicyRecTyp) RETURN   MIGR_GVAR.PolicyRecTyp;
END MIGR_API_INDIVIDUAL_COVERS;
/

CREATE OR REPLACE PACKAGE                    MIGR_LOG
  AS
  /*************************************************************************
    Author: Fani.Avgerou
    Package Purpose: Autonomous porcedures to insert into log table
    Supported log Levels: Info -Werning-Error-Exception declared in spec
    Overloading concept used to support different input record datatypes
  ***************************************************************************/

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_ERROR(p_LogRec MIGR_GVAR.LogRecTyp);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_EXCEPTION(p_LogRec MIGR_GVAR.LogRecTyp);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_INFO(p_LogRec MIGR_GVAR.LogRecTyp);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_WARNING(p_LogRec MIGR_GVAR.LogRecTyp);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     PROCEDURE LOG_ERROR(p_migrBatchId   IN VARCHAR2,
                      p_MigrationArea IN VARCHAR2,
                      p_MigrationStep IN VARCHAR2,
                      p_LogMsg        IN VARCHAR2,
                      p_RelatedTable  IN VARCHAR2,
                      p_RelatedKey    IN VARCHAR2);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_INFO(p_migrBatchId   IN VARCHAR2,
                     p_MigrationArea IN VARCHAR2,
                     p_MigrationStep IN VARCHAR2,
                     p_LogMsg        IN VARCHAR2,
                     p_RelatedTable  IN VARCHAR2,
                     p_RelatedKey    IN VARCHAR2);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  PROCEDURE LOG_WARNING(p_migrBatchId   IN VARCHAR2,
                        p_MigrationArea IN VARCHAR2,
                        p_MigrationStep IN VARCHAR2,
                        p_LogMsg        IN VARCHAR2,
                        p_RelatedTable  IN VARCHAR2,
                        p_RelatedKey    IN VARCHAR2);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_EXCEPTION(p_migrBatchId   IN VARCHAR2,
                          p_MigrationArea IN VARCHAR2,
                          p_MigrationStep IN VARCHAR2,
                          p_LogMsg        IN VARCHAR2,
                          p_RelatedTable  IN VARCHAR2,
                          p_RelatedKey    IN VARCHAR2);

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_INFO(p_policyRec IN MIGR_GVAR.PolicyRecTyp);
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_ERROR(p_policyRec IN MIGR_GVAR.PolicyRecTyp);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_WARNING(p_policyRec IN MIGR_GVAR.PolicyRecTyp);
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_EXCEPTION(p_policyRec IN MIGR_GVAR.PolicyRecTyp);

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   PROCEDURE LOG_ERROR_EVENT(p_LogRec    MIGR_GVAR.LogRecTyp,
                            PIO_ERR  IN SRVERR);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_WARNING_EVENT(p_LogRec    MIGR_GVAR.LogRecTyp,
                              PIO_ERR  IN SRVERR);

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_ERROR_EVENT(p_LogRec IN MIGR_GVAR.PolicyRecTyp,
                            PIO_ERR  IN SRVERR);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_WARNING_EVENT(p_LogRec IN MIGR_GVAR.PolicyRecTyp,
                              PIO_ERR  IN SRVERR);
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PROCEDURE LOG_EVENT_TIME(p_policyRec MIGR_GVAR.PolicyRecTyp);

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PROCEDURE LOG_FAILED_POLICY(P_POLICYREC  IN   MIGR_GVAR.PolicyRecTyp, p_beginStepTimer  TIMESTAMP, p_policyStep IN   VARCHAR);
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PROCEDURE LOG_POLICY(P_POLICYREC  IN   out MIGR_GVAR.PolicyRecTyp, p_beginStepTimer  TIMESTAMP, p_policyStep IN   VARCHAR) ;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_COVER_ERROR_RULES(p_idpl   NUMBER,  p_mig_batch_id IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE);
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- +++ anb 2018-11-11  CLOB recording
  PROCEDURE LOG_CLOB(p_CLOBLogRec MIGR_GVAR.CLOBRecTyp);
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_LOG;
/

CREATE OR REPLACE PACKAGE                   MIGR_API_ACCIDENT
  AS

  FUNCTION  MIGRATE_CHILD_ACC(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)  RETURN  MIGR_GVAR.PolicyRecTyp;

  --------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------
  FUNCTION  MIGRATE_INDIV_ACC(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)  RETURN  MIGR_GVAR.PolicyRecTyp;

  --------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------
  FUNCTION  MIGRATE_RED_ACC(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)  RETURN  MIGR_GVAR.PolicyRecTyp;

  --------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------
  FUNCTION  MIGRATE_RED_CHILD_ACC(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)  RETURN  MIGR_GVAR.PolicyRecTyp;

  --------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------
  FUNCTION  MIGRATE_INDIV60_ACC(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)  RETURN  MIGR_GVAR.PolicyRecTyp;

  --------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------

  END MIGR_API_ACCIDENT;
/

CREATE OR REPLACE PACKAGE               MIGR_API_LEISURE_COOP
  AS


  FUNCTION  MIGRATE_LEISURE_COOP(p_policyRec IN  MIGR_GVAR.PolicyRecTyp) RETURN  MIGR_GVAR.PolicyRecTyp;


END;
/

CREATE OR REPLACE PACKAGE               MIGR_API_BUILDING_VILLA
  AS

  FUNCTION MIGRATE_BUILDING_VILLA(p_policyRec  IN   MIGR_GVAR.PolicyRecTyp) RETURN  MIGR_GVAR.PolicyRecTyp;
END MIGR_API_BUILDING_VILLA;
/

CREATE OR REPLACE PACKAGE               MIGR_API_LEISURE_CONT_ONLY
  AS


  FUNCTION  MIGRATE_LEISURE_CONT_ONLY(p_policyRec IN  MIGR_GVAR.PolicyRecTyp) RETURN MIGR_GVAR.PolicyRecTyp;
END MIGR_API_LEISURE_CONT_ONLY;
/

CREATE OR REPLACE PACKAGE                   MIGRATE_CLIENTS
  AS

  PROCEDURE GET_CLIENT(vGEGN IN VARCHAR2,p_batchId IN VARCHAR2);

--  PROCEDURE RUN_MIGRATION_PROCESS;

--  PROCEDURE GET_CLIENTS_TASK;

  PROCEDURE STOP_MIGRATION_PROCESS;

--  PROCEDURE PROCESSDISPATCHER(KEY1 IN NUMBER, KEY2 IN NUMBER);

  -- PL 20161021
 --- PROCEDURE GET_NEXT_EGN (vNextEGN OUT MIGR_CLIENT.EGN % TYPE);

  PROCEDURE WAIT_ANY_ALERT (vCOUNTER IN OUT PLS_INTEGER, vEXCEPTION_COUNTER IN OUT PLS_INTEGER,p_batchId IN VARCHAR2);

--  PROCEDURE CLIENTS_MIGRATION;

  PROCEDURE STATE_MACHINE_GET_EPA_CLIENT(p_batchId IN VARCHAR2);

  PROCEDURE RUN_CLIENTS_MIGRATION_PROCESS;

  procedure LOAD_TO_MIGR_CLIENT(p_batchId IN VARCHAR2) ;


END MIGRATE_CLIENTS;
/

CREATE OR REPLACE PACKAGE               MIGR_API_CONTENT_ONLY
  AS


  FUNCTION  MIGRATE_CONTENT_ONLY(p_policyRec IN   MIGR_GVAR.PolicyRecTyp) RETURN MIGR_GVAR.PolicyRecTyp;


END;
/

CREATE OR REPLACE PACKAGE                   MIGR_MD_DISCOUNTS
  AS

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_LA_DISCOUNTS (p_migrBatchId IN VARCHAR2, LA_Status OUT VARCHAR2);

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_SA_DISCOUNTS (p_migrBatchId IN VARCHAR2, SA_Status OUT VARCHAR2);

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_IA_DISCOUNTS (p_migrBatchId IN VARCHAR2, IA_Status OUT VARCHAR2);

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

  FUNCTION UPDATE_MD_DISCOUNTS (p_policyRec MIGR_GVAR.PolicyRecTyp, p_discount_type IN VARCHAR2)
    RETURN MIGR_GVAR.PolicyRecTyp;

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOAD_MD_DISCOUNTS(p_migrBatchId IN VARCHAR2, LOAD_Status OUT VARCHAR2);

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE DEFAULT_MD_DISCOUNTS_FILE(vBatchID IN VARCHAR2);

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
function get_insis_discount_id(p_policyRec MIGR_GVAR.PolicyRecTyp, p_discount_type in varchar2, p_ins_object_id in varchar2)
return NUMBER;

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

  FUNCTION MD_DISCOUNTS_FILE_ROW_COUNTER (p_migrBatchId IN VARCHAR2)
    RETURN NUMBER;

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

    function upload_discount(p_policyRec MIGR_GVAR.PolicyRecTyp, p_discount_id IN number, p_discount_value in NUMBER, p_valid_to IN date)   return MIGR_GVAR.PolicyRecTyp ;

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

  procedure run_discounts(p_policyRec IN OUT   MIGR_GVAR.PolicyRecTyp)  ;

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

  procedure dump_table_to_csv( p_migrBatchId IN VARCHAR2, p_tname in varchar2,   p_dir in varchar2,   p_filename in varchar2 ) ;

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

  procedure send_md_discounts_file ;

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
END;
/

CREATE OR REPLACE PACKAGE                   MIGR_EMAIL_NOTIFICATION AS

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE CREATE_EMAIL_NOTIFICATION(p_MIGRATION_BATCH_ID IN VARCHAR2, p_MSG_CODE IN VARCHAR2, p_ATT_FILE_NAME IN VARCHAR2 DEFAULT NULL, p_ATT_FILE_DIR IN VARCHAR2 DEFAULT NULL);

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE CREATE_EMAIL_WITH_DYNAMIC_MSG( p_MIGRATION_BATCH_ID IN VARCHAR2, p_MSG_CODE IN VARCHAR2
                                         , p_MIGR_INFO IN VARCHAR2, p_ATT_FILE_NAME IN VARCHAR2 DEFAULT NULL, p_ATT_FILE_DIR IN VARCHAR2 DEFAULT NULL);

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE SEND_EMAIL (p_MSG_ID IN NUMBER);

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE SEND_EMAIL_WITH_ATT (p_MSG_ID IN NUMBER, p_attach_name IN VARCHAR2, p_FILE_DIR IN VARCHAR2);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

   PROCEDURE SEND_EMAIL_IMMEDIATE (p_LogRecMsg IN VARCHAR2, p_Msg_Code IN VARCHAR2);

 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE SERVICE_EMAIL_QUEUE;
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
END MIGR_EMAIL_NOTIFICATION;
/

CREATE OR REPLACE PACKAGE                    MIGR_REPORTING AS

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- +++ anb 2019-02-28 -- V_MIGR_FACT and V_MIGR_PREMIUMS are build by MIGR_REPORTING procedure
/*
  PROCEDURE MIGR_FACT;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGR_PREMIUMS;
--- end +++ anb 2019-02-28 -- V_MIGR_FACT and V_MIGR_PREMIUMS are build by MIGR_REPORTING procedure
*/
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE REPORTING;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE DAILY_PROGRESS ( pRenewalDate IN DATE );

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_REPORTING;
/

CREATE OR REPLACE PACKAGE                   MIGR_TST_PRC_API
  AS
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE GET_NEXT_BATCH(vMigrationBatchId OUT MIGR_POLICY.MIG_BATCH_ID % TYPE,
                           vStatus           OUT VARCHAR2);
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE GET_NEXT_IDPL(vNextIDPL         OUT MIGR_POLICY.POLICY_IDPL % TYPE,
                          vMigrationBatchId IN  MIGR_POLICY.MIG_BATCH_ID % TYPE,
                          vStatus           IN  VARCHAR2);

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE TRUNCATE_MIGR_TABLES;
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE WAIT_ANY_API_ALERT(vCOUNTER           IN OUT PLS_INTEGER,
                               vEXCEPTION_COUNTER IN OUT PLS_INTEGER);

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE STATE_MACHINE_RUN_API;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_TST_PRC_API;
/

CREATE OR REPLACE PACKAGE                   MIGR_TST_PRC_API_POLICY
  AS

  PROCEDURE MIGRATE_POLICY(P_MIGRBATCHID IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                           P_IDPL        IN VARCHAR2);

  PROCEDURE CONVERT_APPLICATION(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp);

END MIGR_TST_PRC_API_POLICY;
/

CREATE OR REPLACE PACKAGE                   MIGR_TST_PRC_IA
  AS

  ---- IA stage --------------------------------------------------------------
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  -- +++ anb 2016-04-18 no need for parameter passing
  --  PROCEDURE REBUILD_SA_IA(p_schema IN VARCHAR2);        -- Initialize SetupOperation
  PROCEDURE REBUILD_SA_IA;                                 -- Initialize SetupOperation
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------

  ----------------------------------------------------------------------------
  PROCEDURE RUN_IA_SETUP;        -- SetupOperation
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  PROCEDURE IA_LOG_VOL(Migration_area    IN VARCHAR2,
                       Step_message      IN VARCHAR2,
                       Status            IN VARCHAR2,
                       TableName         IN VARCHAR2,
                       vMigrationBatchId IN VARCHAR2);

  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  PROCEDURE IA_CLEAN_UP_XFER(vMigrationBatchId IN VARCHAR2);
  PROCEDURE TRUNCATE_IA_TABLES;
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  PROCEDURE IA_MAIN(p_migrBatchId IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                    O_STATUS      OUT VARCHAR2);

  PROCEDURE IA_MAIN_TBL(p_LogRec     MIGR_GVAR.LogRecTyp,
                        O_STATUS OUT VARCHAR2,
                        p_status IN  VARCHAR2);

  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  PROCEDURE UPDATE_SA_IA(p_MigrationId IN VARCHAR2);
  ----------------------------------------------------------------------------
  ----------------------------------------------------------------------------
  PROCEDURE RUN_IA(p_migrBatchId IN  VARCHAR2,
                   IA_Status     OUT VARCHAR2);

END MIGR_TST_PRC_IA;
/

CREATE OR REPLACE PACKAGE                   MIGR_TST_PRC_LA_SA
  AS

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE fill_SA_B_PRSN(p_migrBatchId IN VARCHAR2);
  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE fill_SA_B_address(p_migrBatchId IN VARCHAR2);

  --------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(p_LogRec MIGR_GVAR.LogRecTyp);

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(p_LogRec    MIGR_GVAR.LogRecTyp,
                                           p_Status IN VARCHAR2); -- PL 20161221

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_ROW_COUNT(p_LogRec    MIGR_GVAR.LogRecTyp,
                                       p_Status IN VARCHAR2); -- PL 20161221

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_MATCHING(p_LogRec    MIGR_GVAR.LogRecTyp,
                                      p_Status IN VARCHAR2); -- PL 20161221

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_NON_MATCH(p_LogRec    MIGR_GVAR.LogRecTyp,
                                       p_Status IN VARCHAR2); -- PL 20161221

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_MATCHING_RECORDS(p_LogRec    MIGR_GVAR.LogRecTyp,
                                     p_Status IN VARCHAR2); -- PL 20161221

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION INSERT_RECORDS_IN_HISTORY(p_LogRec     MIGR_GVAR.LogRecTyp,
                                     p_Status  IN VARCHAR2,
                                     p_renewal IN DATE)
    RETURN BOOLEAN;

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE TRUNCATE_ALL;

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(steparea          IN VARCHAR2,
                                           stepmessage       IN VARCHAR2,
                                           vMigrationBatchId IN VARCHAR2,
                                           vtablename        IN VARCHAR2);

  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  FUNCTION INSERT_RECORDS_IN_HISTORY_SA(p_LogRec    MIGR_GVAR.LogRecTyp,
                                        p_Status IN VARCHAR2)
    RETURN BOOLEAN; -- PL 20161221
  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LA_MIG_FLAG(p_LogRec MIGR_GVAR.LogRecTyp);
  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_LA(p_migrBatchId IN  VARCHAR2,
                   LA_Status     OUT VARCHAR2);
  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_SA(p_migrBatchId IN  VARCHAR2,
                   SA_Status     OUT VARCHAR2);
  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION landing_extra_where(p_LogRec MIGR_GVAR.LogRecTyp)
    RETURN VARCHAR2;
  --------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_RECORDS_NOT_IN_MASTER_FILE(p_LogRec  IN MIGR_GVAR.LogRecTyp,
                                           p_renewal IN DATE);
--------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_TST_PRC_LA_SA;
/

CREATE OR REPLACE PACKAGE                   MIGR_TST_PRC_MD_DISC
  AS

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_LA_DISCOUNTS(p_migrBatchId IN  VARCHAR2,
                             LA_Status     OUT VARCHAR2);

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_SA_DISCOUNTS(p_migrBatchId IN  VARCHAR2,
                             SA_Status     OUT VARCHAR2);

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_IA_DISCOUNTS(p_migrBatchId IN  VARCHAR2,
                             IA_Status     OUT VARCHAR2);

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  FUNCTION UPDATE_MD_DISCOUNTS(p_policyRec        MIGR_GVAR.PolicyRecTyp,
                               p_discount_type IN VARCHAR2)
    RETURN MIGR_GVAR.PolicyRecTyp;

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOAD_MD_DISCOUNTS(p_migrBatchId IN  VARCHAR2,
                              LOAD_Status   OUT VARCHAR2);

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE DEFAULT_MD_DISCOUNTS_FILE(vBatchID IN VARCHAR2);

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------
  FUNCTION get_insis_discount_id(p_policyRec        MIGR_GVAR.PolicyRecTyp,
                                 p_discount_type IN VARCHAR2,
                                 p_ins_object_id IN VARCHAR2)
    RETURN NUMBER;

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  FUNCTION MD_DISCOUNTS_FILE_ROW_COUNTER(p_migrBatchId IN VARCHAR2)
    RETURN NUMBER;

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  FUNCTION upload_discount(p_policyRec         MIGR_GVAR.PolicyRecTyp,
                           p_discount_id    IN NUMBER,
                           p_discount_value IN NUMBER,
                           p_valid_to       IN DATE)
    RETURN MIGR_GVAR.PolicyRecTyp;

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE run_discounts(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp);

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE dump_table_to_csv(p_migrBatchId IN VARCHAR2,
                              p_tname       IN VARCHAR2,
                              p_dir         IN VARCHAR2,
                              p_filename    IN VARCHAR2);

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE send_md_discounts_file;

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
END MIGR_TST_PRC_MD_DISC;
/

CREATE OR REPLACE PACKAGE                   MIGR_TST_PRC_RESUME
  AS
  PROCEDURE DELETE_SA(p_migration_batch_id IN  VARCHAR2,
                      SA_status            OUT VARCHAR2);
  PROCEDURE DELETE_LA(p_migration_batch_id IN  VARCHAR2,
                      LA_Status            OUT VARCHAR2);
  PROCEDURE DELETE_IA(p_migration_batch_id IN  VARCHAR2,
                      IA_status            OUT VARCHAR2);
  PROCEDURE RESUME_MAIN;
  PROCEDURE CHECK_PROCESS_STATUS(p_migration_batch_id IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                                 resume_step          OUT VARCHAR2);
  PROCEDURE initialize_Running_policies;
  PROCEDURE DELETE_LA_to_IA_DISCOUNTS(p_migration_batch_id IN  VARCHAR2,
                                      Status               OUT VARCHAR2);
    PROCEDURE RESUME_MAIN (P_BOLAG_ID IN NUMBER);
END MIGR_TST_PRC_RESUME;
/

CREATE OR REPLACE PACKAGE                   MIGR_TST_PRC_SCHEDULED_JOBS
  AS
  PROCEDURE START_JOBS;
  PROCEDURE STOP_MIGR_RUNNING_JOB(p_job_name IN VARCHAR2);
  PROCEDURE DROP_MIGR_JOB(p_job_name IN VARCHAR2);
  PROCEDURE DISABLE_MIGR_JOB(p_job_name IN VARCHAR2);
  PROCEDURE RUN_PARALLEL;
  PROCEDURE CREATE_MIGR_JOBS(p_job_name        IN VARCHAR2,
                             p_job_action      IN VARCHAR2,
                             p_repeat_interval IN VARCHAR2,
                             p_start_date      IN TIMESTAMP,
                             p_end_date        IN TIMESTAMP);

  PROCEDURE ENABLE_MIGR_JOB(p_job_name IN VARCHAR2);



  -- +++ anb 2016-04-28     called from RUN_MIGRATION().
  PROCEDURE CREATE_PROGRAM;

---PROCEDURE RUN_PARALLEL_DISCOUNTS;

END MIGR_TST_PRC_SCHEDULED_JOBS;
/

CREATE OR REPLACE PACKAGE                   MIGR_TST_PRC_SIGNAL
  IS

  ---------------------------------------------
  --FUNCTION THAT CHECKS IF A FILE EXISTS
  --PARAM1: file directory
  --PARAM2: file name
  FUNCTION IS_FILE_EXISTS(DIR       IN VARCHAR2,
                          FILE_NAME IN VARCHAR2)
    RETURN PLS_INTEGER;
  ---------------------------------------------
     FUNCTION GET_NEXT_QUEUED(P_BOLAG IN NUMBER) RETURN  VARCHAR2 ;
  ---------------------------------------------
  --PROCEDURE THAT CHECKS THE EXISTENCE OF COMPLETED.TXT FILES

  ---------------------------------------------

  ---------------------------------------------
  PROCEDURE CLOSE_PREVIOUS_BATCH_JOBS(vBOLAG_ID IN PLS_INTEGER);

  ---------------------------------------------
  -- FUNCTION INSERT_NEW_BATCH_JOB(vBOLAG_ID IN PLS_INTEGER) RETURN VARCHAR2;

  ---------------------------------------------
  --
  --  PROCEDURE INIT_LOG_MIG_MIGRATION_STEPS(vBOLAG_ID IN PLS_INTEGER);

  -----------------------------------------------
  --  --Initialize batch   -- step10 from demo
  --  FUNCTION INIT_BATCH(vBOLAG_ID IN PLS_INTEGER) RETURN VARCHAR2;
  -----------------------------------------------
  ---------------------------------------------
  --Queue batch   -- step10 from demo
  FUNCTION INIT_BATCH2(vBOLAG_ID     IN PLS_INTEGER,
                       p_queued_flag IN VARCHAR2)
    RETURN VARCHAR2;
  ---------------------------------------------
  ---------------------------------------------
  --Get next Queued batch and make it runnable
  FUNCTION GET_NEXT_QUEUED
    RETURN VARCHAR2;
  ---------------------------------------------
  ---------------------------------------------
  --Make a batch runnable
  PROCEDURE MAKE_RUNNABLE(vMigrationBatchID IN VARCHAR2,
                          v_status          IN VARCHAR2);
  ---------------------------------------------
  ---------------------------------------------
  --valex.20/4/16 change batch status
  --FA. 20151106 Make a batch completed
  --PROCEDURE CLOSE_BATCH(vMigrationBatchID IN VARCHAR2);
  PROCEDURE CLOSE_BATCH(vMigrationBatchID IN VARCHAR2,
                        pStatus           IN VARCHAR2);
  ---------------------------------------------
  ---------------------------------------------

  PROCEDURE RUN_SIGNAL(p_queued_flag IN VARCHAR2);
  -- FUNCTION RUN_SIGNAL(p_queued_flag IN VARCHAR2) RETURN VARCHAR2;
  ---------------------------------------------
  FUNCTION INSERT_BATCH_JOB(vBOLAG_ID IN PLS_INTEGER,
                            p_status  IN VARCHAR2)
    RETURN VARCHAR2;

  PROCEDURE LOG_NOT_MIGRATED_BOLAGS(p_id                IN PLS_INTEGER,
                                    p_applicable_bolags IN VARCHAR2);

  PROCEDURE MIGRATION_SCHEDULE(v_id                 OUT PLS_INTEGER,
                               v_scan_for_completed OUT BOOLEAN,
                               v_scan_for_discounts OUT BOOLEAN);

  PROCEDURE CHECK_FILES(p_queued_flag IN VARCHAR2);

  PROCEDURE LOG_NOT_MIGRATED_BOLAGS_DISC(p_id                IN PLS_INTEGER,
                                         p_applicable_bolags IN VARCHAR2);

  PROCEDURE TXT_NOT_FOUND_REMINDER(p_id                IN PLS_INTEGER,
                                   p_applicable_bolags IN VARCHAR2,
                                   p_status            IN VARCHAR2);



END MIGR_TST_PRC_SIGNAL;
/

CREATE OR REPLACE PACKAGE BODY                    AS_READ_XLSX AS
 function read( p_xlsx blob, p_sheets varchar2 := null, p_cell varchar2 := null )
  return tp_all_cells pipelined
  is
    t_date1904 boolean;
    type tp_date is table of boolean index by pls_integer;
    t_xf_date tp_date;
    t_numfmt_date tp_date;
    type tp_strings is table of varchar2(32767) index by pls_integer;
    t_strings tp_strings;
    t_sheet_ids tp_strings;
    t_sheet_names tp_strings;
    t_r varchar2(32767);
    t_s varchar2(32767);
    t_val varchar2(32767);
    t_t varchar2(400);
    t_nr number;
    t_c pls_integer;
    t_x pls_integer;
    t_xx pls_integer;
    t_ns varchar2(200) := 'xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"';
    t_nd dbms_xmldom.domnode;
    t_nd2 dbms_xmldom.domnode;
    t_nl dbms_xmldom.domnodelist;
    t_nl2 dbms_xmldom.domnodelist;
    t_nl3 dbms_xmldom.domnodelist;
    t_one_cell tp_one_cell;
--
    function blob2node( p_blob blob )
    return dbms_xmldom.domnode
    is
    begin
      if p_blob is null or dbms_lob.getlength( p_blob ) = 0
      then
        return null;
      end if;
      return dbms_xmldom.makenode( dbms_xmldom.getdocumentelement( dbms_xmldom.newdomdocument( xmltype( p_blob, nls_charset_id( 'AL32UTF8' ) ) ) ) );
    exception
      when others
      then
        declare
          t_nd dbms_xmldom.domnode;
          t_clob         clob;
          t_dest_offset  integer;
          t_src_offset   integer;
          t_lang_context number := dbms_lob.default_lang_ctx;
          t_warning      integer;
        begin
          dbms_lob.createtemporary( t_clob, true );
          t_dest_offset := 1;
          t_src_offset  := 1;
          dbms_lob.converttoclob( t_clob
                                , p_blob
                                , dbms_lob.lobmaxsize
                                , t_dest_offset
                                , t_src_offset
                                , nls_charset_id('AL32UTF8')
                                , t_lang_context
                                , t_warning
                                );
          t_nd := dbms_xmldom.makenode( dbms_xmldom.getdocumentelement( dbms_xmldom.newdomdocument( t_clob ) ) );
          dbms_lob.freetemporary( t_clob );
          return t_nd;
      end;
    end;
--
    function blob2num( p_blob blob, p_len integer, p_pos integer )
    return number
    is
    begin
      return utl_raw.cast_to_binary_integer( dbms_lob.substr( p_blob, p_len, p_pos ), utl_raw.little_endian );
    end;
--
    function little_endian( p_big number, p_bytes pls_integer := 4 )
    return raw
    is
    begin
      return utl_raw.substr( utl_raw.cast_from_binary_integer( p_big, utl_raw.little_endian ), 1, p_bytes );
    end;
--
    function col_alfan( p_col varchar2 )
    return pls_integer
    is
    begin
      return ascii( substr( p_col, -1 ) ) - 64
           + nvl( ( ascii( substr( p_col, -2, 1 ) ) - 64 ) * 26, 0 )
           + nvl( ( ascii( substr( p_col, -3, 1 ) ) - 64 ) * 676, 0 );
    end;
--
    function get_file
      ( p_zipped_blob blob
      , p_file_name varchar2
      )
    return blob
    is
      t_tmp blob;
      t_ind integer;
      t_hd_ind integer;
      t_fl_ind integer;
      t_encoding varchar2(10);
      t_len integer;
    begin
      t_ind := dbms_lob.getlength( p_zipped_blob ) - 21;
      loop
        exit when t_ind < 1 or dbms_lob.substr( p_zipped_blob, 4, t_ind ) = hextoraw( '504B0506' ); -- End of central directory signature
        t_ind := t_ind - 1;
      end loop;
--
      if t_ind <= 0
      then
        return null;
      end if;
--
      t_hd_ind := blob2num( p_zipped_blob, 4, t_ind + 16 ) + 1;
      for i in 1 .. blob2num( p_zipped_blob, 2, t_ind + 8 )
      loop
        if utl_raw.bit_and( dbms_lob.substr( p_zipped_blob, 1, t_hd_ind + 9 ), hextoraw( '08' ) ) = hextoraw( '08' )
        then
          t_encoding := 'AL32UTF8'; -- utf8
        else
          t_encoding := 'US8PC437'; -- IBM codepage 437
        end if;
        if p_file_name = utl_i18n.raw_to_char
                           ( dbms_lob.substr( p_zipped_blob
                                            , blob2num( p_zipped_blob, 2, t_hd_ind + 28 )
                                            , t_hd_ind + 46
                                            )
                           , t_encoding
                           )
        then
          t_len := blob2num( p_zipped_blob, 4, t_hd_ind + 24 ); -- uncompressed length
          if t_len = 0
          then
            if substr( p_file_name, -1 ) in ( '/', '\' )
            then  -- directory/folder
              return null;
            else -- empty file
              return empty_blob();
            end if;
          end if;
--
          if dbms_lob.substr( p_zipped_blob, 2, t_hd_ind + 10 ) = hextoraw( '0800' ) -- deflate
          then
            t_fl_ind := blob2num( p_zipped_blob, 4, t_hd_ind + 42 );
            t_tmp := hextoraw( '1F8B0800000000000003' ); -- gzip header
            dbms_lob.copy( t_tmp
                         , p_zipped_blob
                         ,  blob2num( p_zipped_blob, 4, t_hd_ind + 20 )
                         , 11
                         , t_fl_ind + 31
                         + blob2num( p_zipped_blob, 2, t_fl_ind + 27 ) -- File name length
                         + blob2num( p_zipped_blob, 2, t_fl_ind + 29 ) -- Extra field length
                         );
            dbms_lob.append( t_tmp, utl_raw.concat( dbms_lob.substr( p_zipped_blob, 4, t_hd_ind + 16 ) -- CRC32
                                                  , little_endian( t_len ) -- uncompressed length
                                                  )
                           );
            return utl_compress.lz_uncompress( t_tmp );
          end if;
--
          if dbms_lob.substr( p_zipped_blob, 2, t_hd_ind + 10 ) = hextoraw( '0000' ) -- The file is stored (no compression)
          then
            t_fl_ind := blob2num( p_zipped_blob, 4, t_hd_ind + 42 );
            dbms_lob.createtemporary( t_tmp, true );
            dbms_lob.copy( t_tmp
                         , p_zipped_blob
                         , t_len
                         , 1
                         , t_fl_ind + 31
                         + blob2num( p_zipped_blob, 2, t_fl_ind + 27 ) -- File name length
                         + blob2num( p_zipped_blob, 2, t_fl_ind + 29 ) -- Extra field length
                         );
            return t_tmp;
          end if;
        end if;
        t_hd_ind := t_hd_ind + 46
                  + blob2num( p_zipped_blob, 2, t_hd_ind + 28 )  -- File name length
                  + blob2num( p_zipped_blob, 2, t_hd_ind + 30 )  -- Extra field length
                  + blob2num( p_zipped_blob, 2, t_hd_ind + 32 ); -- File comment length
      end loop;
--
      return null;
    end;
--
  begin
    t_one_cell.cell_type := 'S';
    t_one_cell.sheet_name := 'This doesn''t look like an Excel (xlsx) file to me!';
    t_one_cell.string_val := t_one_cell.sheet_name;
    if dbms_lob.substr( p_xlsx, 4, 1 ) != hextoraw( '504B0304' )
    then
      pipe row( t_one_cell );
      return;
    end if;
    t_nd := blob2node( get_file( p_xlsx, 'xl/workbook.xml' ) );
    if dbms_xmldom.isnull( t_nd )
    then
      pipe row( t_one_cell );
      return;
    end if;
    t_date1904 := lower( dbms_xslprocessor.valueof( t_nd, '/workbook/workbookPr/@date1904', t_ns ) ) in ( 'true', '1' );
    t_nl := dbms_xslprocessor.selectnodes( t_nd, '/workbook/sheets/sheet', t_ns );
    for i in 0 .. dbms_xmldom.getlength( t_nl ) - 1
    loop
      t_sheet_ids( i + 1 ) := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '@r:id', 'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"' );
      t_sheet_names( i + 1 ) := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '@name' );
    end loop;
    t_nd := blob2node( get_file( p_xlsx, 'xl/styles.xml' ) );
    t_nl := dbms_xslprocessor.selectnodes( t_nd, '/styleSheet/numFmts/numFmt', t_ns );
    for i in 0 .. dbms_xmldom.getlength( t_nl ) - 1
    loop
      t_val := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '@formatCode' );
      if (  instr( t_val, 'dd' ) > 0
         or instr( t_val, 'mm' ) > 0
         or instr( t_val, 'yy' ) > 0
         )
      then
        t_numfmt_date( dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '@numFmtId' ) ) := true;
      end if;
    end loop;
    t_numfmt_date( 14 ) := true;
    t_numfmt_date( 15 ) := true;
    t_numfmt_date( 16 ) := true;
    t_numfmt_date( 17 ) := true;
    t_numfmt_date( 22 ) := true;
    t_nl := dbms_xslprocessor.selectnodes( t_nd, '/styleSheet/cellXfs/xf/@numFmtId', t_ns );
    for i in 0 .. dbms_xmldom.getlength( t_nl ) - 1
    loop
      t_xf_date( i ) := t_numfmt_date.exists( dbms_xmldom.getnodevalue( dbms_xmldom.item( t_nl, i ) ) );
    end loop;
    t_nd := blob2node( get_file( p_xlsx, 'xl/sharedStrings.xml' ) );
    if not dbms_xmldom.isnull( t_nd )
    then
      t_x := 0;
      t_xx := 5000;
      loop
        t_nl := dbms_xslprocessor.selectnodes( t_nd, '/sst/si[position()>="' || to_char( t_x * t_xx + 1 ) || '" and position()<=" ' || to_char( ( t_x + 1 ) * t_xx ) || '"]', t_ns );
        exit when dbms_xmldom.getlength( t_nl ) = 0;
        t_x := t_x + 1;
        for i in 0 .. dbms_xmldom.getlength( t_nl ) - 1
        loop
          t_c := t_strings.count;
          t_strings( t_c ) := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '.' );
          if t_strings( t_c ) is null
          then
            t_strings( t_c ) := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl, i ), '*/text()' );
            if t_strings( t_c ) is null
            then
              t_nl2 := dbms_xslprocessor.selectnodes( dbms_xmldom.item( t_nl, i ), 'r/t/text()' );
              for j in 0 .. dbms_xmldom.getlength( t_nl2 ) - 1
              loop
                t_strings( t_c ) := t_strings( t_c ) || dbms_xmldom.getnodevalue( dbms_xmldom.item( t_nl2, j ) );
              end loop;
            end if;
          end if;
        end loop;
      end loop;
    end if;
    t_nd2 := blob2node( get_file( p_xlsx, 'xl/_rels/workbook.xml.rels' ) );
    for i in 1 .. t_sheet_ids.count
    loop
      if ( p_sheets is null
         or instr( ':' || p_sheets || ':', ':' || to_char( i ) || ':' ) > 0
         or instr( ':' || p_sheets || ':', ':' || t_sheet_names( i ) || ':' ) > 0
         )
      then
        t_val := dbms_xslprocessor.valueof( t_nd2, '/Relationships/Relationship[@Id="' || t_sheet_ids( i ) || '"]/@Target', 'xmlns="http://schemas.openxmlformats.org/package/2006/relationships"' );
        t_one_cell.sheet_nr := i;
        t_one_cell.sheet_name := t_sheet_names( i );
        t_nd := blob2node( get_file( p_xlsx, 'xl/' || t_val ) );
        t_nl3 := dbms_xslprocessor.selectnodes( t_nd, '/worksheet/sheetData/row' );
        for r in 0 .. dbms_xmldom.getlength( t_nl3 ) - 1
        loop
          t_nl2 := dbms_xslprocessor.selectnodes( dbms_xmldom.item( t_nl3, r ), 'c' );
          for j in 0 .. dbms_xmldom.getlength( t_nl2 ) - 1
          loop
            t_one_cell.date_val := null;
            t_one_cell.number_val := null;
            t_one_cell.string_val := null;
            t_r := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl2, j ), '@r', t_ns );
            t_val := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl2, j ), 'v' );
            -- see Changelog 2013-02-19 formula column
            t_one_cell.formula := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl2, j ), 'f' );
            -- see Changelog 2013-02-18 type='str'
            t_t := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl2, j ), '@t' );
            if t_t in ( 'str', 'inlineStr', 'e' )
            then
              t_one_cell.cell_type := 'S';
              t_one_cell.string_val := t_val;
            elsif t_t = 's'
            then
              t_one_cell.cell_type := 'S';
              if t_val is not null
              then
                t_one_cell.string_val := t_strings( to_number( t_val ) );
              end if;
            else
              t_s := dbms_xslprocessor.valueof( dbms_xmldom.item( t_nl2, j ), '@s' );
              t_nr := to_number( t_val
                               , case when instr( t_val, 'E' ) = 0
                                   then translate( t_val, '.012345678,-+', 'D999999999' )
                                   else translate( substr( t_val, 1, instr( t_val, 'E' ) - 1 ), '.012345678,-+', 'D999999999' ) || 'EEEE'
                                 end
                               , 'NLS_NUMERIC_CHARACTERS=.,'
                               );
              if t_s is not null and t_xf_date( to_number( t_s ) )
              then
                t_one_cell.cell_type := 'D';
                if t_date1904
                then
                  t_one_cell.date_val := to_date('01-01-1904','DD-MM-YYYY') + to_number( t_nr );
                else
                  t_one_cell.date_val := to_date('01-03-1900','DD-MM-YYYY') + ( to_number( t_nr ) - 61 );
                end if;
              else
                t_one_cell.cell_type := 'N';
                t_nr := round( t_nr, 14 - substr( to_char( t_nr, 'TME' ), -3 ) );
                t_one_cell.number_val := t_nr;
              end if;
            end if;
            t_one_cell.row_nr := ltrim( t_r, rtrim( t_r, '0123456789' ) );
            t_one_cell.col_nr := col_alfan( rtrim( t_r, '0123456789' ) );
            t_one_cell.cell := t_r;
            if p_cell is null or t_r = upper( p_cell )
            then
              pipe row( t_one_cell );
            end if;
          end loop;
        end loop;
      end if;
    end loop;
    return;
  end;
--
  function file2blob
    ( p_dir varchar2
    , p_file_name varchar2
    )
  return blob
  is
    file_lob bfile;
    file_blob blob;
  begin
    file_lob := bfilename( p_dir, p_file_name );
    dbms_lob.open( file_lob, dbms_lob.file_readonly );
    dbms_lob.createtemporary( file_blob, true );
    dbms_lob.loadfromfile( file_blob, file_lob, dbms_lob.lobmaxsize );
    dbms_lob.close( file_lob );
    return file_blob;
  exception
    when others then
      if dbms_lob.isopen( file_lob ) = 1
      then
        dbms_lob.close( file_lob );
      end if;
      if dbms_lob.istemporary( file_blob ) = 1
      then
        dbms_lob.freetemporary( file_blob );
      end if;
      raise;
  end;
--
END AS_READ_XLSX;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_TST_PRC_SIGNAL IS

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
FUNCTION IS_FILE_EXISTS (DIR IN VARCHAR2, FILE_NAME IN VARCHAR2) RETURN PLS_INTEGER IS
    l_file_loc  PLS_INTEGER;
    l_LogRec    MIGR_GVAR.LogRecTyp;

  BEGIN

    SELECT dbms_lob.fileexists(bfilename(upper(DIR), FILE_NAME))
      INTO l_file_loc
      FROM DUAL;

    RETURN l_file_loc;

  EXCEPTION WHEN OTHERS THEN
        l_LogRec.mig_batch_id := '0-1';
        l_LogRec.migrArea     := 'MIGR_SIGNAL_RESUME.IS_FILE_EXISTS';
        l_LogRec.migrStep     := 'IS FILE EXISTS';
        l_LogRec.migrRelTbl   := NULL;
        l_LogRec.migrRelKey   := NULL;
        l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM || '-' || DIR || '\' || FILE_NAME;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END IS_FILE_EXISTS;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
--PROCEDURE THAT CHECKS THE EXISTENCE OF COMPLETED.TXT FILES
-- function CHECK_FILES(p_queued_flag IN VARCHAR2) RETURN VARCHAR2
PROCEDURE CHECK_FILES(p_queued_flag IN VARCHAR2)
    IS

    -- l_file_name          VARCHAR(50);
    l_act_file           VARCHAR(50);
    l_act_file_exists    PLS_INTEGER;
    l_bolag_name         VARCHAR2(50);
    l_tfile_name         VARCHAR2(50);
    l_tfile_etx          VARCHAR2(10);
    l_stateme            VARCHAR2(100);
    l_file_exists        PLS_INTEGER;
    l_file_flag          BOOLEAN;
    l_bolag_id           PLS_INTEGER;
    vMigrationBatchId    VARCHAR2(50);
    l_times_run          PLS_INTEGER;
    v_time               TIMESTAMP ;
    l_completed_found    PLS_INTEGER := 0;
    vsql                 VARCHAR2(100);
    v_not_finished       PLS_INTEGER;
    l_LogRec             MIGR_GVAR.LogRecTyp;
    v_scan_for_completed BOOLEAN ;
    v_scan_for_discounts boolean;
    v_id                 PLS_INTEGER;
    L_SRVERRMSG          SRVERRMSG;
    PIO_ERR			         SRVERR;
    l_completed          ETL_SETUP_INFO.MIGG_FILE_NAME%TYPE;
    l_discounts_file     VARCHAR2(100);
    l_discounts_exists   PLS_INTEGER := 0;
    l_waiting_count      PLS_INTEGER;
    V_STATUS            VARCHAR2(50);
    l_eventTimer         TIMESTAMP;
    v_scan_bolag_completed   BOOLEAN;
  v_scan_bolag_discounts BOOLEAN;
  BEGIN

        vMigrationBatchId := NULL;
        l_LogRec.migrArea := 'MIGR_TST_PRC_SIGNAL.CHECK_FILES';
        l_LogRec.mig_batch_id := '0-1';
        l_LogRec.migrArea     := 'MIGR_TST_PRC_SIGNAL.CHECK_FILES';
        l_LogRec.migrStep     := 'CHECK FILES';
        l_LogRec.migrRelTbl   := NULL;
        l_LogRec.migrRelKey   := NULL;

        l_eventTimer := SYSTIMESTAMP;

        -- coordinate actions across different migration month iterations
        MIGRATION_SCHEDULE(v_id, v_scan_for_completed, v_scan_for_discounts);



        -- if within migration time window
        IF v_scan_for_discounts OR v_scan_for_completed THEN


         IF   v_scan_for_discounts then
                    l_LogRec.logMsg := 'Migration scheduled returned with true for check discounts';
                                   MIGR_LOG.LOG_INFO(l_LogRec);
         END IF;

            SELECT MIGG_FILE_NAME, FILE_EXTN, DISCOUNTS_FILE_NAME
              INTO l_tfile_name, l_tfile_etx, l_discounts_file
              FROM ETL_SETUP_INFO;

            -- Iterate through directories in order to check for completed.txt and/or discounts.txt, if applicable (based on OUT params of MIGRATION_SCHEDULE)
            FOR c IN ( SELECT BOLAG_NAME, BOLAG_ID
                         FROM ETL_BOLAG_INFO , (SELECT APPLICABLE_BOLAGS, MISSED_DATA_DEADLINE FROM ETL_MIGRATION_CONDITIONS WHERE ID=v_id)
                        WHERE ',' || APPLICABLE_BOLAGS || ',' LIKE '%,' || SUBSTR(BOLAG_NAME, 2) || ',%'
                          AND ',' || MISSED_DATA_DEADLINE || ',' NOT LIKE '%,' || SUBSTR(BOLAG_NAME, 2) || ',%' -- if bolag missed upload deadline will not be scanned for discounts.txt

            )
            LOOP
                      v_scan_bolag_completed :=v_scan_for_completed;
        v_scan_bolag_discounts:=v_scan_for_discounts;

                       IF   v_scan_for_discounts then
                    l_LogRec.logMsg := 'start checking for bolag :' ||c.bolag_id;
                                   MIGR_LOG.LOG_INFO(l_LogRec);
         END IF;


               --FA.20180220 skip folders for bolags that are in queued, running or running discounts state
              BEGIN
              SELECT STATUS
                INTO V_STATUS
                FROM(
                 SELECT A.*,MAX(START_TIMESTAMP) OVER () AS MAX_CREATED
                 FROM MIG_MIGRATION_INFO A WHERE BOLAG_ID=c.BOLAG_ID   )
                WHERE   START_TIMESTAMP =  MAX_CREATED ;

                          IF   v_scan_for_discounts then
                                    l_LogRec.logMsg := 'STATUS for bolag :' ||c.BOLAG_ID || '   is: '||V_STATUS;
                                   MIGR_LOG.LOG_INFO(l_LogRec);
                         END IF;


              CASE
                WHEN V_STATUS IN
                     (MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC, MIGR_GVAR.GV_BATCH_STATUS_QUEUED,MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC)
                THEN       v_scan_bolag_completed :=FALSE;  v_scan_bolag_discounts:=FALSE;

                    l_LogRec.logMsg := 'Will not check for completed or discounts for bolag: ' || c.BOLAG_ID;
                    MIGR_LOG.LOG_INFO(l_LogRec);


                WHEN  V_STATUS=  MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC    THEN    v_scan_bolag_completed :=FALSE;

                    l_LogRec.logMsg := 'Will  check only  for discounts for bolag: ' || c.BOLAG_ID;
                    MIGR_LOG.LOG_INFO(l_LogRec);



                ELSE

                   NULL;

                END CASE;

             EXCEPTION
                  WHEN NO_DATA_FOUND THEN
                             v_scan_bolag_completed:=v_scan_for_completed;
                             v_scan_bolag_discounts:=v_scan_for_discounts;
                                l_LogRec.logMsg := 'First loading ' || c.BOLAG_ID;
                              MIGR_LOG.LOG_INFO(l_LogRec);
              END;

                IF v_scan_for_completed  AND  v_scan_bolag_completed THEN
                                   l_LogRec.logMsg := 'condition for check for completed is true : ' || c.BOLAG_ID;
                                   MIGR_LOG.LOG_INFO(l_LogRec);
                    l_file_flag := TRUE;

                    ---FA.20161104 Added to support both modes of file name: with or without bolag prefix
                    IF SUBSTR(l_tfile_name,1,1) = '_' THEN
                      l_completed := c.bolag_name||l_tfile_name;
                    ELSE
                      l_completed := l_tfile_name;
                    END IF;

                    l_file_exists := IS_FILE_EXISTS('READ_DIR_' || c.bolag_name, l_completed);

                    IF (l_file_exists = 1) THEN
                                    l_LogRec.logMsg := 'completed file exists : ' || c.BOLAG_ID;
                                   MIGR_LOG.LOG_INFO(l_LogRec);
                        -- once 'completed.txt' is found, make sure all KFxxx files are present in the bolag directory
                        FOR i IN( SELECT etd.TBLNAME
                                    FROM ETL_TBL_DEF etd
                                   WHERE 1=1
                                     AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
                                  -- AND file_role<>'Derived'                      -- valex 2/6/16. exclude B_PRSN file
                                     AND FILE_ROLE NOT IN ('Derived', 'Discounts') -- valex.3/1/2017 - also, do not search for discounts.txt
                        )
                        LOOP
                              l_act_file := c.BOLAG_NAME || '_' || i.TBLNAME || '.' || l_tfile_etx;
                              l_act_file_exists := IS_FILE_EXISTS('READ_DIR_' || c.bolag_name, l_act_file);

                              IF (l_act_file_exists = 0) THEN
                                  l_LogRec.logMsg := 'Missing File: ' || l_act_file;
                                  MIGR_LOG.LOG_ERROR(l_LogRec);
                                  l_file_flag := FALSE;
                              END IF;

                        END LOOP;

                        IF l_file_flag THEN

                           vMigrationBatchId := INIT_BATCH2(c.bolag_id, p_queued_flag); -- let it run
                        ELSE
                           vMigrationBatchId := INSERT_BATCH_JOB(c.bolag_id, MIGR_GVAR.GV_BATCH_STATUS_REJECTED); -- 'Rejected');
                           --FA.20180220 Archive is called at signal start only
                           ---MIGR_ARCHIVE.ARCHIVE_COMPLETED_FILE(vMigrationBatchId);
                           -- pl 20170214 REJECTED BATCH EMAIL NOTIFICATION
                           MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchId, MIGR_GVAR.GV_MSG_CODE_MIGR_REJECTED );
                        END IF;

                    END IF;
                END IF;

                if  v_scan_for_discounts AND v_scan_bolag_discounts THEN
                        l_LogRec.logMsg := 'condition for check for discounts is true : ' || c.BOLAG_ID;
                                   MIGR_LOG.LOG_INFO(l_LogRec);

                    l_discounts_exists := IS_FILE_EXISTS('READ_DIR_' || c.bolag_name, c.BOLAG_NAME || '_' || l_discounts_file);
                    IF (l_discounts_exists = 1) THEN

                          l_LogRec.logMsg := 'discounts file exists : ' || c.BOLAG_ID;
                                   MIGR_LOG.LOG_INFO(l_LogRec);

                        SELECT COUNT(*)
                          INTO l_waiting_count
                          FROM MIG_MIGRATION_INFO
                         WHERE SUBSTR(MIGRATION_BATCH_ID, 1, 2) = SUBSTR(c.BOLAG_NAME, 2)
                           AND STATUS = MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC;



                          IF l_waiting_count=1 THEN
                            UPDATE MIG_MIGRATION_INFO
                               SET STATUS = MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC
                             WHERE SUBSTR(MIGRATION_BATCH_ID, 1, 2) = SUBSTR(c.BOLAG_NAME, 2)
                               AND STATUS = MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC;
                          ELSIF l_waiting_count>1 THEN
                            l_LogRec.logMsg := 'More than one batches wait for discounts for Bolag: ' || SUBSTR(c.BOLAG_NAME, 2);
                            MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                          END IF;
                    END IF;
                END IF;

            END LOOP;
        END IF;

        -- Start MIGR_RUN_PARALLEL_JOB
        FOR c IN (SELECT STATUS, MIGRATION_BATCH_ID
                    FROM MIG_MIGRATION_INFO
                   WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_QUEUED, MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC)
                     AND ROWNUM = 1
                     AND 1 = (SELECT COUNT('X') FROM USER_SCHEDULER_JOBS WHERE JOB_NAME = 'MIGR_RUN_PARALLEL_JOB' AND STATE <> 'RUNNING')
        )
        LOOP

             MIGR_TST_PRC_SCHEDULED_JOBS.ENABLE_MIGR_JOB('MIGR_RUN_PARALLEL_JOB');
             l_LogRec.logMsg := 'MIGR_RUN_PARALLEL_JOB is spawned';
             MIGR_LOG.LOG_INFO(l_LogRec) ;

        END LOOP;


        -- start MIGR_RUN_API
        FOR C IN (SELECT ID
                    FROM MIG_MIGRATION_INFO
                   WHERE 1=1
                     AND ROWNUM = 1
                     AND (SELECT COUNT('X') FROM MIG_MIGRATION_INFO WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_QUEUED,MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC,MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC))>0
                     AND 1 = (SELECT COUNT('X') FROM USER_SCHEDULER_JOBS WHERE JOB_NAME='MIGR_RUN_API' AND STATE<>'RUNNING')
                     AND 0 = (SELECT COUNT('x') FROM ETL_SETUP_INFO WHERE NVL(PARALLEL_LEVEL, 0) = 0) -- dont start if parallel level is 0 or null
        )
        LOOP
           MIGR_TST_PRC_SCHEDULED_JOBS.ENABLE_MIGR_JOB('MIGR_RUN_API');
           l_LogRec.logMsg := 'MIGR_RUN_API is spawned';
           MIGR_LOG.LOG_INFO(l_LogRec);

        END LOOP;


        l_LogRec.logMsg := 'Total CHECK_FILES Process runtime: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
        MIGR_LOG.LOG_INFO(l_LogRec);

  EXCEPTION WHEN OTHERS THEN
      l_LogRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END CHECK_FILES;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
PROCEDURE CLOSE_PREVIOUS_BATCH_JOBS(vBOLAG_ID IN PLS_INTEGER) AS
  l_LogRec MIGR_GVAR.LogRecTyp;
BEGIN
      UPDATE MIG_MIGRATION_INFO
--       SET STATUS = 'Stopped', END_TIMESTAMP = SYSTIMESTAMP
         SET STATUS = MIGR_GVAR.GV_BATCH_STATUS_STOPPED, END_TIMESTAMP = SYSTIMESTAMP
--     WHERE STATUS = 'Running' AND BOLAG_ID = vBOLAG_ID;
       WHERE STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING AND BOLAG_ID = vBOLAG_ID;

-- +++ anb 2015-09-23
EXCEPTION WHEN OTHERS THEN
    l_LogRec.mig_batch_id := vBOLAG_ID;
    l_LogRec.migrArea     := 'MIGR_SIGNAL_RESUME.CLOSE_PREVIOUS_BATCH_JOBS';
    l_LogRec.migrStep     := 'CLOSE_PREVIOUS_BATCH_JOBS';
    l_LogRec.migrRelTbl   := NULL;
    l_LogRec.migrRelKey   := NULL;
    l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END CLOSE_PREVIOUS_BATCH_JOBS;

---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
--valex.21/12/2016 conditional update to support Discounts batches
---FA. 2015-10-20 set to autonomous transaction
PROCEDURE MAKE_RUNNABLE(vMigrationBatchID IN VARCHAR2, v_status IN VARCHAR2) AS
PRAGMA AUTONOMOUS_TRANSACTION;
  l_LogRec MIGR_GVAR.LogRecTyp;
BEGIN

  IF v_status = MIGR_GVAR.GV_BATCH_STATUS_QUEUED THEN

    --FA.20171129 At resume the process overrides the start timestamps- The start timestamps should not be overriden
        UPDATE MIG_MIGRATION_INFO
           SET STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING, START_TIMESTAMP =  --= SYSTIMESTAMP
            case when START_TIMESTAMP IS NULL THEN  SYSTIMESTAMP
              ELSE     START_TIMESTAMP
              end
         WHERE MIGRATION_BATCH_ID = vMigrationBatchID;

        -- PL 20170213 EMAIL NOTIFICATION
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchID, MIGR_GVAR.GV_MSG_CODE_MIGR_STARTED );

  ELSIF v_status = MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC THEN
      --FA.20171129 At resume the process overrides the discounts start timestamps- The start timestamps should not be overriden
        UPDATE MIG_MIGRATION_INFO
           SET STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC, DISCOUNTS_START_TIMESTAMP=  -- = SYSTIMESTAMP
             case when DISCOUNTS_START_TIMESTAMP IS NULL THEN  SYSTIMESTAMP
              ELSE     DISCOUNTS_START_TIMESTAMP
              end
         WHERE MIGRATION_BATCH_ID = vMigrationBatchID;

        -- PL 20170213 PHASE 2 EMAIL NOTIFICATION
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchID, MIGR_GVAR.GV_MSG_CODE_MIGR_PHASE_2 );

  END IF;

  COMMIT;

EXCEPTION WHEN OTHERS THEN
  ROLLBACK;
    l_LogRec.mig_batch_id := vMigrationBatchID;
    l_LogRec.migrArea     := 'MIGR_SIGNAL_RESUME.MAKE_RUNNABLE';
    l_LogRec.migrStep     := 'MAKE_RUNNABLE';
    l_LogRec.migrRelTbl   := NULL;
    l_LogRec.migrRelKey   := NULL;
    l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END MAKE_RUNNABLE;

---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
--valex.20/4/16 change batch status
--FA. 20151106 Change status to finished
PROCEDURE CLOSE_BATCH(vMigrationBatchID IN VARCHAR2, pStatus in varchar2)
  AS
      PRAGMA AUTONOMOUS_TRANSACTION;
      l_LogRec MIGR_GVAR.LogRecTyp;

BEGIN
      UPDATE MIG_MIGRATION_INFO
         -- SET STATUS = 'Finished', END_TIMESTAMP = SYSTIMESTAMP
         SET STATUS = pStatus, END_TIMESTAMP = SYSTIMESTAMP
       WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC) AND MIGRATION_BATCH_ID = vMigrationBatchID;

      -- PL 20170213 EMAIL NOTIFICATION
      IF pStatus = MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC THEN
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchID, MIGR_GVAR.GV_MSG_CODE_MIGR_WAIT_DISC );
      ELSIF pStatus = MIGR_GVAR.GV_BATCH_STATUS_FINISHED THEN
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchID, MIGR_GVAR.GV_MSG_CODE_MIGR_COMPLETED );
      ELSIF pStatus = MIGR_GVAR.GV_BATCH_STATUS_FAILED THEN
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchID, MIGR_GVAR.GV_MSG_CODE_MIGR_FAILED );
      END IF;

      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.mig_batch_id := vMigrationBatchID;
        l_LogRec.migrArea     := 'MIGR_SIGNAL_RESUME.CLOSE_BATCH';
        l_LogRec.migrStep     := 'CLOSE_BATCH';
        l_LogRec.migrRelTbl   := NULL;
        l_LogRec.migrRelKey   := NULL;
        l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

        ROLLBACK;

END CLOSE_BATCH;

---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
--FA. 20151112 Insert batch with specific status e.g rejected when missing files
FUNCTION INSERT_BATCH_JOB(vBOLAG_ID IN PLS_INTEGER, p_status IN VARCHAR2)
RETURN VARCHAR2 IS

  PRAGMA AUTONOMOUS_TRANSACTION;
  vSQl  VARCHAR2(2100);
  VMigBatchID VARCHAR2(10);
  v_Bolag VARCHAR2(10);
  l_LogRec MIGR_GVAR.LogRecTyp;
  v_renewal DATE;

BEGIN
  --valex.15/3/2017 - RENEWAL_DATE will be inserted in MIG_MIGRATION_INFO below, in relative field
  SELECT trunc(RENEWAL_DATE)
    into v_renewal
  FROM (SELECT *   FROM ETL_MIGRATION_CONDITIONS   WHERE 1=1      and ITERATION_STATUS='Pending'   oRDER by id)
  where ROWNUM=1;
    --valex.15/3/2017 - end

  if LENGTH(vBOLAG_ID)=1 THEN
    v_Bolag:='0'||to_char(vBOLAG_ID);
  else
    v_Bolag:=to_char(vBOLAG_ID);
  END IF;

  VMigBatchID := '';
  IF p_status= 'Queued' THEN
    vsql := 'INSERT INTO MIG_MIGRATION_INFO (MIGRATION_BATCH_ID, START_TIMESTAMP, END_TIMESTAMP, STATUS, BOLAG_ID, ID, RENEWAL_DATE)
               SELECT   ''' || v_Bolag ||''' ||'||q'['-']'||'||LPAD( CAST(mmi2.newID AS VARCHAR2(6)),6,'||q'['0']'||') AS  MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS START_TIMESTAMP,
               NULL  AS END_TIMESTAMP ,'
              ||chr(39)|| p_status ||chr(39)||' AS STATUS,
               ' || vBOLAG_ID || ',
               mmi2.newID, ''' ||v_renewal||'''
              FROM DUAL ,(SELECT NVL(MAX(ID),0)+1 AS newID FROM MIG_MIGRATION_INFO) mmi2';
  ELSE
    vsql := 'INSERT INTO MIG_MIGRATION_INFO (MIGRATION_BATCH_ID, START_TIMESTAMP, END_TIMESTAMP, STATUS, BOLAG_ID, ID,RENEWAL_DATE)
               SELECT   ''' || v_Bolag ||''' ||'||q'['-']'||'||LPAD( CAST(mmi2.newID AS VARCHAR2(6)),6,'||q'['0']'||') AS  MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS START_TIMESTAMP,
               SYSTIMESTAMP  AS END_TIMESTAMP ,'
              ||chr(39)|| p_status ||chr(39)||' AS STATUS,
               ' || vBOLAG_ID || ',
               mmi2.newID, ''' ||v_renewal||'''
              FROM DUAL ,(SELECT NVL(MAX(ID),0)+1 AS newID FROM MIG_MIGRATION_INFO) mmi2';
 END IF;
  EXECUTE IMMEDIATE vSQL;
  COMMIT;

  SELECT MIGRATION_BATCH_ID
     INTO VMigBatchID
      FROM (
        SELECT MIGRATION_BATCH_ID
          FROM MIG_MIGRATION_INFO
          WHERE BOLAG_ID = vBOLAG_ID  and STATUS=p_status
          ORDER BY ID desc)
      where ROWNUM=1;


    RETURN VMigBatchID;

    EXCEPTION WHEN OTHERS THEN

        l_LogRec.mig_batch_id:=VMigBatchID;
        l_LogRec.migrArea      :=   'MIGR_SIGNAL_RESUME.INSERT_BATCH_JOB' ;
        l_LogRec.migrStep      :=  ' INSERT_BATCH_JOB' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM    ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

      ROLLBACK;
      RETURN VMigBatchID;
END INSERT_BATCH_JOB;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
--Initialize batch   -- step10 from demo
FUNCTION INIT_BATCH2(vBOLAG_ID IN PLS_INTEGER,p_queued_flag IN VARCHAR2)
RETURN  VARCHAR2 AS
  MIGRATION_BATCH_ID  VARCHAR2(50);
  vBatchRunning   VARCHAR2(100);
  l_LogRec MIGR_GVAR.LogRecTyp;
BEGIN

-- +++ anb 2015-09-08   Batch should be closed after all processing is completed

      vBatchRunning := NULL;
      MIGRATION_BATCH_ID := NULL;

      BEGIN
          SELECT NVL(x.STATUS,' ') INTO vBatchRunning
            from (SELECT STATUS, MIGRATION_BATCH_ID, ID
                  FROM MIG_MIGRATION_INFO
                  WHERE BOLAG_ID = vBOLAG_ID
                  ORDER BY ID desc
            ) x
          WHERE 1=1
            AND ROWNUM =1;
          EXCEPTION WHEN NO_DATA_FOUND THEN
                vBatchRunning:=' ';
      END;

      -- FA. 2015-10-29 if flag value set to 'Y' then allow only one batch id per bolag in status Running or Queued
      -- if flag value is not 'Y' then keep the rule that should be maximum 1 batch Running and 1 batch Queued
      -- If no batch or batch_status<> Queued (ie Running, Stopped, Finished), then insert a new Queued one.

      IF p_queued_flag ='Y' THEN
         IF (NVL(vBatchRunning,' ') NOT IN ('Queued','Running') )  THEN
            MIGRATION_BATCH_ID := INSERT_BATCH_JOB(vBOLAG_ID,'Queued'); --- this will set it to 'Queued'
-- +++ anb 20151116 timing is on INSERT_NEW_BATCH_JOB
--            INIT_LOG_MIG_MIGRATION_STEPS(vBOLAG_ID); -- works
         END IF;

      ELSE
        IF (NVL(vBatchRunning,' ') =' '  OR NVL(vBatchRunning,' ')<>'Queued') THEN
            MIGRATION_BATCH_ID := INSERT_BATCH_JOB(vBOLAG_ID,'Queued'); --- this will set it to 'Queued'
-- +++ anb 20151116 timing is on INSERT_NEW_BATCH_JOB
--            INIT_LOG_MIG_MIGRATION_STEPS(vBOLAG_ID); -- works
        END IF;
      END IF;


      RETURN MIGRATION_BATCH_ID;
EXCEPTION WHEN OTHERS THEN
      l_LogRec.mig_batch_id:=MIGRATION_BATCH_ID;
        l_LogRec.migrArea      :=   'MIGR_SIGNAL_RESUME.INIT_BATCH2' ;
        l_LogRec.migrStep      :=  ' INIT_BATCH2' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM    ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

END INIT_BATCH2;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
--- FA. 2015-10-21 improve readibility and performance
FUNCTION GET_NEXT_QUEUED RETURN  VARCHAR2 IS
  vBatchQueued VARCHAR2(50);
  v_lock_name  VARCHAR2(128);
  v_got_lock   BOOLEAN;
  l_LogRec     MIGR_GVAR.LogRecTyp;
  v_status     VARCHAR2(50);

BEGIN

    vBatchQueued := ' ';
    v_got_lock := FALSE;
    l_LogRec.mig_batch_id:='0-2';
    l_LogRec.migrArea      :=   'MIGR_SIGNAL_RESUME.GET_NEXT_QUEUED' ;
    l_LogRec.migrStep      :=  ' GET_NEXT_QUEUED' ;
    l_LogRec.migrRelTbl    :=   NULL;
    l_LogRec.migrRelKey  :=   NULL;
--- For every Bolag we can have maximum 1 Queued and 1 Running batch_ids
--- get first Batch_id that is queued and has no previous Running batch. Then make it 'Running'

--FA. 2015.10.29 : Require lock so not to start migration process with same batch id
    v_lock_name :=MIGR_LOCK_UTILS.GET_HANDLE('migr');
    v_got_lock:=MIGR_LOCK_UTILS.REQUEST_LOCK(v_lock_name,'migr');

    IF  v_got_lock THEN

      SELECT MIGRATION_BATCH_ID,status INTO vBatchQueued,v_status
      FROM (WITH ORDERED AS (SELECT MIGRATION_BATCH_ID
                                  ,STATUS
                                  ,BOLAG_ID
                                  ,ID
                                  ,ROW_NUMBER() OVER (PARTITION BY BOLAG_ID ORDER BY ID ASC) AS rn
                           FROM MIG_MIGRATION_INFO
                           WHERE 1 = 1
                              AND STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_QUEUED, MIGR_GVAR.GV_BATCH_STATUS_RUNNING))
          ,x AS (SELECT MIGRATION_BATCH_ID
               ,STATUS
              ,BOLAG_ID
               ,ID
          FROM ORDERED
            WHERE 1 = 1
            AND rn = 1
            AND STATUS = MIGR_GVAR.GV_BATCH_STATUS_QUEUED
          ORDER BY ID ASC)
        ,y AS (SELECT MIGRATION_BATCH_ID,STATUS FROM x
                UNION ALL                             --valex.20/12/2016 - addition of batches in 'Queued_Discounts' status for Discounts support purpose
               SELECT MIGRATION_BATCH_ID,status
               FROM MIG_MIGRATION_INFO
               WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC)
        SELECT * FROM y)
        WHERE ROWNUM = 1;

      MAKE_RUNNABLE( vBatchQueued ,v_status);

      MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
    END IF;

      l_LogRec.logMsg        :=    'Run for batch:'||vBatchQueued;
      MIGR_LOG.LOG_INFO(l_LogRec) ;

    RETURN vBatchQueued;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
      IF  v_got_lock THEN
        MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
      END IF;

      l_LogRec.logMsg        :=    'Queued Batch not found:' ||  SQLCODE || '-' || SQLERRM    ;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
      RETURN vBatchQueued;

    WHEN OTHERS THEN
      IF  v_got_lock THEN
        MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
      END IF;

      l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM    ;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

      RETURN vBatchQueued;

END GET_NEXT_QUEUED;

 ---------------------------------------------------
 ---------------------------------------------------

  FUNCTION GET_NEXT_QUEUED(P_BOLAG IN NUMBER) RETURN  VARCHAR2 IS
  vBatchQueued VARCHAR2(50);
  v_lock_name  VARCHAR2(128);
  v_got_lock   BOOLEAN;
  l_LogRec     MIGR_GVAR.LogRecTyp;
  v_status     VARCHAR2(50);

BEGIN

    vBatchQueued := ' ';
    v_got_lock := FALSE;
    l_LogRec.mig_batch_id:='0-2';
    l_LogRec.migrArea      :=   'MIGR_SIGNAL_RESUME.GET_NEXT_QUEUED' ;
    l_LogRec.migrStep      :=  ' GET_NEXT_QUEUED' ;
    l_LogRec.migrRelTbl    :=   NULL;
    l_LogRec.migrRelKey  :=   NULL;
--- For every Bolag we can have maximum 1 Queued and 1 Running batch_ids
--- get first Batch_id that is queued and has no previous Running batch. Then make it 'Running'

--FA. 2015.10.29 : Require lock so not to start migration process with same batch id

    v_lock_name :=MIGR_LOCK_UTILS.GET_HANDLE('migr');
    v_got_lock:=MIGR_LOCK_UTILS.REQUEST_LOCK(v_lock_name,'migr');

    IF  v_got_lock THEN

      SELECT MIGRATION_BATCH_ID,status INTO vBatchQueued,v_status
      FROM (WITH ORDERED AS (SELECT MIGRATION_BATCH_ID
                                  ,STATUS
                                  ,BOLAG_ID
                                  ,ID
                                  ,ROW_NUMBER() OVER (PARTITION BY BOLAG_ID ORDER BY ID ASC) AS rn
                           FROM MIG_MIGRATION_INFO
                           WHERE 1 = 1
        AND  BOLAG_ID   =P_BOLAG
                              AND STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_QUEUED, MIGR_GVAR.GV_BATCH_STATUS_RUNNING))
          ,x AS (SELECT MIGRATION_BATCH_ID
               ,STATUS
              ,BOLAG_ID
               ,ID
          FROM ORDERED
            WHERE 1 = 1
            AND rn = 1
            AND STATUS = MIGR_GVAR.GV_BATCH_STATUS_QUEUED
          ORDER BY ID ASC)
        ,y AS (SELECT MIGRATION_BATCH_ID,STATUS FROM x
                UNION ALL                             --valex.20/12/2016 - addition of batches in 'Queued_Discounts' status for Discounts support purpose
               SELECT MIGRATION_BATCH_ID,status
               FROM MIG_MIGRATION_INFO
               WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC)
        SELECT * FROM y)
        WHERE ROWNUM = 1;

      MAKE_RUNNABLE( vBatchQueued ,v_status);

      MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
    END IF;

    RETURN vBatchQueued;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
      IF  v_got_lock THEN
        MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
      END IF;

      l_LogRec.logMsg        :=    'Queued Batch not found:' ||  SQLCODE || '-' || SQLERRM    ;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
      RETURN vBatchQueued;

    WHEN OTHERS THEN
      IF  v_got_lock THEN
        MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
      END IF;

      l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM    ;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

      RETURN vBatchQueued;

END GET_NEXT_QUEUED;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
  ---FA.20180125 RAC addition:clean up process for RAC failovers :if pol jobs are less than policies in running state the api should be dropped in order to trigger the resume process
  PROCEDURE CLEANUP_PROCESS
  IS
    v_cleanup_time_interval  ETL_SETUP_INFO.CLEANUP_TIME_INTERVAL%TYPE;
    v_cleanup_checks            ETL_SETUP_INFO.CLEANUP_CHECKS%TYPE;
    PRAGMA AUTONOMOUS_TRANSACTION;
     l_LogRec           MIGR_GVAR.LogRecTyp;
     v_cnt_jobs      NUMBER;
     v_cnt_policies    NUMBER;
    BEGIN
       l_LogRec.migrArea := 'MIGR_SIGNAL_RESUME.CLEANUP_PROCESS';


      SELECT esi.CLEANUP_TIME_INTERVAL, NVL(esi.CLEANUP_CHECKS ,0)
      INTO      v_cleanup_time_interval, v_cleanup_checks
      FROM ETL_SETUP_INFO esi;

       IF  v_cleanup_time_interval  = v_cleanup_checks THEN
           l_LogRec.logMsg := 'Entered Cleanup Process';
           MIGR_LOG.LOG_INFO(l_LogRec);
           SELECT COUNT (1) into v_cnt_jobs from USER_SCHEDULER_JOBS WHERE JOB_NAME LIKE 'POL_%';
           SELECT COUNT (1) into v_cnt_policies from IA_POLICY WHERE MIG_FLAG in (MIGR_GVAR.GV_MIG_FLAG_RUNNING, MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS);
           l_LogRec.logMsg := 'Running Policies:' || v_cnt_policies || '- Running Jobs:'|| v_cnt_jobs;
           MIGR_LOG.LOG_INFO(l_LogRec);

          IF  v_cnt_jobs<v_cnt_policies THEN
              l_LogRec.logMsg := 'Stop Migr Run API';
                MIGR_LOG.LOG_INFO(l_LogRec);
               MIGR_SCHEDULED_JOBS.STOP_MIGR_RUNNING_JOB('MIGR_RUN_API');

            FOR c in (SELECT *  FROM USER_SCHEDULER_JOBS  WHERE JOB_NAME like  ( 'POL%') )  LOOP
                       l_LogRec.logMsg := 'Drop Migr Pol Job:' || c.JOB_NAME;
                       MIGR_LOG.LOG_INFO(l_LogRec);
                      dbms_scheduler.drop_job(job_name=>c.job_name,force=>TRUE);
             END LOOP;

           END IF;
           UPDATE ETL_SETUP_INFO SET   CLEANUP_CHECKS =0;
       ELSE
             UPDATE ETL_SETUP_INFO SET   CLEANUP_CHECKS =v_cleanup_checks +1;
       END IF;

      COMMIT;

      EXCEPTION WHEN OTHERS then
                    l_LogRec.logMsg :=  SQLERRM;
                   MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                  ROLLBACK;
    END CLEANUP_PROCESS;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
-- FA. 2015-10-29
-- if p_queued flag is 'Y' then per bolag one batch id is allowed in ('QUEUED'/RUNNABLE)
PROCEDURE RUN_SIGNAL(p_queued_flag IN VARCHAR2)
  IS
    MIGRATION_BATCH_ID VARCHAR2(10);
    L_SRVERRMSG        SRVERRMSG;
    PIO_ERR			   SRVERR;
    vsql               VARCHAR2(200);
    l_LogRec           MIGR_GVAR.LogRecTyp;

    l_eventTimer       TIMESTAMP;

BEGIN

     l_LogRec.migrArea := 'MIGR_SIGNAL_RESUME.RUN_SIGNAL';
     l_eventTimer := SYSTIMESTAMP;

     -- Create MIGR_RUN_API and MIGR_RUN_PARALLEL_JOB, if they do not exist in USER_SCHEDULER_JOBS
     MIGR_TST_PRC_SCHEDULED_JOBS.START_JOBS();

      ---FA.20180125 RAC addition:clean up process for RAC failovers
    CLEANUP_PROCESS;


     -- valex.2/11/2016 - search for batches applicable for resumption and take relative actions
      ---FA.20180130 Alter Resume conditions for RAC
--     FOR c IN (WITH x AS (SELECT MIGRATION_BATCH_ID, 'order' AS seq1
--                            FROM mig_migration_info
--                           WHERE 1=1
--                             AND STATUS in (MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC)
--                             AND 0=(SELECT count('x') FROM USER_SCHEDULER_JOBS WHERE job_name = 'MIGR_RUN_API' AND (STATE='RUNNING' OR STATE='SCHEDULED'))
--                             AND 0=(SELECT count('x') FROM USER_SCHEDULER_JOBS WHERE job_name LIKE 'MIGRATE_BOLAG%' )
--                           )
--               ,y as     (select distinct  MIGRATION_BATCH_ID,seq1 from x)
--               ,z as     (select MIGRATION_BATCH_ID,ROW_NUMBER() OVER (partition BY seq1 ORDER BY seq1) AS seq     from y)
--                SELECT z.*,cnt   FROM z ,(SELECT count(*) as cnt FROM z)  ORDER BY seq   )
--     LOOP

      FOR c IN (WITH running_jobs AS
      (SELECT   JOB_NAME  from  USER_SCHEDULER_JOBS  WHERE ( job_name like 'MIGRATE_BOLAG%')
       UNION ALL (SELECT   JOB_NAME  from  USER_SCHEDULER_JOBS WHERE  job_name = 'MIGR_RUN_API'   AND (STATE='RUNNING' OR STATE='SCHEDULED')))
   select b.migration_batch_id from mig_migration_info  b
     LEFT JOIN  running_jobs on bolag_id =   regexp_substr(job_name,'[0-9]+')     and  REGEXP_LIKE (JOB_NAME, 'MIGRATE_BOLAG_'|| '[0-9]')
      WHERE  status=MIGR_GVAR.GV_BATCH_STATUS_RUNNING  AND IA_COMPLETED='Pending'  and job_name is null
    UNION ALL
    select Migration_batch_id from mig_migration_info
    LEFT JOIN  running_jobs    on bolag_id =   regexp_substr(job_name,'[0-9]+')   and  job_name like 'MIGRATE_BOLAG_DISC%'
   WHERE status=MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC AND DISCOUNT_COMPLETED='Pending' and job_name is null
  UNION  ALL
      select migration_batch_id from mig_migration_info
      WHERE  0=(SELECT count('x') FROM running_jobs WHERE job_name = 'MIGR_RUN_API' )
        AND  (
                       ( status =  MIGR_GVAR.GV_BATCH_STATUS_RUNNING AND IA_COMPLETED='Finished' )
                OR  (STATUS=  MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC   AND DISCOUNT_COMPLETED='Finished' )
                   )
      )
    LOOP

        -- pl 20170214 RESUME EMAIL NOTIFICATION
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_RESUMED );
        ---FA.20180201 Alter Resume conditions for RAC
        ---- IF c.seq=1 THEN
        --l_LogRec.logMsg := 'Entered resume loop';
        l_LogRec.logMsg := 'Entered resume loop for batch: '||c.MIGRATION_BATCH_ID;
        MIGR_LOG.LOG_INFO(l_LogRec);
        ----END IF;

        MIGR_SETUP.CHECK_SID(1);

        UPDATE MIG_MIGRATION_INFO mmi
          SET mmi.resume_process='In Progress',mmi.STATUS=
          (CASE WHEN STATUS=MIGR_GVAR.GV_BATCH_STATUS_RUNNING THEN MIGR_GVAR.GV_BATCH_STATUS_QUEUED
          when STATUS=MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC THEN MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC END)
          WHERE  mmi.MIGRATION_BATCH_ID=c.MIGRATION_BATCH_ID;

        COMMIT;

    END LOOP;

    -- 20170322 pl
    MIGR_ARCHIVE.ARCHIVE_MUTUAL;

    CHECK_FILES(p_queued_flag);

    l_LogRec.logMsg := 'Total Signal Process runtime: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
    MIGR_LOG.LOG_INFO(l_LogRec);

EXCEPTION
  WHEN OTHERS THEN
    l_LogRec.logMsg := SQLCODE || '-' || SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END RUN_SIGNAL;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
PROCEDURE LOG_NOT_MIGRATED_BOLAGS(p_id IN PLS_INTEGER, p_applicable_bolags IN VARCHAR2)
  IS

    i        PLS_INTEGER:=1;     -- variable gets positions of comma in p_applicable_bolags string
    v_bolag  VARCHAR2(10);
    v_flag   PLS_INTEGER:=0;
    l_LogRec MIGR_GVAR.LogRecTyp;
    l_list   VARCHAR2(200);
    l_count  PLS_INTEGER:=0;

begin

    l_LogRec.migrArea := 'MIGR_SIGNAL_RESUME.LOG_NOT_MIGRATED_BOLAGS';
    l_LogRec.migrStep := 'Check for Bolags not included in the Migration Process';

    WHILE INSTR(p_applicable_bolags,',',i+1,1)<> 0   --search p_applicable_bolags string for the next comma until it does not exist
    loop

       v_bolag:=SUBSTR(p_applicable_bolags,INSTR(p_applicable_bolags,',',i,1)+1,2);      --variable carries the bolag which is after the current comma position, in the relative string

          --identify bolags which DO NOT have a batch in MIG_MIGRATION_INFO (all batches of previous renewal months are excluded)
          FOR c IN (SELECT a.bolag
                      FROM (SELECT v_bolag bolag FROM DUAL) a
                      --LEFT JOIN (SELECT MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO WHERE NVL(DATA_MOVED_TO_ARCHIVE,'0') <> MIGR_GVAR.GV_STATUS_FINISHED) b
                        LEFT JOIN (SELECT MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO WHERE NVL(DATA_MOVED_TO_ARCHIVE,'0') <> MIGR_GVAR.GV_STATUS_FINISHED
                                      --AND STATUS <> MIGR_GVAR.GV_STATUS_FAILED) b
                               --FA.20170921 Status should not be in either rejected-failed
                                  AND STATUS NOT IN ( MIGR_GVAR.GV_STATUS_FAILED,MIGR_GVAR.GV_BATCH_STATUS_REJECTED)  )b

                        ON a.bolag=SUBSTR(b.MIGRATION_BATCH_ID, 1, 2)
                     WHERE b.MIGRATION_BATCH_ID IS NULL
          )
          LOOP
              l_LogRec.logMsg := 'Bolag ' ||c.bolag || ' did not upload completed.txt, during renewal month with ID='||p_id;
              MIGR_LOG.LOG_INFO(l_LogRec);
              v_flag:=1;
              l_list:=l_list||c.bolag||',';

              SELECT COUNT('X') INTO l_count FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl WHERE menl.MIGRATION_BATCH_ID=c.BOLAG || '-' || LPAD(p_id, 2, 0) AND menl.MSG_CODE=MIGR_GVAR.GV_MSG_CODE_MIGR_MISSING_TXT;
              IF l_count=0 THEN
                  MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c.BOLAG || '-' || LPAD(p_id, 2, 0), MIGR_GVAR.GV_MSG_CODE_MIGR_MISSING_TXT );
              END IF;
          END LOOP;

          i:=INSTR(p_applicable_bolags,',',i+1,1);

    END LOOP;

    UPDATE ETL_MIGRATION_CONDITIONS SET missed_data_deadline=(CASE WHEN NVL(l_list,' ') <> ' ' then SUBSTR(l_list,1,LENGTH(l_list)-1) else 'All bolags uploaded mutual data' end) WHERE ID=p_id;

 EXCEPTION WHEN OTHERS THEN
    l_LogRec.logMsg := SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
END LOG_NOT_MIGRATED_BOLAGS;
  ---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
 --FA.20170921 Check if file exist in folder
  FUNCTION FILE_EXISTS (p_scan_for_completed IN BOOLEAN,p_scan_for_discounts IN BOOLEAN,l_id IN ETL_MIGRATION_CONDITIONS.ID%TYPE, p_BOLAG_ID IN MIG_MIGRATION_INFO.BOLAG_ID%type)
    RETURN BOOLEAN
    IS

    l_tfile_name         VARCHAR2(50);
    l_tfile_etx          VARCHAR2(10);
    l_file_exists        PLS_INTEGER;
    l_LogRec             MIGR_GVAR.LogRecTyp;
    l_completed          ETL_SETUP_INFO.MIGG_FILE_NAME%TYPE;
    l_discounts_file     VARCHAR2(100);
    l_discounts_exists   PLS_INTEGER := 0;
    l_bolag_name ETL_BOLAG_INFO.BOLAG_NAME%type;
  BEGIN

        l_LogRec.migrArea := 'MIGR_SIGNAL_RESUME.FILE_EXISTS';
        l_LogRec.mig_batch_id := '0-1';
        l_LogRec.migrArea     := 'MIGR_SIGNAL_RESUME.FILE_EXISTS';
        l_LogRec.migrStep     := 'FILE_EXISTS';
        l_LogRec.migrRelTbl   := NULL;
        l_LogRec.migrRelKey   := NULL;
                   l_LogRec.logMsg := 'file exists' ;
      MIGR_LOG.LOG_INFO(l_LogRec);
        SELECT MIGG_FILE_NAME, FILE_EXTN, DISCOUNTS_FILE_NAME   INTO l_tfile_name, l_tfile_etx, l_discounts_file    FROM ETL_SETUP_INFO;


        SELECT BOLAG_NAME into l_bolag_name FROM ETL_BOLAG_INFO WHERE BOLAG_ID=p_BOLAG_ID;
                IF P_scan_for_completed THEN
                 l_LogRec.logMsg := 'P_scan_for_completed' ;
                MIGR_LOG.LOG_INFO(l_LogRec);
                    ---FA.20161104 Added to support both modes of file name: with or without bolag prefix
                    IF SUBSTR(l_tfile_name,1,1) = '_' THEN
                      l_completed := l_bolag_name||l_tfile_name;
                    ELSE
                      l_completed := l_tfile_name;
                    END IF;

                    l_file_exists := IS_FILE_EXISTS('READ_DIR_' ||l_bolag_name, l_completed);
                               l_LogRec.logMsg := 'l_file_exists'||l_file_exists||' ' || l_bolag_name || ' ' || l_completed ;
      MIGR_LOG.LOG_INFO(l_LogRec);
                    IF (l_file_exists = 1) THEN RETURN  TRUE;
                    ELSE    RETURN FALSE;
                    END IF;

               END IF;

                IF  P_scan_for_discounts THEN

                    l_LogRec.logMsg := 'can disc!';
                       MIGR_LOG.LOG_INFO(l_LogRec);
                    l_discounts_exists := IS_FILE_EXISTS('READ_DIR_' || l_bolag_name, l_bolag_name || '_' || l_discounts_file);
                               l_LogRec.logMsg :=l_discounts_exists;
                       MIGR_LOG.LOG_INFO(l_LogRec);
                    IF (l_discounts_exists = 1) THEN RETURN TRUE;
                    ELSE  RETURN FALSE;
                    END IF;

                END IF;

--            END LOOP;


  EXCEPTION WHEN OTHERS THEN
      l_LogRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
      RETURN FALSE;
END FILE_EXISTS;
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
PROCEDURE TXT_NOT_FOUND_REMINDER(p_id IN PLS_INTEGER, p_applicable_bolags IN VARCHAR2, p_status IN VARCHAR2)
  IS
    i         PLS_INTEGER:=1;     -- variable gets positions of comma in p_applicable_bolags string
    v_bolag   VARCHAR2(10);
    v_flag    PLS_INTEGER:=0;
    l_LogRec  MIGR_GVAR.LogRecTyp;
    l_list    VARCHAR2(200);
    l_count   PLS_INTEGER;
    l_days_left PLS_INTEGER;

BEGIN
    l_LogRec.migrArea := 'MIGR_SIGNAL_RESUME.TXT_NOT_FOUND_REMINDER';
    l_LogRec.migrStep := 'MIGR_SIGNAL_RESUME.TXT_NOT_FOUND_REMINDER';

    MIGR_LOG.LOG_INFO(l_LogRec);
    SELECT NVL(COMPLETED_REMINDER_DAYS_BEFORE,0)
      into l_days_left
    FROM ETL_SETUP_INFO;

    WHILE INSTR(p_applicable_bolags, ',', i+1, 1) <> 0  -- search p_applicable_bolags string for the next comma until it does not exist
    LOOP
       v_bolag := SUBSTR(p_applicable_bolags, INSTR(p_applicable_bolags, ',', i, 1) + 1, 2);  -- variable carries the bolag which is after the current comma position, in the relative string

       -- identify bolags which DO NOT have a batch in MIG_MIGRATION_INFO (all batches of previous renewal months are excluded)
          IF p_status = MIGR_GVAR.GV_MSG_CODE_MIGR_TXT_REMINDER THEN
       FOR c IN (SELECT a.BOLAG
                   FROM (SELECT v_bolag BOLAG FROM DUAL) a
                   LEFT JOIN (SELECT MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO WHERE NVL(DATA_MOVED_TO_ARCHIVE, '0') <> MIGR_GVAR.GV_STATUS_FINISHED
                      AND STATUS NOT IN ( MIGR_GVAR.GV_STATUS_FAILED,MIGR_GVAR.GV_BATCH_STATUS_REJECTED) )b
                     ON a.BOLAG=SUBSTR(b.MIGRATION_BATCH_ID, 1, 2)
                  WHERE b.MIGRATION_BATCH_ID is NULL
       )
       LOOP

              SELECT COUNT('X') INTO l_count FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl WHERE menl.MIGRATION_BATCH_ID=c.BOLAG || '-' || LPAD(p_id, 2, 0) AND menl.MSG_CODE=p_status;

              IF l_count=0 THEN
                     ---FA.20170921 Check if bolag has uploaded file  prior to sending the reminder
                   IF not FILE_EXISTS (TRUE,FALSE,p_id,c.BOLAG) THEN

                       l_LogRec.logMsg := 'Bolag ' ||c.bolag || ' did not upload Completed.txt yet. Only '|| l_days_left ||' days left!';
                       MIGR_LOG.LOG_INFO(l_LogRec);

                       MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_WITH_DYNAMIC_MSG(c.BOLAG || '-' || LPAD(p_id, 2, 0), p_status,   l_LogRec.logMsg);
                    END IF;
              END IF;

         END LOOP;
      END IF;
         IF p_status = MIGR_GVAR.GV_MSG_CODE_MIGR_DISC_REMINDER THEN
           FOR c IN (SELECT a.BOLAG
                   FROM (SELECT v_bolag BOLAG FROM DUAL) a
                    JOIN (SELECT MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO WHERE NVL(DATA_MOVED_TO_ARCHIVE, '0') <> MIGR_GVAR.GV_STATUS_FINISHED
            AND STATUS=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC) b
                     ON a.BOLAG=SUBSTR(b.MIGRATION_BATCH_ID, 1, 2)

       )
       LOOP

              SELECT COUNT('X') INTO l_count FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl WHERE menl.MIGRATION_BATCH_ID=c.BOLAG || '-' || LPAD(p_id, 2, 0) AND menl.MSG_CODE=p_status;

              IF l_count=0 THEN

                       l_LogRec.logMsg := 'Bolag ' ||c.bolag || ' did not upload MD_Discounts.txt yet. Only '|| l_days_left ||' days left!';
                       MIGR_LOG.LOG_INFO(l_LogRec);

                       MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_WITH_DYNAMIC_MSG(c.BOLAG || '-' || LPAD(p_id, 2, 0), p_status,   l_LogRec.logMsg);

              END IF;



       END LOOP;
           END IF;
       i := INSTR(p_applicable_bolags, ',', i+1, 1);

    END LOOP;


 EXCEPTION
    WHEN OTHERS THEN
      l_LogRec.logMsg := SQLCODE || ' - ' || SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END TXT_NOT_FOUND_REMINDER;


---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
PROCEDURE MIGRATION_SCHEDULE (v_id OUT PLS_INTEGER, v_scan_for_completed OUT BOOLEAN, v_scan_for_discounts OUT boolean)
  IS

    v_not_finished      PLS_INTEGER;
    l_LogRec            MIGR_GVAR.LogRecTyp;
    l_remove_interval   PLS_INTEGER:=0;
    l_Waiting_discounts PLS_INTEGER:=0;
    l_appl_bolags       VARCHAR2(100);
    l_all_batch_completed  BOOLEAN;
    l_days   NUMBER;
    l_eventTimer        TIMESTAMP;
    l_failDataArc NUMBER;
    l_incompleteCycles NUMBER;
    l_pendingArc number;
    l_count   NUMBER;
  begin
     l_LogRec.migrArea := 'MIGR_SIGNAL_RESUME.MIGRATION_SCHEDULE';
     l_LogRec.migrStep := 'Application of Renewal months schedule';

     l_eventTimer := SYSTIMESTAMP;

     v_scan_for_completed := FALSE;
     v_scan_for_discounts := FALSE;

     MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;

     SELECT NVL(COMPLETED_REMINDER_DAYS_BEFORE,0) into l_days FROM ETL_SETUP_INFO  ;

     for c in (with x AS (SELECT *
                          FROM ETL_MIGRATION_CONDITIONS
                          WHERE 1=1
                            and ITERATION_STATUS='Pending'
                          oRDER by id )
               ,y AS (SELECT *
                      FROM x
                      where ROWNUM=1)
               ,z AS (SELECT y.*
                          ,(CASE WHEN (select count(*) from ETL_MIGRATION_CONDITIONS)=id then null else (select renewal_date from ETL_MIGRATION_CONDITIONS where id=y.ID+1) end) next_renewal
                          ,(CASE WHEN (select count(*) from ETL_MIGRATION_CONDITIONS)=id then null else (select migr_start_date from ETL_MIGRATION_CONDITIONS where id=y.ID+1) end) next_start
                          ,(CASE WHEN (select count(*) from ETL_MIGRATION_CONDITIONS)=id then null else (select id from ETL_MIGRATION_CONDITIONS where id=y.ID+1) end) next_id
                      from y )
               SELECT *
                 from z
      )
      LOOP
          v_id:=c.id;

          SELECT COUNT('x')  INTO l_Waiting_discounts  FROM MIG_MIGRATION_INFO mmi  WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC  AND ROWNUM = 1;

          -- create and send via email the discounts file to bolags, if not done aready
          MIGR_MD_DISCOUNTS.SEND_MD_DISCOUNTS_FILE;


          -- pl 20170626 migration daily progress email notification
          MIGR_REPORTING.DAILY_PROGRESS( c.RENEWAL_DATE );

          IF SYSDATE < c.migr_start_date THEN

             IF SYSDATE < ( c.MIGR_START_DATE- l_days) THEN

                 l_LogRec.logMsg := 'MIGR_RUN_SIGNAL_JOB next run will be postponed:' ||l_days   ||  ' prior to MIGR_START_DATE of current renewal month with ID=' || c.ID;
                  MIGR_LOG.LOG_INFO(l_LogRec);

                  --FA.20170911 Signal should be postponed n days prior to next run in order to send the reminder for missing completed files
                  DBMS_SCHEDULER.SET_ATTRIBUTE (name => 'MIGR_RUN_SIGNAL_JOB',attribute =>'start_date', VALUE => (c.MIGR_START_DATE-l_days));

                  -- Signal postponement email
                  MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION('0-0', MIGR_GVAR.GV_MSG_CODE_MIGR_SIGNAL_POSTP);
                  MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;

              END IF;

              -- PL 20170214 Email reminder for missing completed.txt files
              FOR c_1 IN (SELECT ','|| NVL(APPLICABLE_BOLAGS, 0) ||',' AS APPL_BOLAGS
                            FROM (SELECT APPLICABLE_BOLAGS
                                    FROM ETL_MIGRATION_CONDITIONS
                                   WHERE ITERATION_STATUS = 'Pending'   AND TRUNC(SYSDATE) = TRUNC(MIGR_END_DATE)-l_days
                                   ORDER BY ID ASC)
                           WHERE ROWNUM = 1
              )
              LOOP
                    TXT_NOT_FOUND_REMINDER(c.ID, c_1.APPL_BOLAGS, MIGR_GVAR.GV_MSG_CODE_MIGR_TXT_REMINDER);

                    --FA.20170919 send email immediately - Signal may be postponed
                    MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;

              END LOOP;

          ELSIF SYSDATE <= c.migr_end_date THEN
              v_scan_for_completed := TRUE; -- scan for completed.txt
              IF l_Waiting_discounts = 1 THEN
                v_scan_for_discounts := TRUE; -- scan for discounts.txt
                --MIGR_MD_DISCOUNTS.SEND_MD_DISCOUNTS_FILE; -- create and send via email the discounts file to bolags, if not done aready
              END IF;

          ELSIF SYSDATE <= c.discounts_end_date THEN

              --IF v_not_finished=0 AND NVL(c.MISSED_DATA_DEADLINE,'0')='0' THEN  --if all batches finished or failed and the relative check has not been performed previously
               --FA.20170921 If remain here then is called very on minute and enters one log per minute- As the deadline will pass for all bolags call it only once
                 IF C.missed_data_deadline IS NULL THEN
                          LOG_NOT_MIGRATED_BOLAGS(c.id, ',' || c.applicable_bolags || ',');  --beware! second parameter is enclosed in commas
                 END IF;
                  IF l_Waiting_discounts = 1 THEN
                    v_scan_for_discounts := TRUE; -- scan for discounts.txt

                  END IF;

                  --FA.20170921 Send reminders for bolags that have not missed the completed deadline
                  FOR c_2 IN (SELECT  ',' || NVL( listagg(BOLAG_ID,',')   within GROUP(ORDER by bolag_id) , 0) || ',' AS APPL_BOLAGS
                                       FROM ETL_BOLAG_INFO ,
                                      (SELECT APPLICABLE_BOLAGS, MISSED_DATA_DEADLINE
                                        FROM ETL_MIGRATION_CONDITIONS
                                        WHERE ITERATION_STATUS = 'Pending' AND id=c.id
                                         AND TRUNC(SYSDATE) = TRUNC(DISCOUNTS_END_DATE-(SELECT NVL(COMPLETED_REMINDER_DAYS_BEFORE,0) FROM ETL_SETUP_INFO) )
                                       )
                        WHERE ',' || APPLICABLE_BOLAGS || ',' LIKE '%,' || SUBSTR(BOLAG_NAME, 2) || ',%'
                          AND ',' || MISSED_DATA_DEADLINE || ',' NOT LIKE '%,' || SUBSTR(BOLAG_NAME, 2) || ',%' )
                LOOP

                      TXT_NOT_FOUND_REMINDER(c.ID, c_2.APPL_BOLAGS, MIGR_GVAR.GV_MSG_CODE_MIGR_DISC_REMINDER);
                END LOOP;

           ELSIF SYSDATE > c.discounts_end_date THEN --AND (SYSDATE < c.next_start OR c.next_start IS NULL) THEN
                --FA.20170406 If incomplete batch found notify users and do not close iteration batch and do not archive data
                LOG_NOT_MIGRATED_BOLAGS_DISC(c.id, ',' || c.applicable_bolags || ','); -- beware! second parameter is enclosed in commas
                l_all_batch_completed := TRUE;

              --FA. 20170615 Check if  Phase 1 running batch exist and send delay notification
                  FOR r IN (SELECT MIGRATION_BATCH_ID,PHASE1_DELAY  FROM MIG_MIGRATION_INFO WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_RUNNING)
                  LOOP
                       IF R.PHASE1_DELAY IS NULL THEN
                            MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_WITH_DYNAMIC_MSG (R.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_PROCESS_DELAY,
                            'The deadline for uploading discounts has passed and Phase 1 for batch: ' || r.MIGRATION_BATCH_ID || ' has not been completed. Process may not be able to complete current iteration cycle. When Phase 1 completes processing, Phase 2 will be triggered automatically with zero discounts. Immediate action is required to investigate the cause of delay.  ' );
                            UPDATE MIG_MIGRATION_INFO set PHASE1_DELAY=SYSTIMESTAMP WHERE MIGRATION_BATCH_ID = r.MIGRATION_BATCH_ID;
                       END IF;
                       l_all_batch_completed := FALSE;
                  END LOOP;

                  FOR c_INCOMPLETE IN (SELECT MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC)
                  LOOP
                      l_all_batch_completed := FALSE;
                      -- UPDATE MIG_MIGRATION_INFO SET STATUS=MIGR_GVAR.GV_BATCH_STATUS_INCOMPLETE WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC; --close relative batches status, so that flag l_Waiting_discounts not be raised erronesously, during next months scans
                      -- pl 20170214 INCOMPLETE BATCH EMAIL NOTIFICATION

                      MIGR_MD_DISCOUNTS.DEFAULT_MD_DISCOUNTS_FILE(c_INCOMPLETE.MIGRATION_BATCH_ID);
                      SELECT COUNT(1) into l_count from MIGR_EMAIL_NOTIFICATIONS_LOG WHERE MIGRATION_BATCH_ID= c_INCOMPLETE.MIGRATION_BATCH_ID and  MSG_CODE= MIGR_GVAR.GV_MSG_CODE_MIGR_DEFAULT_DISC;
                      IF l_count =0 THEN
                          MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c_INCOMPLETE.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_MIGR_DEFAULT_DISC );
                      END IF;
                      v_scan_for_discounts := TRUE; -- scan for discounts.txt
                  END LOOP;

                  SELECT COUNT(*)     INTO v_not_finished
                    FROM MIG_MIGRATION_INFO
                   WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

                    IF v_not_finished=0 AND l_all_batch_completed then -- if all batches are either finished or failed their discount phase
                              MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;

                        ---FA.20170919 Check if there are pending batces for archive
                        SELECT COUNT(1) into l_pendingArc FROM MIG_MIGRATION_INFO mmi WHERE mmi.DATA_MOVED_TO_ARCHIVE IN( 'Pending','Failed');
                       ---FA.20170928 For BI reporting reasons do not archive until next start date -1 -For the last run give  10-days to complete phase 2 and extract BI final reports
                       IF l_pendingArc>0  AND  TRUNC(SYSDATE)>= TRUNC(NVL(c.next_start, c.discounts_end_date+10)) -1   then
                            MIGR_ARCHIVE.MOVE_TO_ARCHIVE_SCHEMA;
                      --- END IF;

                       SELECT COUNT('x') into l_failDataArc from mig_migration_info WHERE renewal_date=c.renewal_date AND DATA_MOVED_TO_ARCHIVE<>MIGR_GVAR.GV_STATUS_FINISHED;

                       IF l_failDataArc =0 THEN
                        UPDATE ETL_MIGRATION_CONDITIONS SET ITERATION_STATUS = 'Completed' WHERE ID=c.id;

                       ELSE
                           --FA.20170919 Check if notification was sent before registering message
                            SELECT COUNT('X') INTO l_count  FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl WHERE menl.MIGRATION_BATCH_ID='00'|| '-' || C.ID AND menl.MSG_CODE=MIGR_GVAR.GV_MSG_CODE_FAIL_ARCHIVE_DATA;

                           IF l_count =0 THEN
                                  MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ('00'|| '-' || C.ID, MIGR_GVAR.GV_MSG_CODE_FAIL_ARCHIVE_DATA );
                                  MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;

                                   END IF;
                              END IF;

                        IF c.next_renewal IS NOT NULL THEN  -- not the last month

                            NULL;
                        ELSE  -- last month
                           --FA.20170918 Check if last cycle has been completed
                             select COUNT (1) INTO l_incompleteCycles FROM ETL_MIGRATION_CONDITIONS emc  WHERE iteration_status <> MIGR_GVAR.GV_ITERATION_COMPLETED;

                            IF l_incompleteCycles =0 THEN
                                  l_LogRec.logMsg := 'Migration for all months is finished. MIGR_RUN_SIGNAL_JOB will be disabled' || c.next_start;
                                  MIGR_LOG.LOG_INFO(l_LogRec);
                                  l_remove_interval := 1;  -- signal job minutely interval will be removed at the end of the procedure

                                  -- End of migration!
                                  MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( '0-0', MIGR_GVAR.GV_MSG_CODE_MIGR_END );
                                   --FA.20170915 Send email as signal will be dropped
                                      MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;
                             END IF;
                        END IF;

                    END IF;
                    END IF;
              --FA. 20170615 If next iteration date has arrived and the iteration cycle has not been completed send a notification
                    IF SYSDATE >= c.next_start OR c.next_start IS NULL THEN
                        FOR r IN (SELECT MIGRATION_BATCH_ID,MIGRATION_DELAY  FROM MIG_MIGRATION_INFO WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING,MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC)  )
                        LOOP
                          IF R.MIGRATION_DELAY IS NULL THEN
                              MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_WITH_DYNAMIC_MSG ( R.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_PROCESS_DELAY,
                              'Batch: ' || R.MIGRATION_BATCH_ID || ' for renewal date: ' || TO_CHAR(TRUNC(c.renewal_date), 'dd-mm-yyyy') || ' has not been completed. The next migration iteration for the: ' || TO_CHAR(TRUNC(c.next_renewal), 'dd-mm-yyyy') || ' renewal date cannot be triggered. Immediate action is required. ' );
                              UPDATE MIG_MIGRATION_INFO SET MIGRATION_DELAY=SYSTIMESTAMP WHERE MIGRATION_BATCH_ID =r.MIGRATION_BATCH_ID;
                          END IF;

                        END LOOP;
                    END IF;

          ELSE
              l_LogRec.logMsg := 'Dates inconsistency for renewal month with ID: ' || c.id;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          END IF;
      END LOOP;


      IF l_remove_interval=1 THEN
        DBMS_SCHEDULER.SET_ATTRIBUTE_NULL (name => 'MIGR_RUN_SIGNAL_JOB', attribute => 'repeat_interval');
      END IF;

      l_LogRec.logMsg := 'Total MIGRATION_SCHEDULE Process runtime: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
      MIGR_LOG.LOG_INFO(l_LogRec);

  EXCEPTION WHEN OTHERS THEN
        l_LogRec.logMsg := SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

 END MIGRATION_SCHEDULE;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
PROCEDURE LOG_NOT_MIGRATED_BOLAGS_DISC(p_id IN PLS_INTEGER, p_applicable_bolags IN VARCHAR2)
  IS

    i        PLS_INTEGER:=1;   -- variable gets positions of comma in p_applicable_bolags string
    v_bolag  VARCHAR2(10);
    v_flag   PLS_INTEGER:=0;
    l_LogRec MIGR_GVAR.LogRecTyp;
    l_list   VARCHAR2(200);
    l_count  PLS_INTEGER:=0;

begin

    l_LogRec.migrArea := 'MIGR_SIGNAL_RESUME.LOG_NOT_MIGRATED_BOLAGS_DISC';
    l_LogRec.migrStep := 'Check for Bolags not uploaded MD_DISCOUNTS.txt';

    WHILE INSTR(p_applicable_bolags,',',i+1,1)<> 0   --search p_applicable_bolags string for the next comma until it does not exist
    loop
          v_bolag:=SUBSTR(p_applicable_bolags,INSTR(p_applicable_bolags,',',i,1)+1,2);  --variable carries the bolag which is after the current comma position, in the relative string

          --identify bolags which have a batch in MIG_MIGRATION_INFO in status Wait_Discounts (all batches of previous renewal months are excluded)
          FOR c IN (SELECT a.bolag ,b.MIGRATION_BATCH_ID
                    from (SELECT v_bolag bolag FROM DUAL) a  JOIN (select MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO where NVL(DATA_MOVED_TO_ARCHIVE,'0') <> MIGR_GVAR.GV_STATUS_FINISHED and status=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC) b ON a.bolag=SUBSTR(b.MIGRATION_BATCH_ID,1,2)
          )
          LOOP
              l_LogRec.logMsg := 'Bolag ' ||c.bolag || ' did not upload MD_DISCOUNTS.txt, during renewal month with ID='||p_id;
              MIGR_LOG.LOG_INFO(l_LogRec);
              v_flag:=1;
              l_list:=l_list||c.bolag||',';

              SELECT COUNT('X') INTO l_count FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl WHERE menl.MIGRATION_BATCH_ID=c.MIGRATION_BATCH_ID AND menl.MSG_CODE=MIGR_GVAR.GV_MSG_CODE_MIGR_MISSING_DISC;
              IF l_count=0 THEN
                  ---MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c.BOLAG || '-' || LPAD(p_id, 6, 0), MIGR_GVAR.GV_MSG_CODE_MIGR_MISSING_DISC );
                      MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_MIGR_MISSING_DISC );

              END IF;
          END LOOP;

          i:=INSTR(p_applicable_bolags,',',i+1,1);

    end loop;

    UPDATE ETL_MIGRATION_CONDITIONS SET MISSED_DISCOUNTS_DEADLINE=(CASE when NVL(l_list,' ') <> ' ' THEN SUBSTR(l_list,1,LENGTH(l_list)-1) ELSE 'All bolags (which entered migr process) uploaded MD_DISCOUNTS.txt' END) WHERE ID=p_id;

 EXCEPTION WHEN OTHERS THEN
    l_LogRec.logMsg := SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
end LOG_NOT_MIGRATED_BOLAGS_DISC;


  -------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_TST_PRC_SIGNAL;
/

CREATE OR REPLACE PACKAGE BODY                   MIGR_API
  AS
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- Returns batch number and its status according to api preferences.
PROCEDURE GET_NEXT_BATCH(vMigrationBatchId OUT MIGR_POLICY.MIG_BATCH_ID % TYPE, vStatus OUT VARCHAR2)
  AS
    vPREF_NO  NUMBER(2);
    l_LogRec  MIGR_GVAR.LogRecTyp;
BEGIN
  l_LogRec.migrArea   := 'MIGR_API.GET_NEXT_BATCH';
  l_LogRec.migrStep   := 'MIGR_API.GET_NEXT_BATCH';
  l_LogRec.migrRelTbl := '';

   SELECT NVL(PREF_NO, 0)
    INTO vPREF_NO
    FROM ETL_API_PREFERENCES
   WHERE 1=1
     AND IS_ACTIVE = 'Y'
     AND ROWNUM = 1;

  CASE vPREF_NO
       WHEN 0 THEN
              vMigrationBatchId := NULL;
              vStatus           := NULL;
       WHEN 1 THEN
              SELECT MIGRATION_BATCH_ID, STATUS
                INTO vMigrationBatchId, vStatus
                FROM (SELECT mmi.MIGRATION_BATCH_ID, mmi.STATUS, mmi.START_TIMESTAMP
                        FROM MIG_MIGRATION_INFO mmi
                       WHERE 1=1
                         AND ((mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING AND mmi.IA_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED)
                           OR (mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC AND mmi.DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED))
                       ORDER BY mmi.START_TIMESTAMP ASC
                )
               WHERE 1=1
                 AND ROWNUM = 1;

       WHEN 2 THEN
              SELECT MIG_BATCH_ID, STATUS
                INTO vMigrationBatchId, vStatus
                FROM (SELECT ip.MIG_BATCH_ID, mmi.STATUS, COUNT(*) AS COUNTER
                        FROM IA_POLICY ip
                        JOIN MIG_MIGRATION_INFO mmi ON ip.MIG_BATCH_ID = mmi.MIGRATION_BATCH_ID
                       WHERE 1=1
                         AND ((mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING AND mmi.IA_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_PENDING)
                           OR (mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC AND mmi.DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS))
                       GROUP BY ip.MIG_BATCH_ID, mmi.STATUS
                       ORDER BY COUNTER ASC
                )
               WHERE 1=1
                 AND ROWNUM = 1;

       WHEN 3 THEN
              SELECT MIG_BATCH_ID, STATUS
                INTO vMigrationBatchId, vStatus
                FROM (SELECT ip.MIG_BATCH_ID, mmi.STATUS, COUNT(*) AS COUNTER
                        FROM IA_POLICY ip
                        JOIN MIG_MIGRATION_INFO mmi ON ip.MIG_BATCH_ID = mmi.MIGRATION_BATCH_ID
                       WHERE 1=1
                         AND ((mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING AND mmi.IA_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_PENDING)
                           OR (mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC AND mmi.DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS))
                       GROUP BY ip.MIG_BATCH_ID, mmi.STATUS
                       ORDER BY COUNTER DESC
                )
               WHERE 1=1
                 AND ROWNUM = 1;

       ELSE
          vMigrationBatchId := NULL;
          vStatus           := NULL;
       END CASE;

  l_LogRec.MIG_BATCH_ID := vMigrationBatchId;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
      vMigrationBatchId := NULL;
      vStatus           := NULL;
  WHEN OTHERS THEN
      l_LogRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
END GET_NEXT_BATCH;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---Serves next policy to API according to the input batch number and status. If has pending policies and status is Running then turn policy flag to running  to trigger API phase 1
-- If has pending policies and status is Running Discounts  then turn policy flag to running discounts  to trigger API phase 2
PROCEDURE GET_NEXT_IDPL(vNextIDPL OUT MIGR_POLICY.POLICY_IDPL % TYPE, vMigrationBatchId IN MIGR_POLICY.MIG_BATCH_ID % TYPE, vStatus IN VARCHAR2)
  AS
    l_LogRec  MIGR_GVAR.LogRecTyp;

BEGIN
  l_LogRec.migrArea     := 'MIGR_API.GET_NEXT_IDPL';
  l_LogRec.migrStep     := 'MIGR_API.GET_NEXT_IDPL';
  l_LogRec.mig_batch_id := vMigrationBatchId;
  l_LogRec.migrRelTbl   := 'Status: ' || vStatus;

  SELECT ip.IA_IDPL
    INTO vNextIDPL
    FROM IA_POLICY ip
    JOIN MIG_MIGRATION_INFO mmi ON ip.MIG_BATCH_ID = mmi.MIGRATION_BATCH_ID
   WHERE 1=1
     AND mmi.MIGRATION_BATCH_ID = vMigrationBatchId
     AND mmi.STATUS = vStatus
     AND ((mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING AND mmi.IA_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_PENDING)
       OR (mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC AND mmi.DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS))
     AND ROWNUM = 1;

    l_LogRec.migrRelKey := vNextIDPL;

    IF NOT vNextIDPL IS NULL AND vStatus = MIGR_GVAR.GV_BATCH_STATUS_RUNNING THEN
        -- Update IA_POLICY -> MIG_FLAG RUNNING!
        MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(vNextIDPL, MIGR_GVAR.GV_MIG_FLAG_RUNNING, vMigrationBatchId);

    ELSIF NOT vNextIDPL IS NULL AND vStatus = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC THEN
      -- Update IA_POLICY -> MIG_FLAG RUNNING DISCOUNTS!
      MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(vNextIDPL, MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS, vMigrationBatchId);
    END IF;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
      vNextIDPL := NULL;
  WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
      -- Update IA_POLICY -> MIG_FLAG FAILED!
      IF vStatus = MIGR_GVAR.GV_BATCH_STATUS_RUNNING THEN
        MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(vNextIDPL, MIGR_GVAR.GV_MIG_FLAG_FAILED,vMigrationBatchId);
      ELSE
        MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(vNextIDPL, MIGR_GVAR.GV_MIG_FLAG_FAILED_DISCOUNTS,vMigrationBatchId);
      END IF;
END GET_NEXT_IDPL;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--Truncates MIGR_ tables
PROCEDURE TRUNCATE_MIGR_TABLES AS
  vSQL      VARCHAR2(2100);
  l_LogRec MIGR_GVAR.LogRecTyp;
BEGIN

    vSQL  := 'TRUNCATE TABLE MIGR_O_ENGINE';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_SHIP';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_POLICY';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_VOLUME_LOG';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_IA_SA_LIST';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_CONTENT_COOP';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_INDIVIDUAL_COVERS';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_LEISURE_HOME';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_LEISURE_MOBILE_HOME';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_POLICY_PARTICIPANTS';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_VILLAHEM';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_TRAVEL';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_ACCIDENT';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_CONTENT_ONLY';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_LEISURE_CONT_ONLY';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_LEISURE_COOP';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_O_BUILDING_VILLA';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_FAILED_POLICY';
    EXECUTE IMMEDIATE vSQL;
    vSQL  := 'TRUNCATE TABLE MIGR_IA_SA_LIST';
    EXECUTE IMMEDIATE vSQL;
EXCEPTION WHEN OTHERS THEN
        l_LogRec.mig_batch_id := '0-0';
        l_LogRec.migrArea     := 'TRUNCATE MIGR TABLES';
        l_LogRec.migrStep     := 'MIGR_API.TRUNCATE_MIGR_TABLES';
        l_LogRec.migrRelTbl   := NULL;
        l_LogRec.migrRelKey   := NULL;
        l_LogRec.logMsg       := SQLERRM || ' sql: ' || vSQL;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END TRUNCATE_MIGR_TABLES;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---Waits timeout seconds to receive alert message from an alert registered for session
  --If alert occured then remove alert from registration list and reduce the  reserved resources
PROCEDURE WAIT_ANY_API_ALERT (vCOUNTER IN OUT PLS_INTEGER, vEXCEPTION_COUNTER IN OUT PLS_INTEGER)
  IS
  l_log_rec     MIGR_GVAR.LogRecTyp;

  /* Alert Variables */
  vAlertName    VARCHAR2(30);
  vAlertMsg     VARCHAR2(250);
  vAlertStatus  VARCHAR2(1);
  v_cnt  NUMBER;
  v_alrt  NUMBER;
BEGIN
    l_log_rec.mig_batch_id := '0-0';
    l_log_rec.migrArea     := 'MIGR_API.WAIT_ANY_API_ALERT';
    l_log_rec.migrRelTbl   := '';

    DBMS_ALERT.WAITANY(vAlertName, vAlertMsg, vAlertStatus, 600); -- 10min
    -- vAlertMsg values returned: 0 - alert occurred, 1 - timeout occurred
    -- If alert occurred -> remove from alert list
    IF vAlertStatus = 0 THEN
        l_Log_Rec.migrRelTbl := 'POLICY JOB';
        l_Log_Rec.logMsg := 'About to REMOVE: ' || vAlertName || ' Running Jobs: ' || vCOUNTER;
        l_log_rec.migrRelKey := vAlertMsg;
        MIGR_LOG.LOG_INFO(l_Log_Rec);

        DBMS_ALERT.REMOVE(vAlertName);
        -- We have one job free, go start a new! JOB may still exist in scheduler for few more seconds
        vCOUNTER := vCOUNTER - 1;
    -- If timeout occurred Log and wait again
    ELSIF vAlertStatus = 1 THEN
        l_Log_Rec.migrRelTbl := 'POLICY JOB'; l_Log_Rec.logMsg := 'ALERT_TIME_OUT: ' || vAlertName || ' Running Jobs: ' || vCOUNTER; l_log_rec.migrRelKey := vAlertMsg; MIGR_LOG.LOG_INFO(l_Log_Rec);

    END IF;

    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
          vEXCEPTION_COUNTER := vEXCEPTION_COUNTER + 1;
          l_Log_Rec.logMsg   := 'Exception No: ' || vEXCEPTION_COUNTER || ' | Alert Error - ' || SQLERRM; MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);
END WAIT_ANY_API_ALERT;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --API State Mechanism that decides whether to submit a policy job , wait until server has available resources or exit migration
  PROCEDURE STATE_MACHINE_RUN_API
    IS
        l_log_rec          MIGR_GVAR.LogRecTyp;
        vLogRow            MIGR_PARALLEL_PROCESS_LOG % ROWTYPE;
        vNextPolicyRecord  IA_POLICY % ROWTYPE;
        vStatus            VARCHAR2(50);
        vNextIDPL          MIGR_POLICY.POLICY_IDPL % TYPE;
        vMigBatchId        MIGR_POLICY.MIG_BATCH_ID % TYPE;
        vCOUNTER              PLS_INTEGER;
        vMAX_RESOURCES        PLS_INTEGER;
        vEXCEPTION_COUNTER    PLS_INTEGER;
        IA_COUNTER            PLS_INTEGER;
        Migrate_Policy     BOOLEAN;
        /* Job Variables */
        vJOB_NAME          VARCHAR2(30);
        vJOB_TYPE          VARCHAR2(15);
        vJOB_ACTION        VARCHAR2(4000);
        vJOB_NAME_TMPL     VARCHAR2(30);
        vJOB_COUNTER       PLS_INTEGER;
        vAlertCounter      PLS_INTEGER;
        vSTATE             VARCHAR2(30);
        vNEXT_STATE        VARCHAR2(30);
        vRESOURCES_NEEDED  PLS_INTEGER;

        vSQL               VARCHAR2(200);
        v_my_schema        VARCHAR2(50);
     --  v_mig_insis_user   ETL_SETUP_INFO.MIGRATION_USER%TYPE;
       l_runPhase2   PLS_INTEGER;
  BEGIN
        l_log_rec.mig_batch_id := '0-0';
        l_log_rec.migrArea     := 'MIGR_API.STATE_MACHINE_RUN_API';
        l_log_rec.migrRelTbl   := '';

        vCOUNTER           := 0;
        vRESOURCES_NEEDED  := 0;
        vAlertCounter      := 0;
        vEXCEPTION_COUNTER := 0;

        vSQL := 'ALTER SESSION SET NLS_DATE_FORMAT = ''YYYY-MM-DD''';
        EXECUTE IMMEDIATE vSQL;
        vSQL := 'ALTER SESSION SET NLS_LANGUAGE = ''ENGLISH''';
        EXECUTE IMMEDIATE vSQL;
        vSQL := 'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
        EXECUTE IMMEDIATE vSQL;

        --valex.18/11/2016 - Clean up policies with mig flag = 6 (if exist), as a result of preceding system outage
        MIGR_PROCESS_RESUME.initialize_Running_policies;
        --FA.20170807 Check if at least one batch is in Phase 2 Running State to configure lower INSIS log level and prevent tablespace issues caused by extensive logging

       SELECT COUNT(*) INTO l_runPhase2 FROM MIG_MIGRATION_INFO mmi WHERE mmi.STATUS  in (MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC,MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC);
       IF l_runPhase2>0 THEN
          MIGR_API_COMMON.DISABLE_INSIS_LOG_LEVEL;
       END IF;


        vJOB_TYPE := 'PLSQL_BLOCK';
        vJOB_COUNTER := 0;

        SELECT TASK_NAME INTO vJOB_NAME_TMPL FROM ETL_SETUP_INFO;

        -- dbms_alert init
        DBMS_ALERT.SET_DEFAULTS(1);  -- dbms_alert sensitivity - polling interval, in seconds, to sleep between polls
        -- Do not REMOVEALL!  DBMS_ALERT.REMOVEALL();      -- dbms_alert clean up

        Migrate_Policy := TRUE;
        vSTATE         := 'GetPolicy';

        WHILE Migrate_Policy
        LOOP

            -- Check the PARALLEL_LEVEL field from ETL_SETUP_INFO
           --20170424     Select parallel level according to time windows options for system performance
--  LM - 20180302 - Choose parallel level according to daily plan in ETL_PARALLEL_LEVEL_PER_TIME table - Start
--           SELECT
--            CASE
--              WHEN TRIM(TO_CHAR(SYSDATE, 'DAY')) IN ('MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY')
--                   AND (TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) >= NVL(WORK_START_TIME, '06:00:00') AND TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) <= NVL(WORK_END_TIME, '18:00:00')) -- work day
--              THEN NVL(MIN_PARALLEL_LEVEL, 1)
--              WHEN (TRIM(TO_CHAR(SYSDATE, 'DAY')) IN ('TUESDAY', 'WEDNESDAY', 'THURSDAY')
--                    AND (TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) < NVL(WORK_START_TIME, '06:00:00') OR TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) > NVL(WORK_END_TIME, '18:00:00')))  -- work night
--                OR (TRIM(TO_CHAR(SYSDATE, 'DAY')) = 'FRIDAY' AND TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) < NVL(WORK_START_TIME, '06:00:00'))                                         -- early friday
--                OR (TRIM(TO_CHAR(SYSDATE, 'DAY')) = 'MONDAY' AND TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) > NVL(WORK_END_TIME, '18:00:00'))                                           -- late monday
--              THEN NVL(MID_PARALLEL_LEVEL, 1)
--              WHEN TRIM(TO_CHAR(SYSDATE, 'DAY')) IN ('SATURDAY', 'SUNDAY')                                                                                  -- weekend
--                OR (TRIM(TO_CHAR(SYSDATE, 'DAY')) = 'FRIDAY' AND TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) > NVL(WORK_END_TIME, '18:00:00'))                -- late friday
--                OR (TRIM(TO_CHAR(SYSDATE, 'DAY')) = 'MONDAY' AND TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) < NVL(WORK_START_TIME, '06:00:00'))              -- early monday
--              THEN NVL(PARALLEL_LEVEL, 1)
--              ELSE 1
--             END AS NEW_PRL_LEVEL INTO vMAX_RESOURCES
--            FROM ETL_SETUP_INFO;
           --- SELECT NVL(PARALLEL_LEVEL, 0) INTO vMAX_RESOURCES FROM ETL_SETUP_INFO;

           SELECT
             CASE
                (SELECT PLAN FROM ETL_PARALLEL_LEVEL_PER_TIME eplpt
                      WHERE TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) >=eplpt.TIME_FROM
                        AND TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) <= eplpt.TIME_TO)
              WHEN 'HIGH' THEN NVL(PARALLEL_LEVEL, 1)
              WHEN 'MID'  THEN NVL(MID_PARALLEL_LEVEL, 1)
              WHEN 'MIN'  THEN NVL(MIN_PARALLEL_LEVEL, 1)
              ELSE 1
             END AS NEW_PRL_LEVEL INTO vMAX_RESOURCES
            FROM ETL_SETUP_INFO;
--  LM - 20180302 - End

            IF vMAX_RESOURCES = 0 THEN
                 vRESOURCES_NEEDED := vMAX_RESOURCES;
                 vSTATE            := 'Flush_Queue';
                 vNEXT_STATE       := 'Stop_Migration';
            END IF;

            CASE vSTATE
                 WHEN 'GetPolicy' THEN
                                GET_NEXT_BATCH(vMigBatchId, vStatus);
                                GET_NEXT_IDPL(vNextIDPL, vMigBatchId, vStatus);

                                IF NOT vNextIDPL IS NULL AND NOT vMigBatchId IS NULL AND NOT vStatus IS NULL THEN
                                    vRESOURCES_NEEDED := vRESOURCES_NEEDED + 1;
                                    vSTATE := 'Check_Resources';
                                ELSE
                                    -- Check if mig_migration info has any pending batches :Pending batches conditions :Batch Status Running and ia pending or batch status Running_Discounts and Discount_Completed pending
                                   -- Fa.20170109 Add condition:  OR  (STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC AND DISCOUNT_COMPLETED = 'Pending' )
                                    -- valex.11/1/2017 - added Queued status so that API does not exit right after it starts, as a result of no applicable IDPL in IA_POLICY and no batch in Running status)
                                    -- SELECT COUNT(*) INTO IA_COUNTER FROM MIG_MIGRATION_INFO WHERE (STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING AND IA_COMPLETED = 'Pending' ) OR  (STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC AND DISCOUNT_COMPLETED = 'Pending' ) ;
                                    SELECT COUNT(*) INTO IA_COUNTER FROM MIG_MIGRATION_INFO
                                      WHERE (STATUS IN( MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_QUEUED) AND IA_COMPLETED = MIGR_GVAR.GV_STATUS_PENDING) OR  (STATUS in (MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC, MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC) AND DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_PENDING);

                                    IF IA_COUNTER = 0 THEN
                                        vRESOURCES_NEEDED := vMAX_RESOURCES;
                                        vSTATE            := 'Flush_Queue';
                                        vNEXT_STATE       := 'Exit_Migration';
                                    END IF;
                                END IF;

                 WHEN 'Check_Resources' THEN

                                IF vCOUNTER < vMAX_RESOURCES THEN
                                    vJOB_COUNTER := vJOB_COUNTER + 1;
                                    vJOB_NAME    := vJOB_NAME_TMPL || vJOB_COUNTER;

                                    vJOB_ACTION  := 'BEGIN MIGR_API_POLICY.MIGRATE_POLICY( ''' || vMigBatchId || ''', ''' || vNextIDPL || ''' ); DBMS_ALERT.SIGNAL( ''' || vJOB_NAME || ''', ''' || vNextIDPL || ''' ); COMMIT; END;';

                                    l_Log_Rec.migrRelKey := vNextIDPL;
                                    l_Log_Rec.migrRelTbl := 'POLICY JOB'; l_Log_Rec.logMsg := 'About to CREATE: ' || vJOB_NAME || ' Running Jobs: ' || vCOUNTER; MIGR_LOG.LOG_INFO(l_Log_Rec);

                                    -- Start a new job
                                    BEGIN
                                        -- Increase current running jobs + 1 and resources needed - 1
                                        vCOUNTER          := vCOUNTER + 1;
                                        vRESOURCES_NEEDED := vRESOURCES_NEEDED - 1;

                                        vSTATE := 'GetPolicy';

                                        l_Log_Rec.migrRelTbl:='POLICY JOB'; l_Log_Rec.logMsg := 'About to REGISTER: ' || vJOB_NAME || ' Running Jobs: ' || vCOUNTER;
                                        l_log_rec.migrRelKey := vNextIDPL;
                                        MIGR_LOG.LOG_INFO(l_Log_Rec);
                                        DBMS_ALERT.REGISTER(vJOB_NAME);

                                        COMMIT;

                                        l_Log_Rec.logMsg   := 'Scheduler - ';
                                        DBMS_SCHEDULER.CREATE_JOB(
                                            JOB_NAME        => vJOB_NAME,
                                            JOB_TYPE        => vJOB_TYPE,
                                            JOB_ACTION      => vJOB_ACTION,
                                            START_DATE      => NULL,        -- Schedule job will run as soon as it is enabled
                                            REPEAT_INTERVAL => NULL,        -- Schedule job will run only once
                                            ENABLED         => TRUE,
                                            AUTO_DROP       => TRUE
                                        );

                                        COMMIT;

                                    EXCEPTION
                                        WHEN OTHERS THEN
                                              vSTATE            := 'Check_Resources';
                                              vCOUNTER          := vCOUNTER - 1;
                                              vRESOURCES_NEEDED := vRESOURCES_NEEDED + 1;

                                              FOR xx IN ( SELECT ai.NAME FROM SYS.DBMS_ALERT_INFO ai WHERE UPPER(ai.NAME) = UPPER(vJOB_NAME) )
                                              LOOP
                                                  l_Log_Rec.migrRelTbl := 'POLICY JOB'; l_Log_Rec.logMsg := 'About to CLEAN UP Alert Info: ' || xx.NAME || ' Running Jobs: ' || vCOUNTER; MIGR_LOG.LOG_INFO(l_Log_Rec);
                                                  DBMS_ALERT.REMOVE(xx.NAME);
                                              END LOOP;

                                              vEXCEPTION_COUNTER := vEXCEPTION_COUNTER + 1; l_Log_Rec.logMsg := SQLERRM || ' - ' || vJOB_ACTION;
                                              MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);

                                    END;

                                ELSE
                                    vSTATE      := 'Flush_Queue';
                                    vNEXT_STATE := 'Check_Resources';

                                END IF;

                 WHEN 'Flush_Queue' THEN
                                WHILE vRESOURCES_NEEDED > vMAX_RESOURCES - vCOUNTER
                                LOOP
                                    WAIT_ANY_API_ALERT(vCOUNTER, vEXCEPTION_COUNTER);
                                END LOOP;
                                vSTATE := vNEXT_STATE;

                                IF vSTATE = 'Exit_Migration' OR MOD(vJOB_COUNTER, 1000) = 0  THEN
                                     l_log_rec.migrRelKey := NULL;
                                     l_Log_Rec.migrRelTbl := 'POLICY JOB';
                                    --Fa.20170108 Check whether to turn status to Waiting Discounts or to Finished
                                    FOR c IN (
                                          SELECT mm.MIGRATION_BATCH_ID,
                                           --FA.20180222 Change conditions that mark batch as Finished or Wait discounts pending only to succesfully migrated policies
                                             (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_success
                                         --  (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_FAILED AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_failed,
                                           ---  (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_all
                                             FROM MIG_MIGRATION_INFO mm
                                            WHERE mm.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING
                                              AND mm.IA_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED
                                              AND 0=(SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_PENDING AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID))
                                    LOOP
                                              l_Log_Rec.logMsg := 'About to Set Migration Batch ID: ' || c.MIGRATION_BATCH_ID || ' to Waiting Discounts';
                                              MIGR_LOG.LOG_INFO(l_Log_Rec);
                                              --if at least one policy has been succesfully migrated then turn batch to wait discounts else turn batch to failed
                                              IF c.c_success >=1 then
                                                    MIGR_SIGNAL.CLOSE_BATCH(c.MIGRATION_BATCH_ID,MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC);
                                              ELSE
                                                    MIGR_SIGNAL.CLOSE_BATCH(c.MIGRATION_BATCH_ID,MIGR_GVAR.GV_BATCH_STATUS_FAILED);
                                                    l_Log_Rec.logMsg := 'All batch policies failed migration';
                                                    MIGR_LOG.LOG_ERROR(l_Log_Rec);
                                              END IF;
                                    END LOOP;

                                     FOR c IN (
                                            SELECT mm.MIGRATION_BATCH_ID ,
                                              --FA.20180222 Change conditions that mark batch as Finished or Wait discounts pending only to succesfully migrated policies
                                             (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_SUCCESS AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_success
                                            ---  (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_FAILED_DISCOUNTS AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_failed,
                                             ---  (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_all
                                               FROM MIG_MIGRATION_INFO mm
                                              WHERE mm.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC
                                                AND mm.DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED
                                                AND 0=(SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID))
                                    LOOP
                                                -- if at least one policy has been succesfully completed migration then turn batch to finished else turn batch to failed
                                                  IF c.c_success >=1 then
                                                      l_Log_Rec.logMsg := 'About to Set Migration Batch ID: ' || c.MIGRATION_BATCH_ID || ' to Finished';
                                                      l_log_rec.migrRelKey := NULL;
                                                      MIGR_LOG.LOG_INFO(l_Log_Rec);
                                                      MIGR_SIGNAL.CLOSE_BATCH(c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_BATCH_STATUS_FINISHED);

                                                      UPDATE MIG_MIGRATION_INFO SET DISCOUNTS_FILE_CREATED = MIGR_GVAR.GV_STATUS_PENDING WHERE MIGRATION_BATCH_ID = c.MIGRATION_BATCH_ID;

                                                ELSE
                                                      MIGR_SIGNAL.CLOSE_BATCH(c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_BATCH_STATUS_FAILED);
                                                      l_Log_Rec.logMsg := 'All batch policies failed migration';
                                                      MIGR_LOG.LOG_ERROR(l_Log_Rec);

                                                 END IF;
                                    END LOOP;

                                END IF;

                 WHEN 'Stop_Migration' THEN
                               Migrate_Policy    := FALSE;
                               l_Log_Rec.logMsg  := 'Policy Migration process stopped. MAX_RESOURCES = ' || vMAX_RESOURCES; l_log_rec.migrRelKey := NULL; MIGR_LOG.LOG_INFO(l_Log_Rec);

                 WHEN 'Exit_Migration' THEN
                               ---FA.20170127 Check if ia_policy has pending policies before stopping API
                               FOR cRec IN (SELECT COUNT('x') CNT
                                              FROM IA_POLICY ia
                                              JOIN MIG_MIGRATION_INFO mmi ON ia.MIG_BATCH_ID=mmi.MIGRATION_BATCH_ID
                                             WHERE ia.MIG_FLAG IN (MIGR_GVAR.GV_MIG_FLAG_PENDING,MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS)
                                               AND NOT mmi.STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_INCOMPLETE, MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC))--mmi.STATUS <> MIGR_GVAR.GV_BATCH_STATUS_INCOMPLETE) --'0')
                               LOOP
                                    IF cRec.CNT=0 THEN
                                        Migrate_Policy    := FALSE;
                                        l_Log_Rec.logMsg  := 'End of Policy Migration process.'; l_log_rec.migrRelKey := NULL; MIGR_LOG.LOG_INFO(l_Log_Rec);
                                        --FA.20170807 Call to restore INSIS Log Level at the end of migration process
                                            MIGR_API_COMMON.RESTORE_INSIS_LOG_LEVEL;
                                    ELSE
                                        vSTATE := 'GetPolicy';
                                        vRESOURCES_NEEDED := 0;
                                    END IF;
                                END LOOP;

                 ELSE
                                vRESOURCES_NEEDED := vMAX_RESOURCES;
                                vSTATE            := 'Flush_Queue';
                                vNEXT_STATE       := 'Exit_Migration';
                                l_Log_Rec.logMsg  := 'Policy Migration process stopped.'; MIGR_LOG.LOG_INFO(l_Log_Rec);

            END CASE;

        END LOOP;

        DBMS_ALERT.REMOVEALL();

        COMMIT;

    EXCEPTION
      WHEN OTHERS THEN
        l_log_rec.logMsg := SQLERRM; MIGR_LOG.LOG_EXCEPTION(l_log_rec);

  END STATE_MACHINE_RUN_API;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
END MIGR_API;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_ACCIDENT
  AS
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  FUNCTION MIGRATE_CHILD_ACC(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS

      CURSOR c_iaObj (vPOLICY_IDPL IA_VILLAHEM_POLICY.IA_IDPL % TYPE) IS
          SELECT ivp.IA_POLICY_REF,
                 ivp.IA_IDPL,
                 ivp.IA_IDPLPS,
                 ivp.IA_GENDER,
                 ivp.IA_PID,
                 ivp.IA_AGE,
                 ivp.IA_BIRTH_DATE,
                 ivp.IA_FULL_NAME,
                 ivp.IA_GNAME,
                 ivp.IA_SNAME,
                 ivp.IA_ACCIDENT_TYPE,
                 ivp.IA_ACCIDENT_SUBTYPE,
                 ivp.IA_PSTP,
                 ivp.ia_object_id,
                 ivp.IA_OBJECT_TYPE,
                 ivp.IA_NAME ,
                 mc.MAN_ID
                 --FA 20161007 no needed check mov.object_id, --mov.INS_OBJECT_ID
            FROM IA_CHILD_ACC_POLICY ivp
             --FA 20161007 no needed check LEFT JOIN MIGR_O_ACCIDENT mov  ON ivp.ia_object_id = mov.ia_object_id
            LEFT JOIN MIGR_CLIENT mc ON mc.EGN=ivp.IA_PID
            WHERE ivp.IA_IDPL = vPOLICY_IDPL;

      r_c_iaObj     c_iaObj % ROWTYPE;
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      L_MAN_ID      P_PEOPLE.MAN_ID % TYPE;
      v_gender      VARCHAR2(10);
      v_begintimer  TIMESTAMP WITH TIME ZONE;
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2( 400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      l_policyRec := p_policyRec;
      v_begintimer := SYSTIMESTAMP;

      l_policyRec.migrStep := 'Create Object Children Accident';
      l_policyRec.migrArea := 'MIGR_API_ACCIDENT.MIGRATE_CHILD_ACC';
      l_policyRec.migrRelTbl := 'IA_CHILD_ACC_POLICY';

      OPEN c_iaObj (l_policyRec.policy_idpl);
      LOOP

        FETCH c_iaObj INTO r_c_iaObj;
        EXIT WHEN c_iaObj % NOTFOUND;

          l_policyRec.object_type   := r_c_iaObj.IA_OBJECT_TYPE;
          l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
          l_policyRec.IA_OBJECT_ID  := r_c_iaObj.IA_OBJECT_ID;

          IF r_c_iaObj.IA_GENDER = 1  THEN  v_gender := 'M';
          ELSE   v_gender := 'F';  END IF;

          --FA. 20161031 First check if person has been migrated by client migration and if not search INSIS
          IF r_c_iaObj.MAN_ID IS NOT NULL THEN
              L_MAN_ID:=r_c_iaObj.MAN_ID;
          ELSE
              L_MAN_ID := MIGR_API_CLIENTS.GET_PEOPLE_BY_PID(r_c_iaObj.IA_PID);
          END IF;


          IF L_MAN_ID IS NOT NULL  THEN

            l_in_context := NULL;
            l_out_context := NULL;
            pio_err := NULL;

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'AGE', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_SUBTYPE', r_c_iaObj.IA_ACCIDENT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_TYPE', r_c_iaObj.IA_ACCIDENT_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GENDER', v_gender);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP2', r_c_iaObj.IA_FULL_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP3', r_c_iaObj.IA_PID);

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_ACCINSURED');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR     THEN
              l_policyRec.logMsg := 'PIO_ERR INS_ACCINSURED Failed to register OBJECT';
              MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
              l_policyRec.continue_migr :=FALSE;
              l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  register OBJECT';

            ELSE
              l_policyRec.logMsg := 'Private Accident Insurd Person was inserted succesfully with object_id: ' || l_policyRec.object_id;
              MIGR_LOG.LOG_INFO(l_policyRec);

              l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

              IF NOT  (MIGR_API_CLIENTS.ADD_POL_PARTICIPANTS(l_policyRec))      THEN
                     l_policyRec.continue_migr :=FALSE;
                     l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  add participants';
               END IF;

               IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                    l_policyRec.logMsg := 'INS_ACCINSURED returned with warning -RESULT:' || NULL;
                    MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
               END IF;

            END IF;
          ELSE
                l_policyRec.logMsg := 'Failed to call event INS_ACCINSURED due to null MAN_ID';
                MIGR_LOG.LOG_ERROR(l_policyRec);
                l_policyRec.continue_migr :=FALSE;
                l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  register OBJECT';
          END IF;

        INSERT INTO MIGR_O_ACCIDENT ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,mig_start,mig_end, ia_object_id, mig_batch_id, policy_idpl, OBJ_ERROR_LOG   )
        VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl, l_policyRec.object_fail_log);

      END LOOP;

      CLOSE c_iaObj;
      RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          RETURN l_policyRec;
    END MIGRATE_CHILD_ACC;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  FUNCTION MIGRATE_INDIV60_ACC(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS

      CURSOR c_iaObj (vPOLICY_IDPL IA_VILLAHEM_POLICY.IA_IDPL % TYPE) IS
          SELECT ivp.IA_POLICY_REF,
                 ivp.IA_IDPL,
                 ivp.IA_IDPLPS,
                 ivp.IA_GENDER,
                 ivp.IA_PID,
                 ivp.IA_AGE,
                 ivp.IA_BIRTH_DATE,
                 ivp.IA_FULL_NAME,
                 ivp.IA_GNAME,
                 ivp.IA_SNAME,
                 ivp.IA_ACCIDENT_TYPE,
                 ivp.IA_ACCIDENT_SUBTYPE,
                 ivp.IA_PSTP,
                 ivp.ia_object_id,
                 ivp.IA_OBJECT_TYPE,
                 ivp.IA_NAME ,
                 mc.MAN_ID
              --FA 20161007 no needed check  mov.INS_OBJECT_ID
            FROM IA_INDIV_ACC_60_POLICY ivp
            LEFT JOIN MIGR_CLIENT mc ON mc.EGN=ivp.IA_PID
           --FA 20161007 no needed check  LEFT JOIN MIGR_O_ACCIDENT mov  ON ivp.ia_object_id = mov.ia_object_id
            WHERE ivp.IA_IDPL = vPOLICY_IDPL;

      r_c_iaObj     c_iaObj % ROWTYPE;
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      L_MAN_ID      P_PEOPLE.MAN_ID % TYPE;
      v_gender      VARCHAR2(10);
      v_begintimer  TIMESTAMP WITH TIME ZONE;
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2( 400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      l_policyRec   := p_policyRec;
      v_begintimer  := SYSTIMESTAMP;
      l_policyRec.migrStep := 'Create Object Children Accident';
      l_policyRec.migrArea := 'MIGR_API_ACCIDENT.IA_INDIV_ACC_POLICY';
      l_policyRec.migrRelTbl := 'IA_INDIV_ACC_60_POLICY';

      OPEN c_iaObj (l_policyRec.policy_idpl);
      LOOP

        FETCH c_iaObj INTO r_c_iaObj;
        EXIT WHEN c_iaObj % NOTFOUND;

       --FA 20161007 no needed check IF r_c_iaObj.object_id IS NULL  AND r_c_iaObj.INS_OBJECT_ID IS NULL  THEN
          l_policyRec.object_type   := r_c_iaObj.IA_OBJECT_TYPE;
          l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
          l_policyRec.IA_OBJECT_ID  := r_c_iaObj.IA_OBJECT_ID;

          IF r_c_iaObj.IA_GENDER = 1 THEN  v_gender := 'M';
          ELSE v_gender := 'F';
          END IF;


          --FA. 20161031 First check if person has been migrated by client migration and if not search INSIS
           IF r_c_iaObj.MAN_ID IS NOT NULL THEN
              L_MAN_ID:=r_c_iaObj.MAN_ID;
           ELSE
              L_MAN_ID := MIGR_API_CLIENTS.GET_PEOPLE_BY_PID(r_c_iaObj.IA_PID);
           END IF;


          IF L_MAN_ID IS NOT NULL   THEN

            l_in_context := NULL;
            l_out_context := NULL;
            pio_err := NULL;

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'AGE',  '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_SUBTYPE', r_c_iaObj.IA_ACCIDENT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_TYPE', r_c_iaObj.IA_ACCIDENT_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GENDER', v_gender);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP2', r_c_iaObj.IA_FULL_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP3', r_c_iaObj.IA_PID);

            v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('INS_ACCINSURED');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR        THEN
                l_policyRec.logMsg := 'PIO_ERR INS_ACCINSURED Failed to register OBJECT';
                MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                l_policyRec.continue_migr :=FALSE;
                l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  register OBJECT';

            ELSE
                l_policyRec.logMsg := 'Private Accident Insurd Person was inserted succesfully with object_id: ' || l_policyRec.object_id;
                MIGR_LOG.LOG_INFO(l_policyRec);

               l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);


                IF NOT (MIGR_API_CLIENTS.ADD_POL_PARTICIPANTS(l_policyRec))  THEN
                      l_policyRec.continue_migr :=FALSE;
                      l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  add participants';
                END IF;

                IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                  l_policyRec.logMsg := 'INS_ACCINSURED returned with warning -RESULT:' || NULL;
                  MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                END IF;
            END IF;

          ELSE
              l_policyRec.logMsg := 'Failed to call event INS_ACCINSURED due to null MAN_ID';
              MIGR_LOG.LOG_ERROR(l_policyRec);
              l_policyRec.continue_migr :=FALSE;
              l_policyRec.object_fail_log := l_policyRec.object_fail_log || '-Failed to Insert accident insured';

          END IF;

        INSERT INTO MIGR_O_ACCIDENT (  NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, mig_batch_id, policy_idpl, OBJ_ERROR_LOG  )
        VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl, l_policyRec.object_fail_log);

      END LOOP;

      CLOSE c_iaObj;
      RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr:=FALSE;
          RETURN l_policyRec;
    END MIGRATE_INDIV60_ACC;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  FUNCTION  MIGRATE_RED_CHILD_ACC(p_policyRec IN  MIGR_GVAR.PolicyRecTyp     )  RETURN  MIGR_GVAR.PolicyRecTyp
    IS

      CURSOR c_iaObj (vPOLICY_IDPL IA_VILLAHEM_POLICY.IA_IDPL % TYPE) IS
          SELECT ivp.IA_POLICY_REF,
                 ivp.IA_IDPL,
                 ivp.IA_IDPLPS,
                 ivp.IA_GENDER,
                 ivp.IA_PID,
                 ivp.IA_AGE,
                 ivp.IA_BIRTH_DATE,
                 ivp.IA_FULL_NAME,
                 ivp.IA_GNAME,
                 ivp.IA_SNAME,
                 ivp.IA_ACCIDENT_TYPE,
                 ivp.IA_ACCIDENT_SUBTYPE,
                 ivp.IA_PSTP,
                 ivp.ia_object_id,
                 ivp.IA_OBJECT_TYPE,
                 ivp.IA_NAME,
                 mc.MAN_ID
                --FA no needed check mov.object_id,  mov.INS_OBJECT_ID
            FROM IA_RED_CHILD_ACC_POLICY ivp
               LEFT JOIN MIGR_CLIENT mc ON mc.EGN=ivp.IA_PID
            --FA 20161007 no needed check  LEFT JOIN MIGR_O_ACCIDENT mov    ON ivp.ia_object_id = mov.ia_object_id
            WHERE ivp.IA_IDPL = vPOLICY_IDPL;

      r_c_iaObj     c_iaObj % ROWTYPE;
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      L_MAN_ID      P_PEOPLE.MAN_ID % TYPE;
      v_gender      VARCHAR2(10);
      v_begintimer  TIMESTAMP WITH TIME ZONE;
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2( 400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      l_policyRec := p_policyRec;
      v_begintimer := SYSTIMESTAMP;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Children Accident';
      l_policyRec.migrArea := 'MIGR_API_ACCIDENT.MIGRATE_RED_CHILD_ACC';
      l_policyRec.migrRelTbl := 'IA_RED_CHILD_ACC_POLICY';

      OPEN c_iaObj (l_policyRec.policy_idpl);
      LOOP

        FETCH c_iaObj INTO r_c_iaObj;
        EXIT WHEN c_iaObj % NOTFOUND;

          l_policyRec.object_type   := r_c_iaObj.IA_OBJECT_TYPE;
          l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
           l_policyRec.IA_OBJECT_ID := r_c_iaObj.IA_OBJECT_ID;

          IF r_c_iaObj.IA_GENDER = 1
          THEN
            v_gender := 'M';
          ELSE
            v_gender := 'F';
          END IF;

          l_in_context := NULL;
          l_out_context := NULL;
          pio_err := NULL;

          --FA. 20161031 First check if person has been migrated by client migration and if not search INSIS
          IF r_c_iaObj.MAN_ID IS NOT NULL THEN
              L_MAN_ID:=r_c_iaObj.MAN_ID;
          ELSE
              L_MAN_ID := MIGR_API_CLIENTS.GET_PEOPLE_BY_PID(r_c_iaObj.IA_PID);
          END IF;

          IF L_MAN_ID IS NOT NULL  THEN
            l_in_context := NULL;
            l_out_context := NULL;
            pio_err := NULL;

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'AGE',  '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_SUBTYPE', r_c_iaObj.IA_ACCIDENT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_TYPE', r_c_iaObj.IA_ACCIDENT_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GENDER', v_gender);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP2', r_c_iaObj.IA_FULL_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP3', r_c_iaObj.IA_PID);

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_ACCINSURED');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR    THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_ACCINSURED Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr :=FALSE;
                  l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  register OBJECT';

            ELSE
                  l_policyRec.logMsg := 'Private Accident Insurd Person was inserted succesfully with object_id: ' || l_policyRec.object_id;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                  l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF NOT (MIGR_API_CLIENTS.ADD_POL_PARTICIPANTS(l_policyRec))   THEN
                         l_policyRec.continue_migr :=FALSE;
                        l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  add participants';
                  END IF;

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
                    l_policyRec.logMsg := 'INS_ACCINSURED returned with warning -RESULT:' || NULL;
                    MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                  END IF;

            END IF;

          ELSE
                l_policyRec.logMsg := 'Failed to call event INS_ACCINSURED due to null MAN_ID';
                MIGR_LOG.LOG_ERROR(l_policyRec);
                l_policyRec.continue_migr :=FALSE;
                l_policyRec.object_fail_log := l_policyRec.object_fail_log || '-Failed to Insert accident insured';

          END IF;

        INSERT INTO MIGR_O_ACCIDENT ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, mig_batch_id, policy_idpl, OBJ_ERROR_LOG  )
        VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP,l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl, l_policyRec.object_fail_log);

      END LOOP;

      CLOSE c_iaObj;
       RETURN  l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
           l_policyRec.continue_migr:=FALSE;
           RETURN  l_policyRec;
    END MIGRATE_RED_CHILD_ACC;
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  FUNCTION MIGRATE_RED_ACC(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS

      CURSOR c_iaObj (vPOLICY_IDPL IA_VILLAHEM_POLICY.IA_IDPL % TYPE) IS
          SELECT ivp.IA_POLICY_REF,
                 ivp.IA_IDPL,
                 ivp.IA_IDPLPS,
                 ivp.IA_GENDER,
                 ivp.IA_PID,
                 ivp.IA_AGE,
                 ivp.IA_BIRTH_DATE,
                 ivp.IA_FULL_NAME,
                 ivp.IA_GNAME,
                 ivp.IA_SNAME,
                 ivp.IA_ACCIDENT_TYPE,
                 ivp.IA_ACCIDENT_SUBTYPE,
                 ivp.IA_PSTP,
                 ivp.ia_object_id,
                 ivp.IA_OBJECT_TYPE,
                 ivp.IA_NAME,
                 mc.MAN_ID
             --FA 20161007 no needed check     mov.object_id,    mov.INS_OBJECT_ID
            FROM IA_RED_ACC_POLICY ivp
             LEFT JOIN MIGR_CLIENT mc ON mc.EGN=ivp.IA_PID
          --FA 20161007 no needed check    LEFT JOIN MIGR_O_ACCIDENT mov  ON ivp.ia_object_id = mov.ia_object_id
            WHERE ivp.IA_IDPL = vPOLICY_IDPL;

      r_c_iaObj     c_iaObj % ROWTYPE;
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      L_MAN_ID      P_PEOPLE.MAN_ID % TYPE;
      v_gender      VARCHAR2(10);
      v_begintimer  TIMESTAMP WITH TIME ZONE;
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2( 400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      l_policyRec   := p_policyRec;
      v_begintimer  := SYSTIMESTAMP;
      l_in_context  := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep   := 'Create Object Children Accident';
      l_policyRec.migrArea   := 'MIGR_API_ACCIDENT.MIGRATE_RED_ACC';
      l_policyRec.migrRelTbl := 'IA_RED_ACC_POLICY';

      OPEN c_iaObj (l_policyRec.policy_idpl);
      LOOP

        FETCH c_iaObj INTO r_c_iaObj;
        EXIT WHEN c_iaObj % NOTFOUND;

          l_policyRec.object_type   := r_c_iaObj.IA_OBJECT_TYPE;
          l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
          l_policyRec.IA_OBJECT_ID  := r_c_iaObj.IA_OBJECT_ID;

          IF r_c_iaObj.IA_GENDER = 1
          THEN
            v_gender := 'M';
          ELSE
            v_gender := 'F';
          END IF;

          l_in_context := NULL;
          l_out_context := NULL;
          pio_err := NULL;

          --FA. 20161031 First check if person has been migrated by client migration and if not search INSIS
          IF r_c_iaObj.MAN_ID IS NOT NULL THEN
                L_MAN_ID:=r_c_iaObj.MAN_ID;
          ELSE
                L_MAN_ID := MIGR_API_CLIENTS.GET_PEOPLE_BY_PID(r_c_iaObj.IA_PID);
          END IF;


          IF L_MAN_ID IS NOT NULL
          THEN
            l_in_context := NULL;
            l_out_context := NULL;
            pio_err := NULL;

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'AGE',  '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_SUBTYPE', r_c_iaObj.IA_ACCIDENT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_TYPE', r_c_iaObj.IA_ACCIDENT_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GENDER', v_gender);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP2', r_c_iaObj.IA_FULL_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP3', r_c_iaObj.IA_PID);

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_ACCINSURED');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR       THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PEOPLE Failed to INSERT Accident Insured  Person';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                   l_policyRec.continue_migr :=FALSE;
                  l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  INSERT People';
            ELSE
                  l_policyRec.logMsg := 'Private Accident Insurd Person was inserted succesfully with object_id: ' || l_policyRec.object_id;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                  l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF NOT (MIGR_API_CLIENTS.ADD_POL_PARTICIPANTS(l_policyRec))  THEN
                         l_policyRec.continue_migr :=FALSE;
                         l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  add participants';
                  END IF;

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                    l_policyRec.logMsg := 'INS_ACCINSURED returned with warning -RESULT:' || NULL;
                    MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                  END IF;
            END IF;

          ELSE
                l_policyRec.logMsg := 'Failed to call event INS_ACCINSURED due to null MAN_ID';
                MIGR_LOG.LOG_ERROR(l_policyRec);
                l_policyRec.continue_migr :=FALSE;
                l_policyRec.object_fail_log := l_policyRec.object_fail_log || '-Failed to Insert accident insured';

          END IF;

        INSERT INTO MIGR_O_ACCIDENT (  NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, mig_batch_id, policy_idpl, OBJ_ERROR_LOG )
        VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl, l_policyRec.object_fail_log);

      END LOOP;

      CLOSE c_iaObj;
      RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          RETURN l_policyRec;
    END MIGRATE_RED_ACC;

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  FUNCTION MIGRATE_INDIV_ACC(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS

      CURSOR c_iaObj (vPOLICY_IDPL IA_VILLAHEM_POLICY.IA_IDPL % TYPE) IS
          SELECT ivp.IA_POLICY_REF,
                 ivp.IA_IDPL,
                 ivp.IA_IDPLPS,
                 ivp.IA_GENDER,
                 ivp.IA_PID,
                 ivp.IA_AGE,
                 ivp.IA_BIRTH_DATE,
                 ivp.IA_FULL_NAME,
                 ivp.IA_GNAME,
                 ivp.IA_SNAME,
                 ivp.IA_ACCIDENT_TYPE,
                 ivp.IA_ACCIDENT_SUBTYPE,
                 ivp.IA_PSTP,
                 ivp.ia_object_id,
                 ivp.IA_OBJECT_TYPE,
                 ivp.IA_NAME ,
                mc.MAN_ID
               --FA 20161007 no needed check  mov.object_id,  mov.INS_OBJECT_ID
            FROM IA_INDIV_ACC_POLICY ivp
             LEFT JOIN MIGR_CLIENT mc ON mc.EGN=ivp.IA_PID
            --FA 20161007 no needed check  LEFT JOIN MIGR_O_ACCIDENT mov  ON ivp.ia_object_id = mov.ia_object_id
            WHERE ivp.IA_IDPL = vPOLICY_IDPL;

      r_c_iaObj     c_iaObj % ROWTYPE;
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      L_MAN_ID      P_PEOPLE.MAN_ID % TYPE;
      v_gender      VARCHAR2(10);
      v_begintimer  TIMESTAMP WITH TIME ZONE;
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2( 400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      l_policyRec := p_policyRec;
      v_begintimer := SYSTIMESTAMP;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Children Accident';
      l_policyRec.migrArea := 'MIGR_API_ACCIDENT.MIGRATE_INDIV_ACC';
      l_policyRec.migrRelTbl := 'IA_INDIV_ACC_POLICY';

      OPEN c_iaObj (l_policyRec.policy_idpl);
      LOOP

        FETCH c_iaObj INTO r_c_iaObj;
        EXIT WHEN c_iaObj % NOTFOUND;

    --FA 20161007 no needed check    IF r_c_iaObj.object_id IS NULL   AND r_c_iaObj.INS_OBJECT_ID IS NULL    THEN

          l_policyRec.object_type   := r_c_iaObj.IA_OBJECT_TYPE;
          l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
          l_policyRec.IA_OBJECT_ID  := r_c_iaObj.IA_OBJECT_ID;

          IF r_c_iaObj.IA_GENDER = 1
          THEN
            v_gender := 'M';
          ELSE
            v_gender := 'F';
          END IF;

          l_in_context := NULL;
          l_out_context := NULL;
          pio_err := NULL;

           --FA. 20161031 First check if person has been migrated by client migration and if not search INSIS
            IF r_c_iaObj.MAN_ID IS NOT NULL THEN
                L_MAN_ID:=r_c_iaObj.MAN_ID;
            ELSE
                L_MAN_ID := MIGR_API_CLIENTS.GET_PEOPLE_BY_PID(r_c_iaObj.IA_PID);
            END IF;


          IF L_MAN_ID IS NOT NULL THEN
            l_in_context := NULL;
            l_out_context := NULL;
            pio_err := NULL;

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'AGE',  '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_SUBTYPE', r_c_iaObj.IA_ACCIDENT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_TYPE', r_c_iaObj.IA_ACCIDENT_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GENDER', v_gender);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP2', r_c_iaObj.IA_FULL_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP3', r_c_iaObj.IA_PID);

             v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_ACCINSURED');

             v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

             EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR      THEN
                l_policyRec.logMsg := 'PIO_ERR INS_PEOPLE Failed to INSERT Accident Insured Person';
                MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                 l_policyRec.continue_migr :=FALSE;
                l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  INSERT People';
            ELSE
                  l_policyRec.logMsg := 'Private Accident Insurd Person was inserted succesfully with object_id: ' || l_policyRec.object_id;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                  l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF NOT (MIGR_API_CLIENTS.ADD_POL_PARTICIPANTS(l_policyRec))  THEN
                      l_policyRec.continue_migr :=FALSE;
                    l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  add participants';
                  END IF;

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                    l_policyRec.logMsg := 'INS_ACCINSURED returned with warning -RESULT:' || NULL;
                    MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);

                  END IF;

            END IF;

          ELSE
                l_policyRec.logMsg := 'Failed to call event INS_ACCINSURED due to null MAN_ID';
                l_policyRec.continue_migr :=FALSE;
                l_policyRec.object_fail_log := l_policyRec.object_fail_log || '-Failed to Insert accident insured';
                MIGR_LOG.LOG_ERROR(l_policyRec);

          END IF;

        INSERT INTO MIGR_O_ACCIDENT ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START,MIG_END, ia_object_id, mig_batch_id, policy_idpl, OBJ_ERROR_LOG )
        VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl, l_policyRec.object_fail_log);

      END LOOP;
      CLOSE c_iaObj;
      RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr:=FALSE;
          RETURN l_policyRec;
    END MIGRATE_INDIV_ACC;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


END MIGR_API_ACCIDENT;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_BOAT
AS
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_BOAT_DETAILS(p_policyRec  IN  OUT MIGR_GVAR.PolicyRecTyp)
IS

      l_in_context    SRVCONTEXT;
      l_out_context   SRVCONTEXT;
      pio_err         SRVERR;
      v_begintimer    TIMESTAMP WITH TIME ZONE;
      l_policyRec     MIGR_GVAR.PolicyRecTyp;
      l_reg_no        NUMBER (7, 0);


      CURSOR c_iaObj (v_OBJECT_ID IA_BOAT_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT ibp.IA_OBJECT_TYPE,
      ibp.IA_SHIP_TYPE,
      ibp.IA_SHIP_SUBTYPE,
      ibp.IA_POLICY_REF,
      ibp.IA_IDPLPS,
      ibd.IA_ORIG_BOAT_NAME,
      ibd.IA_BOAT_CODE,
      ibd.IA_REG_NO,
      ibd.IA_REG_PORT,
      ibd.IA_LENGTH,
      ibd.IA_WIDTH,
      ibd.IA_PROD_YEAR,
      ibd.IA_PRODUCER,
      ibd.IA_MATERIAL_CODE,
      ibd.IA_HULL_S_NO,
      ibd.IA_GEOZONE,
      ibd.IA_MAX_KNOTS,
      ibd.IA_SAIL_AREA,
      ibd.IA_ALIAS,
      ibd.IA_TOTAL_HORSE_P,
      ibd.IA_BOAT_MAKE,
      ibd.IA_BOAT_MODEL,
      ibd.IA_NUMENGINES,
      ibd.IA_BOAT_TYPE,
      ibd.IA_TENDER
      FROM IA_BOAT_POLICY ibp
      JOIN IA_BOAT_DETAILS ibd
      ON ibp.IA_OBJECT_ID = ibd.IA_OBJECT_ID
      WHERE 1 = 1
      AND ibd.IA_OBJECT_ID = v_OBJECT_ID;
      v_is_Migrated  BOOLEAN;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
      v_my_schema VARCHAR2(50);
BEGIN
      l_policyRec := p_policyRec;
      v_begintimer := SYSTIMESTAMP;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Boat ';
      l_policyRec.migrArea := 'MIGR_API_BOAT.MIGRATE_O_BOAT_DETAILS';
      l_policyRec.migrRelTbl := 'IA_BOAT_DETAILS';

      select sys_context('userenv','current_schema') INTO v_my_schema
        from dual;

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_reg_no := r_c_iaObj.IA_REG_NO;

            IF l_reg_no IS NULL THEN
              INSERT INTO INSIS_CUST.BOAT_REGISTRY (ID, CODE, TYPE, MAKE, MODEL, ALIAS, MATERIAL, TOTAL_HORSE_POWER, LENGTH, WIDTH, SAIL_AREA, KNOTS, NO_OF_ENGINGES,
                          NOTE, REGISTRATION_DATE, B_CURRENT, APPROVED, DELETED, UW_PROHIBITED, FACTOR, USERNAME, VALID_FROM, VALID_TO, VERSION)
                  VALUES (NULL, r_c_iaObj.IA_BOAT_CODE, r_c_iaObj.IA_BOAT_TYPE, r_c_iaObj.IA_BOAT_MAKE, r_c_iaObj.IA_BOAT_MODEL, r_c_iaObj.IA_ALIAS, r_c_iaObj.IA_MATERIAL_CODE,
                          r_c_iaObj.IA_TOTAL_HORSE_P, r_c_iaObj.IA_LENGTH, r_c_iaObj.IA_WIDTH, r_c_iaObj.IA_SAIL_AREA, r_c_iaObj.IA_MAX_KNOTS, r_c_iaObj.IA_NUMENGINES,
                          '', SYSDATE, 'Y', 'Y', 'N', 'N', NULL, v_my_schema, NULL, NULL, 1)
              RETURNING ID INTO l_reg_no;
            END IF;

              SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OBJECT_TYPE',  r_c_iaObj.IA_OBJECT_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'REG_NO', l_reg_no);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'NAME', r_c_iaObj.IA_ORIG_BOAT_NAME);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'SHIP_TYPE', r_c_iaObj.IA_SHIP_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'SHIP_SUBTYPE', r_c_iaObj.IA_SHIP_SUBTYPE);
              SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'LENGHT',srv_context.Real_Number_Format, r_c_iaObj.IA_LENGTH);
              SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'WIDE',srv_context.Real_Number_Format, r_c_iaObj.IA_WIDTH);

              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'REG_PORT', r_c_iaObj.IA_REG_PORT);
              SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'PROD_YEAR', srv_context.Integers_Format, r_c_iaObj.IA_PROD_YEAR);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'PRODUCER', r_c_iaObj.IA_PRODUCER);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP1', r_c_iaObj.IA_MATERIAL_CODE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP2', r_c_iaObj.IA_HULL_S_NO);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP3', r_c_iaObj.IA_GEOZONE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP4', r_c_iaObj.IA_MAX_KNOTS);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP5', r_c_iaObj.IA_SAIL_AREA);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP6', r_c_iaObj.IA_ALIAS);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP7', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP8', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP9', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP10', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP11', r_c_iaObj.IA_TOTAL_HORSE_P);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP12', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP13', r_c_iaObj.IA_NUMENGINES);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP14', r_c_iaObj.IA_MAX_KNOTS);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP15', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP16', r_c_iaObj.IA_BOAT_MAKE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP17', r_c_iaObj.IA_BOAT_MODEL);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP18', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP19', r_c_iaObj.IA_BOAT_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OSP20', r_c_iaObj.IA_TENDER);

              v_event :=MIGR_API_COMMON.GET_INSIS_EVENT('INS_SHIP');

              v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

              EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR     THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_SHIP Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert boat';
                  l_policyRec.continue_migr:=FALSE;
             ELSE
                    l_policyRec.logMsg := 'Object Boat was inserted succesfully with object_id: ' || l_policyRec.object_id;
                    MIGR_LOG.LOG_INFO(l_policyRec);

                    l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                    l_policyRec.parent_objectId := l_policyRec.object_id;

                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                          l_policyRec.logMsg := 'INS_SHIP returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);

                    END IF;

            END IF;
            INSERT INTO MIGR_O_SHIP (NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,mig_start,mig_end, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
              VALUES (r_c_iaObj.IA_ALIAS, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer, SYSTIMESTAMP,l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
       p_policyRec:=l_policyRec;
EXCEPTION
    WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
           l_policyRec.continue_migr:=FALSE;
           p_policyRec:=l_policyRec;

END MIGRATE_O_BOAT_DETAILS;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_BOAT_ENGINE(p_policyRec  IN OUT  MIGR_GVAR.PolicyRecTyp)
      IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_policyRec    MIGR_GVAR.PolicyRecTyp;

      L_ADDEQUIP_OBJ_ID    INSIS_GEN_V10.O_ADDEQUIPMENT.OBJECT_ID % TYPE;

      CURSOR c_iaObj (v_OBJECT_ID IA_BOAT_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT ibp.IA_OBJECT_TYPE,
      ibp.IA_IDPLPS,
      ibp.IA_POLICY_REF,
      iabe.IA_ENGINEID,
      iabe.IA_BOAT_ENGINE_TYPE,
      iabe.IA_EQUIPMENT_TYPE,
      iabe.IA_EQUIPMENT_SUBTYPE,
      iabe.IA_INSIS_ADDEQP_KIND,
      iabe.IA_ENG_S_NO,
      iabe.IA_ENGINE_USE,
      iabe.IA_ENGINE_PRODUCER,
      iabe.IA_ENGINE_MODEL,
      iabe.IA_STERN_S_NO,
      iabe.IA_ENGINE_HP,
      iabe.IA_TYPE_EFFECT,
      iabe.IA_PROD_YEAR
      FROM IA_BOAT_POLICY ibp
       JOIN IA_BOAT_ENGINE iabe ON ibp.IA_OBJECT_ID = iabe.IA_OBJECT_ID
      WHERE 1 = 1
      AND ibp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

BEGIN


      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Boat Engine';
      l_policyRec.migrArea := 'MIGR_API_BOAT.MIGRATE_O_BOAT_ENGINE';
      l_policyRec.migrRelTbl := 'IA_BOAT_ENGINE';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

      v_begintimer := SYSTIMESTAMP;
      L_ADDEQUIP_OBJ_ID   := NULL;

      l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
      l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OBJECT_TYPE',  r_c_iaObj.IA_BOAT_ENGINE_TYPE);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ADD_EQUIP_OBJECT_ID', SRV_CONTEXT.INTEGERS_FORMAT, L_ADDEQUIP_OBJ_ID);     -- must be null
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'PARENT_OBJECT_ID',srv_context.Integers_Format, l_policyRec.parent_objectId);
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'EQUIPMENT_TYPE',  r_c_iaObj.IA_EQUIPMENT_TYPE);
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'EQUIPMENT_SUBTYPE', r_c_iaObj.IA_EQUIPMENT_SUBTYPE);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'EQUIPMENT_KIND',srv_context.Integers_Format, r_c_iaObj.IA_INSIS_ADDEQP_KIND );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'SERIAL_NO', r_c_iaObj.IA_ENG_S_NO);
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'ADD_EQUIP_MODEL', r_c_iaObj.IA_ENGINE_MODEL);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'AV_VALUE', srv_context.Real_Number_Format, '0');
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'CURRENCY', 'SEK');
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP1', r_c_iaObj.IA_ENGINE_USE );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP2', r_c_iaObj.IA_ENGINE_PRODUCER );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP3', r_c_iaObj.IA_ENGINE_MODEL );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP4', r_c_iaObj.IA_STERN_S_NO );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP5', r_c_iaObj.IA_ENGINE_HP );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP6', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP7', r_c_iaObj.IA_TYPE_EFFECT );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP8', r_c_iaObj.IA_PROD_YEAR );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP9', r_c_iaObj.IA_ENG_S_NO );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP10', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP11', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP12', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP13', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP14', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP15', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP16', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP17', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP18', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP19', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR  (L_IN_CONTEXT, 'OAEP20', '' );

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_ADDEQUIPMENT') ;

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

      IF l_evres = MIGR_GVAR.GV_EVRES_ERROR     THEN
            l_policyRec.logMsg := 'PIO_ERR INS_ADDEQUIPMENT Failed to register OBJECT';
            MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
            l_policyRec.continue_migr:=FALSE;
            l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert engine';

      ELSE
            l_policyRec.logMsg := 'Engine was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
            MIGR_LOG.LOG_INFO(l_policyRec);

            --l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

            IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                  l_policyRec.logMsg := 'INS_ADDEQUIPMENT returned with warning -RESULT:' || NULL;
                  MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
            END IF;
      END IF;
      INSERT INTO MIGR_O_ENGINE (POLICY_REF, ENGINEID, POLICY_ID, OBJECT_ID, ADD_EQUIP_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
         VALUES (r_c_iaObj.IA_POLICY_REF, r_c_iaObj.IA_ENGINEID, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, L_ADDEQUIP_OBJ_ID, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
        p_policyRec:=l_policyRec;
      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
       p_policyRec:=l_policyRec;
END MIGRATE_O_BOAT_ENGINE;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

FUNCTION  MIGRATE_BOAT(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)  RETURN  MIGR_GVAR.PolicyRecTyp
AS
      v_in_context        SRVCONTEXT;
      v_out_context       SRVCONTEXT;
      v_errmsg            SRVERRMSG;
      v_srverrmsg         SRVERRMSG;
      pio_err             SRVERR;
      v_beginTimer        TIMESTAMP WITH TIME ZONE;
      v_is_obj_ok         BOOLEAN;
      v_address_id        NUMBER;

      CURSOR c_iaObj (vPOLICY_IDPL IA_BOAT_POLICY.IA_IDPL % TYPE) IS
      SELECT ivp.IA_POLICY_REF,      IVP.IA_OBJ_DEDUCT,
      ivp.IA_IDPL,
      ivp.IA_OBJECT_ID,
      ivp.IA_OBJECT_TYPE
   --FA 20161007 no needed check   mov.object_id,     mov.INS_OBJECT_ID
      FROM IA_BOAT_POLICY  ivp
    --FA 20161007 no needed check    LEFT JOIN MIGR_O_SHIP mov ON ivp.IA_OBJECT_ID = mov.IA_OBJECT_ID
      WHERE 1 = 1  AND ivp.IA_IDPL = vPOLICY_IDPL
      ORDER BY SUBSTR(ivp.IA_OBJECT_ID, LENGTH(ivp.IA_OBJECT_ID)) ASC;

      r_c_iaObj           c_iaObj % ROWTYPE;
      l_policyRec         MIGR_GVAR.PolicyRecTyp;
BEGIN

      l_policyRec := p_policyRec;

      l_policyRec.migrArea := 'MIGR_API_BOAT_NEW.MIGRATE_BOAT';
      l_policyRec.migrStep := 'Create Policy Boat';
      l_policyRec.migrRelTbl := 'IA_BOAT_POLICY';


      OPEN c_iaObj (l_policyRec.policy_idpl);
      << Boat_loop >>
      LOOP

            FETCH c_iaObj INTO r_c_iaObj;
            EXIT WHEN c_iaObj % NOTFOUND;

          --FA 20161007 no needed check  IF r_c_iaObj.object_id IS NULL     AND r_c_iaObj.INS_OBJECT_ID IS NULL    THEN

                  l_policyRec.IA_OBJECT_ID := r_c_iaObj.IA_OBJECT_ID;
                  --FA.2060912 Added for cover level functionality
                  l_policyRec.objDeduct_val :=    r_c_iaObj.IA_OBJ_DEDUCT;
                  l_policyRec.object_fail_log  :=NULL;
                  CASE r_c_iaObj.IA_OBJECT_TYPE

                     WHEN '9912' THEN  ---  Boat
                          MIGRATE_O_BOAT_DETAILS(l_policyRec);

                         IF   l_policyRec.parent_objectId IS NOT NULL THEN
                            MIGRATE_O_BOAT_ENGINE(l_policyRec);
                        END IF;

                     ELSE l_policyRec.logMsg := 'Boat object with  ' || r_c_iaObj.IA_OBJECT_ID || ' failed due to invalid object type';
                          MIGR_LOG.LOG_ERROR(l_policyRec);

                          l_policyRec.continue_migr:=FALSE;
                          l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED due  invalid object type';
                          INSERT INTO MIGR_O_SHIP ( POLICY_ID, OBJECT_ID,  INS_DATE,   MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                           VALUES ( l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, SYSDATE, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

                  END CASE;

        END LOOP boat_loop;
      CLOSE c_iaObj;
       RETURN l_policyRec;

EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
             l_policyRec.continue_migr:=FALSE;
             RETURN l_policyRec;
END MIGRATE_BOAT;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_API_BOAT;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_BUILDING_VILLA
AS

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_PRIV_ACCIDENT_INS(p_policyRec IN OUT  MIGR_GVAR.PolicyRecTyp)
IS
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      v_begintimer  TIMESTAMP WITH TIME ZONE;
      L_MAN_ID      P_PEOPLE.MAN_ID % TYPE;
      v_gender      VARCHAR2(10);

      CURSOR c_iaObj (v_OBJECT_ID IA_BUILDING_VILLA_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavb.IA_GNAME,
      iavb.IA_SNAME,
      iavb.IA_NAME,
      iavb.IA_POLICY_REF,
      iavb.IA_PID,
      iavb.IA_AGE,
      iavb.IA_GENDER,
      iavb.IA_FULL_NAME,
      iavb.IA_IND_BENEFICIARY,
      iavb.IA_BIRTH_DATE ,
      mc.MAN_ID
      FROM IA_BUILDING_VILLA_POLICY iavp
      JOIN IA_BUILDING_VILLA_PRIV_INS iavb  ON iavp.IA_OBJECT_ID = iavb.IA_OBJECT_ID
      LEFT JOIN  MIGR_CLIENT mc ON mc.EGN=  iavb.IA_PID
      WHERE 1 = 1    AND iavp.IA_OBJECT_ID = v_OBJECT_ID;

      l_evres PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN

      v_begintimer := SYSTIMESTAMP;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      p_policyRec.migrStep := 'Create Object BUILDING_VILLA Private Accident Insured Person';
      p_policyRec.migrArea := 'MIGR_API_BUILDING_VILLA.MIGRATE_O_PRIV_ACCIDENT_INS';
      p_policyRec.migrRelTbl := 'IA_BUILDING_VILLA_PRIV_INS';


      FOR r_c_iaObj IN c_iaObj(p_policyRec.IA_OBJECT_ID)    LOOP
            p_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            p_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            IF r_c_iaObj.IA_GENDER = 1    THEN
                v_gender := 'M';
            ELSE
                v_gender := 'F';
           END IF;

             --FA. 20161031 First check if person has been migrated by client migration and if not search INSIS
            IF  r_c_iaObj.MAN_ID IS NOT NULL THEN
                L_MAN_ID:=r_c_iaObj.MAN_ID;
            ELSE

                L_MAN_ID := MIGR_API_CLIENTS.GET_PEOPLE_BY_PID(r_c_iaObj.IA_PID);

            END IF;
            IF L_MAN_ID IS NOT NULL THEN
                  l_in_context := NULL;
                  l_out_context := NULL;
                  pio_err := NULL;

                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'AGE', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_SUBTYPE', r_c_iaObj.IA_HOME_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GENDER', v_gender);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP1',  p_policyRec.property_id);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP2', r_c_iaObj.IA_FULL_NAME);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP3', r_c_iaObj.IA_PID);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP4', r_c_iaObj.IA_IND_BENEFICIARY);

                  v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_ACCINSURED');

                  v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                  EXECUTE IMMEDIATE v_stmst USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                  SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', p_policyRec.OBJECT_ID);

                  l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

                  IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
                         p_policyRec.logMsg := 'PIO_ERR INS_ACCINSURED Failed to register OBJECT';
                         MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, pio_err);
                         p_policyRec.continue_migr:=FALSE;
                         p_policyRec.object_fail_log :=p_policyRec.object_fail_log ||  '- FAILED to  register OBJECT';

                   ELSE
                          p_policyRec.logMsg := 'Private Accident Insurd Person was inserted succesfully with object_id: ' || p_policyRec.OBJECT_ID;
                          MIGR_LOG.LOG_INFO(p_policyRec);

                         p_policyRec:=  MIGR_API_COMMON.MIGRATE_OBJECT(p_policyRec);

                         IF    p_policyRec.require_pinsured ='Y' THEN
                             IF  NOT MIGR_API_CLIENTS.ADD_PRIV_INS_PARTICIPANTS(p_policyRec ,L_MAN_ID )THEN
                                   p_policyRec.continue_migr:=FALSE;
                                   p_policyRec.object_fail_log :=P_policyRec.object_fail_log ||  '- FAILED to  add policy participant';
                              END IF;
                          END IF;

                         IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                                p_policyRec.logMsg := 'INS_ACCINSURED returned with warning -RESULT:' || NULL;
                                MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);
                          END IF;
                    END IF;
            ELSE

                  p_policyRec.logMsg := 'Failed to call event INS_ACCINSURED due to null MAN_ID';
                  MIGR_LOG.LOG_ERROR(p_policyRec);
                  p_policyRec.continue_migr:=FALSE;
                  p_policyRec.object_fail_log  :=p_policyRec.object_fail_log|| '-Failed to Insert accident insured';

            END IF;

              INSERT INTO MIGR_O_BUILDING_VILLA ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START,MIG_END,IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL ,OBJ_ERROR_LOG )
             VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, p_policyRec.POLICY_ID, p_policyRec.OBJECT_ID, p_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer, SYSTIMESTAMP,p_policyRec.IA_OBJECT_ID, p_policyRec.MIG_BATCH_ID, p_policyRec.policy_idpl,p_policyRec.object_fail_log);

      END LOOP;

EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(p_policyRec);
           p_policyRec.continue_migr:=FALSE;
END MIGRATE_O_PRIV_ACCIDENT_INS;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_OUTHOUSE(p_policyRec  IN   OUT   MIGR_GVAR.PolicyRecTyp,p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      v_address_Id   NUMBER;
      CURSOR c_iaObj (v_OBJECT_ID IA_BUILDING_VILLA_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavb.IA_PROPERTY_ID,
      iavb.IA_COUNTRY_CODE,
      iavb.IA_CITY,
      iavb.IA_ADDRESS,
      iavb.IA_POST_CODE,
      iavb.IA_NAME,
      iavb.IA_POLICY_REF,
      iavb.IA_BUILDING_AREA,
      iavb.IA_FURNISHED,
      iavb.IA_FLOORS_NO,
      iavb.IA_GEO_COORDINATES,
      iavb.IA_OUTHOUSE_LABEL,
      iavb.IA_OUTHOUSE_LABEL_OTHER,
      iavb.IA_INSULATED
      FROM IA_BUILDING_VILLA_POLICY iavp
      JOIN IA_BUILDING_VILLA_OUTHOUSE iavb
      ON iavp.IA_OBJECT_ID = iavb.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      p_policyRec.migrStep := 'Create Object BUILDING_VILLA Outhouse';
      p_policyRec.migrArea := 'MIGR_API_BUILDING_VILLA.MIGRATE_O_OUTHOUSE';
      p_policyRec.migrRelTbl := 'IA_BUILDING_VILLA_OUTHOUSE';

      FOR r_c_iaObj IN c_iaObj(p_policyRec.IA_OBJECT_ID)    LOOP
            p_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            p_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            v_begintimer := SYSTIMESTAMP;

            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL  OR l_postCode IS NULL   OR l_city IS NULL   OR l_country_code IS NULL)  THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_Id IS NOT NULL     THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', r_c_iaObj.IA_BUILDING_AREA);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_FURNISHED);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', r_c_iaObj.IA_INSULATED);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_FLOORS_NO);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_GEO_COORDINATES);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7',  p_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', r_c_iaObj.IA_OUTHOUSE_LABEL);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', r_c_iaObj.IA_OUTHOUSE_LABEL_OTHER);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');


            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', p_policyRec.OBJECT_ID);

            IF v_address_Id IS NULL  THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

           l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                    p_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, pio_err);
                    p_policyRec.continue_migr:=FALSE;
                    p_policyRec.object_fail_log :=p_policyRec.object_fail_log ||  'FAILED to insert property';

            ELSE
                  p_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || p_policyRec.OBJECT_ID;
                  MIGR_LOG.LOG_INFO(p_policyRec);

                  p_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(p_policyRec);

                 IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                        p_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);
                  END IF;
            END IF;

            INSERT INTO MIGR_O_BUILDING_VILLA ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL ,OBJ_ERROR_LOG )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, p_policyRec.POLICY_ID, p_policyRec.OBJECT_ID, p_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, p_policyRec.IA_OBJECT_ID, p_policyRec.MIG_BATCH_ID, p_policyRec.policy_idpl,p_policyRec.object_fail_log);

      END LOOP;

EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(p_policyRec);
      p_policyRec.continue_migr:=FALSE;
END MIGRATE_O_OUTHOUSE;
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------


PROCEDURE MIGRATE_O_BUILDING(p_policyRec  IN  OUT     MIGR_GVAR.PolicyRecTyp,
p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);

      CURSOR c_iaObj (v_OBJECT_ID IA_BUILDING_VILLA_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavb.IA_PROPERTY_ID,
      iavb.IA_LIVING_AREA,
      iavb.IA_ADDITIONAL_AREA,
      iavb.IA_CHIMNEY,
      iavb.IA_BATHROOMS_NO,
      iavb.IA_BUILT_YEAR,
      iavb.IA_WATER_INSIDE,
      iavb.IA_RENOVATION_YEAR,
      iavb.IA_GEO_COORDINATES,
      iavb.IA_COUNTRY_CODE,
      iavb.IA_CITY,
      iavb.IA_ADDRESS,
      iavb.IA_POST_CODE,
      iavb.IA_NAME,
      iavb.IA_BUILDING_ID,
      iavb.IA_BUILDING_LABEL,
      iavb.IA_BUILDING_USAGE,
      iavb.IA_PURCHASE_DATE,
      iavb.IA_STANDARD_POINTS,
      iavb.IA_BUILDING_TYPE,
      iavb.IA_TAXABLE_VALUE,
      iavb.IA_POLICY_REF
      FROM IA_BUILDING_VILLA_POLICY iavp
      JOIN IA_BUILDING_VILLA_BUILDING iavb
      ON iavp.IA_OBJECT_ID = iavb.IA_OBJECT_ID
      WHERE iavp.IA_OBJECT_ID = v_OBJECT_ID;
      v_address_Id   NUMBER;
      l_evres PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;

      p_policyRec.migrStep := 'Create Object BUILDING_VILLA Building';
      p_policyRec.migrArea := 'MIGR_API_BUILDING_VILLA.MIGRATE_O_BUILDING';
      p_policyRec.migrRelTbl := 'IA_BUILDING_VILLA_BUILDING';

      FOR r_c_iaObj IN c_iaObj(p_policyRec.IA_OBJECT_ID)   LOOP

            l_in_context := NULL;
            l_out_context := NULL;
            pio_err := NULL;

            p_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            p_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL OR l_postCode IS NULL  OR l_city IS NULL  OR l_country_code IS NULL)    THEN

                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  p_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_LIVING_AREA);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_ADDITIONAL_AREA);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_CHIMNEY);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', r_c_iaObj.IA_BATHROOMS_NO);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', r_c_iaObj.IA_BUILT_YEAR);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', r_c_iaObj.IA_RENOVATION_YEAR);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', r_c_iaObj.IA_WATER_INSIDE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', r_c_iaObj.IA_BUILDING_USAGE);  --1: Residence 2: Store
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', r_c_iaObj.IA_BUILDING_ID);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', r_c_iaObj.IA_GEO_COORDINATES);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', r_c_iaObj.IA_BUILDING_LABEL);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');

            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', r_c_iaObj.IA_PURCHASE_DATE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', r_c_iaObj.IA_STANDARD_POINTS);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', r_c_iaObj.IA_BUILDING_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', r_c_iaObj.IA_TAXABLE_VALUE);
            IF v_address_Id IS NULL   THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            END IF;

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', p_policyRec.OBJECT_ID);

            IF v_address_Id IS NULL    THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

             IF   l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                      p_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                      MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, pio_err);
                      p_policyRec.continue_migr:=FALSE;
                      p_policyRec.object_fail_log :=p_policyRec.object_fail_log ||  '-FAILED to insert property';
             ELSE
                     p_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || p_policyRec.OBJECT_ID;
                     MIGR_LOG.LOG_INFO(p_policyRec);

                     p_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(p_policyRec);

                    p_policyRec:=MIGR_API_COMMON.CALCULATE_RECONSTRUCTION_COST(p_policyRec);

                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                          p_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);
                   END IF;
            END IF;

            INSERT INTO MIGR_O_BUILDING_VILLA ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START,MIG_END,IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL ,OBJ_ERROR_LOG )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, p_policyRec.POLICY_ID, p_policyRec.OBJECT_ID, p_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, p_policyRec.IA_OBJECT_ID, p_policyRec.MIG_BATCH_ID, p_policyRec.policy_idpl,p_policyRec.object_fail_log);
      END LOOP;

EXCEPTION
    WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyRec);
          p_policyRec.continue_migr:=FALSE;
END MIGRATE_O_BUILDING;

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_SPECIAL_OBJECT(p_policyRec  IN   OUT   MIGR_GVAR.PolicyRecTyp,
     p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS

        l_in_context   SRVCONTEXT;
        l_out_context  SRVCONTEXT;
        pio_err        SRVERR;
        v_begintimer   TIMESTAMP WITH TIME ZONE;
        v_address_Id   NUMBER;
        l_address      VARCHAR2(256);
        l_postCode     VARCHAR2(256);
        l_city         VARCHAR2(256);
        l_country_code VARCHAR2(256);

        CURSOR c_iaObj (v_OBJECT_ID IA_BUILDING_VILLA_POLICY.IA_OBJECT_ID % TYPE) IS
        SELECT iavp.IA_OBJECT_TYPE,
        iavp.IA_IDPLPS,
        iavp.IA_HOME_TYPE,
        iavp.IA_HOME_SUBTYPE,
        iavc.IA_PROPERTY_ID,
        iavc.IA_POLICY_REF,
        iavc.IA_RISK_TYPE,
        iavc.IA_DESCRIPTION,
        iavc.IA_NAME,
        iavc.IA_COUNTRY_CODE,
        iavc.IA_CITY,
        iavc.IA_ADDRESS,
        iavc.IA_POST_CODE
        FROM IA_BUILDING_VILLA_POLICY iavp
        JOIN IA_BUILDING_VILLA_SPECIAL_OBJ iavc
        ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
        WHERE 1 = 1
        AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
        l_evres PLS_INTEGER;
        v_stmst    VARCHAR2( 400);
        v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;

      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      p_policyRec.migrStep := 'Create Object BUILDING_VILLA Special Object';
      p_policyRec.migrArea := 'MIGR_API_BUILDING_VILLA.MIGRATE_O_SPECIAL_OBJECT';
      p_policyRec.migrRelTbl := 'IA_BUILDING_VILLA_SPECIAL_OBJ';

      FOR r_c_iaObj IN c_iaObj(p_policyRec.IA_OBJECT_ID)
      LOOP
            p_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            p_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL    OR l_postCode IS NULL   OR l_city IS NULL   OR l_country_code IS NULL)   THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_Id IS NOT NULL   THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  p_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_RISK_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', r_c_iaObj.IA_DESCRIPTION);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', p_policyRec.OBJECT_ID);

            IF v_address_Id IS NULL THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

             l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

              IF   l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                    p_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, pio_err);
                    p_policyRec.continue_migr:=FALSE;
                    p_policyRec.object_fail_log :=p_policyRec.object_fail_log ||  '-FAILED to insert property';
             ELSE
                   p_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || p_policyRec.OBJECT_ID;
                   MIGR_LOG.LOG_INFO(p_policyRec);

                   p_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(p_policyRec);

                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                          p_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);
                    END IF;
            END IF;

            INSERT INTO MIGR_O_BUILDING_VILLA ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL ,OBJ_ERROR_LOG )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, p_policyRec.POLICY_ID, p_policyRec.OBJECT_ID, p_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, p_policyRec.IA_OBJECT_ID, p_policyRec.MIG_BATCH_ID, p_policyRec.policy_idpl,p_policyRec.object_fail_log);

      END LOOP;

EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(p_policyRec);
            p_policyRec.continue_migr:=FALSE;
END MIGRATE_O_SPECIAL_OBJECT;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


PROCEDURE MIGRATE_O_STORED_CONTENT(p_policyRec  IN  OUT    MIGR_GVAR.PolicyRecTyp,
     p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);

      CURSOR c_iaObj (v_OBJECT_ID IA_BUILDING_VILLA_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_THEFT_ATTRACTIVE,
      iavc.IA_CERTAIN_LOCKS,
      iavc.IA_PROPERTY_ID,
      iavc.IA_STORED_ADDRESS,
      iavc.IA_POLICY_REF,
      iavc.IA_NAME,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_CITY,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_IS_INHABITATED
      FROM IA_BUILDING_VILLA_POLICY iavp
      JOIN IA_BUILDING_VILLA_STORED_CONT iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      p_policyRec.migrStep := 'Create Object BUILDING_VILLA Stored Content';
      p_policyRec.migrArea := 'MIGR_API_BUILDING_VILLA.MIGRATE_O_STORED_CONTENT';
      p_policyRec.migrRelTbl := 'IA_BUILDING_VILLA_STORED_CONT';

      FOR r_c_iaObj IN c_iaObj(p_policyRec.IA_OBJECT_ID)
      LOOP

            p_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            p_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL  OR l_postCode IS NULL  OR l_city IS NULL  OR l_country_code IS NULL)  THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL   THEN
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  p_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', r_c_iaObj.IA_STORED_ADDRESS );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', r_c_iaObj.IA_THEFT_ATTRACTIVE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', r_c_iaObj.IA_CERTAIN_LOCKS);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', r_c_iaObj.IA_IS_INHABITATED);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;
            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', p_policyRec.OBJECT_ID);

            IF v_address_id IS NULL  THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;
            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

            IF   l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                  p_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, pio_err);
                  p_policyRec.continue_migr:=FALSE;
                  p_policyRec.object_fail_log :=p_policyRec.object_fail_log ||  '-FAILED to insert property';
            ELSE
                  p_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || p_policyRec.OBJECT_ID;
                  MIGR_LOG.LOG_INFO(p_policyRec);
                  p_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(p_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                        p_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);
                  END IF;
            END IF;

            INSERT INTO MIGR_O_BUILDING_VILLA ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL ,OBJ_ERROR_LOG )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, p_policyRec.POLICY_ID, p_policyRec.OBJECT_ID, p_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer,SYSTIMESTAMP,p_policyRec.IA_OBJECT_ID, p_policyRec.MIG_BATCH_ID, p_policyRec.policy_idpl,p_policyRec.object_fail_log);

      END LOOP;

EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(p_policyRec);
            p_policyRec.continue_migr:=FALSE;
END MIGRATE_O_STORED_CONTENT;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_MISCELLANEOUS(p_policyRec  IN   OUT   MIGR_GVAR.PolicyRecTyp,
     p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);

      CURSOR c_iaObj (v_OBJECT_ID IA_BUILDING_VILLA_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_BUILDING_VILLA_POLICY iavp
      JOIN IA_BUILDING_VILLA_MIS_OBJ iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      p_policyRec.migrStep := 'Create Object BUILDING_VILLA Miscellaneous';
      p_policyRec.migrArea := 'MIGR_API_BUILDING_VILLA.MIGRATE_O_MISCELLANEOUS';
      p_policyRec.migrRelTbl := 'IA_BUILDING_VILLA_MIS_OBJ';

      FOR r_c_iaObj IN c_iaObj(p_policyRec.IA_OBJECT_ID)
      LOOP

            p_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            p_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL OR l_postCode IS NULL  OR l_city IS NULL   OR l_country_code IS NULL)  THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL  THEN
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  p_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '' );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', p_policyRec.OBJECT_ID);

            IF v_address_id IS NULL    THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);
            IF   l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                  p_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, pio_err);
                  p_policyRec.continue_migr:=FALSE;
                  p_policyRec.object_fail_log :=p_policyRec.object_fail_log ||  '-FAILED to insert property';
             ELSE
                  p_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || p_policyRec.OBJECT_ID;
                  MIGR_LOG.LOG_INFO(p_policyRec);
                  p_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(p_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                        p_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);
                  END IF;

            END IF;

            INSERT INTO MIGR_O_BUILDING_VILLA ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL ,OBJ_ERROR_LOG )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, p_policyRec.POLICY_ID, p_policyRec.OBJECT_ID, p_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, p_policyRec.IA_OBJECT_ID, p_policyRec.MIG_BATCH_ID, p_policyRec.policy_idpl,p_policyRec.object_fail_log);

      END LOOP;

EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(p_policyRec);
        p_policyRec.continue_migr:=FALSE;
END MIGRATE_O_MISCELLANEOUS;

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_HOBBY(p_policyRec  IN   OUT   MIGR_GVAR.PolicyRecTyp,
     p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
      IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);

      CURSOR c_iaObj (v_OBJECT_ID IA_BUILDING_VILLA_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_BUILDING_VILLA_POLICY iavp
      JOIN IA_BUILDING_VILLA_HOBBY iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      p_policyRec.migrStep := 'Create Object BUILDING_VILLA Hobby';
      p_policyRec.migrArea := 'MIGR_API_BUILDING_VILLA.MIGRATE_O_HOBBY';
      p_policyRec.migrRelTbl := 'IA_BUILDING_VILLA_HOBBY';

      FOR r_c_iaObj IN c_iaObj(p_policyRec.IA_OBJECT_ID)
      LOOP

            p_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            p_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL
            OR l_postCode IS NULL
            OR l_city IS NULL
            OR l_country_code IS NULL)
            THEN
            l_address := p_addressTab(1).r_address;
            l_postCode := p_addressTab(1).r_postCode;
            l_city := p_addressTab(1).r_city;
            l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL
            THEN
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  p_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '' );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', p_policyRec.OBJECT_ID);

            IF v_address_id IS NULL THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

            IF   l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                  p_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, pio_err);
                  p_policyRec.continue_migr:=FALSE;
                  p_policyRec.object_fail_log :=p_policyRec.object_fail_log ||  '-FAILED to insert property';
           ELSE
                 p_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || p_policyRec.OBJECT_ID;
                  MIGR_LOG.LOG_INFO(p_policyRec);
                  p_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(p_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
                        p_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);
                  END IF;
            END IF;

            INSERT INTO MIGR_O_BUILDING_VILLA ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL ,OBJ_ERROR_LOG )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, p_policyRec.POLICY_ID, p_policyRec.OBJECT_ID, p_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, p_policyRec.IA_OBJECT_ID, p_policyRec.MIG_BATCH_ID, p_policyRec.policy_idpl,p_policyRec.object_fail_log);

      END LOOP;

EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(p_policyRec);
          p_policyRec.continue_migr:=FALSE;
END MIGRATE_O_HOBBY;

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_ALL_RISK(p_policyRec  IN  OUT    MIGR_GVAR.PolicyRecTyp,
     p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);

      CURSOR c_iaObj (v_OBJECT_ID IA_BUILDING_VILLA_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_TOTAL_LIVING_AREA,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_BUILDING_VILLA_POLICY iavp
      JOIN IA_BUILDING_VILLA_ALL_RISK iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      p_policyRec.migrStep := 'Create Object BUILDING_VILLA All Risk';
      p_policyRec.migrArea := 'MIGR_API_BUILDING_VILLA.MIGRATE_O_ALL_RISK';
      p_policyRec.migrRelTbl := 'IA_BUILDING_VILLA_ALL_RISK';

      FOR r_c_iaObj IN c_iaObj(p_policyRec.IA_OBJECT_ID)
      LOOP

            p_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            p_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL OR l_postCode IS NULL  OR l_city IS NULL  OR l_country_code IS NULL)  THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL   THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  p_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '' );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', r_c_iaObj.IA_TOTAL_LIVING_AREA);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', p_policyRec.OBJECT_ID);

            IF v_address_id IS NULL    THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

              IF   l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                    p_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, pio_err);
                    p_policyRec.continue_migr:=FALSE;
                    p_policyRec.object_fail_log :=p_policyRec.object_fail_log ||  '-FAILED to insert property';
              ELSE
                    p_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || p_policyRec.OBJECT_ID;
                    MIGR_LOG.LOG_INFO(p_policyRec);
                    p_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(p_policyRec);

                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                          p_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);
                   END IF;

            END IF;

            INSERT INTO MIGR_O_BUILDING_VILLA ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL ,OBJ_ERROR_LOG )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, p_policyRec.POLICY_ID, p_policyRec.OBJECT_ID, p_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, p_policyRec.IA_OBJECT_ID, p_policyRec.MIG_BATCH_ID, p_policyRec.policy_idpl,p_policyRec.object_fail_log);

      END LOOP;

EXCEPTION
WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(p_policyRec);
      p_policyRec.continue_migr:=FALSE;
END MIGRATE_O_ALL_RISK;

------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
FUNCTION  MIGRATE_BUILDING_VILLA(p_policyRec IN  MIGR_GVAR.PolicyRecTyp) RETURN MIGR_GVAR.PolicyRecTyp
      AS
      v_in_context        SRVCONTEXT;
      v_out_context       SRVCONTEXT;
      v_srverrmsg         SRVERRMSG;
      pio_err             SRVERR;
      v_is_obj_ok         BOOLEAN;
      v_address_id        NUMBER;

      CURSOR c_iaObj (vPOLICY_IDPL IA_BUILDING_VILLA_POLICY.IA_IDPL % TYPE) IS
      SELECT ivp.IA_POLICY_REF,
      ivp.IA_IDPL,
      ivp.IA_PSTP,
      ivp.IA_OBJECT_ID,
      ivp.IA_OBJECT_TYPE,
      ia.IA_ADDRESS,
      ia.IA_CITY,
      ia.IA_POST_CODE,
      ia.IA_COUNTRY,
      ivp.IA_OBJ_DEDUCT
     --FA 20161007 no needed check mov.OBJECT_ID, mov.INS_OBJECT_ID
      FROM IA_BUILDING_VILLA_POLICY ivp
    --FA 20161007 no needed check  LEFT JOIN MIGR_O_BUILDING_VILLA mov   ON ivp.IA_OBJECT_ID = mov.IA_OBJECT_ID
      JOIN IA_ADDRESS ia
      ON ia.IA_IDPL = ivp.IA_IDPL
      WHERE 1 = 1
      AND ivp.IA_IDPL = vPOLICY_IDPL
      ORDER BY SUBSTR(ivp.IA_OBJECT_ID, LENGTH(ivp.IA_OBJECT_ID)) ASC;

      r_c_iaObj           c_iaObj % ROWTYPE;
      vPropertyAddressTab MIGR_GVAR.PropertyAddressTabTyp;
      l_policyRec         MIGR_GVAR.PolicyRecTyp;

BEGIN
      vPropertyAddressTab.DELETE();
      l_policyRec := p_policyRec;
      l_policyRec.migrArea := 'MIGR_API_BUILDING_VILLA.MIGRATE_BUILDING_VILLA';
      l_policyRec.migrStep := 'Create BUILDING_VILLA Policy';
      l_policyRec.migrRelTbl := 'IA_BUILDING_VILLA_POLICY';

      OPEN c_iaObj (l_policyRec.POLICY_IDPL);
      << BUILDING_VILLA_loop >>
      LOOP

            FETCH c_iaObj INTO r_c_iaObj;
            EXIT WHEN c_iaObj % NOTFOUND;
            --add default client address
            MIGR_API_COMMON.ADD_ADDRESS_ID(vPropertyAddressTab, NULL, r_c_iaObj.IA_ADDRESS, r_c_iaObj.IA_POST_CODE, r_c_iaObj.IA_CITY, r_c_iaObj.IA_COUNTRY);

         --FA 20161007 no needed check   IF r_c_iaObj.OBJECT_ID IS NULL  AND r_c_iaObj.INS_OBJECT_ID IS NULL THEN

                  l_policyRec.IA_OBJECT_ID := r_c_iaObj.IA_OBJECT_ID;
                  --FA.2060912 Added for cover level functionality
                   l_policyRec.objDeduct_val :=    r_c_iaObj.IA_OBJ_DEDUCT;
                    l_policyRec.object_fail_log  :=NULL;
                  CASE r_c_iaObj.IA_OBJECT_TYPE

                 WHEN '1761' THEN  ---Building
                      MIGRATE_O_BUILDING(l_policyRec, vPropertyAddressTab);

                 WHEN '2104' THEN  ---Stored Content
                      MIGRATE_O_STORED_CONTENT(l_policyRec, vPropertyAddressTab);

                 WHEN '2302' THEN  ---Special Object
                      MIGRATE_O_SPECIAL_OBJECT(l_policyRec, vPropertyAddressTab);

                 WHEN '115' THEN  ---Outhouse
                      MIGRATE_O_OUTHOUSE(l_policyRec, vPropertyAddressTab);

                 WHEN '451' THEN  ---Private Accident Insured Person
                      MIGRATE_O_PRIV_ACCIDENT_INS(l_policyRec);

                 WHEN '2402' THEN  ---MISCELLANEOUS
                      MIGRATE_O_MISCELLANEOUS(l_policyRec, vPropertyAddressTab);

                 WHEN '2502' THEN  ---HOBBY
                      MIGRATE_O_HOBBY(l_policyRec, vPropertyAddressTab);

                 WHEN '3004' THEN  ---All risk property
                      MIGRATE_O_ALL_RISK(l_policyRec, vPropertyAddressTab);

                  ELSE l_policyRec.logMsg := 'BUILDING_VILLA object with  ' || r_c_iaObj.IA_OBJECT_ID || ' failed due to invalid object type';
                        MIGR_LOG.LOG_ERROR(l_policyRec);

                       l_policyRec.continue_migr:=FALSE;
                        l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED due  invalid object type';
                        INSERT INTO MIGR_O_BUILDING_VILLA ( POLICY_ID, OBJECT_ID,  INS_DATE,   MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                        VALUES ( l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, SYSDATE, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

                  END CASE;

      END LOOP BUILDING_VILLA_loop;

      CLOSE c_iaObj;
      RETURN l_policyRec;

EXCEPTION
    WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
           l_policyRec.continue_migr:=FALSE;
          RETURN l_policyRec;
END MIGRATE_BUILDING_VILLA;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_API_BUILDING_VILLA;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_CLIENTS
  AS

  ---------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------

  FUNCTION ADD_POL_PARTICIPANTS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN BOOLEAN
    IS

      L_IN_CONTEXT     SRVCONTEXT;
      L_OUT_CONTEXT    SRVCONTEXT;
      L_ERRMSG         SRVERRMSG;
      L_SRVERRMSG      SRVERRMSG;
      PIO_ERR          SRVERR;
      L_RESULT         VARCHAR2(50);
      l_policyRec      MIGR_GVAR.PolicyRecTyp;
      l_man_id         P_PEOPLE.MAN_ID % TYPE;
      --vParticipantsTbl VARCHAR2(30);
      L_PARTICIPANT_ID VARCHAR2(256);
      vParticipantsSql VARCHAR2(2000);
      TYPE particip_rec IS RECORD (
          IA_PART_ROLE   VARCHAR2(30),
          IA_PID         VARCHAR2(30),
          IA_AGE         VARCHAR2(300),
          IA_BIRTH_DATE  DATE,
          IA_FULL_NAME   VARCHAR2(300),
          IA_GNAME       VARCHAR2(300),
          IA_SNAME       VARCHAR2(300),
          IA_GENDER      VARCHAR2(300),
          IA_INSR_BEGIN  DATE,
          IA_PART_STATUS VARCHAR2(300),
          IA_LANGUAGE    VARCHAR2(300) ,
         MAN_ID MIGR_CLIENT.MAN_ID%TYPE
        );
      TYPE t_particip_type_tab IS TABLE OF particip_rec;
      v_particip_tab   t_particip_type_tab;
      v_beginTimer     TIMESTAMP WITH TIME ZONE;
      l_evres          PLS_INTEGER;
      l_ret            BOOLEAN;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

    BEGIN
      l_ret := TRUE;
      v_beginTimer := SYSTIMESTAMP;
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Add Policy Participants';
      l_policyRec.migrArea := 'MIGR_API_CLIENTS.ADD_POL_PARTICIPANTS';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

    --FA.20161031 get migrated client
    --  vParticipantsSql := ' SELECT IA_PART_ROLE,IA_PID,IA_AGE,IA_BIRTH_DATE,IA_FULL_NAME,IA_GNAME,IA_SNAME,IA_GENDER,IA_INSR_BEGIN,IA_PART_STATUS,IA_LANGUAGE FROM '
    ---  || l_policyRec.ia_participantsTbl || ' WHERE IA_IDPL =' || CHR(39) || l_policyRec.policy_idpl || CHR(39);

      vParticipantsSql := ' SELECT IA_PART_ROLE,IA_PID,IA_AGE,IA_BIRTH_DATE,IA_FULL_NAME,IA_GNAME,IA_SNAME,IA_GENDER,IA_INSR_BEGIN,IA_PART_STATUS,IA_LANGUAGE,mc.MAN_ID  FROM '
      || l_policyRec.ia_participantsTbl || '  LEFT JOIN MIGR_CLIENT mc ON mc.EGN= IA_PID  WHERE IA_IDPL =' || CHR(39) || l_policyRec.policy_idpl || CHR(39);


     EXECUTE IMMEDIATE vParticipantsSql
        BULK COLLECT INTO v_particip_tab;

      FOR i IN 1 .. v_particip_tab.COUNT
      LOOP

         --FA.20161031 check if client has been migrated
        IF v_particip_tab(i).MAN_ID IS NOT NULL then
              l_man_id:=v_particip_tab(i).MAN_ID;
        ELSE
            l_man_id := GET_PEOPLE_BY_PID(v_particip_tab(i).IA_PID);
        END IF;

        IF l_man_id IS NULL
        THEN
          --FA.20160520 For insured objects: private accident insured person insert person in p_people.No need for client role
          --- l_man_id := MIGR_API_CLIENTS.INSERT_CLIENT(v_particip_tab(i).IA_GNAME, v_particip_tab(i).IA_SNAME, v_particip_tab(i).IA_FULL_NAME,
          l_man_id := MIGR_API_CLIENTS.INSERT_PEOPLE(v_particip_tab(i).IA_GNAME, v_particip_tab(i).IA_SNAME, v_particip_tab(i).IA_FULL_NAME,

          v_particip_tab(i).IA_PID, v_particip_tab(i).IA_GENDER, v_particip_tab(i).IA_BIRTH_DATE);

        END IF;
        IF l_man_id IS NOT NULL
        THEN

          L_IN_CONTEXT := NULL;
          L_OUT_CONTEXT := NULL;
          PIO_ERR := NULL;
          --!!!!!!FA. 20160322 Always set parameter participant_id to null. if not policy participant sequence retunns with error
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'PARTICIPANT_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'MAN_ID', SRV_CONTEXT.Integers_Format, l_man_id);           -- MAN_ID
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PARTICPANT_ROLE', v_particip_tab(i).IA_PART_ROLE);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'STATUS', v_particip_tab(i).IA_PART_STATUS);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'LANGUAGE', v_particip_tab(i).IA_LANGUAGE);
          SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'VALID_FROM', SRV_CONTEXT.Date_Format, v_particip_tab(i).IA_INSR_BEGIN); -- start
          SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'REGISTRATION_DATE', SRV_CONTEXT.Date_Format, v_particip_tab(i).IA_INSR_BEGIN);

          v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_POLICY_PARTICIPANS') ;

          v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

         EXECUTE IMMEDIATE v_stmst USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

-- LM - 20170327 - GETCONTEXTATTRCHAR returns null - select from INSIS_GEN_V10.POLICY_PARTICIPANTS instead - start
         -- SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PARTICIPANT_ID', L_PARTICIPANT_ID);                     -- returns nothing

        SELECT pp.PARTICIPANT_ID
          INTO L_PARTICIPANT_ID
          FROM INSIS_GEN_V10.POLICY_PARTICIPANTS pp
         WHERE pp.POLICY_ID = l_policyRec.policy_id
           AND pp.PARTICPANT_ROLE = v_particip_tab(i).IA_PART_ROLE ;
-- LM - 20170327 - GETCONTEXTATTRCHAR returns null - select from INSIS_GEN_V10.POLICY_PARTICIPANTS instead - end

          l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

          IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS THEN
            l_policyRec.logMsg := 'Participants were added succesfully ' || '-RESULT:' || L_RESULT;
              MIGR_LOG.LOG_INFO(l_policyRec);

            INSERT INTO MIGR_O_POLICY_PARTICIPANTS (
              MAN_ID, policy_idpl, policy_id, PARTICIPANT_ID, INS_DATE, INS_MS, MIG_START,MIG_END,mig_batch_id
            )
            VALUES (l_man_id, l_policyRec.policy_idpl, l_policyRec.policy_id, L_PARTICIPANT_ID, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_beginTimer),v_beginTimer,SYSTIMESTAMP, l_policyRec.mig_batch_id);

          ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN

            l_policyRec.logMsg := 'INS_POLICY_PARTICIPANS returned with warning -RESULT:' || L_RESULT;
            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);

          ELSE
            l_policyRec.logMsg := 'PIO_ERR INS_POLICY_PARTICIPANS Failed to add participants-RESULT: ' || L_RESULT;
            MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
            l_ret := FALSE;

          END IF;
        END IF;
      END LOOP;
      RETURN l_ret;


    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_ERROR(l_policyRec);
          RETURN FALSE;
    END ADD_POL_PARTICIPANTS;
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160725 Add a policy participant each private accident insured person
  FUNCTION ADD_PRIV_INS_PARTICIPANTS(p_policyRec IN MIGR_GVAR.PolicyRecTyp,l_man_id IN NUMBER)
    RETURN BOOLEAN
    IS

      L_IN_CONTEXT     SRVCONTEXT;
      L_OUT_CONTEXT    SRVCONTEXT;
      L_ERRMSG         SRVERRMSG;
      L_SRVERRMSG      SRVERRMSG;
      PIO_ERR          SRVERR;
      L_RESULT         VARCHAR2(50);
      l_policyRec      MIGR_GVAR.PolicyRecTyp;
      L_PARTICIPANT_ID VARCHAR2(256);
      v_beginTimer     TIMESTAMP WITH TIME ZONE;
      l_evres          PLS_INTEGER;
      l_ret            BOOLEAN;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

    BEGIN
      l_ret := TRUE;
      v_beginTimer := SYSTIMESTAMP;
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Add Private Insured Person Participants';
      l_policyRec.migrArea := 'MIGR_API_CLIENTS.ADD_PRIV_INS_PARTICIPANTS';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

          L_IN_CONTEXT := NULL;
          L_OUT_CONTEXT := NULL;
          PIO_ERR := NULL;
          --!!!!!!FA. 20160322 Always set parameter participant_id to null. if not policy participant sequence retunns with error
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'PARTICIPANT_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'MAN_ID', SRV_CONTEXT.Integers_Format, l_man_id);           -- MAN_ID
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PARTICPANT_ROLE', 'PINSURED');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'STATUS','ACTIVE');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'LANGUAGE', 'ENGLISH');
          SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'VALID_FROM', SRV_CONTEXT.Date_Format, l_policyRec.INSR_BEGIN); -- start
          SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'REGISTRATION_DATE', SRV_CONTEXT.Date_Format, l_policyRec.INSR_BEGIN);

         v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_POLICY_PARTICIPANS');

          v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

          EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

          SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PARTICIPANT_ID', L_PARTICIPANT_ID);                     -- returns nothing
          --FA.20160421 Handle Event Response
          l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

          IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS THEN
            l_policyRec.logMsg := 'Participants were added succesfully ' || '-RESULT:' || L_RESULT;
              MIGR_LOG.LOG_INFO(l_policyRec);

            INSERT INTO MIGR_O_POLICY_PARTICIPANTS (
              MAN_ID, policy_idpl, policy_id, PARTICIPANT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, mig_batch_id
            )
            VALUES (l_man_id, l_policyRec.policy_idpl, l_policyRec.policy_id, L_PARTICIPANT_ID, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_beginTimer),v_beginTimer,SYSTIMESTAMP, l_policyRec.mig_batch_id);

          ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN

            l_policyRec.logMsg := 'INS_POLICY_PARTICIPANS returned with warning -RESULT:' || L_RESULT;
            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);

          ELSE
            l_policyRec.logMsg := 'PIO_ERR INS_POLICY_PARTICIPANS Failed to add participants-RESULT: ' || L_RESULT;
            MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
            l_ret := FALSE;

          END IF;


      RETURN l_ret;


    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_ERROR(l_policyRec);
          RETURN FALSE;
    END ADD_PRIV_INS_PARTICIPANTS;


  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_CLIENT(
                           v_ID_EGN           IN  MIGR_CLIENT.EGN % TYPE,
                           v_MAN_ID           OUT P_PEOPLE.MAN_ID % TYPE,
                           v_CLIENT_ID        OUT P_CLIENTS.client_id % TYPE,
                           p_migrationBatchId IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE)--,

    AS

      L_IN_CONTEXT     SRVCONTEXT;
      L_OUT_CONTEXT    SRVCONTEXT;

      L_ERRMSG         SRVERRMSG;
      L_SRVERRMSG      SRVERRMSG;
      PIO_ERR          SRVERR;

      L_elapsed_ms     NUMBER;
      L_msg            VARCHAR2(250);
      L_beginStepTimer TIMESTAMP WITH TIME ZONE;

      L_EGN            P_PEOPLE.EGN % TYPE;
      L_CLIENT_ID      P_CLIENTS.client_id % TYPE;
      L_MAN_ID         P_PEOPLE.MAN_ID % TYPE;
      l_logRec         MIGR_GVAR.LogRecTyp;
      CURSOR C_IA_CLIENT (v_ID_EGN IA_CLIENT.IA_EGN % TYPE, migrationBatchId IA_CLIENT.mig_batch_id % TYPE) IS
          SELECT IA_EGN,
                 IA_GNAME,
                 IA_SNAME,
                 IA_FNAME,
                 IA_SEX,
                 IA_BIRTH_DATE,
                 IA_FULL_NAME
            FROM IA_CLIENT
            WHERE 1 = 1
              AND IA_CLIENT.IA_EGN = v_ID_EGN
              AND IA_CLIENT.mig_batch_id = migrationBatchId
              AND IA_CLIENT.MIG_FLAG = 0;

      r_C_IA_CLIENT    C_IA_CLIENT % ROWTYPE;
      l_evres          PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      L_beginStepTimer := SYSTIMESTAMP();
      L_EGN := v_ID_EGN;          --- +++ anb 2015-09-25 the rest of the procedure works with L_EGN
      l_logRec.mig_batch_id := p_migrationBatchId;
      l_logRec.migrArea := 'MIGR_API_CLIENTS.MIGRATE_CLIENT';
      l_logRec.migrStep := 'Create Clients';

      l_logRec.logMsg := '   --Client EGN ' || L_EGN;
      l_logRec.migrRelTbl := 'IA_CLIENTS';

      OPEN C_IA_CLIENT (L_EGN, p_migrationBatchId);
      LOOP
        FETCH C_IA_CLIENT INTO r_C_IA_CLIENT;
        EXIT WHEN C_IA_CLIENT % NOTFOUND;

        l_logRec.migrRelKey := L_EGN;

        L_IN_CONTEXT := NULL;
        L_OUT_CONTEXT := NULL;
        PIO_ERR := NULL;

        SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'GIVEN_NAME', r_C_IA_CLIENT.IA_GNAME);    -- first name
        SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'FAMILY_NAME', r_C_IA_CLIENT.IA_SNAME);   -- surname
        SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'NAME', r_C_IA_CLIENT.IA_FULL_NAME);   -- surname
        SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'EGN', r_C_IA_CLIENT.IA_EGN);   -- EGN must be unique
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'SEX', SRV_CONTEXT.Integers_Format, r_C_IA_CLIENT.IA_SEX);    -- sex
        SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'BIRTH_DATE', SRV_CONTEXT.Date_Format, TO_DATE(r_C_IA_CLIENT.IA_BIRTH_DATE, 'DD-MM-YYYY'));

        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INSERT_CLIENT_BO');

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

        EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

        --FA.20160421 Handle Event Response
        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);
        IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
        --IF PIO_ERR IS NULL
        THEN

          SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'MAN_ID', L_MAN_ID);
          SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'CLIENT_ID', L_CLIENT_ID);

          v_MAN_ID := L_MAN_ID;
          v_CLIENT_ID := L_CLIENT_ID;

          IF L_MAN_ID IS NOT NULL
          THEN

            IF L_CLIENT_ID IS NOT NULL
            THEN

                l_logRec.logMsg := 'Client was migrated successfully with Client_ID = ' || L_CLIENT_ID || ' , Man_ID = ' || L_MAN_ID;

                MIGR_LOG.LOG_INFO(l_logRec);

              L_elapsed_ms := 0;
            ELSE                  --- client was NOT ceated

              l_logRec.logMsg := '   --Client EGN ' || r_C_IA_CLIENT.IA_EGN || ' Could not register Client --> MAN_ID = ' || L_MAN_ID;
              MIGR_LOG.LOG_ERROR(l_logRec);
            END IF;     -- Client_ID is not null

          ELSE

            l_logRec.logMsg := '   --Client EGN ' || r_C_IA_CLIENT.IA_EGN || ' Could not register EGN as  MAN_ID = ' || L_MAN_ID || ' --> CLIENT_ID = ' || L_CLIENT_ID;
            MIGR_LOG.LOG_ERROR(l_logRec);
          END IF;           -- MAN_ID is not null

        ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
        THEN
          l_logRec.logMsg := 'INSERT_CLIENT_BO returned with warning -RESULT:' || NULL;
          MIGR_LOG.LOG_WARNING_EVENT(l_logRec, PIO_ERR);

        ELSE
          l_logRec.logMsg := 'MIGR_API_CLIENTS.MIGRATE_CLIENT: INSERT_CLIENT_BO failed';
          MIGR_LOG.LOG_ERROR_EVENT(l_logRec, PIO_ERR);
        END IF;
      END LOOP;
      CLOSE C_IA_CLIENT;
      ----FA. 2015113 If client succesfully migrated commit all insis changes else rollback
      IF (L_CLIENT_ID IS NOT NULL)
        AND (L_MAN_ID IS NOT NULL)
      THEN
        INSERT INTO MIGR_CLIENT (
          EGN, MAN_ID, client_id, INS_DATE, INS_MS,mig_start,mig_end, mig_batch_id ,migrated
        )
        VALUES (L_EGN, L_MAN_ID, L_CLIENT_ID, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, L_beginStepTimer),L_beginStepTimer,SYSTIMESTAMP, p_migrationBatchId,'Y');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN IF C_IA_CLIENT % ISOPEN
          THEN
            CLOSE C_IA_CLIENT;
          END IF;
          l_logRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_logRec);
    END MIGRATE_CLIENT;
  -----------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_CLIENT_ADDRESS(vEGN               IN  P_PEOPLE.EGN % TYPE,
                                   vMAN_ID            IN  P_PEOPLE.MAN_ID % TYPE,
                                   vMADDRESS          IN  VARCHAR2,
                                   vADDRESS_ID        OUT P_ADDRESS.ADDRESS_ID % TYPE,
                                   p_migrationBatchId IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE)
    AS
      L_IN_CONTEXT     SRVCONTEXT;
      L_OUT_CONTEXT    SRVCONTEXT;
      L_ERRMSG         SRVERRMSG;
      L_SRVERRMSG      SRVERRMSG;
      PIO_ERR          SRVERR;
      L_beginTimer     TIMESTAMP WITH TIME ZONE;
      L_beginStepTimer TIMESTAMP WITH TIME ZONE;
      L_endTimer       TIMESTAMP WITH TIME ZONE;
      L_elapsed_ms     NUMBER;
      L_msg            VARCHAR2(250);
      L_EGN            P_PEOPLE.EGN % TYPE;
      L_MAN_ID         P_PEOPLE.MAN_ID % TYPE;
      L_ID_ADDRESS     IA_ADDRESS.IA_ID_ADDRESS % TYPE;
      L_ADDRESS_ID     P_ADDRESS.ADDRESS_ID % TYPE;
      L_MADDRESS       IA_ADDRESS.IA_MADDRESS % TYPE;

      CURSOR C_IA_ADDRESS (v_MAN_ID P_PEOPLE.MAN_ID % TYPE, v_IA_MADDRESS IA_ADDRESS.IA_MADDRESS % TYPE, migrationBatchId IA_CLIENT.mig_batch_id % TYPE) IS
          SELECT ia.IA_EGN,
                 ia.IA_MADDRESS,
                 ia.IA_ADDRESS_TYPE,
                 ia.IA_COUNTRY,
                 ia.IA_CITY,
                 ia.IA_ADDRESS,
                 ia.IA_POST_CODE,
                 ia.IA_NOTE,
                 ia.IA_STATE_NAME,
                 ia.IA_REGION_NAME,
                 ia.IA_QUARTER_NAME,
                 ia.IA_VALID_FROM,
                 ia.IA_VALID_TO,
                 ia.IA_PRIMARY_FLAG,
                 ia.MIG_FLAG,
                 ia.mig_batch_id,
                 ia.MIG_TIMESTAMP,
                 ia.MIG_MUTUAL_ID,
                 ma.ADDRESS_ID
                 --, v_MAN_ID AS MAN_ID
                 ,
                 ma.MAN_ID
            FROM IA_ADDRESS ia
              LEFT JOIN MIGR_ADDRESS ma
                ON ia.IA_MADDRESS = ma.IA_MADDRESS
            WHERE 1 = 1
              AND ia.IA_MADDRESS = v_IA_MADDRESS
              AND ia.mig_batch_id = migrationBatchId
              AND ia.MIG_FLAG = 0
            ORDER BY ia.IA_EGN,
                     ia.IA_ID_ADDRESS ASC;
      r_IA_ADDRESS     C_IA_ADDRESS % ROWTYPE;
      l_LogRec         MIGR_GVAR.LogRecTyp;
      l_evres          PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

    BEGIN
      L_beginStepTimer := SYSTIMESTAMP();
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      L_EGN := vEGN;
      L_MAN_ID := vMAN_ID;
      L_MADDRESS := vMADDRESS;
      l_LogRec.mig_batch_id := p_migrationBatchId;
      l_LogRec.migrArea := 'MIGR_API_CLIENTS.MIGRATE_CLIENT_ADDRESS';
      l_LogRec.migrStep := 'Create Client Address';
      l_LogRec.logMsg := '   --Client EGN ' || L_EGN || ' , ID_Address ' || TO_CHAR(L_ID_ADDRESS);
      l_LogRec.migrRelTbl := 'IA_ADDRESS';
      l_LogRec.migrRelKey := vEGN;
      --KB 2/10/2015 ADDED
      IF L_MAN_ID IS NOT NULL
      THEN
        --- should be only one address (since we pass id_address as parameter).
        OPEN C_IA_ADDRESS (L_MAN_ID, L_MADDRESS, p_migrationBatchId);
        LOOP
          FETCH C_IA_ADDRESS INTO r_IA_ADDRESS;
          EXIT WHEN C_IA_ADDRESS % NOTFOUND;
          L_beginTimer := SYSTIMESTAMP;
          L_IN_CONTEXT := NULL;
          L_OUT_CONTEXT := NULL;

          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ADDRESS_TYPE', r_IA_ADDRESS.IA_ADDRESS_TYPE);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ADDRESS', r_IA_ADDRESS.IA_ADDRESS);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'POST_CODE', r_IA_ADDRESS.IA_POST_CODE);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'COUNTRY', r_IA_ADDRESS.IA_COUNTRY);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'CITY', r_IA_ADDRESS.IA_CITY);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'STATE_NAME', r_IA_ADDRESS.IA_STATE_NAME);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'REGION_NAME', r_IA_ADDRESS.IA_REGION_NAME);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'QUARTER_NAME', r_IA_ADDRESS.IA_QUARTER_NAME);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'NOTE', r_IA_ADDRESS.IA_NOTE);

          ----FA.2016071- Country code seems to create consistency errors if missing:  ERROR:LFAB.SWE_RES.RED_PHOLTYPE:ERROR MESSAGE:Prohibit policy registration. The policyholder has to be a registered resident in Sweden/even if it is a company
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'COUNTRY_CODE', 'SE');
          -- SRV_CONTEXT.SETCONTEXTATTRDATE    (L_IN_CONTEXT, 'VALID_FROM', SRV_CONTEXT.DATE_FORMAT, r_IA_ADDRESS.VALID_FROM);
          --SRV_CONTEXT.SETCONTEXTATTRDATE    (L_IN_CONTEXT, 'VALID_TO', SRV_CONTEXT.DATE_FORMAT, r_IA_ADDRESS.VALID_TO);
          ---    FA: pass null -otherwise inserts duplicates and cannot send customer documents
          ----SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PRIMARY_FLAG', r_IA_ADDRESS.IA_PRIMARY_FLAG);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PRIMARY_FLAG', NULL);
          -- fire event

          v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_ADDRESS');

          v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

          EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

          --FA.20160421 Handle Event Response
          l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);
          IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
          THEN

            SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'ADDRESS_ID', L_ADDRESS_ID);
            vADDRESS_ID := NULL;
            --check event result
            IF L_ADDRESS_ID IS NOT NULL
            THEN

              L_endTimer := SYSTIMESTAMP;
              vADDRESS_ID := L_ADDRESS_ID;

                l_LogRec.logMsg := 'Address was migrated successfully with ADDRESS_ID = ' || L_ADDRESS_ID;
                MIGR_LOG.LOG_INFO(l_LogRec);

              L_elapsed_ms := MIGR_SYSTEM.FN_ELAPSEDMS(L_endTimer, L_beginTimer);
            ELSE                  --- address was NOT ceated

              l_LogRec.logMsg := '...Could not register Address ';
              MIGR_LOG.LOG_ERROR(l_LogRec);
            END IF;     -- L_ADDRESS_ID is not null

          ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
          THEN

            l_LogRec.logMsg := 'INS_ADDRESS returned with warning -RESULT:' || NULL;
            MIGR_LOG.LOG_WARNING_EVENT(l_LogRec, PIO_ERR);
          ELSE
            l_LogRec.logMsg := 'MIGR_API_CLIENTS.MIGRATE_CLIENT_ADDRESS: INS_ADDRESS failed';
            MIGR_LOG.LOG_ERROR_EVENT(l_LogRec, PIO_ERR);
          END IF;
        END LOOP;
      ELSE
        l_LogRec.logMsg := ' ...Man id was empty ';
        MIGR_LOG.LOG_ERROR(l_LogRec);

      END IF;
      CLOSE C_IA_ADDRESS;

      IF L_ADDRESS_ID IS NOT NULL
      THEN
        INSERT INTO MIGR_ADDRESS (
          EGN, MAN_ID, IA_MADDRESS, ADDRESS_ID, INS_DATE, INS_MS,mig_start,mig_end, mig_batch_id
        )
        VALUES (vEGN, L_MAN_ID, r_IA_ADDRESS.IA_MADDRESS, L_ADDRESS_ID, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, L_beginStepTimer),L_beginStepTimer,SYSTIMESTAMP, p_migrationBatchId);

      END IF;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END MIGRATE_CLIENT_ADDRESS;
  ----------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------
   --FA.20161208 get values diractly from db
    PROCEDURE GET_CUSTOMER_FROM_INSIS(P_PID       IN  VARCHAR2,
                                    L_CLIENT_ID OUT P_CLIENTS.client_id % TYPE,
                                    L_MAN_ID    OUT P_PEOPLE.MAN_ID % TYPE)
    AS
     l_LogRec MIGR_GVAR.LogRecTyp;

    BEGIN

      L_CLIENT_ID := NULL;
      L_MAN_ID := NULL;

      SELECT C.CLIENT_ID, C.MAN_ID
        INTO    L_CLIENT_ID ,L_MAN_ID
        FROM INSIS_PEOPLE_V10. P_CLIENTS C,INSIS_PEOPLE_V10.P_PEOPLE P
        WHERE P.MAN_ID=C.MAN_ID AND P.EGN= P_PID ;

    EXCEPTION
      WHEN OTHERS THEN

        l_LogRec.mig_batch_id:=   '1';
        l_LogRec.migrArea      :=   'GET CUSTOMER FROM INSIS' ;
        l_LogRec.migrStep      :=   'MIGR_API_CLIENTS.GET_CUSTOMER_FROM_INSIS' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=    'Could not retrieve client by pid: '  ||  SQLCODE || '-'  ||SQLERRM  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END GET_CUSTOMER_FROM_INSIS;

  PROCEDURE GET_CUSTOMER_FROM_INSIS_EVENT(P_PID       IN  VARCHAR2,
                                    L_CLIENT_ID OUT P_CLIENTS.client_id % TYPE,
                                    L_MAN_ID    OUT P_PEOPLE.MAN_ID % TYPE)
    AS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_DEBUG       VARCHAR2(10);
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
      l_logRec MIGR_GVAR.LogRecTyp;

    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;
      L_CLIENT_ID := NULL;
      L_MAN_ID := NULL;

      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PID', P_PID);    -- find MAN_ID

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('GET_CLIENT_BY_PID');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'CLIENT_ID', L_CLIENT_ID);
      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'MAN_ID', L_MAN_ID);

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.mig_batch_id:=   '1';
        l_LogRec.migrArea      :=   'GET CUSTOMER FROM INSIS EVENT' ;
        l_LogRec.migrStep      :=   'MIGR_API_CLIENTS.GET_CUSTOMER_FROM_INSIS_EVENT' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=    'Call Event:GET_CLIENT_BY_PID: '  ||  SQLCODE || '-'  ||SQLERRM  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END GET_CUSTOMER_FROM_INSIS_EVENT;

  ----------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------

  FUNCTION GET_PEOPLE_BY_PID_EVENT(p_Pid IN VARCHAR2)

    RETURN P_PEOPLE.MAN_ID % TYPE
    IS
      l_ManId       P_PEOPLE.MAN_ID % TYPE;
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

    BEGIN
      l_policyRec.migrStep := 'Get People by PID';
      l_policyRec.migrArea := 'MIGR_API_CLIENTS.GET_PEOPLE_BY_PID';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';
      l_in_context := NULL;
      l_out_context := NULL;

      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PID', p_Pid);

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('GET_PEOPLE_BY_PID');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'PROCEDURE_RESULT', L_RESULT);

      --IF pio_err IS NULL
      --FA.20160421 Handle Event Response
      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
        OR l_evres = MIGR_GVAR.GV_EVRES_WARNING
      THEN
        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'MAN_ID', l_ManId);

        IF l_evres = MIGR_GVAR.GV_EVRES_WARNING
        THEN

          l_policyRec.logMsg := 'GET_PEOPLE_BY_PID returned with warning -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
        END IF;
        RETURN l_ManId;
      ELSE
        l_policyRec.logMsg := 'PIO_ERR GET_PEOPLE_BY_PID Failed to GET man_id -RESULT: ' || L_RESULT;
        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
        RETURN NULL;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_ERROR(l_policyRec);
          RETURN NULL;
    END GET_PEOPLE_BY_PID_EVENT;
   -----------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION GET_PEOPLE_BY_PID(p_pid IN VARCHAR2)

    RETURN P_PEOPLE.MAN_ID % TYPE
    IS
      l_ManId       P_PEOPLE.MAN_ID % TYPE;
      l_policyRec   MIGR_GVAR.LogRecTyp;


    BEGIN
      l_policyRec.migrStep := 'Get People by PID';
      l_policyRec.migrArea := 'MIGR_API_CLIENTS.GET_PEOPLE_BY_PID';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';
      l_policyRec.migrRelKey:=  p_pid;
      l_ManId :=NULL;
     SELECT  MAN_ID
      INTO    l_ManId
      FROM INSIS_PEOPLE_V10.P_PEOPLE
      WHERE EGN= p_pid;

       RETURN  l_ManId;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := 'Could not retrieve Person by PID from INSIS db due to error:' ||SQLCODE|| ' ' ||  SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN NULL;
    END GET_PEOPLE_BY_PID;
  ----------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------
  FUNCTION INSERT_CLIENT(p_gname      IN VARCHAR2,
                         p_sname      IN VARCHAR2,
                         p_fname      IN VARCHAR2,
                         p_pid        IN VARCHAR2,
                         p_gender     IN NUMBER,
                         p_birth_date IN DATE)

    RETURN P_PEOPLE.MAN_ID % TYPE
    IS
      l_ManId       P_PEOPLE.MAN_ID % TYPE;
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN
      l_policyRec.migrStep := 'Insert Client';
      l_policyRec.migrArea := 'MIGR_API_CLIENTS.INSERT_CLIENT';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';
      l_in_context := NULL;
      l_out_context := NULL;

      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GIVEN_NAME', p_gname);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'FAMILY_NAME', p_sname);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', p_fname);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'EGN', p_pid);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'SEX', SRV_CONTEXT.Integers_Format, p_gender);    -- sex
      SRV_CONTEXT.SETCONTEXTATTRDATE(l_in_context, 'BIRTH_DATE', SRV_CONTEXT.Date_Format, p_birth_date); -- date of birth

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INSERT_CLIENT_BO');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

       EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
        OR l_evres = MIGR_GVAR.GV_EVRES_WARNING

      THEN
        SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'MAN_ID', l_ManId);
        IF l_evres = MIGR_GVAR.GV_EVRES_WARNING
        THEN

          l_policyRec.logMsg := 'INSERT_CLIENT_BO returned with warning -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
        END IF;
        RETURN l_ManId;
      ELSE
        l_policyRec.logMsg := 'PIO_ERR INSERT_CLIENT_BO Failed to INSERT Client -RESULT: ' || L_RESULT;
        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
        RETURN NULL;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_ERROR(l_policyRec);
          RETURN NULL;
    END INSERT_CLIENT;
  ----------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------
  --FA.20160520 For insured objects: private accident insured person insert person in p_people.No need for client role if there is a travel isnurance
  FUNCTION INSERT_PEOPLE(p_gname      IN VARCHAR2,
                         p_sname      IN VARCHAR2,
                         p_fname      IN VARCHAR2,
                         p_pid        IN VARCHAR2,
                         p_gender     IN NUMBER,
                         p_birth_date IN DATE)

    RETURN P_PEOPLE.MAN_ID % TYPE
    IS
      l_ManId       P_PEOPLE.MAN_ID % TYPE;
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN
      l_policyRec.migrStep := 'Insert Client';
      l_policyRec.migrArea := 'MIGR_API_CLIENTS.INSERT_CLIENT';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';
      l_in_context := NULL;
      l_out_context := NULL;


      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GNAME', p_gname);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'FNAME', p_sname);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', p_fname);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'EGN', p_pid);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'SEX', SRV_CONTEXT.Integers_Format, p_gender);
      SRV_CONTEXT.SETCONTEXTATTRDATE(l_in_context, 'BIRTH_DATE', SRV_CONTEXT.Date_Format, p_birth_date);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_COMP', SRV_CONTEXT.INTEGERS_FORMAT, 1);    --1 person 2--Legal entity


      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PEOPLE');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'PROCEDURE_RESULT', L_RESULT);
      ------------------------------------------------------

      -- IF pio_err IS NULL
      --FA.20160421 Handle Event Response
      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
        OR l_evres = MIGR_GVAR.GV_EVRES_WARNING

      THEN
        SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'MAN_ID', l_ManId);
        IF l_evres = MIGR_GVAR.GV_EVRES_WARNING
        THEN

          l_policyRec.logMsg := 'INS_PEOPLE returned with warning -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
        END IF;
        RETURN l_ManId;
      ELSE
        l_policyRec.logMsg := 'PIO_ERR INS_PEOPLE Failed to INSERT People -RESULT: ' || L_RESULT;
        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
        RETURN NULL;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_ERROR(l_policyRec);
          RETURN NULL;
    END INSERT_PEOPLE;
  -------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE SETUP_CLIENT(p_migrationBatchId IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE)
    AS
      L_DEBUG           VARCHAR2(10);
      L_beginTimer      TIMESTAMP WITH TIME ZONE;
      L_beginStepTimer  TIMESTAMP WITH TIME ZONE;
      L_endTimer        TIMESTAMP WITH TIME ZONE;
      L_elapsed_ms      NUMBER;
      L_IN_CONTEXT      SRVCONTEXT;
      L_OUT_CONTEXT     SRVCONTEXT;
      PIO_ERR           SRVERR;
      L_ERRMSG          SRVERRMSG;
      L_SRVERRMSG       SRVERRMSG;
      L_TotRows         PLS_INTEGER;
      L_RowsSuccess     PLS_INTEGER;
      L_RowsSkipped     PLS_INTEGER;
      L_RowsErrors      PLS_INTEGER;
      L_RESULT          VARCHAR2(10);
      v_commitedRows    PLS_INTEGER;
      L_MAN_ID          P_PEOPLE.MAN_ID % TYPE;
      L_CLIENT_ID       P_CLIENTS.client_id % TYPE;

      CURSOR C_IA_CLIENT (vMigrationBatchId MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE) IS
          SELECT DISTINCT ic.IA_EGN,
                          ic.IA_COMPANY,
                          ic.IA_BIRTH_DATE,
                          mc.client_id,
                          mc.MAN_ID --ic.IA_IDPL  FA.2010216 Commented due to multiple inserts ,
            FROM IA_CLIENT ic
              LEFT JOIN MIGR_CLIENT mc
                ON ic.IA_EGN = mc.EGN
            WHERE 1 = 1
              AND ic.mig_batch_id = vMigrationBatchId
              AND ic.MIG_FLAG = 0
              AND ic.IA_COMPANY = 0
              AND NOT ic.IA_BIRTH_DATE IS NULL;

      ---FA. 20151116 New cursor to feed clean up process

      CURSOR C_IA_INSIS_CLIENT (vMigrationBatchId MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE) IS
          SELECT DISTINCT ic.IA_EGN,
                          ic.IA_COMPANY,
                          ic.IA_BIRTH_DATE,
                          mc.client_id,
                          mc.MAN_ID  --, ic.IA_IDPL
            FROM IA_CLIENT ic
              LEFT JOIN MIGR_CLIENT mc
                ON ic.IA_EGN = mc.EGN
            WHERE 1 = 1
              AND ic.mig_batch_id = vMigrationBatchId
              AND ic.MIG_FLAG = 0
              AND ic.IA_COMPANY = 0
              AND NOT ic.IA_BIRTH_DATE IS NULL
              AND mc.client_id IS NULL;

      r_IA_CLIENT       C_IA_CLIENT % ROWTYPE;
      r_IA_CLIENT_INSIS C_IA_INSIS_CLIENT % ROWTYPE;
      l_log_rec         MIGR_GVAR.LogRecTyp;
    BEGIN
      l_log_rec.mig_batch_id := p_migrationBatchId;
      l_log_rec.migrArea := 'MIGR_API_CLIENTS.SETUP_CLIENT';
      l_log_rec.migrStep := 'CLIENTS from POLICY records ';
      l_log_rec.logMsg := '  Client EGN';
      l_log_rec.migrRelTbl := 'IA_CLIENTS';


        MIGR_LOG.LOG_INFO(l_log_rec);


      v_commitedRows := 0;
      L_TotRows := 0;
      L_RowsSuccess := 0;
      L_RowsSkipped := 0;
      L_RowsErrors := 0;
      L_beginTimer := SYSTIMESTAMP;
      L_beginStepTimer := NULL;
      L_endTimer := NULL;
      v_commitedRows := 0;

      --  Client Creation
      OPEN C_IA_CLIENT (p_migrationBatchId);

    << Client_loop >>
      LOOP
        FETCH C_IA_CLIENT INTO r_IA_CLIENT;
        EXIT WHEN C_IA_CLIENT % NOTFOUND;



          L_beginStepTimer := SYSTIMESTAMP;
          L_CLIENT_ID := NULL;
          L_MAN_ID := NULL;
          L_TotRows := L_TotRows + 1;
          l_log_rec.migrRelKey := r_IA_CLIENT.IA_EGN;
          IF r_IA_CLIENT.client_id IS NULL
          THEN

            L_IN_CONTEXT := NULL;
            L_OUT_CONTEXT := NULL;
            PIO_ERR := NULL;
            SAVEPOINT skip_clients;

            MIGRATE_CLIENT(r_IA_CLIENT.IA_EGN, L_CLIENT_ID, L_MAN_ID, p_migrationBatchId); --, r_IA_CLIENT.IA_IDPL);

            IF (L_CLIENT_ID IS NOT NULL)
              AND (L_MAN_ID IS NOT NULL)
            THEN

              v_commitedRows := v_commitedRows + 1;
              L_RowsSuccess := L_RowsSuccess + 1;
              L_endTimer := SYSTIMESTAMP;

            ELSE

              ROLLBACK TO skip_clients;
              L_RowsErrors := L_RowsErrors + 1;

            END IF;

          ELSE
            -- client has been migrated
            L_RowsSkipped := L_RowsSkipped + 1;

            IF MIGR_GVAR.GV_DEBUG_WARNING
            THEN
              l_log_rec.logMsg := 'Client has been migrated previously with Client_ID = ' || r_IA_CLIENT.client_id || ' , Man_ID = ' || r_IA_CLIENT.MAN_ID;
              MIGR_LOG.LOG_WARNING(l_log_rec);
            END IF;

          END IF;       -- C_IA_CLIENT.CLIENT_ID IS NULL

          IF v_commitedRows = 1000
          THEN
            v_commitedRows := 0;
            COMMIT;
          END IF;

      END LOOP Client_loop;

      CLOSE C_IA_CLIENT;
      COMMIT;
      --FA. 20151116 Clean up process for those who returned with error to insert into migr_client customers who exist in INSIS.
      OPEN C_IA_INSIS_CLIENT (p_migrationBatchId);
      LOOP
        FETCH C_IA_INSIS_CLIENT INTO r_IA_CLIENT_INSIS;
        EXIT WHEN C_IA_INSIS_CLIENT % NOTFOUND;

        L_beginTimer := SYSTIMESTAMP();

        GET_CUSTOMER_FROM_INSIS(r_IA_CLIENT_INSIS.IA_EGN, L_CLIENT_ID, L_MAN_ID);

        IF (L_CLIENT_ID IS NOT NULL)
          AND (L_MAN_ID IS NOT NULL)
        THEN

          INSERT INTO MIGR_CLIENT (
            EGN, MAN_ID, client_id, INS_DATE, INS_MS, mig_start,mig_end,MIG_BATCH_ID,MIGRATED
          )
          VALUES (r_IA_CLIENT_INSIS.IA_EGN, L_MAN_ID, L_CLIENT_ID, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, L_beginTimer),L_beginTimer,SYSTIMESTAMP, p_migrationBatchId,'Y');

          IF MIGR_GVAR.GV_DEBUG_WARNING
          THEN
            l_log_rec.logMsg := 'Client has been found in INSIS with Client_ID = ' || L_CLIENT_ID || ' , Man_ID = ' || L_MAN_ID;
            MIGR_LOG.LOG_WARNING(l_log_rec);
          END IF;
        END IF;

      END LOOP;
      CLOSE C_IA_INSIS_CLIENT;
      COMMIT;

      L_endTimer := SYSTIMESTAMP;
      MIGR_SYSTEM.MIGR_LOG_VOLUME(p_migrationBatchId, l_log_rec.migrArea, l_log_rec.migrRelTbl, L_beginTimer, L_endTimer, 'Completed ', L_TotRows, L_RowsSuccess, L_RowsSkipped, L_RowsErrors);
    --FA 20151117 Turned into  AUTONOMOUS
    /* INSERT INTO MIGR_VOLUME_LOG( MIGRATION_BATCH_ID, MIGRATION_AREA, TABLE_NAME, LOG_START, LOG_END, DURATION, STATUS, TOTROWS, ROWSSUCCESS, ROWSSKIPPED, ROWSERRORS  )
           VALUES     ( L_MIGRATION_BATCH_ID , L_MIGRATION_AREA, L_RELATED_TABLE,  L_BeginTimer, L_EndTimer, MIGR_SYSTEM.fn_ELAPSEDms( L_EndTimer, L_beginTimer), 'Completed ', L_TotRows, L_RowsSuccess, L_RowsSkipped, L_RowsErrors );
   */

    EXCEPTION
      WHEN OTHERS THEN l_log_rec.logMsg := SQLERRM;
          MIGR_LOG.LOG_ERROR(l_log_rec);

    END SETUP_CLIENT;

  ----------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------

  PROCEDURE SETUP_CLIENT_ADDRESS(p_migrationBatchId MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE)
    AS
      L_Addr_cntr      PLS_INTEGER;
      L_DEBUG          VARCHAR2(10);
      L_beginTimer     TIMESTAMP WITH TIME ZONE;
      L_endTimer       TIMESTAMP WITH TIME ZONE;
      L_beginStepTimer TIMESTAMP WITH TIME ZONE;
      L_elapsed_ms     NUMBER;
      --    Log_Record      MIGRAPIDETAILLOG;
      L_IN_CONTEXT     SRVCONTEXT;
      L_OUT_CONTEXT    SRVCONTEXT;
      PIO_ERR          SRVERR;
      L_ERRMSG         SRVERRMSG;
      L_SRVERRMSG      SRVERRMSG;
      L_TotRows        PLS_INTEGER;
      L_RowsSuccess    PLS_INTEGER;
      L_RowsSkipped    PLS_INTEGER;
      L_RowsErrors     PLS_INTEGER;

      L_CLIENT_ID      P_CLIENTS.client_id % TYPE;
      L_MAN_ID         P_PEOPLE.MAN_ID % TYPE;
      L_OBJECT_ID      O_OBJECTS.object_id % TYPE;
      L_POLICY_ID      POLICY.policy_id % TYPE;
      L_ID_ADDRESS     IA_ADDRESS.IA_ID_ADDRESS % TYPE;
      L_ADDRESS_ID     P_ADDRESS.ADDRESS_ID % TYPE;
      L_INSR_TYPE      PLS_INTEGER;
      v_commitedRows   PLS_INTEGER;

      CURSOR C_IA_ADDRESS (vMigrationBatchId MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE) IS
          SELECT DISTINCT ia.IA_EGN,
                          mc.MAN_ID,
                          ia.IA_MADDRESS,
                          ma.ADDRESS_ID,
                          ia.IA_ID_ADDRESS,
                          ia.IA_ADDRESS_TYPE,
                          ia.IA_COUNTRY,
                          ia.IA_CITY,
                          ia.IA_ADDRESS,
                          ia.IA_POST_CODE,
                          ia.IA_NOTE,
                          ia.IA_STATE_NAME,
                          ia.IA_REGION_NAME,
                          ia.IA_QUARTER_NAME,
                          ia.IA_VALID_FROM,
                          ia.IA_VALID_TO,
                          ia.IA_PRIMARY_FLAG,
                          ia.MIG_FLAG,
                          ia.mig_batch_id,
                          ia.MIG_TIMESTAMP,
                          ia.MIG_MUTUAL_ID
            FROM IA_ADDRESS ia
              LEFT JOIN MIGR_ADDRESS ma
                ON ia.IA_MADDRESS = ma.IA_MADDRESS
                LEFT JOIN MIGR_CLIENT mc
                  ON mc.EGN = ia.IA_EGN
            WHERE 1 = 1
              AND ia.mig_batch_id = p_migrationBatchId
              AND ia.MIG_FLAG = 0
            ORDER BY ia.IA_EGN,
                     ia.IA_ID_ADDRESS ASC;
      r_IA_ADDRESS     C_IA_ADDRESS % ROWTYPE;

      l_log_rec        MIGR_GVAR.LogRecTyp;
    BEGIN

      v_commitedRows := 0;
      ---- Open Policy and Client Cursor for ADDRESS Creation
      l_log_rec.mig_batch_id := p_migrationBatchId;
      l_log_rec.migrArea := 'MIGR_API_CLIENTS.SETUP_CLIENT_ADDRESS';
      l_log_rec.migrStep := 'CLIENT ADDRESS ';
      l_log_rec.logMsg := '  Client EGN';
      l_log_rec.migrRelTbl := 'IA_ADDRESS';

        MIGR_LOG.LOG_INFO(l_log_rec);

      L_TotRows := 0;
      L_RowsSuccess := 0;
      L_RowsSkipped := 0;
      L_RowsErrors := 0;
      L_beginTimer := SYSTIMESTAMP;
      L_endTimer := NULL;
      L_beginStepTimer := NULL;

      OPEN C_IA_ADDRESS (p_migrationBatchId);

    << Client_Addr_loop >>
      LOOP

        FETCH C_IA_ADDRESS INTO r_IA_ADDRESS;
        EXIT WHEN C_IA_ADDRESS % NOTFOUND;

          L_beginStepTimer := SYSTIMESTAMP;
          L_TotRows := L_TotRows + 1;
          l_log_rec.migrRelKey := r_IA_ADDRESS.IA_EGN;

          l_log_rec.logMsg := '  Client EGN = ' || r_IA_ADDRESS.IA_EGN || ' Address No =' || r_IA_ADDRESS.IA_MADDRESS;

            MIGR_LOG.LOG_INFO(l_log_rec);

          IF r_IA_ADDRESS.MAN_ID IS NOT NULL
          THEN

            IF r_IA_ADDRESS.ADDRESS_ID IS NULL      -- new address
            THEN
              --fire event
              SAVEPOINT skip_address;
              MIGRATE_CLIENT_ADDRESS(r_IA_ADDRESS.IA_EGN, r_IA_ADDRESS.MAN_ID, r_IA_ADDRESS.IA_MADDRESS, L_ADDRESS_ID, p_migrationBatchId);
              --check event result
              IF L_ADDRESS_ID IS NOT NULL
              THEN

                L_RowsSuccess := L_RowsSuccess + 1;
                L_endTimer := SYSTIMESTAMP;
                v_commitedRows := v_commitedRows + 1;
              --FA. 20151113 Added from migrate_client_addresses to log step duration
              -- INSERT INTO MIGR_ADDRESS (EGN, MAN_ID, IA_MADDRESS, ADDRESS_ID, INS_DATE, INS_MS, MIG_BATCH_ID)
              --VALUES (r_IA_ADDRESS.IA_EGN, L_MAN_ID, r_IA_ADDRESS.IA_MADDRESS, L_ADDRESS_ID, SYSDATE, MIGR_SYSTEM.fn_ELAPSEDms(L_endTimer, L_beginStepTimer), L_MIGRATION_BATCH_ID);

              ELSE
                L_RowsErrors := L_RowsErrors + 1;
                ROLLBACK TO skip_address;
              END IF;

            ELSE                                  -- address has been migrated

              L_RowsSkipped := L_RowsSkipped + 1;
              l_log_rec.logMsg := 'Address has been migrated previously with ADDRESS_ID = ' || r_IA_ADDRESS.ADDRESS_ID;

                MIGR_LOG.LOG_WARNING(l_log_rec);

            END IF;       --  r_IA_ADDRESS.ADDRESS_ID IS NULL

          ELSE
            L_RowsSkipped := L_RowsSkipped + 1;
            l_log_rec.logMsg := ' Client has not been migrated yet. ';

              MIGR_LOG.LOG_WARNING(l_log_rec);

          END IF;
          IF v_commitedRows = 1000
          THEN
            v_commitedRows := 0;
            COMMIT;
          END IF;

      END LOOP Client_Addr_loop;

      CLOSE C_IA_ADDRESS;
      COMMIT;
      L_endTimer := SYSTIMESTAMP;

      MIGR_SYSTEM.MIGR_LOG_VOLUME(p_migrationBatchId, l_log_rec.migrArea, l_log_rec.migrRelTbl, L_beginTimer, L_endTimer, 'Completed ', L_TotRows, L_RowsSuccess, L_RowsSkipped, L_RowsErrors);
    /*INSERT INTO MIGR_VOLUME_LOG
              ( MIGRATION_BATCH_ID, MIGRATION_AREA, TABLE_NAME, LOG_START, LOG_END, DURATION, STATUS, TOTROWS, ROWSSUCCESS, ROWSSKIPPED, ROWSERRORS )
      VALUES (L_MIGRATION_BATCH_ID, L_MIGRATION_AREA, L_RELATED_TABLE, L_BeginTimer, L_EndTimer, MIGR_SYSTEM.fn_ELAPSEDms(L_EndTimer, L_beginTimer), 'Completed ', L_TotRows, L_RowsSuccess, L_RowsSkipped, L_RowsErrors);

    COMMIT;*/
    ---- end of Address
    EXCEPTION
      WHEN OTHERS THEN l_log_rec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_log_rec);
    END SETUP_CLIENT_ADDRESS;

-----------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------


END MIGR_API_CLIENTS;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_COMMON
  AS
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 --Updates IA_POLICY mig flag
 --is called whenever an action alters the migration state of a policy in the flow
 PROCEDURE UPDATE_IA_POLICY_MIG_FLAG(p_idpl IN NUMBER, p_status IN NUMBER, p_migrBatchId IN VARCHAR2)
    IS
       l_MigrationArea  VARCHAR2(200);
       l_MigrationStep  VARCHAR2(200);
       l_RelatedTable   VARCHAR2(200);

    BEGIN
       l_MigrationArea := 'MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG';
       l_MigrationStep := 'Update Policy Flag';
       l_RelatedTable  := 'IA_POLICY';

       UPDATE IA_POLICY ip  SET ip.MIG_FLAG = p_status WHERE ip.IA_IDPL = p_idpl AND ip.MIG_BATCH_ID =p_migrBatchId;

       MIGR_LOG.LOG_INFO(p_migrBatchId,  l_MigrationArea, l_MigrationStep, 'Policy status was changed to: ' || p_status, l_RelatedTable, p_idpl);

   EXCEPTION
      WHEN OTHERS THEN
         MIGR_LOG.LOG_EXCEPTION(p_migrBatchId,  l_MigrationArea , l_MigrationStep, 'Error occured when changing policy status: ' || SQLERRM, l_RelatedTable, p_idpl);
         SUSPEND_MIGRATION('Error occured when changing policy status: ' || SQLERRM, MIGR_GVAR.GV_MSG_CODE_MIGR_MIG_FLAG_ERR);

    END UPDATE_IA_POLICY_MIG_FLAG;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- For each product there is a row in ETL_IA_INSRPRD_CONFIG table that holds hst, ia and migr tables info to be used by the API procedures
--Dynamic API sql will retrieve the corresponding info according to policy insured product table configuration
  FUNCTION GET_IA_CONFIGURATION(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS
      l_policyRec MIGR_GVAR.PolicyRecTyp;
    BEGIN
      l_policyRec := p_policyRec;

      SELECT IA_COVER_TBL,
             IA_DEDUCTIBLES_TBL,
             IA_QUESTIONS_TBL,
             IA_COVER_VALUES_TBL,
             MIGR_TBL,
             IA_POLICY_TBL,
             IA_ENDORSEMENTS_TBL,
             IA_PARTICIPANTS_TBL ,
             REQUIRE_PROPERTY ,
             REQUIRE_DOCUMENTS ,
             PRODUCT_GROUP,
             REQUIRE_PINSURED_ROLE,
             IA_GEN_DISCOUNTS_TBL,
             REQUIRE_QUEST,
             set_doc_values,         -- EZ 6/11/2018
             SET_SPECIAL_OBJ_VALUES  -- EZ 13/03/2019
        INTO l_policyRec.ia_coversTbl,
             l_policyRec.ia_deductiblesTbl,
             l_policyRec.ia_questionsTbl,
             l_policyRec.ia_coversInsValTbl,
             l_policyRec.migrTbl,
             l_policyRec.ia_policyTbl,
             l_policyRec.ia_endorsementsTbl,
             l_policyRec.ia_participantsTbl ,
             l_policyRec.require_property,
             l_policyRec.require_documents,
             l_policyRec.product_group,
             l_policyRec.require_pinsured,
             l_policyRec.ia_discountsTbl,
             l_policyRec.require_quest,
             l_policyRec.set_doc_values,         -- EZ 6/11/2018
             l_policyRec.set_special_obj_values  -- EZ 12/03/2019

        FROM ETL_IA_INSRPRD_CONFIG
        -- pl 20161027 new insr_type -> offering code. we need the parent_insr_type
        WHERE INSR_TYPE = l_policyRec.PARENT_INSR_TYPE;

      RETURN l_policyRec;

    EXCEPTION
        WHEN OTHERS THEN l_policyRec.logMsg := 'Could not get IA configuration tables for :' || l_policyRec.PARENT_INSR_TYPE;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN l_policyRec;

    END GET_IA_CONFIGURATION;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 --Each Home prodict policy should have a property id registered in order to continue
    PROCEDURE REGISTER_PROPERTY_ID(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      L_ERRMSG      SRVERRMSG;
      L_SRVERRMSG   SRVERRMSG;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      vCounter      NUMBER;
      vADDRESS      VARCHAR2(50 BYTE);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN

      p_policyRec.migrStep := 'Register Policy Mandatory Property';
      p_policyRec.migrArea := 'MIGR_API_COMMON.REGISTER_PROPERTY';
      p_policyRec.migrRelTbl := 'INSIS_EVENT';

      -- PRIMARY PROPERTY COUNTER
      SELECT COUNT(DISTINCT v.IA_IDPL || v.IA_PROPERTY_KEY)
        INTO vCounter
        FROM IA_POLICY_PROPERTY v
        WHERE 1 = 1
          AND v.IA_IDPL = p_policyRec.policy_idpl;-- AND  v.IA_PROPERTY_KEY IS NOT NULL; FA. 20160630 Commented because null fnr is acceptable from Client

      IF vCounter = 1  THEN

          FOR cREC IN (SELECT pv.*  FROM IA_POLICY_PROPERTY pv
              WHERE pv.IA_IDPL = p_policyRec.policy_idpl)-- AND pv.IA_PROPERTY_KEY IS NOT NULL  )       FA. 20160630 Commented because null fnr is acceptable from Client
          LOOP

                L_IN_CONTEXT := NULL;
                L_OUT_CONTEXT := NULL;

                vADDRESS := cREC.IA_ADDRESS;
                 IF cREC.IA_ADDRESS IS NULL  THEN
                    vADDRESS := cREC.IA_PROPERTY_NAME;
                 END IF;

                SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyRec.policy_id);
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, 0);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PROPERTY_KEY', cREC.IA_PROPERTY_KEY);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PROPERTY_NAME', cREC.IA_PROPERTY_NAME);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'MANUAL', 'TRUE');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'COUNTY', cREC.IA_COUNTY);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'MUNICIPALITY', cREC.IA_MUNICIPALITY);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PARISH', cREC.IA_PARISH);
                SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'ENROLLMENT_DATE', SRV_CONTEXT.Date_Format, NULL);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'COORDINATES', cREC.IA_COORDINATES);
                SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'MODIFICATION_DATE', SRV_CONTEXT.Date_Format, SYSDATE);
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'MAIN_INSURANCE', SRV_CONTEXT.Integers_Format, 1);
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'PROPERTY_ADDRESS_ID', SRV_CONTEXT.Integers_Format, NULL);
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'TYPE_CODE', SRV_CONTEXT.Integers_Format, NULL);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'TYPE_CODE_TEXT', NULL);
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANON_FLG', SRV_CONTEXT.Integers_Format, NULL);

                -- INSERT INTO P_PROPERTY_ADDRESS
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'PROPERTY_ID', SRV_CONTEXT.Integers_Format, NULL);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'COUNTRY', cREC.IA_COUNTRY);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'TOWN', cREC.IA_TOWN);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'CITY', cREC.IA_TOWN);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'POST_CODE', cREC.IA_POST_CODE);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ADDRESS', vADDRESS);

                v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INSERT_PROPERTY_DATA');

                v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

                SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);
                SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'PROPERTY_ID', p_policyRec.property_id);

                --FA.20160302 Event does not return property id -- Please fix event - For test just select from cust tables!!!!!!!!!!!!!!!!!!!!!!!!!!!
                IF p_policyRec.property_id IS NULL  THEN
                  BEGIN
                      SELECT property_id
                        INTO p_policyRec.property_id
                        FROM INSIS_CUST.P_PROPERTY
                        WHERE policy_id = p_policyRec.policy_id;

                      --  p_policyRec.logMsg := 'Property was added succesfully l_policyRec.property_id: ' || p_policyRec.property_id;
                      --  MIGR_LOG.LOG_INFO(p_policyRec);

                  EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                         p_policyRec.logMsg := 'INSERT_PROPERTY_DATA event failed to add Property ';
                        MIGR_LOG.LOG_ERROR(p_policyRec);
                        p_policyRec.continue_migr:=FALSE;

                    END;
                END IF;

                l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

                IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS   THEN
                    p_policyRec.logMsg := 'Property was added succesfully l_policyRec.property_id: ' || p_policyRec.property_id || '-RESULT:' || L_RESULT;
                    MIGR_LOG.LOG_INFO(p_policyRec);

                ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                    p_policyRec.logMsg := 'INSERT_PROPERTY_DATA returned with warning -RESULT:' || L_RESULT;
                    MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);

                ELSE
                    p_policyRec.logMsg := 'PIO_ERR INSERT_PROPERTY_DATA Failed to add property -RESULT: ' || L_RESULT;
                    MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, PIO_ERR);
                    p_policyRec.continue_migr:=FALSE;
                END IF;
          END LOOP;

      ELSIF vCounter > 1  THEN
          p_policyRec.logMsg := 'Error: More than one valid property key found.';
          MIGR_LOG.LOG_ERROR(p_policyRec);
           p_policyRec.continue_migr:=FALSE;

      ELSIF vCounter = 0   THEN
          p_policyRec.logMsg := 'Error: Valid property key NOT found.';
          MIGR_LOG.LOG_ERROR(p_policyRec);
          p_policyRec.continue_migr:=FALSE;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_ERROR(p_policyRec);
          p_policyRec.continue_migr:=FALSE;
    END REGISTER_PROPERTY_ID;

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA.20160404 Returns mandatory documents in ref_cursor variable for a specific insured object id
  FUNCTION GET_MANDATORY_DOCS(p_policyRec IN MIGR_GVAR.PolicyRecTyp, p_doc_level IN VARCHAR2)
    RETURN SYS_REFCURSOR
    IS
      ret_        SYS_REFCURSOR;
      l_policyRec MIGR_GVAR.PolicyRecTyp;
      v_doc_id    NVARCHAR2(255);
      VSQL        VARCHAR2(2000);
      v_count     NUMBER;
    BEGIN
      l_policyRec := p_policyRec;

     IF  p_doc_level ='POLICY' THEN

     ---SELECT COUNT('X')  INTO v_count  FROM HST_MAND_DOCUMENTS  WHERE INSIS_PRODUCT = l_policyRec.PARENT_INSR_TYPE  AND object_type <> 'ALL'    AND ACTIVE = 'Y';
    ---   IF v_count = 0 THEN

          VSQL := ' SELECT DOC_ID    FROM HST_MAND_DOCUMENTS ' ||
            ' WHERE INSIS_PRODUCT = ''' || l_policyRec.PARENT_INSR_TYPE || '''   AND  object_type = ''ALL''   AND ACTIVE = ''Y''  AND  MUTUAL_ID = '
            || chr(39)||SUBSTR(l_policyRec.MIG_BATCH_ID, 1, 2)||chr(39)
--            || ' AND SET_DOC_VALUES = ''N'''       -- EZ 06/11/18 -- for non-mandatory doc values
          ;

     ELSE
          IF l_policyRec.ia_coversInsValTbl IS NOT NULL THEN

             VSQL := ' SELECT DOC_ID FROM HST_MAND_DOCUMENTS hst'
            || '   JOIN ' || l_policyRec.ia_coversInsValTbl || ' a ON hst.COVER_ID = a.ia_cover'
            || '    WHERE hst.INSIS_PRODUCT = ''' || p_policyRec.PARENT_INSR_TYPE || ''''
            || '     AND hst.object_type = ''' || p_policyRec.object_type || ''''
            || '     AND (NVL(a.IA_INSURED_VALUE,0) >= hst.INS_VALUE AND a.MIG_MUTUAL_ID = hst.MUTUAL_ID)'
            || '     AND hst.ACTIVE = ''Y''  AND hst.MUTUAL_ID =  ' ||  chr(39)|| SUBSTR(l_policyRec.MIG_BATCH_ID, 1, 2)||chr(39)
            ||' and a.ia_object_id ='''||l_policyRec.ia_object_id||'''' --- EZ 2019-03-22
--            || ' AND SET_DOC_VALUES = ''N'''       -- EZ 06/11/18 -- for non-mandatory doc values
            ;
      /*    || ' union all
                SELECT DOC_ID FROM HST_MAND_DOCUMENTS hst' ||
                ' WHERE hst.INSIS_PRODUCT = ''' || p_policyRec.PARENT_INSR_TYPE || '''
                  AND  object_type = ''ALL''  AND ACTIVE = ''Y'' ';*/
          ELSE

            VSQL := ' SELECT DOC_ID  FROM HST_MAND_DOCUMENTS ' ||
             ' WHERE INSIS_PRODUCT = ''' || l_policyRec.PARENT_INSR_TYPE || '''   AND  object_type = ''ALL''   AND ACTIVE = ''Y''  AND MUTUAL_ID = ''ALL'' '
--             || ' AND SET_DOC_VALUES = ''N'''       -- EZ 06/11/18 -- for non-mandatory doc values
            ;

          END IF;
     END IF;

     OPEN ret_ FOR VSQL;

     RETURN ret_;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN NULL;
    END GET_MANDATORY_DOCS;
 -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --!!!!!!!!!!!!!!!!!!!! GRANT update on INSIS_sys_V10.doc_documents to
  ---Load policy required documents
  FUNCTION LOAD_POLICY_DOCUMENTS(p_policyRec IN MIGR_GVAR.PolicyRecTyp, p_doc_level IN VARCHAR2)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS

      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      L_ERRMSG      SRVERRMSG;
      L_SRVERRMSG   SRVERRMSG;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_mand_docs   SYS_REFCURSOR;
      l_doc_id      VARCHAR2(50);
      l_doc_id2      VARCHAR2(50); -- MB 2018-11-27 inner loop correction
   ---   l_has_loaded  BOOLEAN;
      l_evres       PLS_INTEGER;
      v_count       NUMBER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

          --- +++ EZ 2018-11-12 doc set values
      v_idpl        NUMBER(20,0);
      v_Doc_State   varchar2(100);
      v_Rcv_Date    Date;
      rDoc_id       SYS_REFCURSOR;
      v_Date_clause Varchar2(1000);
      vsql          varchar2(4000);
      --- +++ end EZ 2018-11-12 doc set values
      v_Doc_Date    Date; --- +++ EZ 2019-12-3 set-values for SPECIAL_OBJ docs

    BEGIN
      l_policyRec := p_policyRec;
    --  l_has_loaded := FALSE;
--      l_policyRec := p_policyRec;

      l_policyRec.migrStep := 'Load Policy Mandatory Documents';
      l_policyRec.migrArea := 'MIGR_API_COMMON.LOAD_POLICY_DOCUMENTS';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';


      ---- FA.20160712 Check if product has mandatory documens
      SELECT COUNT('X')
        INTO v_count
        FROM HST_MAND_DOCUMENTS
        -- pl 20161027 new insr_type -> offering code. we need the parent_insr_type
        -- WHERE INSIS_PRODUCT = l_policyRec.INSR_TYPE
        WHERE INSIS_PRODUCT = l_policyRec.PARENT_INSR_TYPE
          AND ACTIVE = 'Y'
          --AND SET_DOC_VALUES ='N'     -- EZ 06/11/18 -- for non-mandatory doc values
      ;


      IF v_count > 0  THEN
        --FA.20160404 Check if object has mandatory docs
        l_mand_docs := GET_MANDATORY_DOCS(l_policyRec,p_doc_level);

        LOOP <<MandDocs>>
          FETCH l_mand_docs INTO l_doc_id;

          EXIT WHEN l_mand_docs % NOTFOUND;
          --Call load doc event only once for each insured object
        --  IF NOT l_has_loaded    THEN

            SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'REFERENCE_TYPE', 'POLICY');
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);

            IF p_doc_level =  'POLICY' THEN
                 SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_ID',SRV_CONTEXT.Integers_Format, NULL);
            ELSE
                 SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_ID', SRV_CONTEXT.Integers_Format, l_policyRec.insured_object_id);
            END IF;

            SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'TO_LOAD', 'Y');

            v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('DOC_LOAD_DOCUMENTS');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

            IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS THEN
                l_policyRec.logMsg := 'Documents were loaded succesfully ' || '-RESULT:' || L_RESULT;
                MIGR_LOG.LOG_INFO(l_policyRec);
                ---l_has_loaded := TRUE;

            ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                l_policyRec.logMsg := 'DOC_LOAD_DOCUMENTS returned with warning -RESULT:' || L_RESULT;
                MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
           ---     l_has_loaded := TRUE;

            ELSE
                l_policyRec.logMsg := 'PIO_ERR DOC_LOAD_DOCUMENTS Failed to load Documents-RESULT: ' || L_RESULT;
                MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
                l_policyRec.continue_migr:=FALSE;
                l_policyRec.object_fail_log := l_policyRec.object_fail_log || '-Failed to load Documents';

            END IF;
       ---   END IF;

          IF l_evres != MIGR_GVAR.GV_EVRES_ERROR  THEN
            --Set all object's mandatory documents to status received
              IF p_doc_level =  'POLICY' THEN
                  UPDATE INSIS_SYS_V10.DOC_DOCUMENTS  SET DOC_STATE = 2
                    WHERE policy_id = l_policyRec.policy_id  AND DOC_ID = l_doc_id AND INSURED_ID IS null;
              ELSE  -- 'OBJECT LEVEL'
                  UPDATE INSIS_SYS_V10.DOC_DOCUMENTS  SET DOC_STATE = 2
                    WHERE policy_id = l_policyRec.policy_id  AND DOC_ID = l_doc_id AND INSURED_ID = l_policyRec.insured_object_id;

                      l_policyRec.logMsg := 'Set all objects mandatory documents';   --++EZ 21/03/19
                      MIGR_LOG.LOG_INFO(l_policyRec);

-- +++ EZ 2018-11-12 set-values for docs
                  IF l_policyRec.set_doc_values = 'Y' THEN
                      l_policyRec.logMsg := 'Merge update Doc Values';
                      MIGR_LOG.LOG_INFO(l_policyRec);

                      -- get Doc_State and Rcv_date from IA_xxx_POLICY table
                      vsql := 'SELECT ia_idpl , ia_Doc_state, ia_rcv_date from '
                              || l_policyRec.ia_policyTbl
                              || ' where ia_idpl ='|| l_policyRec.policy_idpl
                              ;
                      EXECUTE immediate vsql into v_idpl, v_Doc_State, v_Rcv_Date ;

 -- MB 2018/11/27 inner loop correction
--                      -- get Doc_ID's for Insr.Product that need to set their values
--                      vsql := 'SELECT distinct doc_id FROM HST_MAND_DOCUMENTS hmd WHERE hmd.INSIS_PRODUCT = '||CHR(39)|| l_policyRec.parent_insr_type ||CHR(39)
--                              || ' AND hmd.ACTIVE=''Y'' AND hmd.SET_DOC_VALUES = ''Y''';
--        --              l_policyRec.logMsg := VSql;
--        --              MIGR_LOG.LOG_INFO(l_policyRec);
--                      OPEN rDoc_id FOR VSQL;
--                      LOOP <<SetVal_Docs>>
--                          FETCH rDoc_id INTO l_doc_id;
--                          EXIT WHEN rDoc_id% NOTFOUND;

                         -- get Doc_ID's for Insr.Product that need to set their values
                      vsql := 'SELECT distinct doc_id FROM HST_MAND_DOCUMENTS hmd WHERE hmd.INSIS_PRODUCT = '||CHR(39)|| l_policyRec.parent_insr_type ||CHR(39)
                              || ' AND hmd.ACTIVE=''Y'' AND hmd.doc_id = '||CHR(39) || l_doc_id  || CHR(39) || ' AND hmd.SET_DOC_VALUES = ''Y''';
                      l_policyRec.logMsg := VSql;
                      MIGR_LOG.LOG_INFO(l_policyRec);
                      OPEN rDoc_id FOR VSQL;
                      LOOP <<SetVal_Docs>>
                          FETCH rDoc_id INTO l_doc_id2;
                          EXIT WHEN rDoc_id% NOTFOUND;

                          v_Date_clause  :='TO_DATE('|| CHR(39)|| v_Rcv_Date || CHR(39)|| ',''YYYY-MM-DD'')';
                          IF v_Rcv_Date IS NULL THEN
                            v_Date_clause  := 'NULL';
                          END IF;
                          vsql:= 'update INSIS_SYS_V10.DOC_DOCUMENTS dd  '
        --                         ||'set dd.DOC_STATE = '|| v_Doc_State ||', dd.receive_date = TO_DATE('|| CHR(39)|| v_Rcv_Date || CHR(39)|| ',''YYYY-MM-DD'')'
                                 ||'set dd.DOC_STATE = '|| v_Doc_State ||', dd.receive_date = '|| v_Date_clause
                                 ||' WHERE 1=1  AND dd.POLICY_ID = ' || l_policyRec.policy_id
                                 ||' and dd.doc_id = '||CHR(39)|| l_doc_id ||CHR(39)
                                 ;

                           l_policyRec.logMsg := VSql;
                           MIGR_LOG.LOG_INFO(l_policyRec);
                          EXECUTE IMMEDIATE vsql;

                      END LOOP SetVal_Docs;
                      CLOSE rDoc_id;

                     l_policyRec.logMsg := 'Document Values were set at OBJECT level';
                     MIGR_LOG.LOG_INFO(l_policyRec);

                  END IF;
-- +++ EZ end 2018-11-12 set-values for docs

              END IF;
          END IF;
        END LOOP MandDocs;

------ +++ EZ------20/3/19 set-values for SPECIAL_OBJ docs
-- get Doc_state, Doc_Date date from IA_OBJ_TABLE
                   FOR c IN (
                             SELECT DISTINCT epo.IA_OBJ_TABLE
                                FROM ETL_PRODUCT_OBJECTS epo, HST_MAND_DOCUMENTS hmd
                               WHERE 1=1
                               AND epo.IS_ACTIVE = 'Y'
                               AND epo.HAS_SPECIFIED = 'Y'
                               AND epo.PRODUCT_CODE = l_policyRec.parent_insr_type
                               AND epo.OBJECT_TYPE = l_policyRec.object_type
                               AND hmd.MUTUAL_ID = SUBSTR(l_policyRec.MIG_BATCH_ID, 1, 2)
                               AND hmd.SET_SPECIAL_OBJ_VALUES = 'Y'
                              )

                    LOOP
                      v_idpl := NULL;
                      v_Doc_State := NULL;
                      v_Doc_Date := NULL;

                        l_policyRec.logMsg := 'Merge update special_obj Doc Values';
                        MIGR_LOG.LOG_INFO(l_policyRec);

                                vsql:= 'SELECT iaq.ia_idpl, iaq.ia_Doc_state, iaq.ia_Doc_Date FROM '||c.IA_OBJ_TABLE
                                    || ' iaq where iaq.ia_idpl ='|| l_policyRec.policy_idpl|| ' and iaq.ia_object_id ='''||l_policyRec.ia_object_id||'''' ;

                               EXECUTE immediate vsql into v_idpl, v_Doc_State, v_Doc_Date ;
                            l_policyRec.logMsg := VSql;
                            MIGR_LOG.LOG_INFO(l_policyRec);

                               -- get Doc_ID's for Insr.Product that need to set their values
                            vsql := 'SELECT DISTINCT doc_id FROM HST_MAND_DOCUMENTS hmd WHERE hmd.INSIS_PRODUCT = '||CHR(39)|| l_policyRec.parent_insr_type ||CHR(39)
                                    ||' AND hmd.ACTIVE=''Y'' AND hmd.doc_id = '||CHR(39) || l_doc_id  || CHR(39)
                                    ||' AND hmd.MUTUAL_ID =  ' ||  chr(39)|| SUBSTR(l_policyRec.MIG_BATCH_ID, 1, 2)||chr(39)
                                    ||' AND hmd.SET_SPECIAL_OBJ_VALUES = ''Y'''
                                    ;
                            l_policyRec.logMsg := VSql;
                            MIGR_LOG.LOG_INFO(l_policyRec);
                            OPEN rDoc_id FOR VSQL;
                           -- LOOP <<SetVal_Docs>>
                                FETCH rDoc_id INTO l_doc_id2;
                                EXIT WHEN rDoc_id% NOTFOUND;

                                v_Date_clause  :='TO_DATE('|| CHR(39)|| v_Doc_Date || CHR(39)|| ',''YYYY-MM-DD'')';
                                IF v_Doc_Date IS NULL THEN
                                  v_Date_clause  := 'NULL';
                                END IF;
                                vsql:= 'update INSIS_SYS_V10.DOC_DOCUMENTS dd  '
                                       ||'set dd.DOC_STATE = '|| v_Doc_State
                                       ||', dd.DOC_DATE = '|| v_Date_clause
                                       ||' WHERE 1=1  AND dd.POLICY_ID = ' || l_policyRec.policy_id
                                       ||' and dd.doc_id = '||CHR(39)|| l_doc_id ||CHR(39)
                                       ||' and dd.insured_id = '||l_policyRec.insured_object_id
                                       ;

                                 l_policyRec.logMsg := VSql;
                                 MIGR_LOG.LOG_INFO(l_policyRec);
                                EXECUTE IMMEDIATE vsql;

                           -- END LOOP SetVal_Docs;
                            CLOSE rDoc_id;

                            l_policyRec.logMsg := 'Document Values were set at OBJECT level';
                            MIGR_LOG.LOG_INFO(l_policyRec);
                    END LOOP;
------ +++ EZ end 20/3/19  set-values for SPECIAL_OBJ docs

        CLOSE l_mand_docs;

      ELSE
        l_policyRec.logMsg := 'No mandatory Documents are configured ';
        MIGR_LOG.LOG_INFO(l_policyRec);
      END IF;  --check if object has mandatory docs

     RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN IF l_mand_docs % ISOPEN
          THEN
            CLOSE l_mand_docs;
          END IF;
          l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_ERROR(l_policyRec);
          l_policyRec.continue_migr:=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || '-Failed to load Documents exception';
          RETURN l_policyRec;
    END LOAD_POLICY_DOCUMENTS;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Insert object as policy insured object. There are two options either by insis event or by member function
  FUNCTION INSERT_INSURED_OBJ(p_policyRec MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS

      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      L_RESULT      VARCHAR2(50);
      pio_err       SRVERR;
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
      R_INSURED        insis_gen_v10.P_INSOBJ_TYPE;
      L_POLICY_TYPE    INSIS_GEN_V10.P_POLICY_TYPE;
    BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Insert Policy Insured Object';
      l_policyRec.migrArea := 'MIGR_API_COMMON.INSERT_INSURED_OBJ';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

    ---Removed object alternative  due to custom functionality added to event   IF  MIGR_GVAR.GV_MIGRATION_METHOD='EVENT' THEN

          L_IN_CONTEXT := NULL;
          L_OUT_CONTEXT := NULL;
          pio_err := NULL;
          L_RESULT := NULL;

          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.INSR_TYPE);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'OBJECT_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.object_type);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, l_policyRec.object_id);
        ---  SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'IOP3', l_policyRec.objDeduct_val);

          v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INSERT_INSURED_OBJECT');

          v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

          EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT pio_err;

          SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

          SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'INSURED_OBJ_ID', l_policyRec.insured_object_id);

          l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, L_RESULT);

          IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS   THEN
                l_policyRec.logMsg := 'Insert Insured Object for object_id: ' || l_policyRec.object_id || '-RESULT:' || L_RESULT;
                MIGR_LOG.LOG_INFO(l_policyRec);

          ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                l_policyRec.logMsg := 'Insert Insured Object returned with warning -RESULT:' || L_RESULT;
                MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);

          ELSE
                l_policyRec.logMsg := 'Failed to Insert Insured Object-RESULT ' || L_RESULT;
                MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                l_policyRec.continue_migr := FALSE;
          END IF;

          IF l_policyRec.continue_migr   THEN
                   UPDATE INSIS_GEN_V10.INSURED_OBJECT io SET io.IOP3 =  l_policyRec.objDeduct_val WHERE io.INSURED_OBJ_ID = l_policyRec.insured_object_id;
           END IF;
     /*
    ELSE
          L_POLICY_TYPE := INSIS_GEN_V10.POL_TYPES.GET_POLICY( l_policyRec.policy_id );
          R_INSURED := NEW insis_gen_v10.P_INSOBJ_TYPE;
          R_INSURED.INSURED_OBJ_ID:=NULL;
          R_INSURED.POLICY_ID     :=  l_policyRec.policy_id;
          R_INSURED.ANNEX_ID      := MIGR_GVAR.GV_ANNEX_ID;
          R_INSURED.INSR_TYPE     := L_POLICY_TYPE.INSR_TYPE;
          R_INSURED.OBJECT_ID     :=  l_policyRec.object_id;
          R_INSURED.OBJECT_TYPE   :=  l_policyRec.object_type;
          R_INSURED.OBJECT_STATE  := 0;
          R_INSURED.OBJECT_NUM    := 1;
          R_INSURED.OBJECT_ALIVE  := R_INSURED.OBJECT_NUM;
          R_INSURED.IV_TYPE       := insis_gen_v10.GVAR_PAS.IVTYPEIV;
          R_INSURED.IV_CURRENCY   := insis_gen_v10.CURRENCY.LOCAL_CURRENCY;
          R_INSURED.IV_CURRENCY_RATE :=  insis_gen_v10.CURRENCY.RATE( R_INSURED.IV_CURRENCY,L_POLICY_TYPE.DATE_GIVEN);
          R_INSURED.INSR_BEGIN    :=  L_POLICY_TYPE.INSR_BEGIN;
          R_INSURED.INSR_END      :=  L_POLICY_TYPE.INSR_END;
          R_INSURED.DURATION      := L_POLICY_TYPE.INSR_DURATION;
          R_INSURED.DUR_DIMENSION := L_POLICY_TYPE.DUR_DIMENSION;
          R_INSURED.REGISTRATION_DATE := SYSDATE;
          R_INSURED.CHANGE_DATE := SYSDATE;
          R_INSURED.USERNAME :=insis_gen_v10.INSIS_CONTEXT.GET_USER;
          R_INSURED.IOP3:=   l_policyRec.objDeduct_val    ;

           IF NOT R_INSURED.INSERTINSOBJ( PIO_ERR )  THEN
               MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
           END IF;

      END IF;         */

      RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr := FALSE;
          RETURN l_policyRec;
    END INSERT_INSURED_OBJ;
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  /*
   PROCEDURE SET_DEFAULT_AGENT_ID_EVENT(P_agent_no IN VARCHAR2)
    IS
      L_AGENT_ID    P_AGENTS.agent_id % TYPE;
      p_policyRec   MIGR_GVAR.PolicyRecTyp;
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(10);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN

      p_policyRec.migrStep := 'Get Agent By No';
      p_policyRec.migrArea := 'MIGR_API_COMMON.GET_AGENT_BY_NO';
      p_policyRec.migrRelTbl := 'INSIS_EVENT';
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;
      L_RESULT := NULL;

     SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'AGENT_NO', p_agent_no);

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('GET_AGENT_BY_NO');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'AGENT_ID', MIGR_GVAR.GV_DEFAULT_AGENT_ID);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
        MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, PIO_ERR);
      END IF;


    END SET_DEFAULT_AGENT_ID_EVENT;    */
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA.20161208  Instead of calling the event : GET_AGENT_BY_NO  get values directly from db
  PROCEDURE SET_DEFAULT_AGENT_ID(P_agent_no IN VARCHAR2)
    IS
      L_AGENT_ID    P_AGENTS.agent_id % TYPE;
      p_policyRec   MIGR_GVAR.PolicyRecTyp;

    BEGIN

      p_policyRec.migrStep := 'Get Agent By No';
      p_policyRec.migrArea := 'MIGR_API_COMMON.GET_AGENT_BY_NO';
      p_policyRec.migrRelTbl := 'INSIS_EVENT';

       SELECT pa.AGENT_ID INTO MIGR_GVAR.GV_DEFAULT_AGENT_ID
        FROM INSIS_PEOPLE_V10.P_AGENTS pa WHERE pa.AGENT_NO = P_agent_no AND AGENT_STATE='1';

    EXCEPTION
      WHEN OTHERS THEN
            p_policyRec.logMsg:='Could not retrieve agent id due to exception:' || SQLCODE||  ' - '  ||SQLERRM   ;
            MIGR_LOG.LOG_EXCEPTION(p_policyRec);
    END SET_DEFAULT_AGENT_ID;

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA.20161107 Instead of calling the event:GET_INSOBJ_BY_OBJECT get values directly from db:
    PROCEDURE GET_INSURED_OBJ(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp)
    AS

    BEGIN
      p_policyRec.migrStep := 'Get Policy Insured Object';
      p_policyRec.migrArea := 'MIGR_API_COMMON.GET_INSURED_OBJ';
      p_policyRec.migrRelTbl := 'DIRECT DB';

      SELECT INSURED_OBJ_ID INTO p_policyRec.insured_object_id  FROM  INSURED_OBJECT io WHERE io.POLICY_ID= p_policyRec.policy_id AND io.ANNEX_ID =MIGR_GVAR.GV_ANNEX_ID AND io.OBJECT_ID= p_policyRec.object_id;

      IF p_policyRec.insured_object_id IS NOT NULL  THEN

          p_policyRec.logMsg := 'OBJECT_ID: ' || p_policyRec.object_id || ' Insured Object: ' || p_policyRec.insured_object_id;
          MIGR_LOG.LOG_INFO(p_policyRec);
      ELSE
          p_policyRec.logMsg := p_policyRec.logMsg || 'Failed to get Insured Object ID ' || p_policyRec.object_id;
          MIGR_LOG.LOG_ERROR(p_policyRec);
          p_policyRec.continue_migr:=FALSE;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := 'MIGR_API_COMMON.GET_INSURED_OBJ  ERROR:' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyRec);
          p_policyRec.continue_migr:=FALSE;
    END GET_INSURED_OBJ;
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  ---GRANT execute on INSIS_CUST.CUST_POL_BO to
  FUNCTION CALCULATE_RECONSTRUCTION_COST(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    AS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_evres       PLS_INTEGER;
    BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Calculate Object''s reconstruction cost';
      l_policyRec.migrArea := 'MIGR_API_COMMON.CALCULATE_RECONSTRUCTION_COST';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';
      l_policyRec.logMsg := 'Calculate reconstruction for ' || l_policyRec.insured_object_id;
      MIGR_LOG.LOG_INFO(l_policyRec);

      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_OBJ_ID', SRV_CONTEXT.Integers_Format, l_policyRec.insured_object_id);

      INSIS_CUST.CUST_POL_BO.CALCULATE_RECONSTRUCTION(L_IN_CONTEXT, L_OUT_CONTEXT, PIO_ERR);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
      THEN
        l_policyRec.logMsg := 'Reconstruction cost calculated successfully for ' || l_policyRec.insured_object_id;
        MIGR_LOG.LOG_INFO(l_policyRec);

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
      THEN
        l_policyRec.logMsg := 'Calculate reconstruction cost returned with warning -RESULT:' || NULL;
        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);

      ELSE
        l_policyRec.logMsg := 'Failed to calculate reconstruction cost ' || l_policyRec.insured_object_id;
        MIGR_LOG.LOG_ERROR(l_policyRec);
        l_policyRec.continue_migr:=FALSE;
        l_policyRec.object_fail_log := l_policyRec.object_fail_log || '-Failed to calculate reconstruction cost';

      END IF;

      RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr:=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || '-Failed to calculate reconstruction cost';
          RETURN l_policyRec;
    END CALCULATE_RECONSTRUCTION_COST;
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--FA.20160707 Migrate everything although some parts may fail
--All policy data should be registered in INSIS but if anything fails do not continue with calculate premium
  FUNCTION MIGRATE_OBJECT(p_policyRec MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    AS
      l_policyRec     MIGR_GVAR.PolicyRecTyp;
        l_eventTimer TIMESTAMP;
    BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Migrate Object';
      l_policyRec.migrArea := 'MIGR_API_COMMON.MIGRATE_OBJECT';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';
      l_eventTimer  :=SYSTIMESTAMP;

      l_policyRec := INSERT_INSURED_OBJ(l_policyRec);

      l_policyRec.logMsg := 'INSERT_INSURED_OBJ: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
      MIGR_LOG.LOG_EVENT_TIME(l_policyRec);
      l_eventTimer  :=SYSTIMESTAMP;

      IF l_policyRec.continue_migr   THEN
        ---Only if insured object is created continue
      --    GET_INSURED_OBJ(l_policyRec);
      --    l_policyRec.logMsg := 'GET_INSURED_OBJ: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
       --   MIGR_LOG.LOG_EVENT_TIME(l_policyRec);

          IF l_policyRec.insured_object_id IS NOT NULL  THEN
              l_policyRec := MIGR_API_COVERS.MIGRATE_COVERS(l_policyRec);

              --FA.20160912 Call to add object deductible value to cover level
              MIGR_API_COVERS.MIGRATE_DEDUCTIBLES(l_policyRec) ;

          --FA.20170307  Should be called only for object level documents
             IF  p_policyrec.require_documents = 'Y' THEN
                 l_policyRec := LOAD_POLICY_DOCUMENTS(l_policyRec,'OBJECT');
              ELSE
                 l_policyRec.logMsg := 'Documents are not required for this product ';
                 MIGR_LOG.LOG_INFO(l_policyRec);
            END IF;

         END IF;

      END IF;

      RETURN l_policyRec;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr:=FALSE;
          RETURN l_policyRec;
    END MIGRATE_OBJECT;
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  ---Update directly insis insured object table with object deductible
  PROCEDURE SET_OBJECT_DEDUCTIBLES(p_policyRec IN OUT  MIGR_GVAR.PolicyRecTyp)
    IS
      v_deduct_sql    VARCHAR2(2000);
      v_deduct_val    VARCHAR2(10);
  BEGIN
      v_deduct_sql := ' SELECT iaq.IA_OBJ_DEDUCT FROM ' || p_policyRec.ia_policyTbl || ' iaq WHERE iaq.IA_OBJECT_ID = ''' || p_policyRec.ia_OBJECT_ID || ''''; --v_obj_tab(i).ia_OBJECT_ID || '''';
      EXECUTE IMMEDIATE v_deduct_sql INTO v_deduct_val;
      UPDATE INSIS_GEN_V10.INSURED_OBJECT io SET io.IOP3 = v_deduct_val WHERE io.INSURED_OBJ_ID = p_policyRec.insured_object_id; --v_obj_tab(i).INS_OBJECT_ID;

  EXCEPTION
    WHEN OTHERS THEN p_policyRec.logMsg := 'Could not update INSIS object deductibles -' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(p_policyRec);
        p_policyRec.continue_migr:=FALSE;
  END SET_OBJECT_DEDUCTIBLES;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --This function is used to get the property address id of an object from a pl-sql table in order to be available to all policy objects
  --If policy has more than one building with 2 addresses the property should use the same INSIS address id instead of creating a second id with the same address info
  FUNCTION GET_ADDRESS_ID(p_addressTab      IN MIGR_GVAR.PropertyAddressTabTyp,
                          p_ia_address      IN NVARCHAR2,
                          p_ia_post_code    IN NVARCHAR2,
                          p_ia_city         IN NVARCHAR2,
                          p_ia_country_code IN NVARCHAR2)
    RETURN NUMBER
    IS
      indx         BINARY_INTEGER;
      v_address_id NUMBER;

    BEGIN
      v_address_id := NULL;
      FOR indx IN p_addressTab.FIRST .. p_addressTab.LAST
      LOOP
        IF (p_addressTab(indx).r_address = p_ia_address
          AND p_addressTab(indx).r_postCode = TO_CHAR(p_ia_post_code)
          AND p_addressTab(indx).r_city = p_ia_city
          AND p_addressTab(indx).r_countryCode = p_ia_country_code)
        THEN
          v_address_id := p_addressTab(indx).r_addressId;

        END IF;
      END LOOP;
      RETURN v_address_id;

    EXCEPTION
      WHEN OTHERS THEN MIGR_LOG.LOG_EXCEPTION('0-0', 'MIGR_API_COMMON.GET_ADDRESS_ID', 'GET_ADDRESS_ID', SQLERRM, '', '');
          RETURN NULL;

    END GET_ADDRESS_ID;
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 --This function is used to add the property address id of an object in a pl-sql table in order to be available to all policy objects
 --If policy has more than one building with 2 addresses the property should use the same INSIS address id instead of creating a second id with the same address info
  PROCEDURE ADD_ADDRESS_ID(p_addressTab      IN OUT MIGR_GVAR.PropertyAddressTabTyp,
                           p_address_id    IN     NUMBER,
                           p_ia_address    IN     NVARCHAR2,
                           p_ia_post_code  IN     NVARCHAR2,
                           p_ia_city            IN     NVARCHAR2,
                           p_ia_country_code IN     NVARCHAR2)

    IS
      l_indx   BINARY_INTEGER;
      l_exists BOOLEAN;
    BEGIN
      l_indx := p_addressTab.FIRST;
      IF l_indx IS NULL
      THEN
        l_indx := 1;
      ELSE
        l_indx := p_addressTab.COUNT + 1;
      END IF;

      --First check if already exists
      l_exists := FALSE;
      IF p_addressTab.FIRST IS NOT NULL
      THEN
        FOR indx IN p_addressTab.FIRST .. p_addressTab.LAST
        LOOP
          IF (p_addressTab(indx).r_address = p_ia_address
            AND p_addressTab(indx).r_postCode = TO_CHAR(p_ia_post_code)
            AND p_addressTab(indx).r_city = p_ia_city
            AND p_addressTab(indx).r_countryCode = p_ia_country_code)
          THEN

            IF p_address_id IS NOT NULL
            THEN
              p_addressTab(indx).r_addressId := p_address_id;
            END IF;
            l_exists := TRUE;

          END IF;
        END LOOP;

      END IF;
      IF NOT l_exists
      THEN

        p_addressTab(l_indx).r_address := p_ia_address;
        IF p_address_id IS NOT NULL
        THEN
          p_addressTab(l_indx).r_addressId := p_address_id;
        END IF;
        p_addressTab(l_indx).r_city := p_ia_city;
        p_addressTab(l_indx).r_countryCode := p_ia_country_code;
        p_addressTab(l_indx).r_postCode := TO_CHAR(p_ia_post_code);

      END IF;

    EXCEPTION
      WHEN OTHERS THEN MIGR_LOG.LOG_EXCEPTION('0-0', 'MIGR_API_COMMON.ADD_ADDRESS_ID', 'ADD_ADDRESS_ID', SQLERRM, '', '');

    END ADD_ADDRESS_ID;
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --This procedure provides an automated way to map various labels forr aouthouse according to regular expression rules(HST_OUTHOUSE_LABELS)
  --This is called only once when the complete list is provide it in order to populate ETL_OUTHOUSE_LABELS_MAP an map to INSIS key
  PROCEDURE MAP_OUTHOUSE_LABELS
    IS
      v_key VARCHAR(1);
      VSQL  VARCHAR2(2000);
    BEGIN

      FOR c IN (SELECT LABEL
          FROM ETL_OUTHOUSE_LABELS_MAP
          WHERE INSIS_KEY IS NULL)
      LOOP

      << KEY_LOOP >>
        FOR n IN (SELECT MIG_KEY,
                         REGULAR_EXP,
                         PRIORITY,
                         INSIS_CODE,
                         INSIS_KEY
            FROM HST_OUTHOUSE_LABELS
            WHERE PRIORITY <> 0
            ORDER BY PRIORITY ASC)
        LOOP

          VSQL := ' SELECT case WHEN  REGEXP_LIKE(' || q'[']' || c.LABEL || q'[']' || ',' || n.REGULAR_EXP || ') THEN ' || q'[']' || 'Y' || q'[']' || ' ELSE ' || q'[']' || 'N' || q'[']' || ' end   from DUAL';

          EXECUTE IMMEDIATE VSQL
            INTO v_key;

          IF v_key = 'Y'
          THEN
            UPDATE ETL_OUTHOUSE_LABELS_MAP
              SET INSIS_KEY = n.INSIS_KEY
              WHERE LABEL = c.LABEL
              AND INSIS_KEY IS NULL;

            EXIT KEY_LOOP;
          END IF;

        END LOOP;

      END LOOP;

      UPDATE ETL_OUTHOUSE_LABELS_MAP
        SET INSIS_KEY = 'Other'
        WHERE INSIS_KEY IS NULL;
    EXCEPTION
      WHEN OTHERS THEN MIGR_LOG.LOG_EXCEPTION('0-0', 'MIGR_API_COMMON.MAP_OUTHOUSE_LABELS', 'MAP_OUTHOUSE_LABELS', SQLERRM, VSQL, '');
    END MAP_OUTHOUSE_LABELS;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA.20160407 Parse event response properly -If pio error is not null event may result with warning and proccess should continue
  FUNCTION GET_EVENT_RESULT(PIO_ERR IN SRVERR,
                            L_RESULT   VARCHAR2)
    RETURN PLS_INTEGER
    IS
    BEGIN

      IF PIO_ERR IS NULL
      THEN
        IF NVL(L_RESULT, 'TRUE') = 'TRUE'
        THEN
          RETURN MIGR_GVAR.GV_EVRES_SUCCESS;
        ELSE
          RETURN MIGR_GVAR.GV_EVRES_ERROR;
        END IF;
      ELSE
        FOR I IN PIO_ERR.FIRST .. PIO_ERR.LAST
        LOOP
          IF PIO_ERR(I).ERRTYPE = 'ERROR'
          THEN
            RETURN MIGR_GVAR.GV_EVRES_ERROR;
          ELSIF PIO_ERR(I).ERRTYPE = 'WARNING'
          THEN

            RETURN MIGR_GVAR.GV_EVRES_WARNING;
          ELSE
            RETURN MIGR_GVAR.GV_EVRES_UNDEFINED;
          END IF;

        END LOOP;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN RETURN MIGR_GVAR.GV_EVRES_UNDEFINED;

    END GET_EVENT_RESULT;
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  --FA.20160418 SET Default values to global variables
  PROCEDURE SET_DEFAULT_VALUES(MIG_BOLAG_ID IN MIG_MIGRATION_INFO.BOLAG_ID % TYPE)
    IS
      v_def_agent  CHAR;

    BEGIN
      MIGR_GVAR.GV_DEFAULT_AGENT_NO := NULL;
      MIGR_GVAR.GV_DEFAULT_AGENT_ID := NULL;
     --FA.20170504 MIGR_GVAR.GV_DEFAULT_OFFICE_ID := NULL;
     --- MIGR_GVAR.GV_DEFAULT_MIGR_USER := NULL;

      SELECT esi.MIGG_DEFAULT_AGENT, ---fa.20170504 esi.MIGG_DEFAULT_OFFICE,
       -- esi.MIGRATION_USER,
        INSIS_DEFAULT_EVENT , esi.MIGRATE_CLIENTS, MIGRATION_METHOD
        INTO v_def_agent, -- MIGR_GVAR.GV_DEFAULT_MIGR_USER,
        MIGR_GVAR.GV_DEFAULT_EVENT,MIGR_GVAR.GV_DEFAULT_MIGRATE_CLIENT ,MIGR_GVAR.GV_MIGRATION_METHOD
        FROM ETL_SETUP_INFO esi;
         MIGR_GVAR.GV_DEFAULT_AGENT :=v_def_agent;

     ----Always set default agent to be used by zero or null MIGG values IF v_def_agent = 'Y'    THEN


        SELECT DEFAULT_AGENT
          INTO MIGR_GVAR.GV_DEFAULT_AGENT_NO
          FROM ETL_BOLAG_INFO
          WHERE BOLAG_ID = MIG_BOLAG_ID;

        SET_DEFAULT_AGENT_ID(MIGR_GVAR.GV_DEFAULT_AGENT_NO);

     ---- END IF;

    /*FA.20170504   IF v_def_office = 'Y'  THEN
        SELECT DEFAULT_OFFICE
          INTO MIGR_GVAR.GV_DEFAULT_OFFICE_ID
          FROM ETL_BOLAG_INFO
          WHERE BOLAG_ID = MIG_BOLAG_ID;

      END IF;  */
    EXCEPTION
      WHEN OTHERS THEN MIGR_GVAR.GV_DEFAULT_AGENT_NO := NULL;
          MIGR_GVAR.GV_DEFAULT_AGENT_NO := NULL;
    END;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 --FA.20161121 Return the event name should call according to configuration  customized migration or default
 FUNCTION GET_INSIS_EVENT (p_event_key IN VARCHAR2)  RETURN VARCHAR2  IS
       v_event VARCHAR2(100);
 BEGIN
       IF MIGR_GVAR.GV_DEFAULT_EVENT ='N' THEN
           SELECT  MIGR_EVENT_NAME
           INTO v_event
           FROM MIGR_SRV_EVENT_LIST
           WHERE MIGR_EVENT_KEY = p_event_key;

       ELSE
          SELECT INSIS_EVENT_NAME
           INTO v_event
           FROM MIGR_SRV_EVENT_LIST
           WHERE MIGR_EVENT_KEY =p_event_key;

        END IF;
      RETURN v_event;

  EXCEPTION
    WHEN OTHERS THEN
           MIGR_LOG.LOG_EXCEPTION('0-0', 'MIGR_API_COMMON.GET_INSIS_EVENT', 'GET_INSIS_EVENT', SQLERRM, '', '');
           RETURN NULL;
 END GET_INSIS_EVENT;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --LM - 20170425 - UPDATE_CUST_CORRESPONDENCE - START
  PROCEDURE UPDATE_CUST_CORRESPONDENCE(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT    SRVCONTEXT;
      L_OUT_CONTEXT   SRVCONTEXT;
      PIO_ERR         SRVERR;

    BEGIN

      p_policyrec.migrStep := 'Update Policy Correspondence';
      p_policyrec.migrArea := 'MIGR_API_COMMON.UPDATE_CUST_CORRESPONDENCE';

      UPDATE INSIS_CUST.CUST_CORRESPONDENCE
         SET DISTR_METHOD = p_policyrec.IA_DISTR_METHOD
       WHERE POLICY_ID = p_policyRec.policy_id
         AND DISTR_METHOD <> p_policyrec.IA_DISTR_METHOD;

   EXCEPTION
    WHEN OTHERS THEN p_policyRec.logMsg := 'Could not update INSIS Correspondence -' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(p_policyRec);
        p_policyRec.continue_migr:=FALSE;
  END UPDATE_CUST_CORRESPONDENCE;
--LM - 20170425 - UPDATE_CUST_CORRESPONDENCE - END
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_ENG_BILLING(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT    SRVCONTEXT;
      L_OUT_CONTEXT   SRVCONTEXT;
      PIO_ERR         SRVERR;
      l_engbillingtype INSIS_GEN_V10.P_ENGAGEMENT_BILLING_TYPE;
      l_eng_bill_id   NUMBER;
      l_BACKDATED_OPERATION VARCHAR2(100); --EZ 2019/06/11

    BEGIN

      p_policyrec.migrStep := 'Update Policy Engagement Billing';
      p_policyrec.migrArea := 'MIGR_API_COMMON.UPDATE_ENG_BILLING';
      l_eng_bill_id := 0;

      SELECT ENG_BILLING_ID
        INTO l_eng_bill_id
        FROM INSIS_GEN_V10.POLICY_ENGAGEMENT_BILLING
       WHERE POLICY_ID =  p_policyrec.policy_id
         AND ANNEX_ID = MIGR_GVAR.GV_ANNEX_ID;

--      l_engbillingtype :=INSIS_GEN_V10.P_ENGAGEMENT_BILLING_TYPE( l_eng_bill_id );
--      l_engbillingtype.PAYMENT_WAY := TO_NUMBER( p_policyrec.IA_PAYM_WAY,SRV_CONTEXT.Integers_Format);
--      l_engbillingtype.NUM_INSTALMENTS := TO_NUMBER( p_policyrec.numInstalments,SRV_CONTEXT.Integers_Format);
--      l_engbillingtype.ATTR1 := p_policyrec.IA_BANK_ID;
--      l_engbillingtype.ATTR2 := p_policyrec.IA_INVOICE;
--
--      IF NOT l_engbillingtype.UpdatePEngagementBilling( PIO_ERR )   THEN
--          p_policyrec.logMsg := 'PIO_ERR UPDATE_ENG_BILLING Failed to update table';
--          MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
--          p_policyrec.continue_migr:=FALSE;
--      ELSE
--          p_policyrec.logMsg := 'Policy engagement billing updated succesfully';
--          MIGR_LOG.LOG_INFO(p_policyrec);
--      END IF;

--EZ 2019/06/11 In case we have the issue with dataVALID_FROM > INSR_BEGIN_DATE. If BACKDATED_OPERATION is NOT null then set VALID_FROM = INSR_BEGIN - 1.
      SELECT BACKDATED_OPERATION
        INTO l_BACKDATED_OPERATION
        FROM ETL_SETUP_INFO;

      l_engbillingtype :=INSIS_GEN_V10.P_ENGAGEMENT_BILLING_TYPE( l_eng_bill_id );
      l_engbillingtype.PAYMENT_WAY := TO_NUMBER( p_policyrec.IA_PAYM_WAY,SRV_CONTEXT.Integers_Format);
      l_engbillingtype.NUM_INSTALMENTS := TO_NUMBER( p_policyrec.numInstalments,SRV_CONTEXT.Integers_Format);
      l_engbillingtype.ATTR1 := p_policyrec.IA_BANK_ID;
      l_engbillingtype.ATTR2 := p_policyrec.IA_INVOICE;

     IF l_BACKDATED_OPERATION IS NOT NULL THEN --set BACKDATED_OPERATION= -1
        l_engbillingtype.VALID_FROM := p_policyrec.insr_begin + l_BACKDATED_OPERATION;
        p_policyrec.logMsg := 'VALID_FROM '||l_engbillingtype.VALID_FROM;
        MIGR_LOG.LOG_INFO(p_policyrec);
     END IF;

    IF NOT l_engbillingtype.UpdatePEngagementBilling( PIO_ERR )   THEN
          p_policyrec.logMsg := 'PIO_ERR UPDATE_ENG_BILLING Failed to update table';
          MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
          p_policyrec.continue_migr:=FALSE;
      ELSE
          p_policyrec.logMsg := 'Policy engagement billing updated succesfully';
          MIGR_LOG.LOG_INFO(p_policyrec);
    END IF;

EXCEPTION
    WHEN OTHERS THEN p_policyRec.logMsg := 'Could not update UPDATE_ENG_BILLING -' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(p_policyRec);
        p_policyRec.continue_migr:=FALSE;
--EZ 2019/06/11  END

END UPDATE_ENG_BILLING;

 -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--LM - 20170301 - MIGRATE ENDORSEMENTS - START
  --GRANT update on INSIS_GEN_V10.policy_endorsements to
  FUNCTION MIGRATE_ENDORSMENTS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS
      l_evres           PLS_INTEGER;
      l_policyRec       MIGR_GVAR.PolicyRecTyp;
      l_in_context      SRVCONTEXT;
      l_out_context     SRVCONTEXT;
      pio_err           SRVERR;
      L_RESULT          VARCHAR2(50);
      vEndorsementssql  VARCHAR2(2000);
      L_ENDORSEMENT_ID  INSIS_GEN_V10.POLICY_ENDORSEMENTS.ENDORSEMENT_ID % TYPE;
      l_LogRec           MIGR_GVAR.LogRecTyp;  --EZ 2019-03-01
      TYPE endorsement_rec IS RECORD (
          IA_IDPL    NUMBER,
          ECODE      VARCHAR2(2000),
          ETEXT      VARCHAR2(32000),
          ETYPE      VARCHAR2(2000),
          ESUBTYPE   VARCHAR2(2000),
          EORDER     VARCHAR2(2000),
          ECOVERTYPE VARCHAR2(2000),
          EINSRBEGIN DATE,
          EINSREND   DATE
        );
      TYPE t_endorsement_type_tab IS TABLE OF endorsement_rec;
      v_endorsement_tab t_endorsement_type_tab;
      v_stmst           VARCHAR2(400);
      v_event           MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Insert Policy Endorsements';
      l_policyRec.migrArea := 'MIGR_API_COMMON.MIGRATE_ENDORSMENTS';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';
      l_in_context := NULL;
      l_out_context := NULL;

      vEndorsementssql :=
--  LM - 20170602 - Fixed issue with duplicate text in Accident products
--      'SELECT IA_KEY_CODE ,LISTAGG(cast(trim(IA_TEXT) as varchar2(2000)),'' '' )WITHIN GROUP (ORDER BY IA_row_num ASC ) as ETEXT,
--        MAX(IA_ENDORSEMENT_TYPE) ETYPE,
--        MAX(IA_ENDORSEMENT_SUBTYPE) ESUBTYPE, MAX(IA_ENDORSEMENT_ORDER) EORDER,  MAX(IA_COVER_TYPE) ECOVERTYPE  ,MAX(IA_ENDORSEMENT_CODE) ECODE,MAX(IA_INSR_BEGIN) EINSRBEGIN,
--        MAX(IA_INSR_END) EINSREND
--        FROM ' || l_policyRec.ia_endorsementsTbl || '  WHERE IA_IDPL =' || l_policyRec.policy_idpl || ' group by  IA_KEY_CODE ';

        'SELECT IA_IDPL, MAX(IA_ENDORSEMENT_CODE) ECODE ,LISTAGG(cast(trim(IA_TEXT) as varchar2(2000)),'' '' )WITHIN GROUP (ORDER BY IA_row_num ASC ) as ETEXT,
        MAX(IA_ENDORSEMENT_TYPE) ETYPE, MAX(IA_ENDORSEMENT_SUBTYPE) ESUBTYPE, MAX(IA_ENDORSEMENT_ORDER) EORDER,  MAX(IA_COVER_TYPE) ECOVERTYPE, MAX(IA_INSR_BEGIN) EINSRBEGIN,
        MAX(IA_INSR_END) EINSREND
        FROM ' || l_policyRec.ia_endorsementsTbl || '  WHERE IA_IDPL =' || l_policyRec.policy_idpl || ' group by  IA_IDPL, IA_ENDORSEMENT_CODE ';

------EZ 2019-03-01 Fixed issue with missing text in Accident products
--            'SELECT IA_IDPL,
--                    IA_ENDORSEMENT_CODE AS ECODE,
--                    IA_TEXT AS ETEXT,
--                    IA_ENDORSEMENT_TYPE AS ETYPE,
--                    IA_ENDORSEMENT_SUBTYPE AS ESUBTYPE,
--                    IA_ROW_NUM AS EORDER,
--                    IA_COVER_TYPE AS ECOVERTYPE,
--                    IA_INSR_BEGIN AS EINSRBEGIN,
--                    IA_INSR_END AS EINSREND
--             FROM ' || l_policyRec.ia_endorsementsTbl || '  WHERE IA_IDPL =' || l_policyRec.policy_idpl ||
--             ' ORDER BY IA_ROW_NUM';
------EZ  END 2019-03-01

      EXECUTE IMMEDIATE vEndorsementssql
        BULK COLLECT INTO v_endorsement_tab;

      FOR i IN 1 .. v_endorsement_tab.COUNT
      LOOP

      l_in_context := NULL;  --EZ 2019-03-01
      l_out_context := NULL; --EZ 2019-03-01

        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ENDORSEMENT_ID', SRV_CONTEXT.Integers_Format, '');
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.insr_type);
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ENDORSEMENTS_ORDER', SRV_CONTEXT.Integers_Format, v_endorsement_tab(i).EORDER);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ENDORSEMENT_CODE', v_endorsement_tab(i).ECODE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ENDORSEMENT_TYPE', v_endorsement_tab(i).ETYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ENDORSEMENT_SUBTYPE', v_endorsement_tab(i).ESUBTYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'TEXT', v_endorsement_tab(i).ETEXT);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COVER_TYPE', v_endorsement_tab(i).ECOVERTYPE);
        SRV_CONTEXT.SETCONTEXTATTRDATE(l_in_context, 'INSR_BEGIN', SRV_CONTEXT.Date_Format, v_endorsement_tab(i).EINSRBEGIN);
        SRV_CONTEXT.SETCONTEXTATTRDATE(l_in_context, 'INSR_END', SRV_CONTEXT.Date_Format, v_endorsement_tab(i).EINSREND);


         ---FA.20160829 Change event call to dynamic- Call migrate custom evens or insis default events according to etl_setup_info
        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_POLICY_ENDORSEMENT');

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

        EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'PROCEDURE_RESULT', L_RESULT);
        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'ENDORSEMENT_ID', L_ENDORSEMENT_ID);

        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, L_RESULT);

       --EZ 2019-03-01
       l_LogRec.logMsg :='POLICY_ID: '||l_policyRec.policy_id|| '-ENDORSEMENT_ID: '||L_ENDORSEMENT_ID||' -ENDORSEMENT_CODE:'||v_endorsement_tab(i).ECODE|| ' -ENDORSEMENTS_ORDER:'||v_endorsement_tab(i).EORDER;
       MIGR_LOG.LOG_INFO(l_LogRec);
       --EZ END 2019-03-01

        IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN

          l_policyRec.logMsg := 'PIO_ERR INS_POLICY_ENDORSEMENT Failed to add endorsement -RESULT: ' || L_RESULT;
          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
           l_policyRec.continue_migr :=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  migrate endorsements';

        ELSE
          UPDATE INSIS_GEN_V10.POLICY_ENDORSEMENTS
            SET TEXT = v_endorsement_tab(i).ETEXT
            WHERE ENDORSEMENT_ID = L_ENDORSEMENT_ID;

        END IF;
      END LOOP;
      RETURN l_policyRec;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          l_policyRec.migrRelTbl := vEndorsementssql;
          MIGR_LOG.LOG_ERROR(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  migrate endorsements';
          RETURN l_policyRec;
    END MIGRATE_ENDORSMENTS;

--LM - 20170301 - MIGRATE ENDORSEMENTS - END

  ------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------
  --FA.20170613 Procedure called on exceptional cases to force migration to stop and notify support team
  PROCEDURE SUSPEND_MIGRATION (p_LogMsg VARCHAR2, p_Msg_Code IN VARCHAR2)
    IS
    BEGIN

        MIGR_EMAIL_NOTIFICATION.SEND_EMAIL_IMMEDIATE (p_LogMsg, p_Msg_Code);

        FOR C IN (SELECT JOB_NAME FROM USER_SCHEDULER_JOBS)
        LOOP
            DBMS_SCHEDULER.DROP_JOB(JOB_NAME=>C.JOB_NAME, FORCE=>TRUE);
        END LOOP;

  END SUSPEND_MIGRATION;

  ------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------
  --++ 20170802 New procedure to handle failed policies
  PROCEDURE  MIGR_UPD_FAILED_POL_FOR_PHASE2(p_policyId IN MIGR_POLICY.POLICY_ID % TYPE)

  AS

    l_policyRec   MIGR_GVAR.PolicyRecTyp;
    l_batchStatus MIG_MIGRATION_INFO.STATUS % TYPE;
    l_polFlag     IA_POLICY.MIG_FLAG % TYPE;
    l_failedPhase VARCHAR2(100);
    l_polState    INSIS_GEN_V10.POLICY.POLICY_STATE % TYPE;
    l_eventTimer  TIMESTAMP;
    l_beginTimer  TIMESTAMP WITH TIME ZONE;
    vSQL          VARCHAR2(400);
    v_mig_insis_user   ETL_BOLAG_INFO.BOLAG_USERNAME%TYPE;

  BEGIN

    l_policyRec.migrArea := 'MIGR_UPD_FAILED_POL_FOR_PHASE2';
    l_policyRec.migrStep := 'Manual Policy Correction-Update policy status for Migration Phase2';
    l_policyRec.policy_id := p_policyId;

    SELECT POLICY_IDPL,
           MIG_BATCH_ID,
           POLICY_STEP
      INTO l_policyRec.policy_idpl,
           l_policyRec.mig_batch_id,
           l_policyRec.policy_final_step
      FROM MIGR_POLICY
      WHERE POLICY_ID = l_policyRec.policy_id;



    SELECT ip.MIG_FLAG,
           IA_POLICY_REF,
           ip.IA_INSRPRD
      INTO l_polFlag,
           l_policyRec.policy_ref,
           l_policyRec.insrprd
      FROM IA_POLICY ip
      WHERE ip.IA_IDPL = l_policyRec.policy_idpl;

    SELECT mmi.STATUS
      INTO l_batchStatus
      FROM MIG_MIGRATION_INFO mmi
      WHERE mmi.MIGRATION_BATCH_ID = l_policyRec.mig_batch_id;

    --Check if policy failed at Phase 1 or Phase 2

    IF l_batchStatus = MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC
      AND l_polFlag <> MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS
    THEN
      l_policyRec.logMsg := 'Policy ID:' || l_policyRec.policy_id || ' failed at Phase 1.Last successful migration step is: ' || l_policyRec.policy_final_step || '. Policy was corrected manually and will be updated to be included in Phase 2.';
      l_failedPhase := 'PHASE1';

    ELSIF l_batchStatus = MIGR_GVAR.GV_BATCH_STATUS_FINISHED
      AND l_polFlag <> MIGR_GVAR.GV_MIG_FLAG_SUCCESS
    THEN
      l_policyRec.logMsg := 'Policy ID:' || l_policyRec.policy_id || ' failed at Phase 2. Last successful migration step is: ' || l_policyRec.policy_final_step || '. Policy was corrected manually and Phase 2 will be triggered on demand for this policy.';
      l_failedPhase := 'PHASE2';

    ELSE
      l_policyRec.logMsg := 'Cannot identify at which phase Policy ID:' || l_policyRec.policy_id || ' failed. No further action willbe performed.';
      l_failedPhase := 'UNKNOWN';
    END IF;

    MIGR_LOG.LOG_INFO(l_policyRec);


    IF l_failedPhase = 'PHASE1'
    THEN
      UPDATE IA_POLICY
        SET MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS
        WHERE IA_IDPL = l_policyRec.policy_idpl
        AND MIG_BATCH_ID = l_policyRec.mig_batch_id;

    ELSIF l_failedPhase = 'PHASE2'
    THEN
      ---Check if phase 2 should run from calculate premium or only convert event
      SELECT POLICY_STATE,
             CLIENT_ID,
             AGENT_ID,
             INSR_TYPE
        INTO l_polState,
             l_policyRec.client_id,
             l_policyRec.agent_id,
             l_policyRec.insr_type
        FROM INSIS_GEN_V10.POLICY
        WHERE POLICY_ID = l_policyRec.policy_id;

      --If policy is in status CONFIRMED, run only CONVERT_POLICY
      IF l_polState = '-2'
      THEN

          SELECT ebi.BOLAG_USERNAME INTO v_mig_insis_user FROM ETL_BOLAG_INFO ebi WHERE ebi.BOLAG_ID = SUBSTR(l_policyRec.MIG_BATCH_ID, 1, 2);

          -- Initializes the connection session
          INSIS_SYS_V10.INSIS_CONTEXT.Prepare_Session(Pi_App       => 'GEN',
                                                      Pi_Action    => 'InsisPolicyGen',
                                                      Pi_Username  => v_mig_insis_user,
                                                      Pi_User_Role => 'InsisStaff',
                                                      Pi_Lang      => NULL,
                                                      Pi_Country   => NULL);

          --set default values according to etl_setup_info configuration
          MIGR_API_COMMON.SET_DEFAULT_VALUES(SUBSTR(l_policyRec.MIG_BATCH_ID, 1, 2));



        l_policyRec.mig_flag := MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS;
        l_policyRec.continue_migr := TRUE;
        l_policyRec.policy_final_step := 'CONFIRMED';
        l_eventTimer := SYSTIMESTAMP;


        MIGR_API_POLICY.CONVERT_APPLICATION(l_policyrec);
        l_policyrec.logMsg := 'CONVERTED: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
        MIGR_LOG.LOG_EVENT_TIME(l_policyrec);

        MIGR_LOG.LOG_POLICY(l_policyRec, l_beginTimer, l_policyRec.policy_final_step);   --l_beginTimer is not meaningful here because is the policy is not fully migrated in one stream. value here is null
      --if policy is in status other than CONFIRMED, policy should rerun the whole phase 2
      ELSE
        UPDATE IA_POLICY
          SET MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS
          WHERE IA_IDPL = l_policyRec.policy_idpl
          AND MIG_BATCH_ID = l_policyRec.mig_batch_id;

        vSQL := 'ALTER SESSION SET NLS_DATE_FORMAT = ''YYYY-MM-DD''';
        EXECUTE IMMEDIATE vSQL;
        vSQL := 'ALTER SESSION SET NLS_LANGUAGE = ''ENGLISH''';
        EXECUTE IMMEDIATE vSQL;
        vSQL := 'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
        EXECUTE IMMEDIATE vSQL;

        MIGR_API_COMMON.SET_DEFAULT_VALUES(SUBSTR(l_policyRec.mig_batch_id, 1, 2));
        MIGR_API_POLICY.MIGRATE_POLICY(l_policyRec.mig_batch_id, l_policyRec.policy_idpl);
      END IF;

    END IF;

  END;
  ------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------
  --++ 201708011 New procedure to handle manually corected policies
  PROCEDURE  MIGR_PHASE2_POL_PROCESS
  AS

    l_policyRec   MIGR_GVAR.PolicyRecTyp;
    l_batchStatus MIG_MIGRATION_INFO.STATUS % TYPE;
    l_polFlag     IA_POLICY.MIG_FLAG % TYPE;
    l_failedPhase VARCHAR2(100);
    l_polState    INSIS_GEN_V10.POLICY.POLICY_STATE % TYPE;
    l_eventTimer  TIMESTAMP;
    l_beginTimer  TIMESTAMP WITH TIME ZONE;
    vSQL          VARCHAR2(400);
    l_status       CHAR(1);
    l_Pol_IDPL    MIGR_POLICY.POLICY_IDPL%TYPE;
    l_migFlag       PLS_INTEGER;
  BEGIN

    l_policyRec.migrArea := 'MIGR_PHASE2_POL_PROCESS';
    l_policyRec.migrStep := 'Start processing of Manually Corrected Policies';
    l_policyRec.mig_batch_id:='0-4';
    l_policyRec.logMsg:=    'Start processing of Manually Corrected Policies';
    MIGR_LOG.LOG_INFO(l_policyRec) ;

    FOR  pol IN (select POLICY_ID FROM MIGR_UPDATE_LIST lst  WHERE STATUS is null )
    LOOP
         BEGIN
                SELECT mig.POLICY_IDPL, ia.mig_flag INTO  l_Pol_IDPL,l_migFlag FROM IA_POLICY ia , MIGR_POLICY mig  WHERE  mig.POLICY_IDPL= ia.IA_IDPL AND    mig.POLICY_ID=pol.POLICY_ID  ;

                 IF  l_migFlag IN (MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS , MIGR_GVAR.GV_MIG_FLAG_SUCCESS)   THEN
                       l_policyRec.logMsg:='Policy Id :' || pol.POLICY_ID || ' was succesfully migrated in previous phase so no action will be perfomed. ' ;
                       MIGR_LOG.LOG_WARNING(l_policyRec);
                       l_status:='I';

                 ELSE

                      MIGR_UPD_FAILED_POL_FOR_PHASE2(pol.policy_Id);

                      SELECT mig_flag into l_migFlag   FROM IA_POLICY WHERE  IA_IDPL =l_Pol_IDPL  ;

                      IF   l_migFlag IN (MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS , MIGR_GVAR.GV_MIG_FLAG_SUCCESS) THEN
                           l_status:='S';
                      ELSE
                            l_status:='F';
                      END IF;

                 END IF;
         EXCEPTION
          WHEN NO_DATA_FOUND THEN
                  l_policyRec.logMsg:='Policy Id :' || pol.POLICY_ID || ' is not a MIGG policy and will be igored ' ;
                  MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                  l_status:='I';
         END;

        UPDATE     MIGR_UPDATE_LIST SET STATUS=  l_status WHERE POLICY_ID=pol.POLICY_ID;
        COMMIT;
    END LOOP;



  END MIGR_PHASE2_POL_PROCESS;
  ------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------

 --FA.20170807 Restore INSIS log level values as when prior to migraition
 PROCEDURE RESTORE_INSIS_LOG_LEVEL
  AS
       l_LogRec         MIGR_GVAR.LogRecTyp;
       v_lookup_id       insis_gen_blc_v10.blc_values .lookup_id%TYPE;
        PRAGMA AUTONOMOUS_TRANSACTION;

  BEGIN
      l_LogRec.mig_batch_id := '0-0';
      l_LogRec.migrArea     := 'MIGR_API_COMMON.RESTORE_INSIS_LOG_LEVEL';
      l_LogRec.mig_batch_id := '0-0';
      l_LogRec.migrStep     := 'MIGR_API_COMMON.RESTORE_INSIS_LOG_LEVEL';
      l_LogRec.migrRelTbl   := NULL;
      l_LogRec.migrRelKey   := NULL;

     SELECT eas.STEP_ALIAS INTO v_lookup_id FROM ETL_API_STEPS eas WHERE eas.STEP ='DebugLogLevel';

      IF  v_lookup_id IS NOT NULL THEN
            UPDATE insis_gen_blc_v10.blc_values
            SET lookup_id =v_lookup_id
            WHERE setting = 'DebugLogLevel';
      ELSE
            l_LogRec.logMsg := 'Failed to restore INSIS Debug Log Level because the initial INSIS values were not regsitered';
            MIGR_LOG.LOG_EXCEPTION(l_LogRec);

      END IF;

     SELECT eas.STEP_ALIAS  INTO v_lookup_id FROM ETL_API_STEPS eas WHERE eas.STEP ='AccountingDebugLogEnabled';

     IF  v_lookup_id IS NOT NULL THEN
          UPDATE insis_gen_blc_v10.blc_values
          SET lookup_id =  v_lookup_id
          WHERE setting = 'AccountingDebugLogEnabled';
     ELSE
           l_LogRec.logMsg := 'Failed to restore INSIS Debug Log Level because the initial INSIS values were not regsitered';
           MIGR_LOG.LOG_EXCEPTION(l_LogRec);

     END IF;
    COMMIT;
      l_LogRec.logMsg := 'INSIS Debug Log Level Restored';
     MIGR_LOG.LOG_INFO(l_LogRec);

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
         l_LogRec.logMsg := 'Failed to restore INSIS Debug Log Level: '  || SQLCODE || '-' || SQLERRM;
         MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END RESTORE_INSIS_LOG_LEVEL;
  ------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------
 --FA.20170807 Configure to lower INSIS log level and prevent tablespace issues caused by extensive logging
 PROCEDURE DISABLE_INSIS_LOG_LEVEL
  AS
          l_LogRec         MIGR_GVAR.LogRecTyp;
        PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
      l_LogRec.mig_batch_id := '0-0';
      l_LogRec.migrArea     := 'MIGR_API_COMMON.DISABLE_INSIS_LOG_LEVEL';
      l_LogRec.mig_batch_id := '0-0';
      l_LogRec.migrStep     := 'MIGR_API_COMMON.DISABLE_INSIS_LOG_LEVEL';
      l_LogRec.migrRelTbl   := NULL;
      l_LogRec.migrRelKey   := NULL;

  UPDATE insis_gen_blc_v10.blc_values SET lookup_id = (SELECT lookup_id FROM insis_gen_blc_v10.blc_lookups WHERE lookup_set = 'DebugLogLevelValues' AND lookup_code = 4) WHERE setting = 'DebugLogLevel';


  UPDATE insis_gen_blc_v10.blc_values SET lookup_id = (SELECT lookup_id FROM insis_gen_blc_v10.blc_lookups WHERE lookup_set = 'YES_NO' AND lookup_code = 'N') WHERE setting = 'AccountingDebugLogEnabled';
  COMMIT;
   l_LogRec.logMsg := 'INSIS Debug Log Level Disabled';
   MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION
    WHEN OTHERS THEN
         ROLLBACK;
         l_LogRec.logMsg := 'Failed to disable INSIS Debug Log Level: ' || l_LogRec.migrArea || SQLCODE || '-' || SQLERRM;
         MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END DISABLE_INSIS_LOG_LEVEL;
      ------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------
  --FA.20170807 Store INSIS Debug Log Level values
  PROCEDURE STORE_INSIS_LOG_LEVEL
  AS
        l_LogRec         MIGR_GVAR.LogRecTyp;
        v_lookup_id       insis_gen_blc_v10.blc_values .lookup_id%TYPE;

        PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
      l_LogRec.mig_batch_id := '0-0';
      l_LogRec.migrArea     := 'MIGR_API_COMMON.STORE_INSIS_LOG_LEVEL';
      l_LogRec.mig_batch_id := '0-0';
      l_LogRec.migrStep     := 'MIGR_API_COMMON.STORE_INSIS_LOG_LEVEL';
      l_LogRec.migrRelTbl   := NULL;
      l_LogRec.migrRelKey   := NULL;

     SELECT LOOKUP_ID into v_lookup_id FROM  insis_gen_blc_v10.blc_values  WHERE setting = 'DebugLogLevel';

     UPDATE  ETL_API_STEPS    SET  STEP_ALIAS=v_lookup_id  WHERE STEP ='DebugLogLevel';

      SELECT LOOKUP_ID into v_lookup_id FROM insis_gen_blc_v10.blc_values  WHERE setting = 'AccountingDebugLogEnabled';

      UPDATE  ETL_API_STEPS  SET  STEP_ALIAS=v_lookup_id   WHERE STEP ='AccountingDebugLogEnabled';

      COMMIT;
       l_LogRec.logMsg := 'Store INSIS Debug Log Level ';
       MIGR_LOG.LOG_INFO(l_LogRec);



    EXCEPTION
    WHEN OTHERS THEN
         ROLLBACK;
         l_LogRec.logMsg := 'Failed to store INSIS Debug Log Level: ' || l_LogRec.migrArea || SQLCODE || '-' || SQLERRM;
         MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END STORE_INSIS_LOG_LEVEL;


     ------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------
END MIGR_API_COMMON;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_CONTENT_COOP
AS
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PROCEDURE MIGRATE_O_COLLECTION(p_policyRec  IN  OUT   MIGR_GVAR.PolicyRecTyp, p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      v_address_id   NUMBER;
      l_policyRec    MIGR_GVAR.PolicyRecTyp;

      CURSOR c_iaObj (v_OBJECT_ID IA_CONT_COOP_COLLECTION.IA_OBJECT_ID % TYPE) IS
      SELECT iccp.IA_OBJECT_TYPE,
      iccp.IA_HOME_TYPE,
      iccp.IA_HOME_SUBTYPE,
      iccc.IA_COLLECTION_TYPE,
      iccc.IA_PROTECTION_POINTS,
      iccc.IA_PROPERTY_ID,
      iccc.IA_DESCRIPTION,
      iccc.IA_POLICY_REF,
      iccc.IA_NAME,
      iccc.IA_COUNTRY_CODE,
      iccc.IA_CITY,
      iccc.IA_ADDRESS,
      iccc.IA_POST_CODE,
      iccp.IA_IDPLPS
      FROM IA_CONT_COOP_POLICY iccp
      JOIN IA_CONT_COOP_COLLECTION iccc
      ON iccp.IA_OBJECT_ID = iccc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iccc.IA_OBJECT_ID = v_OBJECT_ID;
      v_is_Migrated  BOOLEAN;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN
      l_policyRec:=p_policyRec;
      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Content and Cooperative Collection';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_COOP.MIGRATE_O_COLLECTION';
      l_policyRec.migrRelTbl := 'IA_CONT_COOP_COLLECTION';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');

            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL  OR l_postCode IS NULL OR l_city IS NULL OR l_country_code IS NULL)   THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            IF v_address_id IS NOT NULL  THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            END IF;

            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_COLLECTION_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', r_c_iaObj.IA_DESCRIPTION);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10','' );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            ---20170525 Non-mandatory Attributes participating in calculation formulas should not be null -
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13',NVL(r_c_iaObj.IA_PROTECTION_POINTS,'0'));

            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

             v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

             v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

             EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

             SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            IF v_address_id IS NULL   THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr:=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                  l_policyRec:=  MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  INSERT INTO MIGR_O_CONTENT_COOP (NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                  VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                   END IF;
            END IF;

      END LOOP;
       p_policyRec:=l_policyRec ;
EXCEPTION
WHEN OTHERS THEN
        l_policyRec.logMsg := SQLERRM;
       MIGR_LOG.LOG_EXCEPTION(l_policyRec);
       l_policyRec.continue_migr:=FALSE;
       p_policyRec:=l_policyRec;
END MIGRATE_O_COLLECTION;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_PRIV_ACCIDENT_INS(p_policyRec IN OUT  MIGR_GVAR.PolicyRecTyp)
IS
      l_evres       PLS_INTEGER;
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      v_begintimer  TIMESTAMP WITH TIME ZONE;
      L_MAN_ID      P_PEOPLE.MAN_ID % TYPE;
      v_gender      VARCHAR2(10);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

      CURSOR c_iaObj (v_OBJECT_ID IA_CONT_COOP_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iccp.IA_OBJECT_TYPE,
      iccp.IA_HOME_TYPE,
      iccp.IA_HOME_SUBTYPE,
      iccpi.IA_GNAME,
      iccpi.IA_SNAME,
      iccpi.IA_POLICY_REF,
      iccpi.IA_PID,
      iccpi.IA_AGE,
      iccpi.IA_GENDER,
      iccpi.IA_FULL_NAME,
      iccpi.IA_IND_BENEFICIARY,
      iccpi.IA_BIRTH_DATE,
      iccp.IA_IDPLPS ,
        mc.MAN_ID
      FROM IA_CONT_COOP_POLICY iccp
      JOIN IA_CONT_COOP_PRIVATE_INS iccpi     ON iccp.IA_OBJECT_ID = iccpi.IA_OBJECT_ID
       LEFT JOIN MIGR_CLIENT mc ON mc.EGN=iccpi.IA_PID
      WHERE 1 = 1
      AND iccpi.IA_OBJECT_ID = v_OBJECT_ID;

BEGIN
      l_policyRec := p_policyRec;
      v_begintimer := SYSTIMESTAMP;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Content and Cooperative Private Accident Insured Person';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_COOP.MIGRATE_O_PRIV_ACCIDENT_INS';
      l_policyRec.migrRelTbl := 'IA_CONT_COOP_PRIVATE_INS';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP
          l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
          l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            IF r_c_iaObj.IA_GENDER = 1   THEN   v_gender := 'M';
            ELSE      v_gender := 'F';
            END IF;

         --FA. 20161031 First check if person has been migrated by client migration and if not search INSIS
            IF r_c_iaObj.MAN_ID IS NOT NULL THEN
                 L_MAN_ID:=r_c_iaObj.MAN_ID;
            ELSE
                 L_MAN_ID := MIGR_API_CLIENTS.GET_PEOPLE_BY_PID(r_c_iaObj.IA_PID);

            END IF;

            IF L_MAN_ID IS NOT NULL    THEN
                  l_in_context := NULL;
                  l_out_context := NULL;
                  pio_err := NULL;

                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'AGE', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_SUBTYPE', r_c_iaObj.IA_HOME_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GENDER', v_gender);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP1',  p_policyRec.property_id);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP2', r_c_iaObj.IA_FULL_NAME);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP3', r_c_iaObj.IA_PID);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP4', r_c_iaObj.IA_IND_BENEFICIARY);

                   v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_ACCINSURED');

                   v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                   EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                   SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

                   l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

                   IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
                         l_policyRec.logMsg := 'PIO_ERR INS_ACCINSURED Failed to register OBJECT';
                         MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                         l_policyRec.continue_migr:=FALSE;
                         l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '- FAILED to  register OBJECT';

                   ELSE
                        l_policyRec.logMsg := 'Private Accident InsurEd Person was inserted succesfully with object_id: ' || l_policyRec.object_id;
                        MIGR_LOG.LOG_INFO(l_policyRec);
                        l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                        IF p_policyRec.require_pinsured ='Y' THEN
                            IF  NOT MIGR_API_CLIENTS.ADD_PRIV_INS_PARTICIPANTS(l_policyRec ,L_MAN_ID )THEN
                                    l_policyRec.continue_migr:=FALSE;
                                    l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '- FAILED to  add policy participant';
                              END IF;
                        END IF;


                        IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                              l_policyRec.logMsg := 'INS_ACCINSURED returned with warning -RESULT:' || NULL;
                              MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                       END IF;

                  END IF;
             ELSE
                        l_policyRec.logMsg := 'Failed to call event INS_ACCINSURED due to null MAN_ID';
                        MIGR_LOG.LOG_ERROR(l_policyRec);
                        l_policyRec.continue_migr:=FALSE;

             END IF;

             INSERT INTO MIGR_O_CONTENT_COOP ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl,OBJ_ERROR_LOG             )
             VALUES (r_c_iaObj.IA_FULL_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer,SYSTIMESTAMP,l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
       p_policyRec:=l_policyRec  ;
      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_policyRec);
              l_policyRec.continue_migr:=FALSE;
               p_policyRec:=l_policyRec;
END MIGRATE_O_PRIV_ACCIDENT_INS;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


PROCEDURE MIGRATE_O_CONTENT(p_policyRec  IN  out   MIGR_GVAR.PolicyRecTyp,
p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_Id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;

      CURSOR c_iaObj (v_OBJECT_ID IA_CONT_COOP_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iccp.IA_OBJECT_TYPE,
      iccp.IA_HOME_TYPE,
      iccp.IA_HOME_SUBTYPE,
      iccc.IA_UNION_HOME_INSURANCE,
      iccc.IA_LIVING_AREA,
      iccc.IA_CERTAIN_LOCKS,
      iccc.IA_UNION_NAME,
      iccc.IA_PROPERTY_ID,
      iccc.IA_POLICY_REF,
      iccc.IA_NAME,
      iccc.IA_COUNTRY_CODE,
      iccc.IA_CITY,
      iccc.IA_ADDRESS,
      iccc.IA_POST_CODE,
      iccp.IA_IDPLPS
      FROM IA_CONT_COOP_POLICY iccp
      JOIN IA_CONT_COOP_CONTENT iccc
      ON iccp.IA_OBJECT_ID = iccc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iccc.IA_OBJECT_ID = v_OBJECT_ID;
      v_is_Migrated  BOOLEAN;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN
      l_policyRec := p_policyRec;
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Content and Cooperative Content';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_COOP.MIGRATE_O_CONTENT';
      l_policyRec.migrRelTbl := 'IA_CONT_COOP_CONTENT';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL
            OR l_postCode IS NULL
            OR l_city IS NULL
            OR l_country_code IS NULL)
            THEN
            l_address := p_addressTab(1).r_address;
            l_postCode := p_addressTab(1).r_postCode;
            l_city := p_addressTab(1).r_city;
            l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');

            IF v_address_Id IS NOT NULL   THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            ELSE

                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            END IF;

            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_LIVING_AREA);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', r_c_iaObj.IA_CERTAIN_LOCKS);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', r_c_iaObj.IA_UNION_HOME_INSURANCE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', r_c_iaObj.IA_UNION_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

             v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

             v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            IF v_address_Id IS NULL THEN
                SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                   l_policyRec.continue_migr:=FALSE;
                   l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
             ELSE
                    l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                    MIGR_LOG.LOG_INFO(l_policyRec);

                   l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                          l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                    END IF;

            END IF;
             INSERT INTO MIGR_O_CONTENT_COOP (  NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START,mig_end,IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl  ,OBJ_ERROR_LOG   )
             VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
       p_policyRec:=l_policyRec;
      EXCEPTION
      WHEN OTHERS THEN
            l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr:=FALSE;
            p_policyRec:=l_policyRec;
END MIGRATE_O_CONTENT;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


PROCEDURE MIGRATE_O_SPECIAL_OBJECT(p_policyRec  IN out    MIGR_GVAR.PolicyRecTyp,
 p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_Id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_CONT_COOP_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iccp.IA_OBJECT_TYPE,
      iccp.IA_HOME_TYPE,
      iccp.IA_HOME_SUBTYPE,
      iccsp.IA_PROPERTY_ID,
      iccsp.IA_POLICY_REF,
      iccsp.IA_RISK_TYPE,
      iccsp.IA_DESCRIPTION,
      iccsp.IA_NAME,
      iccsp.IA_COUNTRY_CODE,
      iccsp.IA_CITY,
      iccsp.IA_ADDRESS,
      iccsp.IA_POST_CODE,
      iccsp.IA_EVALUATION_CERTIFICATE,
      iccp.IA_IDPLPS
      FROM IA_CONT_COOP_POLICY iccp
      JOIN IA_CONT_COOP_SPECIAL_OBJ iccsp
      ON iccp.IA_OBJECT_ID = iccsp.IA_OBJECT_ID
      WHERE 1 = 1
      AND iccsp.IA_OBJECT_ID = v_OBJECT_ID;
      v_is_Migrated  BOOLEAN;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Create Object Content and Cooperative Special Object';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_COOP.MIGRATE_O_SPECIAL_OBJECT';
      l_policyRec.migrRelTbl := 'IA_CONT_COOP_SPECIAL_OBJ';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL  OR l_postCode IS NULL   OR l_city IS NULL  OR l_country_code IS NULL)  THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_Id IS NOT NULL     THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_RISK_TYPE );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8',r_c_iaObj.IA_DESCRIPTION );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14',  r_c_iaObj.IA_EVALUATION_CERTIFICATE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);
            IF v_address_Id IS NULL     THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                    l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                     l_policyRec.continue_migr:=FALSE;
                     l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
            ELSE
                   l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                   MIGR_LOG.LOG_INFO(l_policyRec);

                   l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                   IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                   END IF;

            END IF;
             INSERT INTO MIGR_O_CONTENT_COOP (  NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START,MIG_END,IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl ,OBJ_ERROR_LOG  )
             VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
        p_policyRec:=l_policyRec  ;
      EXCEPTION
          WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr:=FALSE;
           p_policyRec:=l_policyRec ;
END MIGRATE_O_SPECIAL_OBJECT;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_STORED_CONTENT(p_policyRec  IN OUT    MIGR_GVAR.PolicyRecTyp,
 p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS

l_in_context   SRVCONTEXT;
l_out_context  SRVCONTEXT;
pio_err        SRVERR;
v_begintimer   TIMESTAMP WITH TIME ZONE;
v_address_id   NUMBER;
l_address      VARCHAR2(256);
l_postCode     VARCHAR2(256);
l_city         VARCHAR2(256);
l_country_code VARCHAR2(256);
l_policyRec    MIGR_GVAR.PolicyRecTyp;
CURSOR c_iaObj (v_OBJECT_ID IA_CONT_COOP_POLICY.IA_OBJECT_ID % TYPE) IS
SELECT iccp.IA_OBJECT_TYPE,
iccp.IA_HOME_TYPE,
iccp.IA_HOME_SUBTYPE,
iccsc.IA_THEFT_ATTRACTIVE,
iccsc.IA_CERTAIN_LOCKS,
iccsc.IA_PROPERTY_ID,
iccsc.IA_STORED_ADDRESS,
iccsc.IA_POLICY_REF,
iccsc.IA_NAME,
iccsc.IA_COUNTRY_CODE,
iccsc.IA_CITY,
iccsc.IA_ADDRESS,
iccsc.IA_POST_CODE,
iccsc.IA_IS_INHABITATED,
iccp.IA_IDPLPS
FROM IA_CONT_COOP_POLICY iccp
JOIN IA_CONT_COOP_STORED_CONTENT iccsc
ON iccp.IA_OBJECT_ID = iccsc.IA_OBJECT_ID
WHERE 1 = 1
AND iccsc.IA_OBJECT_ID = v_OBJECT_ID;
v_is_Migrated  BOOLEAN;
l_evres        PLS_INTEGER;
v_stmst    VARCHAR2( 400);
v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN

      l_policyRec:=p_policyRec;
      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Content and Cooperative Stored Content';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_COOP.MIGRATE_O_STORED_CONTENT';
      l_policyRec.migrRelTbl := 'IA_CONT_COOP_STORED_CONTENT';
      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL  OR l_postCode IS NULL OR l_city IS NULL   OR l_country_code IS NULL) THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', r_c_iaObj.IA_STORED_ADDRESS);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', r_c_iaObj.IA_THEFT_ATTRACTIVE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', r_c_iaObj.IA_CERTAIN_LOCKS);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', r_c_iaObj.IA_IS_INHABITATED);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            IF v_address_id IS NULL THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr:=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';

            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                 l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                      l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                      MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                  END IF;

            END IF;

            INSERT INTO MIGR_O_CONTENT_COOP (NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl ,OBJ_ERROR_LOG)
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
        p_policyRec:=l_policyRec;
EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
      l_policyRec.continue_migr:=FALSE;
        p_policyRec:=l_policyRec  ;
END MIGRATE_O_STORED_CONTENT;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--FA.20160518 Create new objects CONTENT COOPERATIVE
PROCEDURE MIGRATE_O_MISCELLANEOUS(p_policyRec  IN OUT     MIGR_GVAR.PolicyRecTyp,
 p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_CONT_COOP_POLICY iavp
      JOIN IA_CONT_COOP_MISCELLANEOUS iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

BEGIN

        v_begintimer := SYSTIMESTAMP;
        v_address_id := NULL;
        l_policyRec := p_policyRec;
        l_in_context := NULL;
        l_out_context := NULL;
        pio_err := NULL;

        l_policyRec.migrStep := 'Create Object Content and Cooperative Miscellaneous';
        l_policyRec.migrArea := 'MIGR_API_CONTENT_COOP.MIGRATE_O_MISCELLANEOUS';
        l_policyRec.migrRelTbl := 'IA_CONT_COOP_MISCELLANEOUS';

        FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
        LOOP

              l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
              l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
              l_address := r_c_iaObj.IA_ADDRESS;
              l_postCode := r_c_iaObj.IA_POST_CODE;
              l_city := r_c_iaObj.IA_CITY;
              l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

              IF (l_address IS NULL  OR l_postCode IS NULL  OR l_city IS NULL  OR l_country_code IS NULL)  THEN
                    l_address := p_addressTab(1).r_address;
                    l_postCode := p_addressTab(1).r_postCode;
                    l_city := p_addressTab(1).r_city;
                    l_country_code := p_addressTab(1).r_countryCode;
              END IF;

              v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

              SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
              IF v_address_id IS NOT NULL   THEN
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
              ELSE
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

              END IF;
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  l_policyRec.property_id);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '' );
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

              v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

              v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

              EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

              SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

              IF v_address_id IS NULL  THEN
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                    MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
              END IF;

              l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

              IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                    l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                    l_policyRec.continue_migr:=FALSE;
                    l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
              ELSE
                    l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                    MIGR_LOG.LOG_INFO(l_policyRec);

                   l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                    INSERT INTO MIGR_O_CONTENT_COOP ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG  )
                    VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL,l_policyRec.object_fail_log);


                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
                          l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                    END IF ;
              END IF;

    END LOOP;
  p_policyRec:=l_policyRec;
EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr:=FALSE;p_policyRec:=l_policyRec   ;
END MIGRATE_O_MISCELLANEOUS;


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--FA.20160518 Create new objects CONTENT COOPERATIVE
PROCEDURE MIGRATE_O_HOBBY(p_policyRec  IN  OUT   MIGR_GVAR.PolicyRecTyp,
 p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_CONT_COOP_POLICY iavp
      JOIN  IA_CONT_COOP_HOBBY iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

 BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Content and Cooperative Hobby';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_COOP.MIGRATE_O_HOBBY';
      l_policyRec.migrRelTbl := 'IA_CONT_COOP_HOBBY';
      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL
            OR l_postCode IS NULL
            OR l_city IS NULL
            OR l_country_code IS NULL)
            THEN
            l_address := p_addressTab(1).r_address;
            l_postCode := p_addressTab(1).r_postCode;
            l_city := p_addressTab(1).r_city;
            l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');

           IF v_address_id IS NOT NULL  THEN
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '' );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

            IF v_address_id IS NULL    THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;
            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

           IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr:=FALSE;
                   l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
             ELSE
                   l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                   MIGR_LOG.LOG_INFO(l_policyRec);

                   l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                 IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                      l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                      MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                 END IF;

            END IF;

           INSERT INTO MIGR_O_CONTENT_COOP (  NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL ,OBJ_ERROR_LOG   )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL,l_policyRec.object_fail_log);

      END LOOP;
         p_policyRec:=l_policyRec;
      EXCEPTION
            WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
                  MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                  l_policyRec.continue_migr:=FALSE;
                    p_policyRec:=l_policyRec;
END MIGRATE_O_HOBBY;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--FA.20160518 Create new objects CONTENT COOPERATIVE

PROCEDURE MIGRATE_O_EXTENDED_TRAVEL(p_policyRec  IN  OUT   MIGR_GVAR.PolicyRecTyp,
 p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_CONT_COOP_POLICY iavp
      JOIN  IA_CONT_COOP_EXTENDED_TRV iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Content and Cooperative Extended Travel';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_COOP.MIGRATE_O_EXTENDED_TRAVEL';
      l_policyRec.migrRelTbl := 'IA_CONT_COOP_EXTENDED_TRV';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL OR l_postCode IS NULL OR l_city IS NULL OR l_country_code IS NULL) THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL THEN
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '' );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

            IF v_address_id IS NULL THEN
                SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                 l_policyRec.continue_migr:=FALSE;
                l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                  l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                  END IF;
            END IF;

            INSERT INTO MIGR_O_CONTENT_COOP ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL ,OBJ_ERROR_LOG )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL,l_policyRec.object_fail_log);

      END LOOP;
      p_policyRec:=l_policyRec ;
EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);  l_policyRec.continue_migr:=FALSE;
              p_policyRec:=l_policyRec;
END MIGRATE_O_EXTENDED_TRAVEL;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--FA.20160518 Create new objects CONTENT COOPERATIVE

PROCEDURE MIGRATE_O_COOPERATIVE_APART(p_policyRec  IN OUT  MIGR_GVAR.PolicyRecTyp,
 p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
      IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_CONT_COOP_POLICY iavp
      JOIN  IA_CONT_COOP_COOPERATIVE iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Content and Cooperative Apartment';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_COOP.MIGRATE_O_COOPERATIVE_APART';
      l_policyRec.migrRelTbl := 'IA_CONT_COOP_COOPERATIVE';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL  OR l_postCode IS NULL  OR l_city IS NULL  OR l_country_code IS NULL) THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL   THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',  l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '' );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

            IF v_address_id IS NULL   THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr:=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                  MIGR_LOG.LOG_INFO(l_policyRec);
                  l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                  END IF;

            END IF;
            INSERT INTO MIGR_O_CONTENT_COOP ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL ,OBJ_ERROR_LOG)
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL,l_policyRec.object_fail_log);
      END LOOP;
        p_policyRec:=l_policyRec;
      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
      p_policyRec:=l_policyRec ;
END MIGRATE_O_COOPERATIVE_APART;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

FUNCTION MIGRATE_CONTENT_COOP(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)   RETURN MIGR_GVAR.PolicyRecTyp
AS
      v_beginTimer        TIMESTAMP WITH TIME ZONE;
      v_is_obj_ok         BOOLEAN;
      v_address_id        NUMBER;

      CURSOR c_iaObj (vPOLICY_IDPL IA_CONT_COOP_POLICY.IA_IDPL % TYPE) IS
      SELECT ivp.IA_POLICY_REF,
      ivp.IA_IDPL,
      ivp.IA_PSTP,
      ivp.IA_OBJECT_ID,
      ivp.IA_OBJECT_TYPE,
      ia.IA_ADDRESS,
      ia.IA_CITY,
      ia.IA_POST_CODE,
      ia.IA_COUNTRY,
     --FA 20161007 no needed check mov.object_id,  mov.INS_OBJECT_ID ,
      ivp.IA_OBJ_DEDUCT
      FROM IA_CONT_COOP_POLICY ivp
     --FA 20161007 no needed check LEFT JOIN MIGR_O_CONTENT_COOP mov  ON ivp.IA_OBJECT_ID = mov.IA_OBJECT_ID
      JOIN IA_ADDRESS ia
      ON ia.IA_IDPL = ivp.IA_IDPL
      WHERE 1 = 1
      AND ivp.IA_IDPL = vPOLICY_IDPL
      ORDER BY SUBSTR(ivp.IA_OBJECT_ID, LENGTH(ivp.IA_OBJECT_ID)) ASC;

      r_c_iaObj           c_iaObj % ROWTYPE;
      l_policyRec         MIGR_GVAR.PolicyRecTyp;
      vPropertyAddressTab MIGR_GVAR.PropertyAddressTabTyp;
BEGIN

      l_policyRec := p_policyRec;
      vPropertyAddressTab.DELETE();
      l_policyRec.migrArea := 'MIGR_API_CONTENT_COOP_NEW.MIGRATE_CONTENT_COOP';
      l_policyRec.migrStep := 'Create Policy Content Coop';
      l_policyRec.migrRelTbl := 'IA_CONT_COOP_POLICY';

      OPEN c_iaObj (l_policyRec.policy_idpl);
      << content_coop_loop >>
      LOOP

            FETCH c_iaObj INTO r_c_iaObj;
            EXIT WHEN c_iaObj % NOTFOUND;

            --add default client address
            MIGR_API_COMMON.ADD_ADDRESS_ID(vPropertyAddressTab, NULL, r_c_iaObj.IA_ADDRESS, r_c_iaObj.IA_POST_CODE, r_c_iaObj.IA_CITY, r_c_iaObj.IA_COUNTRY);

         --FA 20161007 no needed check   IF r_c_iaObj.object_id IS NULL  AND r_c_iaObj.INS_OBJECT_ID IS NULL THEN

                  l_policyRec.IA_OBJECT_ID := r_c_iaObj.IA_OBJECT_ID;
                  --FA.2060912 Added for cover level functionality
                   l_policyRec.objDeduct_val :=    r_c_iaObj.IA_OBJ_DEDUCT;
                  CASE r_c_iaObj.IA_OBJECT_TYPE
                        WHEN '452' THEN  ---Content
                        MIGRATE_O_CONTENT(l_policyRec, vPropertyAddressTab);

                        WHEN '2101' THEN  ---Stored Content
                        MIGRATE_O_STORED_CONTENT(l_policyRec, vPropertyAddressTab);

                        WHEN '2201' THEN  ---Collection
                        MIGRATE_O_COLLECTION(l_policyRec, vPropertyAddressTab);

                        WHEN '2301' THEN  ---Special Object
                        MIGRATE_O_SPECIAL_OBJECT(l_policyRec, vPropertyAddressTab);

                        WHEN '451' THEN  ---Private Accident Insured Person
                        MIGRATE_O_PRIV_ACCIDENT_INS(l_policyRec);

                        WHEN '2401' THEN  ---MISCELLANEOUS
                        MIGRATE_O_MISCELLANEOUS(l_policyRec, vPropertyAddressTab);

                        WHEN '2501' THEN  ---HOBBY
                        MIGRATE_O_HOBBY(l_policyRec, vPropertyAddressTab);

                        WHEN '2601' THEN  ---EXTENDED_TRAVEL
                        MIGRATE_O_EXTENDED_TRAVEL(l_policyRec, vPropertyAddressTab);

                        WHEN '2701' THEN  ---EXTENDED_TRAVEL
                        MIGRATE_O_COOPERATIVE_APART(l_policyRec, vPropertyAddressTab);

                        ELSE
                              l_policyRec.logMsg := 'Content and Cooperative object with  ' || r_c_iaObj.IA_OBJECT_ID || ' failed due to invalid object type';
                              MIGR_LOG.LOG_ERROR(l_policyRec);
                              l_policyRec.continue_migr:=FALSE;
                              l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED due  invalid object type';
                              INSERT INTO MIGR_O_CONTENT_COOP ( POLICY_ID, OBJECT_ID,  INS_DATE,   MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                              VALUES ( l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, SYSDATE, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

                  END CASE;

      END LOOP content_coop_loop;

      CLOSE c_iaObj;
       RETURN l_policyRec;
      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
      l_policyRec.continue_migr:=FALSE;
       RETURN l_policyRec;
END MIGRATE_CONTENT_COOP;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


END MIGR_API_CONTENT_COOP;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_CONTENT_ONLY
  AS
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE MIGRATE_O_COLLECTION(p_policyRec  IN  OUT  MIGR_GVAR.PolicyRecTyp,
                                 p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      v_address_id   NUMBER;
      l_policyRec    MIGR_GVAR.PolicyRecTyp;

      CURSOR c_iaObj (v_OBJECT_ID IA_CONTENT_ONLY_COLLECTION.IA_OBJECT_ID % TYPE) IS
      SELECT icop.IA_OBJECT_TYPE,
      icop.IA_HOME_TYPE,
      icop.IA_HOME_SUBTYPE,
      iccc.IA_COLLECTION_TYPE,
      iccc.IA_PROTECTION_POINTS,
      iccc.IA_PROPERTY_ID,
      iccc.IA_DESCRIPTION,
      iccc.IA_POLICY_REF,
      iccc.IA_NAME,
      iccc.IA_COUNTRY_CODE,
      iccc.IA_CITY,
      iccc.IA_ADDRESS,
      iccc.IA_POST_CODE,
      icop.IA_IDPLPS
      FROM IA_CONTENT_ONLY_POLICY icop
      JOIN IA_CONTENT_ONLY_COLLECTION iccc
      ON icop.IA_OBJECT_ID = iccc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iccc.IA_OBJECT_ID = v_OBJECT_ID;
      v_is_Migrated  BOOLEAN;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
      BEGIN
          l_policyRec := p_policyRec;
          v_begintimer := SYSTIMESTAMP;
          v_address_id := NULL;
          l_in_context := NULL;
          l_out_context := NULL;
          pio_err := NULL;
          l_policyRec.migrStep := 'Create Object Content Only Collection';
          l_policyRec.migrArea := 'MIGR_API_CONTENT_ONLY.MIGRATE_O_COLLECTION';
          l_policyRec.migrRelTbl := 'IA_CONTENT_ONLY_COLLECTION';

          FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)   LOOP

          l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
          l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');

          l_address := r_c_iaObj.IA_ADDRESS;
          l_postCode := r_c_iaObj.IA_POST_CODE;
          l_city := r_c_iaObj.IA_CITY;
          l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

          IF (l_address IS NULL   OR l_postCode IS NULL   OR l_city IS NULL    OR l_country_code IS NULL)   THEN
                l_address := p_addressTab(1).r_address;
                l_postCode := p_addressTab(1).r_postCode;
                l_city := p_addressTab(1).r_city;
                l_country_code := p_addressTab(1).r_countryCode;
          END IF;

          v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

          IF v_address_id IS NOT NULL   THEN
              SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
          ELSE
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
          END IF;
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_COLLECTION_TYPE);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', r_c_iaObj.IA_DESCRIPTION);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
          ---20170525 Non-mandatory Attributes participating in calculation formulas should not be null
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', NVL(r_c_iaObj.IA_PROTECTION_POINTS,'0'));

          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');


          v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

          v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
          EXECUTE IMMEDIATE v_stmst
          USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;
          SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

          IF v_address_id IS NULL    THEN
              SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
              MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
          END IF;

          l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

          IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                 l_policyRec.continue_migr:=FALSE;
                l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
          ELSE
                l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                MIGR_LOG.LOG_INFO(l_policyRec);

                l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                IF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
                      l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                      MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
               END IF;

          END IF;

          INSERT INTO MIGR_O_CONTENT_ONLY ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END,  IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl   ,OBJ_ERROR_LOG  )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

          END LOOP;
           p_policyRec:=l_policyRec;
      EXCEPTION
          WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_policyRec);
               l_policyRec.continue_migr:=FALSE;
              p_policyRec:=l_policyRec;
    END MIGRATE_O_COLLECTION;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_PRIV_ACCIDENT_INS(p_policyRec IN OUT  MIGR_GVAR.PolicyRecTyp   )
    IS
      l_evres       PLS_INTEGER;
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      v_begintimer  TIMESTAMP WITH TIME ZONE;
      L_MAN_ID      P_PEOPLE.MAN_ID % TYPE;
      v_gender      VARCHAR2(10);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

      CURSOR c_iaObj (v_OBJECT_ID IA_CONTENT_ONLY_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT icop.IA_OBJECT_TYPE,
      icop.IA_HOME_TYPE,
      icop.IA_HOME_SUBTYPE,
      icopi.IA_GNAME,
      icopi.IA_SNAME,
      icopi.IA_NAME,
      icopi.IA_POLICY_REF,
      icopi.IA_PID,
      icopi.IA_AGE,
      icopi.IA_GENDER,
      icopi.IA_FULL_NAME,
      icopi.IA_IND_BENEFICIARY,
      icopi.IA_BIRTH_DATE,
      icop.IA_IDPLPS ,
      mc.MAN_ID
      FROM IA_CONTENT_ONLY_POLICY icop
      JOIN IA_CONTENT_ONLY_PRIVATE_INS icopi   ON icop.IA_OBJECT_ID = icopi.IA_OBJECT_ID
      LEFT JOIN MIGR_CLIENT mc ON mc.EGN=icopi.IA_PID
      WHERE 1 = 1
      AND icopi.IA_OBJECT_ID = v_OBJECT_ID;

   BEGIN
      l_policyRec := p_policyRec;
      v_begintimer := SYSTIMESTAMP;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;


      l_policyRec.migrStep := 'Create Object Content Only Private Accident Insured Person';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_ONLY.MIGRATE_O_PRIV_ACCIDENT_INS';
      l_policyRec.migrRelTbl := 'IA_CONTENT_ONLY_PRIVATE_INS';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)   LOOP
            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            IF r_c_iaObj.IA_GENDER = 1  THEN    v_gender := 'M';
            ELSE   v_gender := 'F';    END IF;

             --FA. 20161031 First check if person has been migrated by client migration and if not search INSIS
             IF r_c_iaObj.MAN_ID IS NOT NULL THEN
                 L_MAN_ID:=r_c_iaObj.MAN_ID;
             ELSE
                  L_MAN_ID := MIGR_API_CLIENTS.GET_PEOPLE_BY_PID(r_c_iaObj.IA_PID);

                  l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);


            END IF;

            IF L_MAN_ID IS NOT NULL  THEN
                  l_in_context := NULL;
                  l_out_context := NULL;
                  pio_err := NULL;

                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'AGE', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_SUBTYPE', r_c_iaObj.IA_HOME_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GENDER', v_gender);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP1',  p_policyRec.property_id);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP2', r_c_iaObj.IA_FULL_NAME);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP3', r_c_iaObj.IA_PID);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP4', r_c_iaObj.IA_IND_BENEFICIARY);

                  v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('INS_ACCINSURED');

                  v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
                  EXECUTE IMMEDIATE v_stmst
                  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                  SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

                  l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

                 IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
                         l_policyRec.logMsg := 'PIO_ERR INS_ACCINSURED Failed to register OBJECT';
                        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                         l_policyRec.continue_migr:=FALSE;
                         l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '- FAILED to  register OBJECT';
                 ELSE
                        l_policyRec.logMsg := 'Private Accident Insurd Person was inserted succesfully with object_id: ' || l_policyRec.object_id;
                        MIGR_LOG.LOG_INFO(l_policyRec);

                        l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                          IF    p_policyRec.require_pinsured ='Y' THEN
                                IF  NOT MIGR_API_CLIENTS.ADD_PRIV_INS_PARTICIPANTS(l_policyRec ,L_MAN_ID )THEN
                                      l_policyRec.continue_migr:=FALSE;
                                      l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '- FAILED to  add policy participant';
                                END IF;
                          END IF;
                        IF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
                              l_policyRec.logMsg := 'INS_ACCINSURED returned with warning -RESULT:' || NULL;
                              MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                        END IF;

                  END IF;
            ELSE

                  l_policyRec.logMsg := 'Failed to call event INS_ACCINSURED due to null MAN_ID';
                  MIGR_LOG.LOG_ERROR(l_policyRec);
                  l_policyRec.continue_migr:=FALSE;
                  l_policyRec.object_fail_log  :=l_policyRec.object_fail_log|| '-Failed to Insert accident insured';
            END IF;

            INSERT INTO MIGR_O_CONTENT_ONLY ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl   ,OBJ_ERROR_LOG  )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
       p_policyRec:=l_policyRec;
      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
       l_policyRec.continue_migr:=FALSE;
      p_policyRec:=l_policyRec;

    END MIGRATE_O_PRIV_ACCIDENT_INS;
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  PROCEDURE MIGRATE_O_CONTENT(p_policyRec  IN OUT    MIGR_GVAR.PolicyRecTyp,
                              p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
            l_in_context   SRVCONTEXT;
            l_out_context  SRVCONTEXT;
            pio_err        SRVERR;
            v_begintimer   TIMESTAMP WITH TIME ZONE;
            v_address_Id   NUMBER;
            l_address      VARCHAR2(256);
            l_postCode     VARCHAR2(256);
            l_city         VARCHAR2(256);
            l_country_code VARCHAR2(256);
            l_policyRec    MIGR_GVAR.PolicyRecTyp;

            CURSOR c_iaObj (v_OBJECT_ID IA_CONTENT_ONLY_POLICY.IA_OBJECT_ID % TYPE) IS
            SELECT iccp.IA_OBJECT_TYPE,
            iccp.IA_HOME_TYPE,
            iccp.IA_HOME_SUBTYPE,
            iccc.IA_UNION_HOME_INSURANCE,
            iccc.IA_LIVING_AREA,
            iccc.IA_CERTAIN_LOCKS,
            iccc.IA_UNION_NAME,
            iccc.IA_PROPERTY_ID,
            iccc.IA_POLICY_REF,
            iccc.IA_NAME,
            iccc.IA_COUNTRY_CODE,
            iccc.IA_CITY,
            iccc.IA_ADDRESS,
            iccc.IA_POST_CODE,
            iccp.IA_IDPLPS
            FROM IA_CONTENT_ONLY_POLICY iccp
            JOIN IA_CONTENT_ONLY_CONTENT iccc
            ON iccp.IA_OBJECT_ID = iccc.IA_OBJECT_ID
            WHERE 1 = 1
            AND iccc.IA_OBJECT_ID = v_OBJECT_ID;
            v_is_Migrated  BOOLEAN;
            l_evres        PLS_INTEGER;
            v_stmst    VARCHAR2( 400);
            v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
      BEGIN
            l_policyRec := p_policyRec;
            v_begintimer := SYSTIMESTAMP;
            v_address_Id := NULL;
            l_in_context := NULL;
            l_out_context := NULL;
            pio_err := NULL;

            l_policyRec.migrStep := 'Create Object Content Only Content';
            l_policyRec.migrArea := 'MIGR_API_CONTENT_ONLY.MIGRATE_O_CONTENT';
            l_policyRec.migrRelTbl := 'IA_CONTENT_ONLY_CONTENT';

            FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)    LOOP

                  l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
                  l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

                  l_address := r_c_iaObj.IA_ADDRESS;
                  l_postCode := r_c_iaObj.IA_POST_CODE;
                  l_city := r_c_iaObj.IA_CITY;
                  l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

                  IF (l_address IS NULL  OR l_postCode IS NULL   OR l_city IS NULL   OR l_country_code IS NULL)  THEN
                        l_address := p_addressTab(1).r_address;
                        l_postCode := p_addressTab(1).r_postCode;
                        l_city := p_addressTab(1).r_city;
                        l_country_code := p_addressTab(1).r_countryCode;
                  END IF;

                  v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');

                  IF v_address_Id IS NOT NULL  THEN
                        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
                  ELSE

                        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
                  END IF;

                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_LIVING_AREA);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', r_c_iaObj.IA_CERTAIN_LOCKS);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', r_c_iaObj.IA_UNION_HOME_INSURANCE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', r_c_iaObj.IA_UNION_NAME);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

                  v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

                  v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
                  EXECUTE IMMEDIATE v_stmst
                  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                  SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

                  IF v_address_Id IS NULL            THEN
                        SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                        MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
                  END IF;

                  l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

                  IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                        l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                         l_policyRec.continue_migr:=FALSE;
                        l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';

                 ELSE
                       l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                        MIGR_LOG.LOG_INFO(l_policyRec);

                         l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                       IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                        END IF;
                  END IF;
                  INSERT INTO MIGR_O_CONTENT_ONLY ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl   ,OBJ_ERROR_LOG  )
                  VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

            END LOOP;
             p_policyRec:=l_policyRec;
      EXCEPTION
            WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
                  MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                  l_policyRec.continue_migr:=FALSE;
                  p_policyRec:=l_policyRec;
    END MIGRATE_O_CONTENT;

  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------


  PROCEDURE MIGRATE_O_SPECIAL_OBJECT(p_policyRec  IN  OUT   MIGR_GVAR.PolicyRecTyp,
                                     p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_Id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_CONTENT_ONLY_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iccp.IA_OBJECT_TYPE,
                 iccp.IA_HOME_TYPE,
                 iccp.IA_HOME_SUBTYPE,
                 iccsp.IA_PROPERTY_ID,
                 iccsp.IA_POLICY_REF,
                 iccsp.IA_RISK_TYPE,
                 iccsp.IA_DESCRIPTION,
                 iccsp.IA_NAME,
                 iccsp.IA_COUNTRY_CODE,
                 iccsp.IA_CITY,
                 iccsp.IA_ADDRESS,
                 iccsp.IA_POST_CODE,
                 iccsp.IA_EVALUATION_CERTIFICATE,
                 iccp.IA_IDPLPS
            FROM IA_CONTENT_ONLY_POLICY iccp
              JOIN IA_CONTENT_ONLY_SPECIAL_OBJ iccsp
                ON iccp.IA_OBJECT_ID = iccsp.IA_OBJECT_ID
            WHERE 1 = 1
              AND iccsp.IA_OBJECT_ID = v_OBJECT_ID;
      v_is_Migrated  BOOLEAN;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN
          v_begintimer := SYSTIMESTAMP;
          v_address_Id := NULL;
          l_in_context := NULL;
          l_out_context := NULL;
          pio_err := NULL;
          l_policyRec := p_policyRec;
          l_policyRec.migrStep := 'Create Object Content Only Special Object';
          l_policyRec.migrArea := 'MIGR_API_CONTENT_ONLY.MIGRATE_O_SPECIAL_OBJECT';
          l_policyRec.migrRelTbl := 'IA_CONTENT_ONLY_SPECIAL_OBJ';

          FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)   LOOP

                l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
                l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

                l_address := r_c_iaObj.IA_ADDRESS;
                l_postCode := r_c_iaObj.IA_POST_CODE;
                l_city := r_c_iaObj.IA_CITY;
                l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

                IF (l_address IS NULL    OR l_postCode IS NULL  OR l_city IS NULL  OR l_country_code IS NULL)    THEN
                      l_address := p_addressTab(1).r_address;
                      l_postCode := p_addressTab(1).r_postCode;
                      l_city := p_addressTab(1).r_city;
                      l_country_code := p_addressTab(1).r_countryCode;
                END IF;

                v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
                IF v_address_Id IS NOT NULL THEN
                      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
                ELSE
                      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
                END IF;
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_RISK_TYPE);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', r_c_iaObj.IA_DESCRIPTION);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', r_c_iaObj.IA_EVALUATION_CERTIFICATE);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

                v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

                v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);
                IF v_address_Id IS NULL    THEN
                      SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                      MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
                END IF;

                l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

                IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                      l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                      MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                      l_policyRec.continue_migr:=FALSE;
                      l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';

               ELSE
                     l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                      MIGR_LOG.LOG_INFO(l_policyRec);
                      l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);


                      IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                            l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                      END IF;
                END IF;
                INSERT INTO MIGR_O_CONTENT_ONLY ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl   ,OBJ_ERROR_LOG  )
                VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

          END LOOP;
            p_policyRec:=l_policyRec;
      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr:=FALSE;
            p_policyRec:=l_policyRec;
    END MIGRATE_O_SPECIAL_OBJECT;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  PROCEDURE MIGRATE_O_STORED_CONTENT(p_policyRec  IN  OUT   MIGR_GVAR.PolicyRecTyp,
                                     p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_CONTent_ONLY_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iccp.IA_OBJECT_TYPE,
                 iccp.IA_HOME_TYPE,
                 iccp.IA_HOME_SUBTYPE,
                 iccsc.IA_THEFT_ATTRACTIVE,
                 iccsc.IA_CERTAIN_LOCKS,
                 iccsc.IA_PROPERTY_ID,
                 iccsc.IA_STORED_ADDRESS,
                 iccsc.IA_POLICY_REF,
                 iccsc.IA_NAME,
                 iccsc.IA_COUNTRY_CODE,
                 iccsc.IA_CITY,
                 iccsc.IA_ADDRESS,
                 iccsc.IA_POST_CODE,
                 iccsc.IA_IS_INHABITATED,
                 iccp.IA_IDPLPS
            FROM IA_CONTENT_ONLY_POLICY iccp
              JOIN IA_CONTENT_ONLY_STORED_CONTENT iccsc
                ON iccp.IA_OBJECT_ID = iccsc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iccsc.IA_OBJECT_ID = v_OBJECT_ID;
      v_is_Migrated  BOOLEAN;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      l_policyRec := p_policyRec;
      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Content Only Stored Content';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_ONLY.MIGRATE_O_STORED_CONTENT';
      l_policyRec.migrRelTbl := 'IA_CONTENT_ONLY_STORED_CONTENT';
      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

              l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
              l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

              l_address := r_c_iaObj.IA_ADDRESS;
              l_postCode := r_c_iaObj.IA_POST_CODE;
              l_city := r_c_iaObj.IA_CITY;
              l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

              IF (l_address IS NULL  OR l_postCode IS NULL   OR l_city IS NULL   OR l_country_code IS NULL)   THEN
                    l_address := p_addressTab(1).r_address;
                    l_postCode := p_addressTab(1).r_postCode;
                    l_city := p_addressTab(1).r_city;
                    l_country_code := p_addressTab(1).r_countryCode;
              END IF;

              v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

              SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
              IF v_address_id IS NOT NULL  THEN
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
              ELSE
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

              END IF;
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', r_c_iaObj.IA_STORED_ADDRESS);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', r_c_iaObj.IA_THEFT_ATTRACTIVE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', r_c_iaObj.IA_CERTAIN_LOCKS);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', r_c_iaObj.IA_IS_INHABITATED);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');
                 v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

              v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
              EXECUTE IMMEDIATE v_stmst
              USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

              SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

              IF v_address_id IS NULL       THEN
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                    MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
              END IF;

              l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

              IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                    l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                    l_policyRec.continue_migr:=FALSE;
                    l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
              ELSE
                    l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                    MIGR_LOG.LOG_INFO(l_policyRec);

                   l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                    END IF;
              END IF;

              INSERT INTO MIGR_O_CONTENT_ONLY ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl   ,OBJ_ERROR_LOG  )
              VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
      p_policyRec:=l_policyRec;
      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr:=FALSE;
            p_policyRec:=l_policyRec;
    END MIGRATE_O_STORED_CONTENT;
  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  --FA.20160518 Create new objects CONTENT COOPERATIVE
  PROCEDURE MIGRATE_O_MISCELLANEOUS(p_policyRec  IN OUT    MIGR_GVAR.PolicyRecTyp,
                                    p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavc.IA_PROPERTY_ID,
                 iavc.IA_POLICY_REF,
                 iavc.IA_ADDRESS,
                 iavc.IA_POST_CODE,
                 iavc.IA_CITY,
                 iavc.IA_COUNTRY_CODE,
                 iavc.IA_NAME
            FROM IA_CONTENT_ONLY_POLICY iavp
              JOIN IA_CONTENT_ONLY_MISCELLANEOUS iavc
                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

    BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Content Only Miscellaneous';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_ONLY.MIGRATE_O_MISCELLANEOUS';
      l_policyRec.migrRelTbl := 'IA_CONTENT_ONLY_MISCELLANEOUS';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL  OR l_postCode IS NULL   OR l_city IS NULL   OR l_country_code IS NULL)   THEN
            l_address := p_addressTab(1).r_address;
            l_postCode := p_addressTab(1).r_postCode;
            l_city := p_addressTab(1).r_city;
            l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL
            THEN
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');
           v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
            EXECUTE IMMEDIATE v_stmst
            USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;
            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

            IF v_address_id IS NULL  THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr:=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                 l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING      THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);

                  END IF;
            END IF;
            INSERT INTO MIGR_O_CONTENT_ONLY ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl   ,OBJ_ERROR_LOG  )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
       p_policyRec:=l_policyRec;
      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr:=FALSE;
            p_policyRec:=l_policyRec;
    END MIGRATE_O_MISCELLANEOUS;


  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  --FA.20160518 Create new objects CONTENT COOPERATIVE
  PROCEDURE MIGRATE_O_HOBBY(p_policyRec  IN OUT    MIGR_GVAR.PolicyRecTyp,
                            p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavc.IA_PROPERTY_ID,
                 iavc.IA_POLICY_REF,
                 iavc.IA_ADDRESS,
                 iavc.IA_POST_CODE,
                 iavc.IA_CITY,
                 iavc.IA_COUNTRY_CODE,
                 iavc.IA_NAME
            FROM IA_CONTENT_ONLY_POLICY iavp
              JOIN IA_CONTENT_ONLY_HOBBY iavc
                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

    BEGIN
        v_begintimer := SYSTIMESTAMP;
        v_address_id := NULL;
        l_policyRec := p_policyRec;
        l_in_context := NULL;
        l_out_context := NULL;
        pio_err := NULL;

        l_policyRec.migrStep := 'Create Object Content Only Hobby';
        l_policyRec.migrArea := 'MIGR_API_CONTENT_ONLY.MIGRATE_O_HOBBY';
        l_policyRec.migrRelTbl := 'IA_CONTENT_ONLY_HOBBY';
        FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
        LOOP

              l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
              l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
              l_address := r_c_iaObj.IA_ADDRESS;
              l_postCode := r_c_iaObj.IA_POST_CODE;
              l_city := r_c_iaObj.IA_CITY;
              l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

              IF (l_address IS NULL   OR l_postCode IS NULL   OR l_city IS NULL   OR l_country_code IS NULL)  THEN
                    l_address := p_addressTab(1).r_address;
                    l_postCode := p_addressTab(1).r_postCode;
                    l_city := p_addressTab(1).r_city;
                    l_country_code := p_addressTab(1).r_countryCode;
              END IF;
              v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

              SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
              IF v_address_id IS NOT NULL  THEN
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
              ELSE
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

              END IF;
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

              v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

              v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

              EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

              SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

              IF v_address_id IS NULL  THEN
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                    MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
              END IF;
              l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

             IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                    l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                    l_policyRec.continue_migr:=FALSE;
                    l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
             ELSE
                    l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                    MIGR_LOG.LOG_INFO(l_policyRec);

                    l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);
                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
                          l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                    END IF;
              END IF;
              INSERT INTO MIGR_O_CONTENT_ONLY ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl   ,OBJ_ERROR_LOG  )
              VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

        END LOOP;
          p_policyRec:=l_policyRec;
        EXCEPTION
              WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_policyRec);
              l_policyRec.continue_migr:=FALSE;
             p_policyRec:=l_policyRec;
    END MIGRATE_O_HOBBY;

  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  --FA.20160518 Create new objects CONTENT COOPERATIVE

  PROCEDURE MIGRATE_O_EXTENDED_TRAVEL(p_policyRec  IN  OUT   MIGR_GVAR.PolicyRecTyp,
                                      p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavc.IA_PROPERTY_ID,
                 iavc.IA_POLICY_REF,
                 iavc.IA_ADDRESS,
                 iavc.IA_POST_CODE,
                 iavc.IA_CITY,
                 iavc.IA_COUNTRY_CODE,
                 iavc.IA_NAME
            FROM IA_CONTENT_ONLY_POLICY iavp
              JOIN IA_CONTENT_ONLY_EXTENDED_TRV iavc
                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Content Only Extended Travel';
      l_policyRec.migrArea := 'MIGR_API_CONTENT_ONLY.MIGRATE_O_EXTENDED_TRAVEL';
      l_policyRec.migrRelTbl := 'IA_CONTENT_ONLY_EXTENDED_TRV';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL   OR l_postCode IS NULL  OR l_city IS NULL   OR l_country_code IS NULL)   THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL    THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

            IF v_address_id IS NULL   THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr:=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                  MIGR_LOG.LOG_INFO(l_policyRec);
                   l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                  END IF;


            END IF;
            INSERT INTO MIGR_O_CONTENT_ONLY ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START,MIG_END,IA_OBJECT_ID, MIG_BATCH_ID, policy_idpl   ,OBJ_ERROR_LOG  )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
       p_policyRec:=l_policyRec;
EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr:=FALSE;
            p_policyRec:=l_policyRec;
    END MIGRATE_O_EXTENDED_TRAVEL;

  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  --FA.20160518 Create new objects CONTENT COOPERATIVE

--  PROCEDURE MIGRATE_O_COOPERATIVE_APART(p_policyRec  IN     MIGR_API_COMMON.PolicyRecTyp,
--                                        p_addressTab IN OUT MIGR_API_COMMON.PropertyAddressTabTyp,
--                                        p_is_obj_ok  OUT    BOOLEAN)
--    IS
--      l_in_context   SRVCONTEXT;
--      l_out_context  SRVCONTEXT;
--      pio_err        SRVERR;
--      v_begintimer   TIMESTAMP WITH TIME ZONE;
--      v_address_id   NUMBER;
--      l_address      VARCHAR2(256);
--      l_postCode     VARCHAR2(256);
--      l_city         VARCHAR2(256);
--      l_country_code VARCHAR2(256);
--      l_policyRec    MIGR_API_COMMON.PolicyRecTyp;
--      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
--          SELECT iavp.IA_OBJECT_TYPE,
--                 iavp.IA_IDPLPS,
--                 iavp.IA_HOME_TYPE,
--                 iavp.IA_HOME_SUBTYPE,
--                 iavc.IA_PROPERTY_ID,
--                 iavc.IA_POLICY_REF,
--                 iavc.IA_ADDRESS,
--                 iavc.IA_POST_CODE,
--                 iavc.IA_CITY,
--                 iavc.IA_COUNTRY_CODE,
--                 iavc.IA_NAME
--            FROM IA_CONT_COOP_POLICY iavp
--              JOIN IA_CONT_COOP_COOPERATIVE iavc
--                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
--            WHERE 1 = 1
--              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
--      l_evres        PLS_INTEGER;
--
--    BEGIN
--
--      v_begintimer := SYSTIMESTAMP;
--      v_address_id := NULL;
--      l_policyRec := p_policyRec;
--      l_in_context := NULL;
--      l_out_context := NULL;
--      pio_err := NULL;
--
--      l_policyRec.migrStep := 'Create Object Content and Cooperative Apartment';
--      l_policyRec.migrArea := 'MIGR_API_CONTENT_COOP.MIGRATE_O_COOPERATIVE_APART';
--      l_policyRec.migrRelTbl := 'IA_CONT_COOP_COOPERATIVE';
--
--      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
--      LOOP
--        p_is_obj_ok := FALSE;
--        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
--        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
--        l_address := r_c_iaObj.IA_ADDRESS;
--        l_postCode := r_c_iaObj.IA_POST_CODE;
--        l_city := r_c_iaObj.IA_CITY;
--        l_country_code := r_c_iaObj.IA_COUNTRY_CODE;
--
--        IF (l_address IS NULL
--          OR l_postCode IS NULL
--          OR l_city IS NULL
--          OR l_country_code IS NULL)
--        THEN
--          l_address := p_addressTab(1).r_address;
--          l_postCode := p_addressTab(1).r_postCode;
--          l_city := p_addressTab(1).r_city;
--          l_country_code := p_addressTab(1).r_countryCode;
--        END IF;
--
--        v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);
--
--        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
--        IF v_address_id IS NOT NULL
--        THEN
--          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
--        ELSE
--          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
--          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
--          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
--          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
--          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
--
--        END IF;
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
--        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');
--
--        MIGR_SYSTEM.CALL_EVENT('INS_PROPERTY', l_in_context, MIGR_API_COMMON.GV_DEBUG, l_out_context, pio_err);
--
--        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);
--
--
--        IF v_address_id IS NULL
--        THEN
--          SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
--          MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
--        END IF;
--
--
--        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);
--
--        IF l_evres = MIGR_API_COMMON.GV_EVRES_SUCCESS
--        THEN
--          l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
--          IF MIGR_LOG.GV_DEBUG_INFO
--          THEN
--            MIGR_LOG.LOG_INFO(l_policyRec);
--          END IF;
--          MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec, p_is_obj_ok);
--          IF p_is_obj_ok
--          THEN
--            INSERT INTO MIGR_O_CONTENT_COOP (
--              NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL
--            )
--            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL);
--
--            p_is_obj_ok := TRUE;
--
--          END IF;
--        ELSIF l_evres = MIGR_API_COMMON.GV_EVRES_WARNING
--        THEN
--
--          l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
--          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
--
--        ELSE
--
--          l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
--          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
--          MIGR_LOG.LOG_FAILED_POLICY(l_policyRec);
--        END IF;
--
--      END LOOP;
--
--    EXCEPTION
--      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
--          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
--    END MIGRATE_O_COOPERATIVE_APART;



  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

FUNCTION MIGRATE_CONTENT_ONLY(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)
RETURN  MIGR_GVAR.PolicyRecTyp
AS
      v_in_context        SRVCONTEXT;
      v_out_context       SRVCONTEXT;
      v_errmsg            SRVERRMSG;
      v_srverrmsg         SRVERRMSG;
      pio_err             SRVERR;
      v_beginTimer        TIMESTAMP WITH TIME ZONE;
      v_is_obj_ok         BOOLEAN;
      v_address_id        NUMBER;

      CURSOR c_iaObj (vPOLICY_IDPL IA_CONTENT_ONLY_POLICY.IA_IDPL % TYPE) IS
      SELECT ivp.IA_POLICY_REF,
      ivp.IA_IDPL,
      ivp.IA_PSTP,
      ivp.IA_OBJECT_ID,
      ivp.IA_OBJECT_TYPE,
      ivp.IA_OBJ_DEDUCT,
      ia.IA_ADDRESS,
      ia.IA_CITY,
      ia.IA_POST_CODE,
      ia.IA_COUNTRY
      --FA 20161007 no needed check mov.object_id, mov.INS_OBJECT_ID
      FROM IA_CONTENT_ONLY_POLICY ivp
     --FA 20161007 no needed check  LEFT JOIN MIGR_O_CONTENT_ONLY mov ON ivp.IA_OBJECT_ID = mov.IA_OBJECT_ID
      JOIN IA_ADDRESS ia
      ON ia.IA_IDPL = ivp.IA_IDPL
      WHERE 1 = 1
      AND ivp.IA_IDPL = vPOLICY_IDPL
      ORDER BY SUBSTR(ivp.IA_OBJECT_ID, LENGTH(ivp.IA_OBJECT_ID)) ASC;

      r_c_iaObj           c_iaObj % ROWTYPE;
      l_policyRec         MIGR_GVAR.PolicyRecTyp;
      vPropertyAddressTab MIGR_GVAR.PropertyAddressTabTyp;
BEGIN

      l_policyRec := p_policyRec;
      vPropertyAddressTab.DELETE();
      l_policyRec.migrArea := 'MIGR_API_CONTENT_ONLY.MIGRATE_CONTENT_ONLY';
      l_policyRec.migrStep := 'Create Policy Content Only';
      l_policyRec.migrRelTbl := 'IA_CONTENT_ONLY_POLICY';


      OPEN c_iaObj (l_policyRec.policy_idpl);
      << content_only_loop >>
      LOOP

      FETCH c_iaObj INTO r_c_iaObj;
      EXIT WHEN c_iaObj % NOTFOUND;

      --add default client address
      MIGR_API_COMMON.ADD_ADDRESS_ID(vPropertyAddressTab, NULL, r_c_iaObj.IA_ADDRESS, r_c_iaObj.IA_POST_CODE, r_c_iaObj.IA_CITY, r_c_iaObj.IA_COUNTRY);

     --FA 20161007 no needed check  IF r_c_iaObj.object_id IS NULL   AND r_c_iaObj.INS_OBJECT_ID IS NULL THEN
            v_is_obj_ok := FALSE;
            l_policyRec.IA_OBJECT_ID := r_c_iaObj.IA_OBJECT_ID;
            --FA.2060912 Added for cover level functionality
           l_policyRec.objDeduct_val :=    r_c_iaObj.IA_OBJ_DEDUCT;
            --START LM.20160518 CR change from pstp to object type
            l_policyRec.object_fail_log  :=NULL;
            CASE r_c_iaObj.IA_OBJECT_TYPE
                  WHEN '452' THEN  ---Content
                      MIGRATE_O_CONTENT(l_policyRec, vPropertyAddressTab);

                 WHEN '2101' THEN  ---Stored Content
                      MIGRATE_O_STORED_CONTENT(l_policyRec, vPropertyAddressTab);

                  WHEN '2201' THEN  ---Collection
                      MIGRATE_O_COLLECTION(l_policyRec, vPropertyAddressTab);

                  WHEN '2301' THEN  ---Special Object
                      MIGRATE_O_SPECIAL_OBJECT(l_policyRec, vPropertyAddressTab);

                  WHEN '451' THEN  ---Private Accident Insured Person
                      MIGRATE_O_PRIV_ACCIDENT_INS(l_policyRec);

                 WHEN '2401' THEN  ---MISCELLANEOUS
                      MIGRATE_O_MISCELLANEOUS(l_policyRec, vPropertyAddressTab);

                 WHEN '2501' THEN  ---HOBBY
                      MIGRATE_O_HOBBY(l_policyRec, vPropertyAddressTab);

                  WHEN '2601' THEN  ---EXTENDED_TRAVEL
                      MIGRATE_O_EXTENDED_TRAVEL(l_policyRec, vPropertyAddressTab);

                 ELSE l_policyRec.logMsg := 'Content Only object with  ' || r_c_iaObj.IA_OBJECT_ID || ' failed due to invalid object type';
                  MIGR_LOG.LOG_ERROR(l_policyRec);
                  l_policyRec.continue_migr   :=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED due  invalid object type';

                 INSERT INTO MIGR_O_CONTENT_ONLY ( POLICY_ID, OBJECT_ID,  INS_DATE,   MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                  VALUES ( l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, SYSDATE, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);
            END CASE;

      END LOOP content_only_loop;

      CLOSE c_iaObj;
      RETURN l_policyRec;
      EXCEPTION
          WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_policyRec);
               l_policyRec.continue_migr   :=FALSE;
              RETURN l_policyRec;
END MIGRATE_CONTENT_ONLY;

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------


END MIGR_API_CONTENT_ONLY;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_COVERS
  AS

  PROCEDURE  MIGRATE_DEDUCTIBLES(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp)
  IS
      L_IN_CONTEXT  SRVCONTEXT := NULL;
      L_OUT_CONTEXT SRVCONTEXT := NULL;
      PIO_ERR       SRVERR     := NULL;
      L_RESULT      VARCHAR2(50);
      vDeductssql   VARCHAR2(500);
      l_evres       PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

      TYPE deduct_rec IS RECORD (
          IA_COVER               VARCHAR2(200),
          IA_FRANCHISE_TYPE      VARCHAR2(200),
          IA_FRANCHISE_DIMENSION VARCHAR2(10),
          IA_FRANCHISE_CLAIM     VARCHAR2(10),
          IA_CURRENCY            VARCHAR2(10),
          IA_FRANCHISE_VALUE     NUMBER
        );
      TYPE t_deduct_type_tab IS TABLE OF deduct_rec;
      v_deduct_tab  t_deduct_type_tab;
      l_update BOOLEAN;
      l_policy_id   NUMBER;
      l_eventTimer TIMESTAMP;

      l_indemnity_type INSIS_GEN_V10.P_INDEMNITY_TYPE;

    BEGIN

       l_eventTimer := SYSTIMESTAMP;

      p_policyRec.migrStep := 'Migrate Deductibles';
      p_policyRec.migrArea := 'MIGR_API_COVERS.MIGRATE_DEDUCTIBLES';
      p_policyRec.migrRelTbl := 'INSIS_EVENT';

      IF  p_policyRec.ia_deductiblesTbl IS NOT  NULL THEN

          vDeductssql := ' SELECT IA_COVER, IA_FRANCHISE_TYPE,IA_FRANCHISE_DIMENSION,IA_FRANCHISE_CLAIM,
          IA_CURRENCY,IA_FRANCHISE_VALUE  FROM ' || p_policyRec.ia_deductiblesTbl || ' WHERE IA_OBJECT_ID =' || CHR(39) || p_policyRec.ia_object_id || CHR(39);

          EXECUTE IMMEDIATE vDeductssql
            BULK COLLECT INTO v_deduct_tab;

          FOR i IN 1 .. v_deduct_tab.COUNT
          LOOP

            --FA.20161208 Provide choice between object and events method
            --!!!!FA.20170306 Use only object method - event dows not work properly.....
          /*  IF  MIGR_GVAR.GV_MIGRATION_METHOD='EVENT' THEN

              L_OUT_CONTEXT := NULL;
              L_IN_CONTEXT := NULL;
              PIO_ERR := NULL;
              SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyRec.policy_id);     -- Policy Id
              SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);           --  0
              SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_OBJ_ID', SRV_CONTEXT.Integers_Format, p_policyRec.insured_object_id);     -- Object Id
              SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'COVER_TYPE', v_deduct_tab(i).IA_COVER);                                     -- Cover_type
              SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'FRANCHISE_TYPE', v_deduct_tab(i).IA_FRANCHISE_TYPE);                                     --
              SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'FRANCHISE_DIMENSION', v_deduct_tab(i).IA_FRANCHISE_DIMENSION);                                     -- Value
              --FA.20160908 Deductibles on Cover level should take object's value SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'FRANCHISE_VALUE', SRV_CONTEXT.Real_Number_Format, v_deduct_tab(i).IA_FRANCHISE_VALUE);     -- deductible
              SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'FRANCHISE_VALUE', SRV_CONTEXT.Real_Number_Format, v_deduct_tab(i).IA_FRANCHISE_VALUE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'FRANCHISE_CLAIM', v_deduct_tab(i).IA_FRANCHISE_CLAIM);                                     -- All Claims
              SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'FRANCHISE_CURRENCY', v_deduct_tab(i).IA_CURRENCY);

              v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('GET_RISK_INDEMNITY');
              --Check if default deductible exists

              v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

              EXECUTE IMMEDIATE v_stmst    USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

              SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'POLICY_ID', l_policy_id);

               L_OUT_CONTEXT := NULL;

               l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

               IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS  THEN

                    IF l_policy_id IS NOT NULL   THEN

                        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('UPD_INDEMNITY');
                        --if exists call update
                        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                       EXECUTE IMMEDIATE v_stmst     USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                       l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

                        IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS   THEN
                              p_policyRec.logMsg := 'Indemnity for cover: ' || v_deduct_tab(i).IA_COVER || ' updated succesfully';
                              MIGR_LOG.LOG_INFO(p_policyRec);

                        ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                            p_policyRec.logMsg := 'Indemnity for cover returned with warning -RESULT:' || L_RESULT;
                            MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);

                        ELSE
                            p_policyRec.logMsg := 'PIO_ERR UPD_INDEMNITY Failed to migrate deductibles-RESULT: ' || L_RESULT;
                            MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, PIO_ERR);
                            p_policyRec.continue_migr:=FALSE;
                            p_policyRec.object_fail_log:= p_policyRec.object_fail_log || '- Failed to migrate cover level deductibles ' ;
                        END IF;

                    ELSE
                          v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_INDEMNITY');

                          v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                          EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                          l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

                          IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS  THEN
                              p_policyRec.logMsg := 'Indemnity for cover: ' || v_deduct_tab(i).IA_COVER || ' INSERTED succesfully';
                              MIGR_LOG.LOG_INFO(p_policyRec);

                          ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING      THEN
                              p_policyRec.logMsg := 'PIO_ERR INS_INDEMNITY returned with warning -RESULT:' || L_RESULT;
                              MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);

                          ELSE
                              p_policyRec.logMsg := 'PIO_ERR INS_INDEMNITY Failed to migrate deductibles-RESULT: ' || L_RESULT;
                              MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, PIO_ERR);
                              p_policyRec.continue_migr:=FALSE;

                          END IF;
                  END IF;
                ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN

                    p_policyRec.logMsg := 'PIO_ERR GET_RISK_INDEMNITY returned with warning -RESULT:' || L_RESULT;
                    MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);

                ELSE
                    p_policyRec.logMsg := 'PIO_ERR GET_RISK_INDEMNITY Failed to get indemnity for cover: ' || v_deduct_tab(i).IA_COVER;
                    MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, PIO_ERR);
                    p_policyRec.continue_migr:=FALSE;
                    p_policyRec.object_fail_log:= p_policyRec.object_fail_log || '-Failed to get indemnity for cover: ' || v_deduct_tab(i).IA_COVER;
                END IF;
            ELSE     */

                 l_indemnity_type :=   INSIS_GEN_V10.pol_types.GET_INDEMNITY(p_policyRec.policy_id,MIGR_GVAR.GV_ANNEX_ID,p_policyRec.insured_object_id, v_deduct_tab(i).IA_COVER, v_deduct_tab(i).IA_FRANCHISE_CLAIM,pio_err);

                  IF TRIM(l_indemnity_type.COVER_TYPE)= TRIM(v_deduct_tab(i).IA_COVER)  THEN
                     l_update:= TRUE;
                  ELSE
                     l_update:= FALSE;
                  END IF;

                IF PIO_ERR IS NULL  THEN
                       l_indemnity_type.POLICY_ID:= TO_NUMBER( p_policyRec.policy_id,SRV_CONTEXT.Integers_Format);     -- Policy Id
                       l_indemnity_type.ANNEX_ID:= TO_NUMBER( MIGR_GVAR.GV_ANNEX_ID,SRV_CONTEXT.Integers_Format);           --  0
                       l_indemnity_type.INSURED_OBJ_ID:=  TO_NUMBER(  p_policyRec.insured_object_id, SRV_CONTEXT.Integers_Format);     -- Object Id
                       l_indemnity_type.COVER_TYPE:= v_deduct_tab(i).IA_COVER;                                     -- Cover_type
                       l_indemnity_type.FRANCHISE_TYPE:= v_deduct_tab(i).IA_FRANCHISE_TYPE;                                     --
                       l_indemnity_type.FRANCHISE_DIMENSION:= v_deduct_tab(i).IA_FRANCHISE_DIMENSION;
                       l_indemnity_type.FRANCHISE_VALUE:= TO_NUMBER( v_deduct_tab(i).IA_FRANCHISE_VALUE,SRV_CONTEXT.Real_Number_Format);
                       l_indemnity_type.FRANCHISE_CLAIM:= v_deduct_tab(i).IA_FRANCHISE_CLAIM ;
                       l_indemnity_type.franchise_currency:= v_deduct_tab(i).IA_CURRENCY;


                      IF l_update  THEN

                          IF  l_indemnity_type.UpdateIndemnity( PIO_ERR )  THEN
                                 p_policyRec.logMsg := 'Indemnity for cover: ' || v_deduct_tab(i).IA_COVER || ' updated succesfully';
                                 MIGR_LOG.LOG_INFO(p_policyRec);

                           ELSE
                                p_policyRec.logMsg := 'PIO_ERR UPD_INDEMNITY Failed to migrate deductibles-RESULT: ' || L_RESULT;
                                MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, PIO_ERR);
                                p_policyRec.continue_migr:=FALSE;
                                p_policyRec.object_fail_log:= p_policyRec.object_fail_log || '- Failed to migrate cover level deductibles ' ;

                           END IF;

                      ELSE

                          IF  l_indemnity_type.InsertIndemnity( PIO_ERR )  THEN
                                 p_policyRec.logMsg := 'Indemnity for cover: ' || v_deduct_tab(i).IA_COVER || ' INSERTED succesfully';
                                 MIGR_LOG.LOG_INFO(p_policyRec);

                           ELSE
                                p_policyRec.logMsg := 'PIO_ERR INS_INDEMNITY Failed to migrate deductibles-RESULT: ' || L_RESULT;
                                MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, PIO_ERR);
                                p_policyRec.continue_migr:=FALSE;
                           END IF;

                      END IF;

                ELSE

                    p_policyRec.logMsg := 'PIO_ERR GET_RISK_INDEMNITY Failed to get indemnity for cover: ' || v_deduct_tab(i).IA_COVER;
                    MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, PIO_ERR);
                    p_policyRec.continue_migr:=FALSE;
                    p_policyRec.object_fail_log:= p_policyRec.object_fail_log || '-Failed to get indemnity for cover: ' || v_deduct_tab(i).IA_COVER;

                END IF;


              ---END IF;
      END LOOP;


       ELSE
           p_policyRec.logMsg := 'Deductible table not configured ';
          MIGR_LOG.LOG_INFO(p_policyRec);
      END IF;
       p_policyrec.logMsg := 'Migrating deductibles: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

    EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyRec);
           p_policyRec.continue_migr:=FALSE;

    END MIGRATE_DEDUCTIBLES;


  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------


  FUNCTION FILL_COVERS_FOR_SELECT(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN BOOLEAN
    IS

      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      L_ERRMSG      SRVERRMSG;
      L_SRVERRMSG   SRVERRMSG;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_evres       PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN
          l_policyRec := p_policyRec;
          l_policyRec.migrStep := 'Fil Covers for Select';
          l_policyRec.migrArea := 'MIGR_API_COVERS.FILL_COVERS_FOR_SELECT';
          l_policyRec.migrRelTbl := 'INSIS_EVENT';

          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_OBJ_ID', SRV_CONTEXT.Integers_Format, l_policyRec.insured_object_id);

         v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('FILL_COVERS_FOR_SELECT');

          v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
          EXECUTE IMMEDIATE v_stmst
          USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

          SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

          l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

          IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS  THEN
              l_policyRec.logMsg := 'Covers were filled succesfully ' || '-RESULT:' || L_RESULT;
              MIGR_LOG.LOG_INFO(l_policyRec);
              RETURN TRUE;

          ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
              l_policyRec.logMsg := 'FILL_COVERS_FOR_SELECT returned with warning -RESULT:' || L_RESULT;
              MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
              RETURN TRUE;

          ELSE
              l_policyRec.logMsg := 'PIO_ERR FILL_COVERS_FOR_SELECT Failed to fill covers-RESULT: ' || L_RESULT;
              MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
              RETURN FALSE;
          END IF;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_ERROR(l_policyRec);
          RETURN FALSE;
    END FILL_COVERS_FOR_SELECT;

  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------
  --Del_Cover Events isn't working in devmig -Let's check when syt and dev mig are synchronized

  FUNCTION DELETE_INSR_OBJ_COVERS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN BOOLEAN
    IS
      l_policyRec MIGR_GVAR.PolicyRecTyp;
    BEGIN
      l_policyRec := p_policyRec;

      l_policyRec.migrStep := 'Delete insured object covers';
      l_policyRec.migrArea := 'MIGR_API_COVERS.DELETE_INSR_OBJ_COVERS';
      l_policyRec.migrRelTbl := 'INSIS_UPDATE';


      UPDATE INSIS_GEN_V10.GEN_COVERS_SELECT gcs
        SET APPLY_COVER = 0
        WHERE policy_id = l_policyRec.policy_id
        AND ANNEX_ID = MIGR_GVAR.GV_ANNEX_ID
        AND INSURED_OBJ_ID = l_policyRec.insured_object_id;

      l_policyRec.logMsg := 'Covers were deleted succesfully';
      MIGR_LOG.LOG_INFO(l_policyRec);

      RETURN TRUE;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN FALSE;
    END DELETE_INSR_OBJ_COVERS;
  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------

  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------
  --Ins_Cover Events isn't working in devmig -Let's check when syt and dev mig are synchronized

  FUNCTION UPDATE_INSR_OBJ_COVERS(p_policyRec  MIGR_GVAR.PolicyRecTyp)
    RETURN  MIGR_GVAR.PolicyRecTyp
    IS
      vsql        VARCHAR(4000);
      l_policyRec MIGR_GVAR.PolicyRecTyp;
      v_count NUMBER:=0;
      v_updated    NUMBER:=0;
    BEGIN
      l_policyRec := p_policyRec;

      l_policyRec.migrStep := 'Update insured object covers';
      l_policyRec.migrArea := 'MIGR_API_COVERS.UPDATE_INSR_OBJ_COVERS';
      l_policyRec.migrRelTbl := 'INSIS_UPDATE';


      vsql := ' UPDATE INSIS_GEN_V10.GEN_COVERS_SELECT gcs'
      || ' SET APPLY_COVER = 1'
      || ' WHERE 1 = 1'
      || ' AND POLICY_ID = '
      || ''''
      || l_policyRec.policy_id
      || ''''
      || ' AND INSURED_OBJ_ID =  '
      || l_policyRec.insured_object_id
      || ' AND ANNEX_ID = '
      || ''''
      || MIGR_GVAR.GV_ANNEX_ID
      || ''''
      || ' AND COVER_TYPE IN  '
      || ' ( SELECT ibc.IA_COVER FROM '
      || l_policyRec.ia_coversTbl
      || ' ibc WHERE 1 = 1'
      || ' AND ibc.IA_IDPL= '
      || ''''
      || l_policyRec.policy_idpl
      || ''''
      || ' AND ibc.IA_OBJECT_ID = '
      || ''''
      || l_policyRec.ia_object_id
      || ''''
      || ' )';

      EXECUTE IMMEDIATE vsql;
      v_updated:=SQL%ROWCOUNT;
          vsql := ' SELECT count(''1'') FROM '
      || l_policyRec.ia_coversTbl
      || ' ibc WHERE 1 = 1'
      || ' AND ibc.IA_IDPL= '
      || ''''
      || l_policyRec.policy_idpl
      || ''''
      || ' AND ibc.IA_OBJECT_ID = '
      || ''''
      || l_policyRec.ia_object_id
      || ''''  ;


         EXECUTE IMMEDIATE vsql  into v_count;

          IF   v_count >v_updated THEN
                 l_policyRec.continue_migr :=FALSE;
                 l_policyRec.object_fail_log:='At least one MIGG cover type does not exist in INSIS' ;
                 l_policyRec.logMsg := 'At least one MIGG cover type does not exist in INSIS';
                 MIGR_LOG.LOG_ERROR(l_policyRec);

          ELSE
                  l_policyRec.logMsg := 'Covers were updated succesfully';
                  MIGR_LOG.LOG_INFO(l_policyRec);
           END IF;

      RETURN l_policyRec;
    EXCEPTION
         WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_policyRec);
              l_policyRec.continue_migr := FALSE;
              l_policyRec.object_fail_log := 'Error updating cover';
              RETURN l_policyRec;
    END UPDATE_INSR_OBJ_COVERS;
  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------

  FUNCTION APPLY_SELECTED_COVER(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN BOOLEAN
    IS

      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_evres       PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Apply Selected Covers';
      l_policyRec.migrArea := 'MIGR_API_COVERS.APPLY_SELECTED_COVER';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_OBJ_ID', SRV_CONTEXT.Integers_Format, l_policyRec.insured_object_id);


      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('APPLY_SELECTED_COVER');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
      EXECUTE IMMEDIATE v_stmst
      USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS THEN
          l_policyRec.logMsg := 'Selected Covers Applied succesfully' || ' -RESULT' || L_RESULT;
          MIGR_LOG.LOG_INFO(l_policyRec);
          RETURN TRUE;

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
            l_policyRec.logMsg := 'APPLY_SELECTED_COVER returned with warning -RESULT:' || L_RESULT;
            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
            RETURN TRUE;

      ELSE
            l_policyRec.logMsg := 'PIO_ERR APPLY_SELECTED_COVER Failed to apply selected covers-RESULT: ' || L_RESULT;
            MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
            RETURN FALSE;

      END IF;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN FALSE;
    END APPLY_SELECTED_COVER;

  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------

  FUNCTION GET_COVER_INSURED_VALUE(p_statement     IN VARCHAR2,
                                   p_num_of_params IN NUMBER,
                                   p_idpl             NUMBER,
                                   p_idplps           NUMBER,
                                   p_ia_object_id  IN VARCHAR2,
                                   p_mig_batch_id  IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE)
    RETURN NUMBER
    AS
      v_returnVal NUMBER;
      VSQL        VARCHAR2(2000);
      v_radnr     NUMBER;
      v_InsrVal   VARCHAR2(50);

    BEGIN

      v_radnr := REGEXP_SUBSTR(p_ia_object_id, '\w+', 1, 6);

      IF p_num_of_params = 0
      THEN
        EXECUTE IMMEDIATE p_statement
          INTO v_returnVal;
      ELSIF p_num_of_params = 1
      THEN
        EXECUTE IMMEDIATE p_statement
          INTO v_returnVal
        USING p_idplps;
      ELSIF p_num_of_params = 2
      THEN
        EXECUTE IMMEDIATE p_statement
          INTO v_returnVal
        USING p_idplps, v_radnr;
      ELSE
        RETURN NULL;
      END IF;

      RETURN v_returnVal;

    EXCEPTION
      WHEN OTHERS THEN

          MIGR_LOG.LOG_COVER_ERROR_RULES(p_idpl, p_mig_batch_id);

          RETURN NULL;


    END GET_COVER_INSURED_VALUE;


  -------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------

  FUNCTION UPDATE_COVER_INSURED_VAL(p_policyRec   IN MIGR_GVAR.PolicyRecTyp, p_coverType   IN VARCHAR2, p_insured_val IN NUMBER)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS

      L_IN_CONTEXT        SRVCONTEXT;
      L_OUT_CONTEXT       SRVCONTEXT;
      PIO_ERR             SRVERR;
      L_RESULT            VARCHAR2(50);
      v_registration_date DATE;
      v_risk_state        VARCHAR2(256);
      v_currency          VARCHAR2(256);
      v_insr_begin        DATE;
      v_insr_end          DATE;
      v_premium           NUMBER;
      v_full_premium      NUMBER;
      v_discount          NUMBER;
      v_duration          NUMBER;
      v_object_num        NUMBER;
      v_currency_rate     NUMBER;
      v_annual_premium    NUMBER;
      v_net_premium       NUMBER;
      v_dur_dimension     VARCHAR2(256);
      v_USERNAME          VARCHAR2(256);
      l_policyRec         MIGR_GVAR.PolicyRecTyp;
      l_evres             PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
      l_cover_type     INSIS_GEN_V10.P_COVER_TYPE;
      l_IV_SEK      NUMBER;
    BEGIN
          l_policyRec := p_policyRec;
          l_policyRec.migrStep := 'Update Cover Insured Value';
          l_policyRec.migrArea := 'MIGR_API_COVERS.UPDATE_COVER_INSURED_VAL';
          l_policyRec.migrRelTbl := 'INSIS_EVENT';

          --FA.20161208 Provide choice between object and events method
     /*     IF  MIGR_GVAR.GV_MIGRATION_METHOD='EVENT' THEN
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_OBJ_ID', SRV_CONTEXT.Integers_Format, l_policyRec.insured_object_id);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'COVER_TYPE', p_coverType);
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.insr_type);


                v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('GET_COVER');

                v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
                EXECUTE IMMEDIATE v_stmst
                USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

                l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

                IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS  THEN

                    SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'RISK_STATE', v_risk_state);
                    SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'CURRENCY', v_currency);
                    SRV_CONTEXT.GETCONTEXTATTRDATE(L_OUT_CONTEXT, 'INSR_BEGIN', v_insr_begin);
                    SRV_CONTEXT.GETCONTEXTATTRDATE(L_OUT_CONTEXT, 'INSR_END', v_insr_end);
                    SRV_CONTEXT.GETCONTEXTATTRDATE(L_OUT_CONTEXT, 'REGISTRATION_DATE', v_registration_date);
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'PREMIUM', v_premium);
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'FULL_PREMIUM', v_full_premium);
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'DISCOUNT', v_discount);
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'DURATION', v_duration);
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'OBJECT_NUM', v_object_num);
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'CURRENCY_RATE', v_currency_rate);
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'ANNUAL_PREMIUM', v_annual_premium);
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'NET_PREMIUM', v_net_premium);
                    SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'DUR_DIMENSION', v_dur_dimension);
                    SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'USERNAME', v_USERNAME);

                    L_IN_CONTEXT := NULL;
                    L_OUT_CONTEXT := NULL;
                    PIO_ERR := NULL;
                    L_RESULT := NULL;

                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_OBJ_ID', SRV_CONTEXT.Integers_Format, l_policyRec.insured_object_id);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.insr_type);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'RISK_STATE', SRV_CONTEXT.Integers_Format, v_risk_state);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'PREMIUM', SRV_CONTEXT.Integers_Format, v_premium);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'FULL_PREMIUM', SRV_CONTEXT.Integers_Format, v_full_premium);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'DISCOUNT', SRV_CONTEXT.Integers_Format, v_discount);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'DURATION', SRV_CONTEXT.Integers_Format, v_duration);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'OBJECT_NUM', SRV_CONTEXT.Integers_Format, v_object_num);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'CURRENCY_RATE', SRV_CONTEXT.Integers_Format, v_currency_rate);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNUAL_PREMIUM', SRV_CONTEXT.Integers_Format, v_annual_premium);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'NET_PREMIUM', SRV_CONTEXT.Integers_Format, v_net_premium);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'COVER_TYPE', p_coverType);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'DUR_DIMENSION', v_dur_dimension);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_VALUE', SRV_CONTEXT.Integers_Format, p_insured_val);
                    IF l_policyRec.product_group = 'ACCIDENT'  THEN
                         SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ADD_PREMIUM', p_insured_val);
                    ELSE
                        SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'CURRENCY', v_currency);
                        SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'USERNAME', v_USERNAME);
                    END IF;
                    SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'INSR_BEGIN', SRV_CONTEXT.Date_Format, v_insr_begin);
                    SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'INSR_END', SRV_CONTEXT.Date_Format, v_insr_end);
                    SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'REGISTRATION_DATE', SRV_CONTEXT.Date_Format, v_registration_date);


                    v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('UPD_COVER');

                    v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
                    EXECUTE IMMEDIATE v_stmst
                    USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                    l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

                    IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS THEN
                         l_policyRec.logMsg := 'Cover Updated succesfully';
                         MIGR_LOG.LOG_INFO(l_policyRec);

                    ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                          l_policyRec.logMsg := 'UPD_COVER returned with warning -RESULT:' || L_RESULT;
                          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);

                    ELSE
                          l_policyRec.logMsg := 'PIO_ERR UPD_COVER Failed to Update Cover';
                          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
                          l_policyRec.object_fail_log:=l_policyRec.object_fail_log || '-Failed to Update Cover Value:' ||p_coverType;
                          l_policyRec.continue_migr:=FALSE;

                    END IF;

                ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                    l_policyRec.logMsg := 'GET_COVER returned with warning -RESULT:' || L_RESULT;
                    MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);

                ELSE
                    l_policyRec.logMsg := 'PIO_ERR GET_COVER Failed to Get Cover-RESULT: ' || L_RESULT;
                    MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
                    l_policyRec.object_fail_log:=l_policyRec.object_fail_log || '-Failed to get Cover Value:' ||p_coverType;
                    l_policyRec.continue_migr:=FALSE;

                END IF;

           ELSE      */
                 l_cover_type := INSIS_GEN_V10.POL_TYPES.GET_COVER( l_policyRec.insured_object_id,   l_policyRec.policy_id,p_coverType,MIGR_GVAR.GV_ANNEX_ID,PIO_ERR) ;

                 l_IV_SEK := INSIS_GEN_V10.currency.Convert(p_insured_val, INSIS_CUST.GVAR_CUST.PBB_CURR,  'SEK', l_policyRec.INSR_BEGIN, NULL, NULL);

                  IF l_policyRec.product_group = 'ACCIDENT'  THEN
                      l_cover_type.ADD_PREMIUM:= p_insured_val;
                      l_cover_type.INSURED_VALUE:= l_IV_SEK;
                  ELSE
                      l_cover_type.INSURED_VALUE:= p_insured_val;
                  END IF;

                  IF NOT l_cover_type.UPDATECOVER(PIO_ERR) THEN
                       l_policyRec.logMsg := 'PIO_ERR UPD_COVER Failed to Update Cover';
                       MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
                       l_policyRec.object_fail_log:=l_policyRec.object_fail_log || '-Failed to Update Cover Value:' ||p_coverType;
                       l_policyRec.continue_migr:=FALSE;
                  ELSE
                     l_policyRec.logMsg := 'Cover Updated succesfully';
                     MIGR_LOG.LOG_INFO(l_policyRec);
                  END IF;


       ---    END IF;
          RETURN l_policyRec;
    EXCEPTION

      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.object_fail_log:=l_policyRec.object_fail_log || '-Failed to update Cover insured value for :' ||p_coverType;
          l_policyRec.continue_migr:=FALSE;
          RETURN l_policyRec;
    END UPDATE_COVER_INSURED_VAL;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   FUNCTION MIGRATE_COVERS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN  MIGR_GVAR.PolicyRecTyp
    IS
      vCoverssql      VARCHAR2(240);
      TYPE cover_rec IS RECORD (
          cover       VARCHAR2(200),
          insured_val NUMBER -- ,        IA_COVORDER  NVARCHAR2(335)
        );
      TYPE t_cover_type_tab IS TABLE OF cover_rec;
      v_cover_tab     t_cover_type_tab;
      v_error_message VARCHAR2(2000);
      l_policyRec     MIGR_GVAR.PolicyRecTyp;
      l_eventTimer TIMESTAMP;
    BEGIN

      l_eventTimer := SYSTIMESTAMP;

      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Migrate Covers';
      l_policyRec.migrArea := 'MIGR_API_COVERS.MIGRATE_COVERS';
      l_policyRec.migrRelTbl := l_policyRec.ia_coversTbl;


      --Step 1: Fill Covers For Select
      IF FILL_COVERS_FOR_SELECT(l_policyRec)  THEN

        --Step 2:Delete all pre-inserted covers
        IF DELETE_INSR_OBJ_COVERS(l_policyRec)  THEN

          --Step 3:Update Mig covers
         l_policyRec := UPDATE_INSR_OBJ_COVERS(l_policyRec) ;

            --Step 4:Apply Selected Cover
            IF APPLY_SELECTED_COVER(l_policyRec)  THEN

              --Step 5:Update Insured Value for each Insured Obj's cover
              --FA.2016050 Split covers insured values for improve performance  only for coverswith hst select statements
              IF l_policyRec.ia_coversInsValTbl IS NOT NULL THEN
                  vCoverssql := ' SELECT IA_COVER,IA_INSURED_VALUE  FROM ' || l_policyRec.ia_coversInsValTbl || ' WHERE IA_IDPL =' || l_policyRec.policy_idpl || ' and ia_object_id =' || CHR(39) || l_policyRec.ia_object_id || CHR(39)  ;

              ELSE
                  vCoverssql := ' SELECT IA_COVER,IA_INSURED_VALUE  FROM ' || l_policyRec.ia_coversTbl || ' WHERE IA_IDPL =' || l_policyRec.policy_idpl || ' and ia_object_id =' || CHR(39) || l_policyRec.ia_object_id || CHR(39)   ;
              END IF;

              EXECUTE IMMEDIATE vCoverssql  BULK COLLECT INTO v_cover_tab;

              FOR i IN 1 .. v_cover_tab.COUNT  LOOP

                    IF v_cover_tab(i).insured_val IS NOT NULL  THEN
                        l_policyRec:= UPDATE_COVER_INSURED_VAL(l_policyRec, v_cover_tab(i).cover, v_cover_tab(i).insured_val) ;

                    END IF;

              END LOOP;

            ELSE
              l_policyRec.logMsg := 'Failed to apply selected cover';
              MIGR_LOG.LOG_ERROR(l_policyRec);
              l_policyRec.object_fail_log:= l_policyRec.object_fail_log || '-Failed to apply selected covers';
              l_policyRec.continue_migr :=FALSE;
            END IF;


        ELSE
          l_policyRec.logMsg := 'Failed to delete cover for insured object';
          MIGR_LOG.LOG_ERROR(l_policyRec);
          l_policyRec.object_fail_log:= l_policyRec.object_fail_log || '-Failed to delete covers';
          l_policyRec.continue_migr :=FALSE;
        END IF;
      ELSE
        l_policyRec.logMsg := 'Failed to fill covers for select for insured object';
        MIGR_LOG.LOG_ERROR(l_policyRec);
        l_policyRec.object_fail_log:= l_policyRec.object_fail_log || '-Failed to fill covers for select.';
        l_policyRec.continue_migr :=FALSE;

      END IF;
        l_policyRec.logMsg := 'Migrating covers: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(l_policyRec);
      RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN
          l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          l_policyRec.continue_migr :=FALSE;
          l_policyRec.object_fail_log:= l_policyRec.object_fail_log || '-Failed to migrate covers exception.';
          RETURN l_policyRec;


    END MIGRATE_COVERS;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    --cOMMENTED ON 20160707
--  FUNCTION MIGRATE_COVERS_CONS(p_policyRec IN MIGR_API_COMMON.PolicyRecTyp)
--    RETURN BOOLEAN
--    IS
--      vCoverssql      VARCHAR2(240);
--      TYPE cover_rec IS RECORD (
--          cover       VARCHAR2(200),
--          insured_val NUMBER -- ,        IA_COVORDER  NVARCHAR2(335)
--        );
--      TYPE t_cover_type_tab IS TABLE OF cover_rec;
--      v_cover_tab     t_cover_type_tab;
--      v_error_message VARCHAR2(2000);
--      l_policyRec     MIGR_API_COMMON.PolicyRecTyp;
--    BEGIN
--
--      l_policyRec := p_policyRec;
--      l_policyRec.migrStep := 'Migrate Covers';
--      l_policyRec.migrArea := 'MIGR_API_COVERS.MIGRATE_COVERS';
--      l_policyRec.migrRelTbl := l_policyRec.ia_coversTbl;
--      --Step 1: Fill Covers For Select
--      IF FILL_COVERS_FOR_SELECT(l_policyRec)  THEN
--        --Step 2:Delete all pre-inserted covers
--        IF DELETE_INSR_OBJ_COVERS(l_policyRec)  THEN
--          --Step 3:Update Mig covers
--          IF UPDATE_INSR_OBJ_COVERS(l_policyRec)   THEN
--            --Step 4:Apply Selected Cover
--            IF APPLY_SELECTED_COVER(l_policyRec)  THEN
--
--              --Step 5:Update Insured Value for each Insured Obj's cover
--              ---vCoverssql := ' SELECT IA_COVER,IA_INSURED_VALUE FROM ' || l_policyRec.ia_coversTbl || ' WHERE IA_IDPL =' || l_policyRec.policy_idpl || ' and ia_object_id =' || CHR(39) || l_policyRec.ia_object_id || CHR(39);
--              --FA.2016050 Split covers insured values for improve performance  only for coverswith hst select statements
--              IF l_policyRec.ia_coversInsValTbl IS NOT NULL THEN
--                  vCoverssql := ' SELECT IA_COVER,IA_INSURED_VALUE  FROM ' || l_policyRec.ia_coversInsValTbl || ' WHERE IA_IDPL =' || l_policyRec.policy_idpl || ' and ia_object_id =' || CHR(39) || l_policyRec.ia_object_id || CHR(39)  ;
--              ELSE
--                vCoverssql := ' SELECT IA_COVER,IA_INSURED_VALUE  FROM ' || l_policyRec.ia_coversTbl || ' WHERE IA_IDPL =' || l_policyRec.policy_idpl || ' and ia_object_id =' || CHR(39) || l_policyRec.ia_object_id || CHR(39)   ;
--              END IF;
--
--              EXECUTE IMMEDIATE vCoverssql  BULK COLLECT INTO v_cover_tab;
--
--              FOR i IN 1 .. v_cover_tab.COUNT  LOOP
--
--                IF v_cover_tab(i).insured_val IS NOT NULL  THEN
--
--                 l_policyRec := UPDATE_COVER_INSURED_VAL(l_policyRec, v_cover_tab(i).cover, v_cover_tab(i).insured_val);
--                 IF NOT l_policyRec.action_completed   THEN
--                    l_policyRec.logMsg := 'Failed to update cover: '|| v_cover_tab(i).cover || ' insured value cover :'||v_cover_tab(i).insured_val  ;
--                    MIGR_LOG.LOG_ERROR(l_policyRec);
--                   --FA.20160706 Migrate although something fails
--                   --RETURN FALSE;
--                  END IF;
--                END IF;
--              END LOOP;
--
--            ELSE
--              l_policyRec.logMsg := 'Failed to apply selected cover';
--              MIGR_LOG.LOG_ERROR(l_policyRec);
--              --FA.20160706 Migrate although something fails
--             --RETURN FALSE;
--            END IF;
--          ELSE
--            l_policyRec.logMsg := 'Failed to update cover for insured object';
--            MIGR_LOG.LOG_ERROR(l_policyRec);
--            --FA.20160706 Migrate although something fails
--           --RETURN FALSE;
--          END IF;
--        ELSE
--          l_policyRec.logMsg := 'Failed to update cover for insured object';
--          MIGR_LOG.LOG_ERROR(l_policyRec);
--          --FA.20160706 Migrate although something fails
--         --RETURN FALSE;
--        END IF;
--      ELSE
--        l_policyRec.logMsg := 'Failed to fill covers for select for insured object';
--        MIGR_LOG.LOG_ERROR(l_policyRec);
--         --FA.20160706 Migrate although something fails
--        ---RETURN FALSE;
--      END IF;
--
--      RETURN TRUE;
--    EXCEPTION
--      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
--          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
--          --FA.20160706 Migrate although something fails
--         -- RETURN FALSE;
--          RETURN TRUE;
--
--
--    END MIGRATE_COVERS_CONS;


  /*
FUNCTION FILL_COVERS_FOR_SELECT(p_migrationBatchId IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                                P_POLICY_ID        IN MIGR_POLICY.policy_id % TYPE,
                                P_INSURED_OBJ_ID   IN INSURED_OBJECT.INSURED_OBJ_ID % TYPE,
                                p_policy_idpl      IN IA_POLICY.IA_IDPL % TYPE)
  RETURN BOOLEAN
  IS

    L_IN_CONTEXT  SRVCONTEXT;
    L_OUT_CONTEXT SRVCONTEXT;
    L_ERRMSG      SRVERRMSG;
    L_SRVERRMSG   SRVERRMSG;
    PIO_ERR       SRVERR;
    L_RESULT      VARCHAR2(50);


  BEGIN

    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, P_POLICY_ID);
    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_API_COMMON.GV_ANNEX_ID);
    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_OBJ_ID', SRV_CONTEXT.Integers_Format, P_INSURED_OBJ_ID);
    MIGR_SYSTEM.CALL_EVENT('FILL_COVERS_FOR_SELECT', L_IN_CONTEXT, MIGR_API_COMMON.GV_DEBUG, L_OUT_CONTEXT, PIO_ERR);
    SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

    IF PIO_ERR IS NULL
      AND L_RESULT = 'TRUE'
    THEN
      RETURN TRUE;
    ELSE
      RETURN FALSE;
    END IF;

  EXCEPTION

        RETURN FALSE;
  END FILL_COVERS_FOR_SELECT;   */
   --Del_Cover Events isn't working in devmig -Let's check when syt and dev mig are synchronized
  /*
FUNCTION DELETE_INSR_OBJ_COVERS(p_migrationBatchId IN IA_POLICY.MIG_BATCH_ID % TYPE,
                          P_POLICY_ID        IN MIGR_POLICY.policy_id % TYPE,
                          P_INSURED_OBJ_ID   IN INSURED_OBJECT.INSURED_OBJ_ID % TYPE,
                          p_policy_idpl      IN IA_POLICY.IA_IDPL % TYPE)
RETURN BOOLEAN
IS

BEGIN


UPDATE INSIS_GEN_V10.GEN_COVERS_SELECT gcs
SET APPLY_COVER = 0
WHERE policy_id = P_POLICY_ID
AND ANNEX_ID = MIGR_API_COMMON.GV_ANNEX_ID
AND INSURED_OBJ_ID = P_INSURED_OBJ_ID;
RETURN TRUE;
EXCEPTION
WHEN OTHERS THEN
  RETURN FALSE;
END DELETE_INSR_OBJ_COVERS;   */

  --Ins_Cover Events isn't working in devmig -Let's check when syt and dev mig are synchronized
  /*
  FUNCTION UPDATE_INSR_OBJ_COVERS(p_migrationBatchId IN IA_POLICY.MIG_BATCH_ID % TYPE,
                                  P_POLICY_ID        IN MIGR_POLICY.policy_id % TYPE,
                                  p_policy_idpl      IN IA_POLICY.IA_IDPL % TYPE,
                                  P_INSURED_OBJ_ID   IN INSURED_OBJECT.INSURED_OBJ_ID % TYPE,
                                  p_CoversTbl        IN VARCHAR2,
                                  p_ia_object_id     IN VARCHAR2)
    RETURN BOOLEAN
    IS
      vsql VARCHAR(4000);
    BEGIN

      vsql := ' UPDATE INSIS_GEN_V10.GEN_COVERS_SELECT gcs'
      || ' SET APPLY_COVER = 1'
      || ' WHERE 1 = 1'
      || ' AND POLICY_ID = '
      || ''''
      || P_POLICY_ID
      || ''''
      || ' AND INSURED_OBJ_ID =  '
      || P_INSURED_OBJ_ID
      || ' AND ANNEX_ID = '
      || ''''
      || MIGR_API_COMMON.GV_ANNEX_ID
      || ''''
      || ' AND COVER_TYPE IN  '
      || ' ( SELECT ibc.IA_COVER FROM '
      || p_CoversTbl
      || ' ibc WHERE 1 = 1'
      || ' AND ibc.IA_IDPL= '
      || ''''
      || p_policy_idpl
      || ''''
      || ' AND ibc.IA_OBJECT_ID = '
      || ''''
      || p_ia_object_id
      || ''''
      || ' )';

      EXECUTE IMMEDIATE vsql;
      RETURN TRUE;
    EXCEPTION
      WHEN OTHERS THEN
          RETURN FALSE;
    END UPDATE_INSR_OBJ_COVERS;
                                  */
 /*
FUNCTION APPLY_SELECTED_COVER(p_migrationBatchId IN IA_POLICY.MIG_BATCH_ID % TYPE,
                            p_policy_id        IN MIGR_POLICY.policy_id % TYPE,
                            p_insured_obj_id   IN INSURED_OBJECT.INSURED_OBJ_ID % TYPE,
                            p_insr_type        IN IA_POLICY.IA_INSR_TYPE % TYPE,
                            p_policy_idpl      IN IA_POLICY.IA_IDPL % TYPE)
RETURN BOOLEAN
IS

  L_IN_CONTEXT  SRVCONTEXT;
  L_OUT_CONTEXT SRVCONTEXT;
  PIO_ERR       SRVERR;
  L_RESULT      VARCHAR2(50);

BEGIN


  SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policy_id);
  SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_API_COMMON.GV_ANNEX_ID);
  SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_OBJ_ID', SRV_CONTEXT.Integers_Format, p_insured_obj_id);
  MIGR_SYSTEM.CALL_EVENT('APPLY_SELECTED_COVER', L_IN_CONTEXT, MIGR_API_COMMON.GV_DEBUG, L_OUT_CONTEXT, PIO_ERR);
  SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

  IF PIO_ERR IS NULL
    AND L_RESULT = 'TRUE'
  THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;

EXCEPTION
  WHEN OTHERS THEN
      RETURN FALSE;
END APPLY_SELECTED_COVER;

   */
 /*
FUNCTION UPDATE_COVER_INSURED_VAL(p_migrationBatchId IN IA_POLICY.MIG_BATCH_ID % TYPE,
                                  p_policy_id        IN MIGR_POLICY.policy_id % TYPE,
                                  p_insured_obj_id   IN INSURED_OBJECT.INSURED_OBJ_ID % TYPE,
                                  p_insr_type        IN IA_POLICY.IA_INSR_TYPE % TYPE,
                                  p_policy_idpl      IN IA_POLICY.IA_IDPL % TYPE,
                                  p_coverType        IN VARCHAR2,

                                  p_insured_val      IN NUMBER)
  RETURN BOOLEAN
  IS

    L_IN_CONTEXT        SRVCONTEXT;
    L_OUT_CONTEXT       SRVCONTEXT;
    PIO_ERR             SRVERR;
    L_RESULT            VARCHAR2(50);
    v_registration_date DATE;
    v_risk_state        VARCHAR2(256);
    v_currency          VARCHAR2(256);
    v_insr_begin        DATE;
    v_insr_end          DATE;
    v_premium           NUMBER;
    v_full_premium      NUMBER;
    v_discount          NUMBER;
    v_duration          NUMBER;
    v_object_num        NUMBER;
    v_currency_rate     NUMBER;
    v_annual_premium    NUMBER;
    v_net_premium       NUMBER;
    v_dur_dimension     VARCHAR2(256);
    v_USERNAME          VARCHAR2(256);

  BEGIN

    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policy_id);
    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_API_COMMON.GV_ANNEX_ID);
    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_OBJ_ID', SRV_CONTEXT.Integers_Format, p_insured_obj_id);
    SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'COVER_TYPE', p_coverType);
    SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_insr_type);

    MIGR_SYSTEM.CALL_EVENT('GET_COVER', L_IN_CONTEXT, MIGR_API_COMMON.GV_DEBUG, L_OUT_CONTEXT, PIO_ERR);

    SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

    IF PIO_ERR IS NOT NULL
    THEN
      MIGR_LOG.LOG_ERROR(p_migrationBatchId, 'MIGR_API_COVERS.UPDATE_COVER_INSURED_VAL', '-Get InsuredObject Cover', 'PIO ERROR', 'API_EVENT:GET_COVER', p_policy_idpl);
      RETURN FALSE;
    END IF;

    IF L_RESULT <> 'TRUE'
    THEN
      MIGR_LOG.LOG_ERROR(p_migrationBatchId, 'MIGR_API_COVERS.UPDATE_COVER_INSURED_VAL', '-Get InsuredObject Cover', 'PROCEDURE RETURNED WITH:' || L_RESULT, 'API_EVENT:GET_COVER', p_policy_idpl);
      RETURN FALSE;
    END IF;


    IF PIO_ERR IS NULL
    THEN
      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'RISK_STATE', v_risk_state);
      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'CURRENCY', v_currency);
      SRV_CONTEXT.GETCONTEXTATTRDATE(L_OUT_CONTEXT, 'INSR_BEGIN', v_insr_begin);
      SRV_CONTEXT.GETCONTEXTATTRDATE(L_OUT_CONTEXT, 'INSR_END', v_insr_end);
      SRV_CONTEXT.GETCONTEXTATTRDATE(L_OUT_CONTEXT, 'REGISTRATION_DATE', v_registration_date);
      SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'PREMIUM', v_premium);
      SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'FULL_PREMIUM', v_full_premium);
      SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'DISCOUNT', v_discount);
      SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'DURATION', v_duration);
      SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'OBJECT_NUM', v_object_num);
      SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'CURRENCY_RATE', v_currency_rate);
      SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'ANNUAL_PREMIUM', v_annual_premium);
      SRV_CONTEXT.GETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'NET_PREMIUM', v_net_premium);
      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'DUR_DIMENSION', v_dur_dimension);
      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'USERNAME', v_USERNAME);


      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;
      L_RESULT := NULL;

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_API_COMMON.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_OBJ_ID', SRV_CONTEXT.Integers_Format, p_insured_obj_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_insr_type);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_VALUE', SRV_CONTEXT.Integers_Format, p_insured_val);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'RISK_STATE', SRV_CONTEXT.Integers_Format, v_risk_state);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'PREMIUM', SRV_CONTEXT.Integers_Format, v_premium);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'FULL_PREMIUM', SRV_CONTEXT.Integers_Format, v_full_premium);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'DISCOUNT', SRV_CONTEXT.Integers_Format, v_discount);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'DURATION', SRV_CONTEXT.Integers_Format, v_duration);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'OBJECT_NUM', SRV_CONTEXT.Integers_Format, v_object_num);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'CURRENCY_RATE', SRV_CONTEXT.Integers_Format, v_currency_rate);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNUAL_PREMIUM', SRV_CONTEXT.Integers_Format, v_annual_premium);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'NET_PREMIUM', SRV_CONTEXT.Integers_Format, v_net_premium);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'COVER_TYPE', p_coverType);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'CURRENCY', v_currency);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'DUR_DIMENSION', v_dur_dimension);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'USERNAME', v_USERNAME);
      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'INSR_BEGIN', SRV_CONTEXT.Date_Format, v_insr_begin);
      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'INSR_END', SRV_CONTEXT.Date_Format, v_insr_end);
      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'REGISTRATION_DATE', SRV_CONTEXT.Date_Format, v_registration_date);

      MIGR_SYSTEM.CALL_EVENT('UPD_COVER', L_IN_CONTEXT, MIGR_API_COMMON.GV_DEBUG, L_OUT_CONTEXT, PIO_ERR);

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);


      IF PIO_ERR IS NOT NULL
      THEN
        MIGR_LOG.LOG_ERROR(p_migrationBatchId, 'MIGR_API_COVERS.UPDATE_COVER_INSURED_VAL', '-Get InsuredObject Cover', 'PIO ERROR', 'API_EVENT:UPD_COVER', p_policy_idpl);
        RETURN FALSE;
      END IF;

      IF L_RESULT <> 'TRUE'
      THEN
        MIGR_LOG.LOG_ERROR(p_migrationBatchId, 'MIGR_API_COVERS.UPDATE_COVER_INSURED_VAL', '-Get InsuredObject Cover', 'PROCEDURE RETURNED WITH:' || L_RESULT, 'API_EVENT:UPD_COVER', p_policy_idpl);
        RETURN FALSE;
      END IF;


    ELSE
      RETURN FALSE;
    END IF;
    RETURN TRUE;
  EXCEPTION
    WHEN OTHERS THEN
        RETURN FALSE;
  END UPDATE_COVER_INSURED_VAL;

    */

   /* FUNCTION MIGRATE_COVERS(p_migrationBatchId IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                           P_POLICY_ID        IN MIGR_POLICY.POLICY_ID % TYPE,
                           P_INSURED_OBJ_ID   IN INSURED_OBJECT.INSURED_OBJ_ID % TYPE,
                           p_policy_idpl      IN NUMBER,
                           p_CoversTbl        IN VARCHAR2,
                           p_ia_object_id     IN VARCHAR2,
                           p_insr_type        IN VARCHAR2)
     RETURN BOOLEAN
     IS
       vCoverssql      VARCHAR2(240);

       TYPE cover_rec IS RECORD (
           cover       VARCHAR2(200),
           insured_val NUMBER
         );
       TYPE t_cover_type_tab IS TABLE OF cover_rec;
       v_cover_tab     t_cover_type_tab;
       v_error_message VARCHAR2(2000);
     BEGIN

       --Step 1: Fill Covers For Select
       IF FILL_COVERS_FOR_SELECT(p_migrationBatchId, P_POLICY_ID, P_INSURED_OBJ_ID, p_policy_idpl)
       THEN
         --Step 2:Delete all pre-inserted covers
         IF DELETE_INSR_OBJ_COVERS(p_migrationBatchId, P_POLICY_ID, P_INSURED_OBJ_ID, p_policy_idpl)
         THEN
           --Step 3:Update Mig covers
           IF UPDATE_INSR_OBJ_COVERS(p_migrationBatchId, P_POLICY_ID, p_policy_idpl, P_INSURED_OBJ_ID, p_CoversTbl, p_ia_object_id)
           THEN
             --Step 4:Apply Selected Cover
             IF APPLY_SELECTED_COVER(p_migrationBatchId, P_POLICY_ID, P_INSURED_OBJ_ID, p_insr_type, p_policy_idpl)
             THEN
               --Step 5:Update Insured Value for each Insured Obj's cover
               vCoverssql := ' SELECT IA_COVER,IA_INSURED_VALUE FROM ' || p_CoversTbl || ' WHERE IA_IDPL =' || p_policy_idpl || ' and ia_object_id =' || CHR(39) || p_ia_object_id || CHR(39);
               MIGR_LOG.LOG_WARNING(p_migrationBatchId, 'test', 'DEBUG', 'vCoverssql' || vCoverssql, '', p_policy_idpl);
               EXECUTE IMMEDIATE vCoverssql
                 BULK COLLECT INTO v_cover_tab;


               FOR i IN 1 .. v_cover_tab.COUNT
               LOOP

                 MIGR_LOG.LOG_INFO(p_migrationBatchId, 'MIGR_API_COVERS.MIGRATE_COVERS', 'MIGRATE_COVERS', 'v_cover_tab(i).insured_val:' || v_cover_tab(i).insured_val || '-v_cover_tab(i).cover:' || v_cover_tab(i).cover, '', p_policy_idpl);

                 IF v_cover_tab(i).insured_val IS NOT NULL
                 THEN

                   IF UPDATE_COVER_INSURED_VAL(p_migrationBatchId, P_POLICY_ID, P_INSURED_OBJ_ID, p_insr_type, p_policy_idpl, v_cover_tab(i).cover, v_cover_tab(i).insured_val)
                   THEN
                    NULL;
                    -- v_error_message := 'Update cover insured value for:' || v_cover_tab(i).cover;

                   ELSE
                     v_error_message := 'Failed to update cover insured value';

                     RETURN FALSE;
                   END IF;


                 END IF;
               END LOOP;

             ELSE
               v_error_message := 'Failed to apply selected cover';

               RETURN FALSE;
             END IF;
           ELSE
             v_error_message := 'Failed to update cover for insured object';

             RETURN FALSE;
           END IF;
         ELSE
           v_error_message := 'Failed to update cover for insured object';

           RETURN FALSE;
         END IF;
       ELSE
         v_error_message := 'Failed to fill covers for select for insured object';

         RETURN FALSE;
       END IF;

       RETURN TRUE;
     EXCEPTION
       WHEN OTHERS THEN
           RETURN FALSE;


     END MIGRATE_COVERS;   */
-------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------
END MIGR_API_COVERS;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_INDIVIDUAL_COVERS
  AS

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_COLLECTION(p_policyRec  IN OUT    MIGR_GVAR.PolicyRecTyp,
                                 p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS
      l_evres PLS_INTEGER;
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      v_address_id   NUMBER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_INDIVIDUAL_COV_POLICY.ia_object_id % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavp.IA_IDPLPS,
      iavc.IA_COLLECTION_TYPE,
      iavc.IA_PROTECTION_POINTS,
      iavc.IA_COLLECTION_DESCRIPTION,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_NAME,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_CITY,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE
      FROM IA_INDIVIDUAL_COV_POLICY iavp
      JOIN IA_INDIVIDUAL_COV_COLLECTION iavc
      ON iavp.ia_object_id = iavc.ia_object_id
      WHERE 1 = 1
      AND iavp.ia_object_id = v_OBJECT_ID;

BEGIN
        l_policyRec := p_policyRec;
        v_begintimer := SYSTIMESTAMP;
        v_address_id := NULL;
        l_in_context := NULL;
        l_out_context := NULL;
        pio_err := NULL;

        l_policyRec.migrStep := 'Create Object Individual Covers Collection';
        l_policyRec.migrArea := 'MIGR_API_INDIVIDUAL_COVERS.MIGRATE_O_COLLECTION';
        l_policyRec.migrRelTbl := 'IA_INDIVIDUAL_COV_COLLECTION';

        FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)
        LOOP

                l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
                l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;

                l_address := r_c_iaObj.IA_ADDRESS;
                l_postCode := r_c_iaObj.IA_POST_CODE;
                l_city := r_c_iaObj.IA_CITY;
                l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

                IF (l_address IS NULL OR l_postCode IS NULL OR l_city IS NULL OR l_country_code IS NULL)     THEN
                      l_address := p_addressTab(1).r_address;
                      l_postCode := p_addressTab(1).r_postCode;
                      l_city := p_addressTab(1).r_city;
                      l_country_code := p_addressTab(1).r_countryCode;
                END IF;

                v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
                IF v_address_id IS NOT NULL  THEN
                      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
                ELSE
                      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
                END IF;

                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4',r_c_iaObj.IA_COLLECTION_TYPE);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', r_c_iaObj.IA_COLLECTION_DESCRIPTION);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12','' );
                 ---20170525 Non-mandatory Attributes participating in calculation formulas should not be null
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', NVL( r_c_iaObj.IA_PROTECTION_POINTS,'0'));

                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

                 v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

                v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

                IF v_address_id IS NULL  THEN
                      SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                      MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
                END IF;

                l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

                IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
                      l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                      MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                      l_policyRec.continue_migr:=FALSE;
                      l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property'   ;

                ELSE
                      l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                      MIGR_LOG.LOG_INFO(l_policyRec);

                      l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                      IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                          l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                      END IF;

                END IF;

                INSERT INTO MIGR_O_INDIVIDUAL_COVERS (   NAME, POLICY_REF, POLICY_ID, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,mig_start,mig_end, ia_object_id, MIG_BATCH_ID, policy_idpl,OBJ_ERROR_LOG    )
                VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

        END LOOP;
        p_policyRec:=l_policyRec;

        EXCEPTION
              WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
                    MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                    l_policyRec.continue_migr:=FALSE;
                    p_policyRec:=l_policyRec;
END MIGRATE_O_COLLECTION;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_PRIV_ACCIDENT_INS(p_policyRec IN OUT  MIGR_GVAR.PolicyRecTyp)
IS

      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      v_begintimer  TIMESTAMP WITH TIME ZONE;
      L_MAN_ID      P_PEOPLE.MAN_ID % TYPE;
      v_gender      VARCHAR2(10);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_evres  PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

      CURSOR c_iaObj (v_OBJECT_ID IA_INDIVIDUAL_COV_POLICY.ia_object_id % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavb.IA_GNAME,
      iavb.IA_SNAME,
      iavb.IA_POLICY_REF,
      iavb.IA_PID,
      iavb.IA_AGE,
      iavb.IA_GENDER,
      iavb.IA_FULL_NAME,
      iavb.IA_IND_BENEFICIARY,
      iavb.IA_BIRTH_DATE,
        mc.MAN_ID
      FROM IA_INDIVIDUAL_COV_POLICY iavp
      JOIN IA_INDIVIDUAL_COV_PRIV_INS iavb   ON iavp.ia_object_id = iavb.ia_object_id
        LEFT JOIN MIGR_CLIENT mc ON mc.EGN=iavb.IA_PID
      WHERE 1 = 1
      AND iavp.ia_object_id = v_OBJECT_ID;

BEGIN
        l_policyRec := p_policyRec;
        v_begintimer := SYSTIMESTAMP;
        l_in_context := NULL;
        l_out_context := NULL;
        pio_err := NULL;

        l_policyRec.migrStep := 'Create Object Individual Covers Private Accident Insured Person';
        l_policyRec.migrArea := 'MIGR_API_INDIVIDUAL_COVERS.MIGRATE_O_PRIV_ACCIDENT_INS';
        l_policyRec.migrRelTbl := 'IA_INDIVIDUAL_COV_PRIV_INS';

        FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)
        LOOP
              l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
              l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
              IF r_c_iaObj.IA_GENDER = 1    THEN  v_gender := 'M';
              ELSE   v_gender := 'F';
              END IF;

               --FA. 20161031 First check if person has been migrated by client migration and if not search INSIS
               IF r_c_iaObj.MAN_ID IS NOT NULL THEN
                    L_MAN_ID:=r_c_iaObj.MAN_ID;
              ELSE
                    L_MAN_ID := MIGR_API_CLIENTS.GET_PEOPLE_BY_PID(r_c_iaObj.IA_PID);


              END IF;
              IF L_MAN_ID IS NOT NULL     THEN
                    l_in_context := NULL;
                    l_out_context := NULL;
                    pio_err := NULL;

                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'AGE', '');
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_SUBTYPE', r_c_iaObj.IA_HOME_TYPE);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GENDER', v_gender);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP1',  p_policyRec.property_id);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP2', r_c_iaObj.IA_FULL_NAME);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP3', r_c_iaObj.IA_PID);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP4', r_c_iaObj.IA_IND_BENEFICIARY);

                     v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_ACCINSURED');

                     v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                     EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                     SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

                     l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

                     IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
                          l_policyRec.logMsg := 'PIO_ERR INS_ACCINSURED Failed to register OBJECT';
                          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                           l_policyRec.continue_migr:=FALSE;
                           l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '- FAILED to  register OBJECT';

                     ELSE
                          l_policyRec.logMsg := 'Private Accident Insurd Person was inserted succesfully with object_id: ' || l_policyRec.object_id;
                          MIGR_LOG.LOG_INFO(l_policyRec);

                          l_policyRec:=  MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                        IF  p_policyRec.require_pinsured ='Y' THEN
                              IF  NOT MIGR_API_CLIENTS.ADD_PRIV_INS_PARTICIPANTS(l_policyRec ,L_MAN_ID )THEN
                                      l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '- FAILED to  add policy participant';
                                      l_policyRec.continue_migr:=FALSE;
                                END IF;
                         END IF;

                          IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                            l_policyRec.logMsg := 'INS_ACCINSURED returned with warning -RESULT:' || NULL;
                            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                          END IF;

                     END IF;

              ELSE
                     l_policyRec.logMsg := 'Failed to call event INS_ACCINSURED due to null MAN_ID';
                     MIGR_LOG.LOG_ERROR(l_policyRec);
                      l_policyRec.continue_migr:=FALSE;
                      l_policyRec.object_fail_log  :=l_policyRec.object_fail_log|| '-Failed to Insert accident insured';

              END IF;

              INSERT INTO MIGR_O_INDIVIDUAL_COVERS ( NAME, POLICY_REF, POLICY_ID, object_id, INS_OBJECT_ID, INS_DATE, INS_MS, mig_start,mig_end,ia_object_id, MIG_BATCH_ID, policy_idpl ,OBJ_ERROR_LOG)
              VALUES (r_c_iaObj.IA_FULL_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

        END LOOP;

        p_policyRec:=l_policyRec;

        EXCEPTION
            WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
                MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                l_policyRec.continue_migr:=FALSE;
                p_policyRec:=l_policyRec;

END MIGRATE_O_PRIV_ACCIDENT_INS;


-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

--FA.20160523 Due to CR there is no longer a content object
/* PROCEDURE MIGRATE_O_CONTENT(p_policyRec  IN     MIGR_API_COMMON.PolicyRecTyp,
p_addressTab IN OUT MIGR_API_COMMON.PropertyAddressTabTyp,
p_is_obj_ok  OUT    BOOLEAN)
IS

l_in_context   SRVCONTEXT;
l_out_context  SRVCONTEXT;
pio_err        SRVERR;
v_begintimer   TIMESTAMP WITH TIME ZONE;
v_address_Id   NUMBER;
l_address      VARCHAR2(256);
l_postCode     VARCHAR2(256);
l_city         VARCHAR2(256);
l_country_code VARCHAR2(256);
l_policyRec    MIGR_API_COMMON.PolicyRecTyp;
CURSOR c_iaObj (v_OBJECT_ID IA_INDIVIDUAL_COV_POLICY.ia_object_id % TYPE) IS
SELECT iavp.IA_OBJECT_TYPE,
iavp.IA_IDPLPS,
iavp.IA_HOME_TYPE,
iavp.IA_HOME_SUBTYPE,
iavc.IA_UNION_HOME_INSURANCE,
iavc.IA_LIVING_AREA,
iavc.IA_CERTAIN_LOCKS,
iavc.IA_UNION_NAME,
iavc.IA_DISCOUNT,
iavc.IA_PROPERTY_ID,
iavc.IA_TOTAL_LIVING_AREA,
iavc.IA_POLICY_REF,
iavc.IA_INSURED_VAL,
iavc.IA_NAME,
iavc.IA_COUNTRY_CODE,
iavc.IA_CITY,
iavc.IA_ADDRESS,
iavc.IA_POST_CODE
FROM IA_INDIVIDUAL_COV_POLICY iavp
JOIN IA_INDIVIDUAL_COV_CONTENT iavc
ON iavp.ia_object_id = iavc.ia_object_id
WHERE 1 = 1
AND iavp.ia_object_id = v_OBJECT_ID;
l_evres  PLS_INTEGER;
BEGIN
v_begintimer := SYSTIMESTAMP;
v_address_Id := NULL;
l_policyRec := p_policyRec;
l_in_context := NULL;
l_out_context := NULL;
pio_err := NULL;

l_policyRec.migrStep := 'Create Object Individual Covers Content';
l_policyRec.migrArea := 'MIGR_API_INDIVIDUAL_COVERS.MIGRATE_O_CONTENT';
l_policyRec.migrRelTbl := 'IA_INDIVIDUAL_COV_CONTENT';



FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)
LOOP
p_is_obj_ok := FALSE;
l_address := r_c_iaObj.IA_ADDRESS;
l_postCode := r_c_iaObj.IA_POST_CODE;
l_city := r_c_iaObj.IA_CITY;
l_country_code := r_c_iaObj.IA_COUNTRY_CODE;
l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
IF (l_address IS NULL
OR l_postCode IS NULL
OR l_city IS NULL
OR l_country_code IS NULL)
THEN
l_address := p_addressTab(1).r_address;
l_postCode := p_addressTab(1).r_postCode;
l_city := p_addressTab(1).r_city;
l_country_code := p_addressTab(1).r_countryCode;
END IF;

v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);


SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');

IF v_address_Id IS NOT NULL
THEN
SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
ELSE

SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
END IF;
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_CERTAIN_LOCKS);
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');

SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

MIGR_SYSTEM.CALL_EVENT('INS_PROPERTY', l_in_context, MIGR_API_COMMON.GV_DEBUG, l_out_context, pio_err);

SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);
IF v_address_Id IS NULL
THEN
SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
END IF;


-- IF pio_err IS NULL
--FA.20160421 Handle Event Response
l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

IF l_evres = MIGR_API_COMMON.GV_EVRES_SUCCESS
THEN
l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
IF MIGR_LOG.GV_DEBUG_INFO
THEN
MIGR_LOG.LOG_INFO(l_policyRec);
END IF;
MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec, p_is_obj_ok);
IF p_is_obj_ok
THEN
INSERT INTO MIGR_O_INDIVIDUAL_COVERS (
NAME, POLICY_REF, POLICY_ID, object_id, INS_OBJECT_ID, INS_DATE, INS_MS, ia_object_id, MIG_BATCH_ID, policy_idpl
)
VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), l_policyRec.ia_object_id, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl);

--MIGR_API_QUESTIONS.MIGRATE_QUESTIONS(l_policyRec.mig_batch_id, l_policyRec.insr_type, L_INSURED_OBJ_ID, l_policyRec.policy_id, l_policyRec.policy_idpl, r_c_iaObj.IA_IDPLPS, c_QuestionsTbl);
p_is_obj_ok := TRUE;

END IF;
ELSIF l_evres = MIGR_API_COMMON.GV_EVRES_WARNING
THEN

l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
ELSE

l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);

END IF;

END LOOP;

EXCEPTION
WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
MIGR_LOG.LOG_EXCEPTION(l_policyRec);
END MIGRATE_O_CONTENT;
*/
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PROCEDURE MIGRATE_O_SPECIAL_OBJECT(p_policyRec  IN OUT    MIGR_GVAR.PolicyRecTyp,
p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_Id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_INDIVIDUAL_COV_POLICY.ia_object_id % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,

      iavc.IA_RISK_TYPE,
      iavc.IA_DESCRIPTION,
      iavc.IA_NAME,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_CITY,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE

      FROM IA_INDIVIDUAL_COV_POLICY iavp
      JOIN IA_INDIVIDUAL_COV_SPECIAL_OBJ iavc
      ON iavp.ia_object_id = iavc.ia_object_id
      WHERE 1 = 1
      AND iavp.ia_object_id = v_OBJECT_ID;
      l_evres  PLS_INTEGER;
    v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;

      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Create Object Individual Covers Special Object';
      l_policyRec.migrArea := 'MIGR_API_INDIVIDUAL_COVERS.MIGRATE_O_SPECIAL_OBJECT';
      l_policyRec.migrRelTbl := 'IA_INDIVIDUAL_COV_SPECIAL_OBJ';


      FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)
      LOOP

            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL OR l_postCode IS NULL   OR l_city IS NULL OR l_country_code IS NULL)   THEN
                l_address := p_addressTab(1).r_address;
                l_postCode := p_addressTab(1).r_postCode;
                l_city := p_addressTab(1).r_city;
                l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_Id IS NOT NULL  THEN
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            ELSE
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_RISK_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', r_c_iaObj.IA_DESCRIPTION);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

           SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

           IF v_address_Id IS NULL THEN
                SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr:=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';

            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                  l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                      l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                      MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                  END IF;
            END IF;

            INSERT INTO MIGR_O_INDIVIDUAL_COVERS (   NAME, POLICY_REF, POLICY_ID, object_id, INS_OBJECT_ID, INS_DATE, INS_MS, mig_start,mig_end, ia_object_id, MIG_BATCH_ID, policy_idpl,OBJ_ERROR_LOG    )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;

      p_policyRec:=l_policyRec;

      EXCEPTION
          WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_policyRec);
              l_policyRec.continue_migr:=FALSE;
              p_policyRec:=l_policyRec;
    END MIGRATE_O_SPECIAL_OBJECT;

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_STORED_CONTENT(p_policyRec  IN OUT     MIGR_GVAR.PolicyRecTyp,
p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_INDIVIDUAL_COV_POLICY.ia_object_id % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.ia_property_id,
      iavc.IA_THEFT_ATTRACTIVE,
      iavc.IA_CERTAIN_LOCKS,
      iavc.IA_STORED_ADDRESS,
      iavc.IA_POLICY_REF,

      iavc.IA_NAME,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_CITY,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_IS_INHABITATED
      FROM IA_INDIVIDUAL_COV_POLICY iavp
      JOIN IA_INDIVIDUAL_COV_STORED_CONT iavc
      ON iavp.ia_object_id = iavc.ia_object_id
      WHERE 1 = 1
      AND iavp.ia_object_id = v_OBJECT_ID;
      l_evres  PLS_INTEGER;
       v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Individual Covers Stored Content';
      l_policyRec.migrArea := 'MIGR_API_INDIVIDUAL_COVERS.MIGRATE_O_STORED_CONTENT';
      l_policyRec.migrRelTbl := 'IA_INDIVIDUAL_COV_STORED_CONT';


      FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)
      LOOP

            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL  OR l_postCode IS NULL OR l_city IS NULL  OR l_country_code IS NULL) THEN
                l_address := p_addressTab(1).r_address;
                l_postCode := p_addressTab(1).r_postCode;
                l_city := p_addressTab(1).r_city;
                l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL  THEN
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1',l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', r_c_iaObj.IA_STORED_ADDRESS);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4','' );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6',r_c_iaObj.IA_THEFT_ATTRACTIVE );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9',  r_c_iaObj.IA_CERTAIN_LOCKS);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', r_c_iaObj.IA_IS_INHABITATED);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

             v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

             v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

             EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

             SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

              IF v_address_id IS NULL THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
              END IF;

              l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

              IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
                    l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                     l_policyRec.continue_migr:=FALSE;
                    l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property'  ;

             ELSE
                    l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                    MIGR_LOG.LOG_INFO(l_policyRec);

                   l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                          l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                    END IF;

              END IF;

             INSERT INTO MIGR_O_INDIVIDUAL_COVERS (   NAME, POLICY_REF, POLICY_ID, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START, MIG_END, ia_object_id, MIG_BATCH_ID, policy_idpl,OBJ_ERROR_LOG    )
             VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;

      p_policyRec:=l_policyRec;

      EXCEPTION
            WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
                MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                l_policyRec.continue_migr:=FALSE;
                p_policyRec:=l_policyRec;

END MIGRATE_O_STORED_CONTENT;
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
--FA.20160523 Create new objects Individual Covers
PROCEDURE MIGRATE_O_MISCELLANEOUS(p_policyRec  IN  OUT   MIGR_GVAR.PolicyRecTyp,
      p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
      IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_INDIVIDUAL_COV_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_INDIVIDUAL_COV_POLICY iavp
      JOIN IA_INDIVIDUAL_COV_MIS_OBJ iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
         v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN

    v_begintimer := SYSTIMESTAMP;
    v_address_id := NULL;
    l_policyRec := p_policyRec;
    l_in_context := NULL;
    l_out_context := NULL;
    pio_err := NULL;

    l_policyRec.migrStep := 'Create Object Individual Covers Miscellaneous';
    l_policyRec.migrArea := 'MIGR_API_INDIVIDUAL_COVERS.MIGRATE_O_MISCELLANEOUS';
    l_policyRec.migrRelTbl := 'INDIVIDUAL_COV_MIS_OBJ';

    FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
    LOOP

            l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL    OR l_postCode IS NULL              OR l_city IS NULL
            OR l_country_code IS NULL)
            THEN
            l_address := p_addressTab(1).r_address;
            l_postCode := p_addressTab(1).r_postCode;
            l_city := p_addressTab(1).r_city;
            l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL
            THEN
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '' );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

              v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

              v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

              EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

              SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

              IF v_address_id IS NULL  THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;

              l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

              IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                   l_policyRec.continue_migr:=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property'  ;

            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                  l_policyRec:=  MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                 IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                      l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                      MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                  END IF;

              END IF;

            INSERT INTO MIGR_O_INDIVIDUAL_COVERS (   NAME, POLICY_REF, POLICY_ID, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, MIG_BATCH_ID, policy_idpl,OBJ_ERROR_LOG    )
               VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

    END LOOP;

    p_policyRec:=l_policyRec;

    EXCEPTION
          WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
                MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                l_policyRec.continue_migr:=FALSE;
                p_policyRec:=l_policyRec;
END MIGRATE_O_MISCELLANEOUS;

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
--FA.20160523 Create new objects Individual Covers
PROCEDURE MIGRATE_O_HOBBY(p_policyRec  IN OUT    MIGR_GVAR.PolicyRecTyp,
p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_INDIVIDUAL_COV_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_INDIVIDUAL_COV_POLICY iavp
      JOIN  IA_INDIVIDUAL_COV_HOBBY iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
        v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Individual Covers Hobby';
      l_policyRec.migrArea := 'MIGR_API_INDIVIDUAL_COVERS.MIGRATE_O_HOBBY';
      l_policyRec.migrRelTbl := 'IA_INDIVIDUAL_COV_HOBBY';
      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

      l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
      l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
      l_address := r_c_iaObj.IA_ADDRESS;
      l_postCode := r_c_iaObj.IA_POST_CODE;
      l_city := r_c_iaObj.IA_CITY;
      l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

      IF (l_address IS NULL OR l_postCode IS NULL  OR l_city IS NULL OR l_country_code IS NULL)  THEN
            l_address := p_addressTab(1).r_address;
            l_postCode := p_addressTab(1).r_postCode;
            l_city := p_addressTab(1).r_city;
            l_country_code := p_addressTab(1).r_countryCode;
      END IF;

      v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
      IF v_address_id IS NOT NULL   THEN
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
      ELSE
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

      END IF;
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '' );
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

       v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

       v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

       EXECUTE IMMEDIATE v_stmst     USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

       SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

       IF v_address_id IS NULL  THEN
            SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
            MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
       END IF;
       l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

      IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
            l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
            MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
            l_policyRec.continue_migr:=FALSE;
            l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property' ;

      ELSE
            l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
            MIGR_LOG.LOG_INFO(l_policyRec);

            l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

            IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                  l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                  MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
            END IF;

      END IF;

       INSERT INTO MIGR_O_INDIVIDUAL_COVERS (   NAME, POLICY_REF, POLICY_ID, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,mig_start, MIG_END, ia_object_id, MIG_BATCH_ID, policy_idpl,OBJ_ERROR_LOG    )
       VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;

      p_policyRec:=l_policyRec;

      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr:=FALSE;
            p_policyRec:=l_policyRec;

END MIGRATE_O_HOBBY;

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
--FA.20160523 Create new objects CONTENT COOPERATIVE

PROCEDURE MIGRATE_O_EXTENDED_TRAVEL(p_policyRec  IN  OUT    MIGR_GVAR.PolicyRecTyp,
p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_INDIVIDUAL_COV_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_INDIVIDUAL_COV_POLICY iavp
      JOIN  IA_INDIVIDUAL_COV_EXT_TRAVEL iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
       v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Individual Covers Extended Travel';
      l_policyRec.migrArea := 'MIGR_API_INDIVIDUAL_COVERS.MIGRATE_O_EXTENDED_TRAVEL';
      l_policyRec.migrRelTbl := 'INDIVIDUAL_COV_EXT_TRAVEL';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

              l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
              l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
              l_address := r_c_iaObj.IA_ADDRESS;
              l_postCode := r_c_iaObj.IA_POST_CODE;
              l_city := r_c_iaObj.IA_CITY;
              l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

              IF (l_address IS NULL  OR l_postCode IS NULL  OR l_city IS NULL   OR l_country_code IS NULL) THEN
                    l_address := p_addressTab(1).r_address;
                    l_postCode := p_addressTab(1).r_postCode;
                    l_city := p_addressTab(1).r_city;
                    l_country_code := p_addressTab(1).r_countryCode;
              END IF;

              v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

              SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
              IF v_address_id IS NOT NULL   THEN
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
              ELSE
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

              END IF;
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '' );
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');


              v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

              v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

              EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

              SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

              IF v_address_id IS NULL   THEN
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                    MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
              END IF;

              l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

              IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN

                    l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                    l_policyRec.continue_migr:=FALSE;
                    l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property'  ;
              ELSE
                    l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;

                    MIGR_LOG.LOG_INFO(l_policyRec);

                     l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                          l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);

                    END IF;

              END IF;

              INSERT INTO MIGR_O_INDIVIDUAL_COVERS (   NAME, POLICY_REF, POLICY_ID, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, MIG_BATCH_ID, policy_idpl,OBJ_ERROR_LOG    )
              VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;

      p_policyRec:=l_policyRec;

      EXCEPTION
            WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
                  MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                  l_policyRec.continue_migr:=FALSE;
                  p_policyRec:=l_policyRec;

END MIGRATE_O_EXTENDED_TRAVEL;


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--FA.20160518 Create new objects CONTENT COOPERATIVE

PROCEDURE MIGRATE_O_COOPERATIVE_APART(p_policyRec  IN OUT    MIGR_GVAR.PolicyRecTyp,
p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_INDIVIDUAL_COV_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_INDIVIDUAL_COV_POLICY iavp
      JOIN  IA_INDIVIDUAL_COV_COOPERATIVE iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres PLS_INTEGER;
          v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Individual Covers Cooperative Apartment';
      l_policyRec.migrArea := 'MIGR_API_INDIVIDUAL_COVERS.MIGRATE_O_COOPERATIVE_APART';
      l_policyRec.migrRelTbl := 'IA_INDIVIDUAL_COV_COOPERATIVE';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)     LOOP

              l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
              l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
              l_address := r_c_iaObj.IA_ADDRESS;
              l_postCode := r_c_iaObj.IA_POST_CODE;
              l_city := r_c_iaObj.IA_CITY;
              l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

              IF (l_address IS NULL  OR l_postCode IS NULL  OR l_city IS NULL   OR l_country_code IS NULL)   THEN
                    l_address := p_addressTab(1).r_address;
                    l_postCode := p_addressTab(1).r_postCode;
                    l_city := p_addressTab(1).r_city;
                    l_country_code := p_addressTab(1).r_countryCode;
              END IF;

              v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

              SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
              IF v_address_id IS NOT NULL  THEN
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
              ELSE
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

              END IF;
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '' );
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

              v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

              v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

              EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

              SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

              IF v_address_id IS NULL   THEN
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                    MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
              END IF;

              l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

              IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
                    l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                    l_policyRec.continue_migr:=FALSE;
                    l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property'   ;
              ELSE
                    l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                    MIGR_LOG.LOG_INFO(l_policyRec);

                    l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                          l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                    END IF;
              END IF;

            INSERT INTO MIGR_O_INDIVIDUAL_COVERS (   NAME, POLICY_REF, POLICY_ID, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, MIG_BATCH_ID, policy_idpl,OBJ_ERROR_LOG    )
             VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;

      p_policyRec:=l_policyRec;

      EXCEPTION
            WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
                  MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                  l_policyRec.continue_migr:=FALSE;
                  p_policyRec:=l_policyRec;

END MIGRATE_O_COOPERATIVE_APART;

------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
FUNCTION  MIGRATE_INDIVIDUAL_COVERS(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)  RETURN  MIGR_GVAR.PolicyRecTyp
AS
      v_in_context        SRVCONTEXT;
      v_out_context       SRVCONTEXT;
      v_srverrmsg         SRVERRMSG;
      pio_err             SRVERR;
      v_is_obj_ok         BOOLEAN;
      v_address_id        NUMBER;

      CURSOR c_iaObj (vPOLICY_IDPL IA_INDIVIDUAL_COV_POLICY.IA_IDPL % TYPE) IS
      SELECT ivp.IA_POLICY_REF,
      ivp.IA_IDPL,
      ivp.IA_PSTP,
      ivp.ia_object_id,
      ivp.IA_OBJECT_TYPE,
      ia.IA_ADDRESS,
      ia.IA_CITY,
      ia.IA_POST_CODE,
      ivp.IA_OBJ_DEDUCT,
      ia.IA_COUNTRY
     --FA 20161007 no needed check  mov.object_id,  mov.INS_OBJECT_ID
      FROM IA_INDIVIDUAL_COV_POLICY ivp
    --FA 20161007 no needed check  LEFT JOIN MIGR_O_INDIVIDUAL_COVERS mov   ON ivp.ia_object_id = mov.ia_object_id
      JOIN IA_ADDRESS ia
      ON ia.IA_IDPL = ivp.IA_IDPL
      WHERE 1 = 1
      AND ivp.IA_IDPL = vPOLICY_IDPL
      ORDER BY SUBSTR(ivp.ia_object_id, LENGTH(ivp.ia_object_id)) ASC;

      r_c_iaObj           c_iaObj % ROWTYPE;
      vPropertyAddressTab MIGR_GVAR.PropertyAddressTabTyp;
      l_policyRec         MIGR_GVAR.PolicyRecTyp;

BEGIN

        vPropertyAddressTab.DELETE();
        l_policyRec := p_policyRec;

        l_policyRec.migrArea := 'MIGR_API_INDIVIDUAL_COVERS.MIGRATE_INDIVIDUAL_COVERS';
        l_policyRec.migrStep := 'Create Individual Covers Policy';
        l_policyRec.migrRelTbl := 'IA_INDIVIDUAL_COV_POLICY';

        OPEN c_iaObj (l_policyRec.policy_idpl);

        << villahem_loop >>
        LOOP

              FETCH c_iaObj INTO r_c_iaObj;
              EXIT WHEN c_iaObj % NOTFOUND;

              --add default client address
              MIGR_API_COMMON.ADD_ADDRESS_ID(vPropertyAddressTab, NULL, r_c_iaObj.IA_ADDRESS, r_c_iaObj.IA_POST_CODE, r_c_iaObj.IA_CITY, r_c_iaObj.IA_COUNTRY);

           --FA 20161007 no needed check   IF r_c_iaObj.object_id IS NULL  AND  r_c_iaObj.INS_OBJECT_ID IS NULL THEN

                    l_policyRec.ia_object_id := r_c_iaObj.ia_object_id;
                    --FA.2060912 Added for cover level functionality
                     l_policyRec.objDeduct_val :=    r_c_iaObj.IA_OBJ_DEDUCT;
                     l_policyRec.object_fail_log  :=NULL;
                    CASE r_c_iaObj.IA_OBJECT_TYPE
                          WHEN '2102' THEN  ---Stored Content
                          MIGRATE_O_STORED_CONTENT(l_policyRec, vPropertyAddressTab);

                         WHEN '2202' THEN  ---Collection
                          MIGRATE_O_COLLECTION(l_policyRec, vPropertyAddressTab);

                         WHEN '2302' THEN  ---Special Object
                          MIGRATE_O_SPECIAL_OBJECT(l_policyRec, vPropertyAddressTab);

                         WHEN '191' THEN  ---Private Accident Insured Person
                          MIGRATE_O_PRIV_ACCIDENT_INS(l_policyRec);

                         WHEN '2402' THEN  ---MISCELLANEOUS
                          MIGRATE_O_MISCELLANEOUS(l_policyRec, vPropertyAddressTab);

                         WHEN '2502' THEN  ---HOBBY
                          MIGRATE_O_HOBBY(l_policyRec, vPropertyAddressTab);

                         WHEN '2602' THEN  ---EXTENDED_TRAVEL
                          MIGRATE_O_EXTENDED_TRAVEL(l_policyRec, vPropertyAddressTab);

                         WHEN '2702' THEN  ---EXTENDED_TRAVEL
                          MIGRATE_O_COOPERATIVE_APART(l_policyRec, vPropertyAddressTab);

                         ELSE l_policyRec.logMsg := ' Individual Coverse object with  ' || r_c_iaObj.IA_OBJECT_ID || ' failed due to invalid object type';
                              MIGR_LOG.LOG_ERROR(l_policyRec);
                              l_policyRec.continue_migr:=FALSE;
                              l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED due  invalid object type';

                            INSERT INTO MIGR_O_INDIVIDUAL_COVERS ( POLICY_ID, OBJECT_ID,  INS_DATE,   MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                               VALUES ( l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, SYSDATE, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);
                    END CASE;

        END LOOP villahem_loop;

        CLOSE c_iaObj;
        RETURN l_policyRec;

        EXCEPTION
            WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
                  MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                  l_policyRec.continue_migr:=FALSE;
                  RETURN l_policyRec;
    END MIGRATE_INDIVIDUAL_COVERS;

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------



END MIGR_API_INDIVIDUAL_COVERS;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_LEISURE_CONT_ONLY
AS

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_CONTENT(p_policyRec  IN   OUT  MIGR_GVAR.PolicyRecTyp, p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_Id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_LEISURE_CONT_ONLY_POLICY.ia_object_id % TYPE) IS
      SELECT ilmhp.IA_OBJECT_TYPE,
      ilmhp.IA_HOME_TYPE,
      ilmhp.IA_HOME_SUBTYPE,
      ilmhc.IA_CERTAIN_LOCKS,
      ilmhc.IA_PROPERTY_ID,
      ilmhc.IA_POLICY_REF,
      ilmhc.IA_NAME,
      ilmhc.IA_COUNTRY_CODE,
      ilmhc.IA_CITY,
      ilmhc.IA_ADDRESS,
      ilmhc.IA_POST_CODE,
      ilmhp.IA_IDPLPS
      FROM IA_LEISURE_CONT_ONLY_POLICY ilmhp
      JOIN IA_LEISURE_CONT_ONLY_CONTENT ilmhc
      ON ilmhp.ia_object_id = ilmhc.ia_object_id
      WHERE 1 = 1
      AND ilmhc.ia_object_id = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
    v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Create Object Leisure Mobile Home Content';
      l_policyRec.migrArea := 'MIGR_API_LEISURE_CONT_ONLY.MIGRATE_O_CONTENT';
      l_policyRec.migrRelTbl := 'IA_LEISURE_CONT_ONLY_CONTENT';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)
      LOOP

            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;
            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

            IF (l_address IS NULL   OR l_postCode IS NULL    OR l_city IS NULL   OR l_country_code IS NULL)       THEN
            l_address := p_addressTab(1).r_address;
            l_postCode := p_addressTab(1).r_postCode;
            l_city := p_addressTab(1).r_city;
            l_country_code := p_addressTab(1).r_countryCode;

            END IF;

            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_CERTAIN_LOCKS);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
            ---20170525 Non-mandatory Attributes participating in calculation formulas should not be null - OPP4 LIVING AREA
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '0');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            IF v_address_Id IS NOT NULL   THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            END IF;

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY') ;

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

           IF v_address_Id IS NULL   THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

             IF l_evres = MIGR_GVAR.GV_EVRES_ERROR     THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr   :=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';

            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                  l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                 IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                  END IF;
            END IF;

           INSERT INTO MIGR_O_LEISURE_CONT_ONLY ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
           VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
      p_policyRec:=l_policyRec;

      EXCEPTION
          WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_policyRec);
               l_policyRec.continue_migr   :=FALSE;
              p_policyRec:=l_policyRec;

END MIGRATE_O_CONTENT;

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

FUNCTION  MIGRATE_LEISURE_CONT_ONLY(p_policyRec IN  MIGR_GVAR.PolicyRecTyp) RETURN MIGR_GVAR.PolicyRecTyp
AS

      v_is_obj_ok         BOOLEAN;
      v_address_id        NUMBER;
      CURSOR c_iaObj (vPOLICY_IDPL IA_LEISURE_CONT_ONLY_POLICY.IA_IDPL % TYPE) IS
      SELECT ilmhp.IA_POLICY_REF,
      ilmhp.IA_IDPL,
      ilmhp.IA_PSTP,
      ilmhp.ia_object_id,
      ilmhp.IA_OBJECT_TYPE,
      ilmhp.IA_OBJ_DEDUCT,
      ia.IA_ADDRESS,
      ia.IA_CITY,
      ia.IA_POST_CODE,
      ia.IA_COUNTRY
      --FA 20161007 no needed check mov.object_id,  mov.INS_OBJECT_ID
      FROM IA_LEISURE_CONT_ONLY_POLICY ilmhp
      --FA 20161007 no needed check LEFT JOIN MIGR_O_LEISURE_CONT_ONLY mov ON ilmhp.ia_object_id = mov.ia_object_id
      JOIN IA_ADDRESS ia
      ON ia.IA_IDPL = ilmhp.IA_IDPL
      WHERE 1 = 1
      AND ilmhp.IA_IDPL = vPOLICY_IDPL
      ORDER BY SUBSTR(ilmhp.ia_object_id, LENGTH(ilmhp.ia_object_id)) ASC;
      l_policyRec         MIGR_GVAR.PolicyRecTyp;
      r_c_iaObj           c_iaObj % ROWTYPE;
      vPropertyAddressTab MIGR_GVAR.PropertyAddressTabTyp;
BEGIN
      vPropertyAddressTab.DELETE();
      l_policyRec := p_policyRec;
      l_policyRec.migrArea := 'MIGR_API_LEISURE_CONT_ONLY.MIGRATE_LEISURE_CONT_ONLY';
      l_policyRec.migrStep := 'Create Leisure Content Only Policy';
      l_policyRec.migrRelTbl := 'IA_LEISURE_CONT_ONLY_POLICY';

      OPEN c_iaObj (l_policyRec.policy_idpl);
      << leisure_mob_home_loop >>
      LOOP

            FETCH c_iaObj INTO r_c_iaObj;
            EXIT WHEN c_iaObj % NOTFOUND;
            --add default client address
            MIGR_API_COMMON.ADD_ADDRESS_ID(vPropertyAddressTab, NULL, r_c_iaObj.IA_ADDRESS, r_c_iaObj.IA_POST_CODE, r_c_iaObj.IA_CITY, r_c_iaObj.IA_COUNTRY);

          --FA 20161007 no needed check  IF r_c_iaObj.object_id IS NULL      AND r_c_iaObj.INS_OBJECT_ID IS NULL     THEN

                  l_policyRec.ia_object_id := r_c_iaObj.ia_object_id;
                  --FA.2060912 Added for cover level functionality
                   l_policyRec.objDeduct_val :=    r_c_iaObj.IA_OBJ_DEDUCT;
                  l_policyRec.object_fail_log  :=NULL;
                  CASE r_c_iaObj.IA_OBJECT_TYPE

                  WHEN '231' THEN  ---Content
                  MIGRATE_O_CONTENT(l_policyRec, vPropertyAddressTab);

                  ELSE l_policyRec.logMsg := 'Leisure Content Only object with  ' || r_c_iaObj.ia_object_id || ' failed due to invalid object type';
                        MIGR_LOG.LOG_ERROR(l_policyRec);
                         l_policyRec.continue_migr   :=FALSE;
                        l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED due  invalid object type';
                        INSERT INTO MIGR_O_LEISURE_CONT_ONLY ( POLICY_ID, OBJECT_ID,  INS_DATE,   MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                        VALUES ( l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, SYSDATE, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

                  END CASE;

      END LOOP leisure_mob_home_loop;

      CLOSE c_iaObj;
      RETURN l_policyRec;

EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
           l_policyRec.continue_migr   :=FALSE;
          RETURN l_policyRec;
END MIGRATE_LEISURE_CONT_ONLY;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_API_LEISURE_CONT_ONLY;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_LEISURE_COOP
AS
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_CONTENT(p_policyRec  IN  OUT MIGR_GVAR.PolicyRecTyp,  p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_Id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;

      CURSOR c_iaObj (v_OBJECT_ID IA_LEISURE_COOP_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iccp.IA_OBJECT_TYPE,
      iccp.IA_HOME_TYPE,
      iccp.IA_HOME_SUBTYPE,
      iccc.IA_CERTAIN_LOCKS,
      iccc.IA_PROPERTY_ID,
      iccc.IA_POLICY_REF,
      iccc.IA_NAME,
      iccc.IA_COUNTRY_CODE,
      iccc.IA_CITY,
      iccc.IA_ADDRESS,
      iccc.IA_POST_CODE,
      iccp.IA_IDPLPS
      FROM IA_LEISURE_COOP_POLICY iccp
      JOIN IA_LEISURE_COOP_CONTENT iccc
      ON iccp.IA_OBJECT_ID = iccc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iccc.IA_OBJECT_ID = v_OBJECT_ID;
      v_is_Migrated  BOOLEAN;
      l_evres        PLS_INTEGER;
       v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN
      l_policyRec := p_policyRec;
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Leisure Coop Content';
      l_policyRec.migrArea := 'MIGR_API_LEISURE_COOP.MIGRATE_O_CONTENT';
      l_policyRec.migrRelTbl := 'IA_LEISURE_COOP_CONTENT';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL  OR l_postCode IS NULL   OR l_city IS NULL   OR l_country_code IS NULL)   THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');

            IF v_address_Id IS NOT NULL   THEN
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            ELSE

                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            END IF;

            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1','');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2',r_c_iaObj.IA_CERTAIN_LOCKS);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');

             ---20170525 Non-mandatory Attributes participating in calculation formulas should not be null - OPP4 LIVING AREA
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '0');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9','' );
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            IF v_address_Id IS NULL    THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR     THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr :=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';

             ELSE
                    l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                    MIGR_LOG.LOG_INFO(l_policyRec);
                    l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                    IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                          l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                    END IF;

            END IF;

            INSERT INTO MIGR_O_LEISURE_COOP ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;

       p_policyRec:=l_policyRec;

EXCEPTION
    WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
           p_policyRec:=l_policyRec;

END MIGRATE_O_CONTENT;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_COOPERATIVE_APART(p_policyRec  IN OUT  MIGR_GVAR.PolicyRecTyp,  p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
      IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT iavp.IA_OBJECT_TYPE,
      iavp.IA_IDPLPS,
      iavp.IA_HOME_TYPE,
      iavp.IA_HOME_SUBTYPE,
      iavc.IA_PROPERTY_ID,
      iavc.IA_POLICY_REF,
      iavc.IA_ADDRESS,
      iavc.IA_POST_CODE,
      iavc.IA_CITY,
      iavc.IA_COUNTRY_CODE,
      iavc.IA_NAME
      FROM IA_LEISURE_COOP_POLICY iavp
      JOIN IA_LEISURE_COOP_COOPERATIVE iavc
      ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
      WHERE 1 = 1
      AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
            v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Leisure Coop Apartment';
      l_policyRec.migrArea := 'MIGR_API_LEISURE_COOP.MIGRATE_O_COOPERATIVE_APART';
      l_policyRec.migrRelTbl := 'IA_LEISURE_COOP_COOPERATIVE';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL   OR l_postCode IS NULL    OR l_city IS NULL  OR l_country_code IS NULL)  THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;
            v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_id IS NOT NULL    THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

            END IF;
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

             v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

             v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

             EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

            IF v_address_id IS NULL   THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
            END IF;
            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR     THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr :=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';

            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                  l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                  END IF;
            END IF;

           INSERT INTO MIGR_O_LEISURE_COOP ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
        p_policyRec:=l_policyRec;

      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
      l_policyRec.continue_migr :=FALSE;
       p_policyRec:=l_policyRec;
END MIGRATE_O_COOPERATIVE_APART;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

FUNCTION  MIGRATE_LEISURE_COOP(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)  RETURN  MIGR_GVAR.PolicyRecTyp
AS
      v_in_context        SRVCONTEXT;
      v_out_context       SRVCONTEXT;
      v_errmsg            SRVERRMSG;
      v_srverrmsg         SRVERRMSG;
      pio_err             SRVERR;
      v_beginTimer        TIMESTAMP WITH TIME ZONE;
      v_is_obj_ok         BOOLEAN;
      v_address_id        NUMBER;

      CURSOR c_iaObj (vPOLICY_IDPL IA_LEISURE_COOP_POLICY.IA_IDPL % TYPE) IS
      SELECT ivp.IA_POLICY_REF,
      ivp.IA_IDPL,
      ivp.IA_PSTP,
      ivp.IA_OBJECT_ID,
      ivp.IA_OBJECT_TYPE,
        ivp.IA_OBJ_DEDUCT,
      ia.IA_ADDRESS,
      ia.IA_CITY,
      ia.IA_POST_CODE,
      ia.IA_COUNTRY
    --FA 20161007 no needed check  mov.object_id,   mov.INS_OBJECT_ID
      FROM IA_LEISURE_COOP_POLICY  ivp
      --FA 20161007 no needed checkLEFT JOIN MIGR_O_LEISURE_COOP mov    ON ivp.IA_OBJECT_ID = mov.IA_OBJECT_ID
      JOIN IA_ADDRESS ia
      ON ia.IA_IDPL = ivp.IA_IDPL
      WHERE 1 = 1
      AND ivp.IA_IDPL = vPOLICY_IDPL
      ORDER BY SUBSTR(ivp.IA_OBJECT_ID, LENGTH(ivp.IA_OBJECT_ID)) ASC;

      r_c_iaObj           c_iaObj % ROWTYPE;
      l_policyRec         MIGR_GVAR.PolicyRecTyp;
      vPropertyAddressTab MIGR_GVAR.PropertyAddressTabTyp;
BEGIN

      l_policyRec := p_policyRec;

      vPropertyAddressTab.DELETE();
      l_policyRec.migrArea := 'MIGR_API_LEISURE_COOP_NEW.MIGRATE_LEISURE_COOP';
      l_policyRec.migrStep := 'Create Policy Leisure Coop';
      l_policyRec.migrRelTbl := 'IA_LEISURE_COOP_POLICY';

      OPEN c_iaObj (l_policyRec.policy_idpl);
      << leisure_coop_loop >>
      LOOP

            FETCH c_iaObj INTO r_c_iaObj;
            EXIT WHEN c_iaObj % NOTFOUND;

            MIGR_API_COMMON.ADD_ADDRESS_ID(vPropertyAddressTab, NULL, r_c_iaObj.IA_ADDRESS, r_c_iaObj.IA_POST_CODE, r_c_iaObj.IA_CITY, r_c_iaObj.IA_COUNTRY);
          --FA 20161007 no needed check  IF r_c_iaObj.object_id IS NULL     AND r_c_iaObj.INS_OBJECT_ID IS NULL    THEN

                  l_policyRec.IA_OBJECT_ID := r_c_iaObj.IA_OBJECT_ID;
                  --FA.2060912 Added for cover level functionality
                  l_policyRec.objDeduct_val :=    r_c_iaObj.IA_OBJ_DEDUCT;
                  l_policyRec.object_fail_log  :=NULL;
                  CASE r_c_iaObj.IA_OBJECT_TYPE

                     WHEN '231' THEN  ---Content
                            MIGRATE_O_CONTENT(l_policyRec, vPropertyAddressTab);
                      WHEN '2705' THEN  ---EXTENDED_TRAVEL
                            MIGRATE_O_COOPERATIVE_APART(l_policyRec, vPropertyAddressTab);

                     ELSE l_policyRec.logMsg := 'Leisure Coop object with  ' || r_c_iaObj.IA_OBJECT_ID || ' failed due to invalid object type';
                          MIGR_LOG.LOG_ERROR(l_policyRec);
                          l_policyRec.continue_migr   :=FALSE;
                          l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED due  invalid object type';
                          INSERT INTO MIGR_O_LEISURE_COOP ( POLICY_ID, OBJECT_ID,  INS_DATE,   MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                           VALUES ( l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, SYSDATE, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

                  END CASE;


      END LOOP leisure_coop_loop;
      CLOSE c_iaObj;
       RETURN l_policyRec;

EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
             l_policyRec.continue_migr :=FALSE;
             RETURN l_policyRec;
END MIGRATE_LEISURE_COOP;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_API_LEISURE_COOP;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_LEISURE_HOME
  AS

  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  PROCEDURE MIGRATE_O_OUTHOUSE(p_policyRec  IN OUT     MIGR_GVAR.PolicyRecTyp,
                               p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      v_addressId    NUMBER;
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      l_evres        PLS_INTEGER;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.ia_object_id % TYPE) IS
      SELECT ilhp.IA_OBJECT_TYPE,
      ilhp.IA_HOME_TYPE,
      ilhp.IA_HOME_SUBTYPE,
      ilho.IA_COUNTRY_CODE,
      ilho.IA_CITY,
      ilho.IA_ADDRESS,
      ilho.IA_POST_CODE,
      ilho.IA_NAME,
      ilho.IA_POLICY_REF,
      ilho.IA_PROPERTY_ID,
      ilho.IA_BUILDING_AREA,
      ilho.IA_FURNISHED,
      ilho.IA_FLOORS_NO,
      ilho.IA_INSULATED,
      ilho.IA_OUTHOUSE_LABEL,
      ilho.IA_OUTHOUSE_LABEL_OTHER,
      ilhp.IA_IDPLPS
      FROM IA_LEISURE_HOME_POLICY ilhp
      JOIN IA_LEISURE_HOME_OUTHOUSE ilho
      ON ilhp.ia_object_id = ilho.ia_object_id
      WHERE 1 = 1
      AND ilho.ia_object_id = v_OBJECT_ID;
        v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
      BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_addressId := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Leisure Home Outhouse';
      l_policyRec.migrArea := 'MIGR_API_LEISURE_HOME.MIGRATE_O_OUTHOUSE';
      l_policyRec.migrRelTbl := 'IA_LEISURE_HOME_OUTHOUSE';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)   LOOP

      l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
      l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
      v_begintimer := SYSTIMESTAMP;

      l_address := r_c_iaObj.IA_ADDRESS;
      l_postCode := r_c_iaObj.IA_POST_CODE;
      l_city := r_c_iaObj.IA_CITY;
      l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

      IF (l_address IS NULL  OR l_postCode IS NULL OR l_city IS NULL OR l_country_code IS NULL) THEN
            l_address := p_addressTab(1).r_address;
            l_postCode := p_addressTab(1).r_postCode;
            l_city := p_addressTab(1).r_city;
            l_country_code := p_addressTab(1).r_countryCode;
      END IF;

      v_addressId := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_OUTHOUSE_LABEL);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', r_c_iaObj.IA_BUILDING_AREA);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_FURNISHED);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_INSULATED);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', r_c_iaObj.IA_FLOORS_NO);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', r_c_iaObj.IA_OUTHOUSE_LABEL_OTHER);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

      IF v_addressId IS NOT NULL  THEN
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_addressId);
      ELSE
            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
      END IF;

        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

       v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

       EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

       SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

      IF v_addressId IS NULL   THEN
            SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_addressId);
            MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_addressId, l_address, l_postCode, l_city, l_country_code);
      END IF;

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

      IF l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
            l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
            MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
            l_policyRec.continue_migr :=FALSE;
            l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';

        ELSE

            l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
            MIGR_LOG.LOG_INFO(l_policyRec);
            l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);


            IF l_evres = MIGR_GVAR.GV_EVRES_WARNING     THEN
                  l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                  MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
            END IF;
      END IF;

      INSERT INTO MIGR_O_LEISURE_HOME (  NAME, policy_ref, policy_id, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, mig_batch_id, POLICY_IDPL,OBJ_ERROR_LOG)
      VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer,SYSTIMESTAMP,l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
      p_policyRec:=l_policyRec;
      EXCEPTION
            WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr :=FALSE;
            p_policyRec:=l_policyRec;
    END MIGRATE_O_OUTHOUSE;
  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_BUILDING(p_policyRec  IN   OUT   MIGR_GVAR.PolicyRecTyp,
                               p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      v_addressId    NUMBER;

      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.ia_object_id % TYPE) IS
      SELECT ilhp.IA_OBJECT_TYPE,
      ilhp.IA_HOME_TYPE,
      ilhp.IA_HOME_SUBTYPE,
      ilhb.IA_PROPERTY_ID,
      ilhb.IA_LIVING_AREA,
      ilhb.IA_ADDITIONAL_AREA,
      ilhb.IA_CHIMNEY,
      ilhb.IA_BATHROOMS_NO,
      ilhb.IA_BUILT_YEAR,
      ilhb.IA_RENOVATION_YEAR,
      ilhb.IA_WATER_INSIDE,
      ilhb.IA_COUNTRY_CODE,
      ilhb.IA_CITY,
      ilhb.IA_ADDRESS,
      ilhb.IA_POST_CODE,
      ilhb.IA_NAME,
      ilhb.IA_BUILDING_ID,
      ilhb.IA_BUILDING_LABEL,
      ilhb.IA_PURCHASE_DATE,
      ilhb.IA_STANDARD_POINTS,
      ilhb.IA_BUILDING_TYPE,
      ilhb.IA_TAXABLE_VALUE,
      ilhb.IA_POLICY_REF,
      ilhb.IA_BUILDING_ADDRESS,
      ilhp.IA_IDPLPS
      FROM IA_LEISURE_HOME_POLICY ilhp
      JOIN IA_LEISURE_HOME_BUILDING ilhb
      ON ilhp.ia_object_id = ilhb.ia_object_id
      WHERE 1 = 1
      AND ilhp.ia_object_id = v_OBJECT_ID;
       v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
      l_evres        PLS_INTEGER;
      BEGIN
            v_begintimer := SYSTIMESTAMP;
            v_addressId := NULL;
            l_in_context := NULL;
            l_out_context := NULL;
            pio_err := NULL;
            l_policyRec := p_policyRec;
            l_policyRec.migrStep := 'Create Object Leisure Home Building';
            l_policyRec.migrArea := 'MIGR_API_LEISURE_HOME.MIGRATE_O_BUILDING';
            l_policyRec.migrRelTbl := 'IA_LEISURE_HOME_BUILDING';

            FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)  LOOP

                  l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
                  l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
                  l_address := r_c_iaObj.IA_ADDRESS;
                  l_postCode := r_c_iaObj.IA_POST_CODE;
                  l_city := r_c_iaObj.IA_CITY;
                  l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

                  IF (l_address IS NULL  OR l_postCode IS NULL  OR l_city IS NULL OR l_country_code IS NULL)  THEN

                        l_address := p_addressTab(1).r_address;
                        l_postCode := p_addressTab(1).r_postCode;
                        l_city := p_addressTab(1).r_city;
                        l_country_code := p_addressTab(1).r_countryCode;
                  END IF;

                  v_addressId := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', l_policyRec.property_id);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', r_c_iaObj.IA_BUILDING_ID);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_BUILDING_LABEL);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', r_c_iaObj.IA_BUILDING_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', r_c_iaObj.IA_LIVING_AREA);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', r_c_iaObj.IA_ADDITIONAL_AREA);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', r_c_iaObj.IA_BUILT_YEAR);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', r_c_iaObj.IA_RENOVATION_YEAR);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', r_c_iaObj.IA_PURCHASE_DATE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', r_c_iaObj.IA_CHIMNEY);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', r_c_iaObj.IA_BATHROOMS_NO);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', r_c_iaObj.IA_WATER_INSIDE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '1'); ----RECONSTRUCTION COST
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', r_c_iaObj.IA_STANDARD_POINTS);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', r_c_iaObj.IA_TAXABLE_VALUE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

                  IF v_addressId IS NULL   THEN
                          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
                  ELSE
                        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_addressId);
                  END IF;
                  v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

                   v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                   EXECUTE IMMEDIATE v_stmst    USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                  SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

                    IF v_addressId IS NULL  THEN
                          SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_addressId);
                          MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_addressId, l_address, l_postCode, l_city, l_country_code);
                    END IF;

                    l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

                    IF   l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                          l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                          l_policyRec.continue_migr :=FALSE;
                          l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED to insert property';

                    ELSE

                          l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                          MIGR_LOG.LOG_INFO(l_policyRec);
                           l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);
                           l_policyRec:=MIGR_API_COMMON.CALCULATE_RECONSTRUCTION_COST(l_policyRec);

                          IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                                l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                                MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                          END IF;

                    END IF;

                    INSERT INTO MIGR_O_LEISURE_HOME ( NAME, policy_ref, policy_id, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, mig_batch_id, POLICY_IDPL,OBJ_ERROR_LOG   )
                    VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer,SYSTIMESTAMP,l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

            END LOOP;

            p_policyRec:=l_policyRec;

      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
      l_policyRec.continue_migr :=FALSE;
      p_policyRec:=l_policyRec;

    END MIGRATE_O_BUILDING;

  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_CONTENT(p_policyRec  IN  OUT   MIGR_GVAR.PolicyRecTyp,
                              p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
            l_in_context   SRVCONTEXT;
            l_out_context  SRVCONTEXT;
            pio_err        SRVERR;
            v_begintimer   TIMESTAMP WITH TIME ZONE;
            v_addressId    NUMBER;
            l_address      VARCHAR2(256);
            l_postCode     VARCHAR2(256);
            l_city         VARCHAR2(256);
            l_country_code VARCHAR2(256);
            l_policyRec    MIGR_GVAR.PolicyRecTyp;
            CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.ia_object_id % TYPE) IS
            SELECT ilhp.IA_OBJECT_TYPE,
            ilhp.IA_HOME_TYPE,
            ilhp.IA_HOME_SUBTYPE,
            ilhc.IA_TOTAL_LIVING_AREA,
            ilhc.IA_PROPERTY_ID,
            ilhc.IA_CERTAIN_LOCKS,
            ilhc.IA_POLICY_REF,
            ilhc.IA_NAME,
            ilhc.IA_COUNTRY_CODE,
            ilhc.IA_CITY,
            ilhc.IA_ADDRESS,
            ilhc.IA_POST_CODE,
            ilhp.IA_IDPLPS
            FROM IA_LEISURE_HOME_POLICY ilhp
            JOIN IA_LEISURE_HOME_CONTENT ilhc
            ON ilhp.ia_object_id = ilhc.ia_object_id
            WHERE 1 = 1
            AND ilhc.ia_object_id = v_OBJECT_ID;
            l_evres        PLS_INTEGER;
     v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
      BEGIN
            l_policyRec := p_policyRec;
            v_addressId := NULL;
            l_in_context := NULL;
            l_out_context := NULL;
            pio_err := NULL;
            l_policyRec.migrStep := 'Create Object Leisure Home Content';
            l_policyRec.migrArea := 'MIGR_API_LEISURE_HOME.MIGRATE_O_CONTENT';
            l_policyRec.migrRelTbl := 'IA_LEISURE_HOME_CONTENT';

            FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)
            LOOP

                  v_begintimer := SYSTIMESTAMP;
                  l_address := r_c_iaObj.IA_ADDRESS;
                  l_postCode := r_c_iaObj.IA_POST_CODE;
                  l_city := r_c_iaObj.IA_CITY;
                  l_country_code := r_c_iaObj.IA_COUNTRY_CODE;
                  l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
                  l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

                 IF (l_address IS NULL  OR l_postCode IS NULL OR l_city IS NULL  OR l_country_code IS NULL)  THEN
                        l_address := p_addressTab(1).r_address;
                        l_postCode := p_addressTab(1).r_postCode;
                        l_city := p_addressTab(1).r_city;
                        l_country_code := p_addressTab(1).r_countryCode;
                  END IF;

                 v_addressId := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_CERTAIN_LOCKS);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', r_c_iaObj.IA_TOTAL_LIVING_AREA );
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_TOTAL_LIVING_AREA );
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', l_policyRec.property_id);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

                  IF v_addressId IS NOT NULL THEN
                        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_addressId);
                  ELSE
                        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
                  END IF;

                  v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

                  v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                  EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                  SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

                  IF v_addressId IS NULL    THEN
                        SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_addressId);
                        MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_addressId, l_address, l_postCode, l_city, l_country_code);
                  END IF;

                  l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

                   IF l_evres = MIGR_GVAR.GV_EVRES_ERROR     THEN
                        l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                        l_policyRec.continue_migr :=FALSE;
                        l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
                  ELSE
                        l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                        MIGR_LOG.LOG_INFO(l_policyRec);
                        l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                        IF  l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                              l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                              MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);

                        END IF;

                  END IF;

                  INSERT INTO MIGR_O_LEISURE_HOME (  NAME, policy_ref, policy_id, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, mig_batch_id, policy_idpl ,OBJ_ERROR_LOG   )
                  VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

            END LOOP;

            p_policyRec:=l_policyRec;

      EXCEPTION
            WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr :=FALSE;
            p_policyRec:=l_policyRec;
    END MIGRATE_O_CONTENT;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_ALL_RISK(p_policyRec  IN  OUT   MIGR_GVAR.PolicyRecTyp,
                              p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
            l_in_context   SRVCONTEXT;
            l_out_context  SRVCONTEXT;
            pio_err        SRVERR;
            v_begintimer   TIMESTAMP WITH TIME ZONE;
            v_addressId    NUMBER;
            l_address      VARCHAR2(256);
            l_postCode     VARCHAR2(256);
            l_city         VARCHAR2(256);
            l_country_code VARCHAR2(256);
            l_policyRec    MIGR_GVAR.PolicyRecTyp;
            CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.ia_object_id % TYPE) IS
            SELECT ilhp.IA_OBJECT_TYPE,
            ilhp.IA_HOME_TYPE,
            ilhp.IA_HOME_SUBTYPE,
            ilhc.IA_TOTAL_LIVING_AREA,
            ilhc.IA_PROPERTY_ID,
            ilhc.IA_POLICY_REF,
            ilhc.IA_NAME,
            ilhc.IA_COUNTRY_CODE,
            ilhc.IA_CITY,
            ilhc.IA_ADDRESS,
            ilhc.IA_POST_CODE,
            ilhp.IA_IDPLPS
            FROM IA_LEISURE_HOME_POLICY ilhp
            JOIN IA_LEISURE_HOME_ALL_RISK ilhc
            ON ilhp.ia_object_id = ilhc.ia_object_id
            WHERE 1 = 1
            AND ilhc.ia_object_id = v_OBJECT_ID;
            l_evres        PLS_INTEGER;
     v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
      BEGIN
            l_policyRec := p_policyRec;
            v_addressId := NULL;
            l_in_context := NULL;
            l_out_context := NULL;
            pio_err := NULL;
            l_policyRec.migrStep := 'Create Object Leisure Home Content';
            l_policyRec.migrArea := 'MIGR_API_LEISURE_HOME.MIGRATE_O_ALL_RISK';
            l_policyRec.migrRelTbl := 'IA_LEISURE_HOME_ALL_RISK';

            FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)
            LOOP

                  v_begintimer := SYSTIMESTAMP;
                  l_address := r_c_iaObj.IA_ADDRESS;
                  l_postCode := r_c_iaObj.IA_POST_CODE;
                  l_city := r_c_iaObj.IA_CITY;
                  l_country_code := r_c_iaObj.IA_COUNTRY_CODE;
                  l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
                  l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

                 IF (l_address IS NULL   OR l_postCode IS NULL   OR l_city IS NULL  OR l_country_code IS NULL)    THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
                  END IF;
                  v_addressId := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', r_c_iaObj.IA_TOTAL_LIVING_AREA);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

                  IF v_addressId IS NOT NULL    THEN
                        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_addressId);
                  ELSE
                      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
                  END IF;
                  v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

                  v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                  EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                  SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

                   IF v_addressId IS NULL  THEN
                          SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_addressId);
                          MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_addressId, l_address, l_postCode, l_city, l_country_code);
                    END IF;

                    l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

                    IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
                          l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                          l_policyRec.continue_migr :=FALSE;
                          l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';
                  ELSE
                        l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                        MIGR_LOG.LOG_INFO(l_policyRec);
                        l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                        IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                              l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                              MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                        END IF;
                   END IF;

                   INSERT INTO MIGR_O_LEISURE_HOME (  NAME, policy_ref, policy_id, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, mig_batch_id, POLICY_IDPL,OBJ_ERROR_LOG    )
                  VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

            END LOOP;

            p_policyRec:=l_policyRec;

      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr :=FALSE;
            p_policyRec:=l_policyRec;
    END MIGRATE_O_ALL_RISK;

  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------

  FUNCTION MIGRATE_LEISURE_HOME(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)
    RETURN  MIGR_GVAR.PolicyRecTyp
    AS

          v_addressId         NUMBER;
          CURSOR c_iaObj (vPOLICY_IDPL IA_VILLAHEM_POLICY.IA_IDPL % TYPE) IS
          SELECT ilhp.IA_POLICY_REF,
          ilhp.IA_IDPL,
          ilhp.IA_PSTP,
          ilhp.ia_object_id,
          ilhp.IA_OBJECT_TYPE,
          ilhp.IA_OBJ_DEDUCT,
          ia.IA_ADDRESS,
          ia.IA_CITY,
          ia.IA_POST_CODE,
          ia.IA_COUNTRY --,
        --FA 20161007 no needed check  mov.OBJECT_ID,   mov.INS_OBJECT_ID
          FROM IA_LEISURE_HOME_POLICY ilhp
          --FA 20161007 no needed check LEFT JOIN MIGR_O_LEISURE_HOME mov ON ilhp.ia_object_id = mov.ia_object_id
          JOIN IA_ADDRESS ia
          ON ia.IA_IDPL = ilhp.IA_IDPL
          WHERE 1 = 1
          AND ilhp.IA_IDPL = vPOLICY_IDPL
          ORDER BY SUBSTR(ilhp.ia_object_id, LENGTH(ilhp.ia_object_id)) ASC;

          r_c_iaObj           c_iaObj % ROWTYPE;
          vPropertyAddressTab MIGR_GVAR.PropertyAddressTabTyp;
          l_policyRec         MIGR_GVAR.PolicyRecTyp;
          BEGIN

                vPropertyAddressTab.DELETE();
                l_policyRec := p_policyRec;

                l_policyRec.migrRelTbl := 'IA_LEISURE_HOME_POLICY';
                l_policyRec.migrArea := 'MIGR_API_LEISURE_HOME.MIGRATE_LEISURE_HOME';
                l_policyRec.migrStep := 'Create Leisure Home Policy ';

                OPEN c_iaObj (l_policyRec.policy_idpl);

                << leisure_home_loop >>
                LOOP

                FETCH c_iaObj INTO r_c_iaObj;
                EXIT WHEN c_iaObj % NOTFOUND;
                --add default client address

                MIGR_API_COMMON.ADD_ADDRESS_ID(vPropertyAddressTab, NULL, r_c_iaObj.IA_ADDRESS, r_c_iaObj.IA_POST_CODE, r_c_iaObj.IA_CITY, r_c_iaObj.IA_COUNTRY);
             --FA 20161007 no needed check   IF r_c_iaObj.OBJECT_ID IS NULL   AND r_c_iaObj.INS_OBJECT_ID IS NULL  THEN

                    l_policyRec.ia_object_id := r_c_iaObj.ia_object_id;
                    --FA.2060912 Added for cover level functionality
                      l_policyRec.objDeduct_val :=    r_c_iaObj.IA_OBJ_DEDUCT;
                     l_policyRec.object_fail_log  :=NULL;
                    CASE r_c_iaObj.IA_OBJECT_TYPE
                        WHEN '180' THEN  ---Building
                        MIGRATE_O_BUILDING(l_policyRec, vPropertyAddressTab);

                        WHEN '181' THEN  ---Content
                        MIGRATE_O_CONTENT(l_policyRec, vPropertyAddressTab);

                        WHEN '182' THEN  ---Outhouse
                        MIGRATE_O_OUTHOUSE(l_policyRec, vPropertyAddressTab);

                        WHEN '3003' THEN ---All-Risk Building
                        MIGRATE_O_ALL_RISK(l_policyRec, vPropertyAddressTab);

                        ELSE l_policyRec.logMsg := 'Leisure Home object with  ' || r_c_iaObj.ia_object_id || ' failed due to invalid object type';

                            MIGR_LOG.LOG_ERROR(l_policyRec);
                            l_policyRec.continue_migr :=FALSE;
                            l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED due  invalid object type';
                            INSERT INTO MIGR_O_LEISURE_HOME ( POLICY_ID, OBJECT_ID,  INS_DATE,   MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                             VALUES ( l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, SYSDATE, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

                    END CASE;


                END LOOP leisure_home_loop;

                CLOSE c_iaObj;
                RETURN l_policyRec ;

          EXCEPTION
                WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          RETURN l_policyRec;
    END MIGRATE_LEISURE_HOME;
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

END MIGR_API_LEISURE_HOME;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_LEISURE_MOBILE_HOME
  AS

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_OUTHOUSE(p_policyRec  IN  OUT   MIGR_GVAR.PolicyRecTyp,
                               p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      v_address_Id   NUMBER;
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.ia_object_id % TYPE) IS
      SELECT ilmhp.IA_OBJECT_TYPE,
      ilmhp.IA_HOME_TYPE,
      ilmhp.IA_HOME_SUBTYPE,
      ilmho.IA_COUNTRY_CODE,
      ilmho.IA_CITY,
      ilmho.IA_ADDRESS,
      ilmho.IA_POST_CODE,
      ilmho.IA_NAME,
      ilmho.IA_POLICY_REF,
      ilmho.IA_BUILDING_AREA,
      ilmho.IA_PROPERTY_ID,
      ilmho.IA_FURNISHED,
      ilmho.IA_FLOORS_NO,
      ilmho.IA_INSULATED,
      ilmho.IA_OUTHOUSE_LABEL,
      ilmho.IA_OUTHOUSE_LABEL_OTHER,
      ilmhp.IA_IDPLPS
      FROM IA_LEISURE_MOBILE_HOME_POLICY ilmhp
      JOIN IA_LEISURE_MOB_HOME_OUTHOUSE ilmho
      ON ilmhp.ia_object_id = ilmho.ia_object_id
      WHERE 1 = 1
      AND ilmho.ia_object_id = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Create Object Leisure Mobile Home Outhouse';
      l_policyRec.migrArea := 'MIGR_API_LEISURE_MOBILE_HOME.MIGRATE_O_OUTHOUSE';
      l_policyRec.migrRelTbl := 'IA_LEISURE_MOB_HOME_OUTHOUSE';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)  LOOP

            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
            v_begintimer := SYSTIMESTAMP;

            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;


            IF (l_address IS NULL  OR l_postCode IS NULL   OR l_city IS NULL    OR l_country_code IS NULL)  THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;
            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_OUTHOUSE_LABEL);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', r_c_iaObj.IA_BUILDING_AREA);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_FURNISHED);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_INSULATED);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', r_c_iaObj.IA_FLOORS_NO);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', r_c_iaObj.IA_OUTHOUSE_LABEL_OTHER);

            IF v_address_Id IS NOT NULL  THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            END IF;

            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            IF v_address_Id IS NULL  THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr :=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';

            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                  MIGR_LOG.LOG_INFO(l_policyRec);

                  l_policyRec:=  MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                  END IF;
            END IF;

            INSERT INTO MIGR_O_LEISURE_MOBILE_HOME (  NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, mig_batch_id, policy_idpl  ,OBJ_ERROR_LOG   )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;
      p_policyRec:=l_policyRec;

      EXCEPTION
            WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr :=FALSE;
            p_policyRec:=l_policyRec;

    END MIGRATE_O_OUTHOUSE;
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_BUILDING(p_policyRec  IN OUT    MIGR_GVAR.PolicyRecTyp,
  p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
  IS
        l_in_context   SRVCONTEXT;
        l_out_context  SRVCONTEXT;
        pio_err        SRVERR;
        v_begintimer   TIMESTAMP WITH TIME ZONE;
        l_address      VARCHAR2(256);
        l_postCode     VARCHAR2(256);
        l_city         VARCHAR2(256);
        l_country_code VARCHAR2(256);
        l_policyRec    MIGR_GVAR.PolicyRecTyp;

        CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.ia_object_id % TYPE) IS
        SELECT ilmhp.IA_OBJECT_TYPE,
        ilmhp.IA_HOME_TYPE,
        ilmhp.IA_HOME_SUBTYPE,
        ilmhb.IA_PROPERTY_ID,
        ilmhb.IA_LIVING_AREA,
        ilmhb.IA_BATHROOMS_NO,
        ilmhb.IA_BUILT_YEAR,
        ilmhb.IA_RENOVATION_YEAR,
        ilmhb.IA_WATER_INSIDE,
        ilmhb.IA_COUNTRY_CODE,
        ilmhb.IA_CITY,
        ilmhb.IA_ADDRESS,
        ilmhb.IA_POST_CODE,
        ilmhb.IA_NAME,
        ilmhb.IA_BUILDING_LABEL,
        ilmhb.IA_PURCHASE_DATE,
        ilmhb.IA_POLICY_REF,
        ilmhp.IA_IDPLPS
        FROM IA_LEISURE_MOBILE_HOME_POLICY ilmhp
        JOIN IA_LEISURE_MOB_HOME_BUILDING ilmhb
        ON ilmhp.ia_object_id = ilmhb.ia_object_id
        WHERE 1 = 1
        AND ilmhb.ia_object_id = v_OBJECT_ID;
        v_address_Id   NUMBER;
        l_evres        PLS_INTEGER;
        v_stmst    VARCHAR2( 400);
        v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
  BEGIN
        v_begintimer := SYSTIMESTAMP;
        l_policyRec := p_policyRec;
        v_address_Id := NULL;
        l_policyRec.migrStep := 'Create Object Leisure Mobile Home Building';
        l_policyRec.migrArea := 'MIGR_API_LEISURE_MOBILE_HOME.MIGRATE_O_BUILDING';
        l_policyRec.migrRelTbl := 'IA_LEISURE_MOB_HOME_BUILDING';


        FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)     LOOP

            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL   OR l_postCode IS NULL   OR l_city IS NULL   OR l_country_code IS NULL)   THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_BUILDING_LABEL);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', r_c_iaObj.IA_LIVING_AREA);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', r_c_iaObj.IA_BUILT_YEAR);  --1: Residence 2: Store
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', r_c_iaObj.IA_RENOVATION_YEAR);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', r_c_iaObj.IA_PURCHASE_DATE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', r_c_iaObj.IA_BATHROOMS_NO);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', r_c_iaObj.IA_WATER_INSIDE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            IF v_address_Id IS NULL   THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            ELSE
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            END IF;

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            IF v_address_Id IS NULL   THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF   l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr :=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED to insert property';

            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                  MIGR_LOG.LOG_INFO(l_policyRec);
                  l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                       MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
                  End if;
            END IF;

            INSERT INTO MIGR_O_LEISURE_MOBILE_HOME ( NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, mig_batch_id, POLICY_IDPL,OBJ_ERROR_LOG   )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

        END LOOP;

        p_policyRec:=l_policyRec;

  EXCEPTION
  WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_policyRec);
        l_policyRec.continue_migr :=FALSE;
        p_policyRec:=l_policyRec;
  END MIGRATE_O_BUILDING;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  PROCEDURE MIGRATE_O_CONTENT(p_policyRec  IN OUT    MIGR_GVAR.PolicyRecTyp,
                              p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_Id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.ia_object_id % TYPE) IS
      SELECT ilmhp.IA_OBJECT_TYPE,
      ilmhp.IA_HOME_TYPE,
      ilmhp.IA_HOME_SUBTYPE,
      ilmhc.IA_CERTAIN_LOCKS,
      ilmhc.IA_PROPERTY_ID, IA_TOTAL_LIVING_AREA,
      ilmhc.IA_POLICY_REF,
      ilmhc.IA_NAME,
      ilmhc.IA_COUNTRY_CODE,
      ilmhc.IA_CITY,
      ilmhc.IA_ADDRESS,
      ilmhc.IA_POST_CODE,
      ilmhp.IA_IDPLPS
      FROM IA_LEISURE_MOBILE_HOME_POLICY ilmhp
      JOIN IA_LEISURE_MOB_HOME_CONTENT ilmhc
      ON ilmhp.ia_object_id = ilmhc.ia_object_id
      WHERE 1 = 1
      AND ilmhc.ia_object_id = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
      BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Create Object Leisure Mobile Home Content';
      l_policyRec.migrArea := 'MIGR_API_LEISURE_MOBILE_HOME.MIGRATE_O_CONTENT';
      l_policyRec.migrRelTbl := 'IA_LEISURE_MOB_HOME_CONTENT';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.ia_object_id)
      LOOP

            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;
            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

            IF (l_address IS NULL  OR l_postCode IS NULL  OR l_city IS NULL  OR l_country_code IS NULL)   THEN
            l_address := p_addressTab(1).r_address;
            l_postCode := p_addressTab(1).r_postCode;
            l_city := p_addressTab(1).r_city;
            l_country_code := p_addressTab(1).r_countryCode;

            END IF;

            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_CERTAIN_LOCKS);
            ---20170525 Non-mandatory Attributes participating in calculation formulas should not be null
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', NVL( r_c_iaObj.IA_TOTAL_LIVING_AREA,'0'));
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', NVL( r_c_iaObj.IA_TOTAL_LIVING_AREA,'0'));

            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', l_policyRec.property_id);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            IF v_address_Id IS NOT NULL  THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            ELSE
                SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            END IF;

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

            EXECUTE IMMEDIATE v_stmst   USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.object_id);

            IF v_address_Id IS NULL    THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_ERROR     THEN
                  l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                  l_policyRec.continue_migr :=FALSE;
                  l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';

            ELSE
                  l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.object_id;
                  MIGR_LOG.LOG_INFO(l_policyRec);
                  l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                  IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                        l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                  END IF;

            END IF;

             INSERT INTO MIGR_O_LEISURE_MOBILE_HOME (  NAME, policy_ref, policy_id, object_id, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, ia_object_id, mig_batch_id, policy_idpl,OBJ_ERROR_LOG   )
            VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.policy_id, l_policyRec.object_id, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer, SYSTIMESTAMP,l_policyRec.ia_object_id, l_policyRec.mig_batch_id, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

      END LOOP;

      p_policyRec:=l_policyRec;
      EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr :=FALSE;
            p_policyRec:=l_policyRec;
    END MIGRATE_O_CONTENT;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  FUNCTION MIGRATE_LEISURE_MOBILE_HOME(p_policyRec IN  MIGR_GVAR.PolicyRecTyp)
     RETURN  MIGR_GVAR.PolicyRecTyp
    AS

        v_address_id        NUMBER;

        CURSOR c_iaObj (vPOLICY_IDPL IA_VILLAHEM_POLICY.IA_IDPL % TYPE) IS
        SELECT ilmhp.IA_POLICY_REF,
        ilmhp.IA_IDPL,
        ilmhp.IA_PSTP,
        ilmhp.ia_object_id,
        ilmhp.IA_OBJECT_TYPE,
        ia.IA_ADDRESS,
        ia.IA_CITY,
        ilmhp.IA_OBJ_DEDUCT,
        ia.IA_POST_CODE,
        ia.IA_COUNTRY --,
      --FA 20161007 no needed check  mov.object_id,    mov.INS_OBJECT_ID
        FROM IA_LEISURE_MOBILE_HOME_POLICY ilmhp
      --FA 20161007 no needed check  LEFT JOIN MIGR_O_LEISURE_MOBILE_HOME mov    ON ilmhp.ia_object_id = mov.ia_object_id
        JOIN IA_ADDRESS ia
        ON ia.IA_IDPL = ilmhp.IA_IDPL
        WHERE 1 = 1
        AND ilmhp.IA_IDPL = vPOLICY_IDPL
        ORDER BY SUBSTR(ilmhp.ia_object_id, LENGTH(ilmhp.ia_object_id)) ASC;
        l_policyRec         MIGR_GVAR.PolicyRecTyp;
        r_c_iaObj           c_iaObj % ROWTYPE;
        vPropertyAddressTab MIGR_GVAR.PropertyAddressTabTyp;
        BEGIN
              vPropertyAddressTab.DELETE();
              l_policyRec := p_policyRec;

              l_policyRec.migrArea := 'MIGR_API_LEISURE_MOBILE_HOME.MIGRATE_LEISURE_MOBILE_HOME';
              l_policyRec.migrStep := 'Create Leisure Mobile Home Policy';
              l_policyRec.migrRelTbl := 'IA_LEISURE_MOBILE_HOME_POLICY';

              OPEN c_iaObj (l_policyRec.policy_idpl);

              << leisure_mob_home_loop >>
              LOOP

              FETCH c_iaObj INTO r_c_iaObj;
              EXIT WHEN c_iaObj % NOTFOUND;
              --add default client address
              MIGR_API_COMMON.ADD_ADDRESS_ID(vPropertyAddressTab, NULL, r_c_iaObj.IA_ADDRESS, r_c_iaObj.IA_POST_CODE, r_c_iaObj.IA_CITY, r_c_iaObj.IA_COUNTRY);

         --FA 20161007 no needed check     IF r_c_iaObj.object_id IS NULL AND r_c_iaObj.INS_OBJECT_ID IS NULL THEN

                    l_policyRec.ia_object_id := r_c_iaObj.ia_object_id;
                    --FA.2060912 Added for cover level functionality
                    l_policyRec.objDeduct_val :=    r_c_iaObj.IA_OBJ_DEDUCT;
                    l_policyRec.object_fail_log  :=NULL;
                    CASE r_c_iaObj.IA_OBJECT_TYPE

                        WHEN '184' THEN  ---Building
                        MIGRATE_O_BUILDING(l_policyRec, vPropertyAddressTab);

                        WHEN '181' THEN  ---Content
                        MIGRATE_O_CONTENT(l_policyRec, vPropertyAddressTab );

                        WHEN '182' THEN  ---Outhouse
                        MIGRATE_O_OUTHOUSE(l_policyRec, vPropertyAddressTab );

                        ELSE l_policyRec.logMsg := 'Leisure Mobile Home object with  ' || r_c_iaObj.ia_object_id || ' failed due to invalid object type';
                              MIGR_LOG.LOG_ERROR(l_policyRec);
                               l_policyRec.continue_migr :=FALSE;
                              l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED due  invalid object type';
                              INSERT INTO MIGR_O_LEISURE_MOBILE_HOME ( POLICY_ID, OBJECT_ID,  INS_DATE,   MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                               VALUES ( l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, SYSDATE, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);
                    END CASE;


              END LOOP leisure_mob_home_loop;

              CLOSE c_iaObj;
              RETURN l_policyRec;

        EXCEPTION
        WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          RETURN l_policyRec;
    END MIGRATE_LEISURE_MOBILE_HOME;
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

END MIGR_API_LEISURE_MOBILE_HOME;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_POLICY
  AS
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Commisions Workaround-should be moved to common
    /*FUNCTION SET_POLICY_AGENT_COMMISSIONS (p_policyRec IN  MIGR_GVAR.PolicyRecTyp ) RETURN  MIGR_GVAR.PolicyRecTyp
  IS
     l_policyRec               MIGR_GVAR.PolicyRecTyp ;
     l_PolicyAgentRecord  INSIS_GEN_V10.P_AGENT_TYPE;
     PIO_ERR                  SRVERR;
      l_commissionRec        INSIS_GEN_V10.POLICY_COMMISSIONS%ROWTYPE;
      l_comObjRec INSIS_GEN_V10.P_COMMISSION_TYPE;
   BEGIN
     l_policyRec := p_policyRec;
     l_comObjRec := NEW  INSIS_GEN_V10.P_COMMISSION_TYPE;
     SELECT * into l_commissionRec FROM  INSIS_GEN_V10.policy_commissions where  policy_id =  l_policyRec.policy_id AND COMM_TYPE='SALES';
    l_comObjRec.ENGAGEMENT_ID:=l_commissionRec.ENGAGEMENT_ID;
    l_comObjRec.POLICY_ID :=   l_commissionRec.POLICY_ID;
    l_comObjRec.ANNEX_ID :=l_commissionRec.ANNEX_ID;
    l_comObjRec.INSR_TYPE  :=l_commissionRec.INSR_TYPE  ;
    l_comObjRec.COMM_TYPE:=   'BELONGS';
      l_comObjRec.COVER_TYPE:= l_commissionRec.COVER_TYPE;
    l_comObjRec.COMM_VALUE:=l_commissionRec.COMM_VALUE;
      l_comObjRec.CURRENCY :=   l_commissionRec.CURRENCY ;
              l_comObjRec.COMM_DIMENSION := l_commissionRec.COMM_DIMENSION ;
              l_comObjRec.ON_INSTALL :=  l_commissionRec.ON_INSTALL;
              l_comObjRec.HOLD_COMMISSION := l_commissionRec.HOLD_COMMISSION  ;
              l_comObjRec.VALID_FROM :=  l_commissionRec.VALID_FROM;
              l_comObjRec.VALID_TO :=  l_commissionRec.VALID_TO;
             l_comObjRec.AUX_ANNEX_ID:=  l_commissionRec.AUX_ANNEX_ID;
              l_comObjRec.POLICY_YEAR:= l_commissionRec.POLICY_YEAR;


      IF NOT l_comObjRec.INSERTCOMMISSION( PIO_ERR )  THEN
               MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
               l_policyRec.continue_migr :=FALSE;
           END IF;


        l_comObjRec.ENGAGEMENT_ID:=l_commissionRec.ENGAGEMENT_ID;
        l_comObjRec.POLICY_ID :=   l_commissionRec.POLICY_ID;
        l_comObjRec.ANNEX_ID :=l_commissionRec.ANNEX_ID;
        l_comObjRec.INSR_TYPE  :=l_commissionRec.INSR_TYPE  ;
        l_comObjRec.COMM_TYPE:=   'SALES_2';
          l_comObjRec.COVER_TYPE:= l_commissionRec.COVER_TYPE;
        l_comObjRec.COMM_VALUE:=l_commissionRec.COMM_VALUE;
          l_comObjRec.CURRENCY :=   l_commissionRec.CURRENCY ;
        l_comObjRec.COMM_DIMENSION := l_commissionRec.COMM_DIMENSION ;
        l_comObjRec.ON_INSTALL :=  l_commissionRec.ON_INSTALL;
        l_comObjRec.HOLD_COMMISSION := l_commissionRec.HOLD_COMMISSION  ;
        l_comObjRec.VALID_FROM :=  l_commissionRec.VALID_FROM;
        l_comObjRec.VALID_TO :=  l_commissionRec.VALID_TO;
       l_comObjRec.AUX_ANNEX_ID:=  l_commissionRec.AUX_ANNEX_ID;
        l_comObjRec.POLICY_YEAR:= l_commissionRec.POLICY_YEAR;

        IF NOT l_comObjRec.INSERTCOMMISSION( PIO_ERR )  THEN
               MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
               l_policyRec.continue_migr :=FALSE;
         END IF;


    RETURN l_policyRec;

     EXCEPTION
        WHEN OTHERS THEN
             l_policyRec.logMsg:='Could not add commisions for agents: '||SQLERRM;
             MIGR_LOG.LOG_EXCEPTION(l_policyRec) ;
             l_policyRec.continue_migr :=FALSE;
             RETURN  l_policyRec;

    END SET_POLICY_AGENT_COMMISSIONS;        */
 --Call custoization service to insert data to anticimex integration tables
 FUNCTION  INSERT_ANTICIMEX_DATA    (p_policyRec IN  MIGR_GVAR.PolicyRecTyp ) RETURN  MIGR_GVAR.PolicyRecTyp
  IS
    l_policyRec               MIGR_GVAR.PolicyRecTyp ;
    L_IN_CONTEXT  SRVCONTEXT;
    L_OUT_CONTEXT SRVCONTEXT;
    PIO_ERR       SRVERR;
    l_evres       PLS_INTEGER;
    i             PLS_INTEGER;
  BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Insert Anticimex Data';
      l_policyRec.migrArea := 'MIGR_API_POLICY.INSERT_ANTICIMEX_DATA';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

      i:=1;

      WHILE (i<5) -- 4 not successful tries are allowed
      loop

           ---20180117 FA. Replace anticimex service with direct call for performance improvement
           INSIS_CUST.CUST_POL_DM.INSERT_ANTICIMEX_DATA( l_policyRec.policy_id, MIGR_GVAR.GV_ANNEX_ID, NULL, NULL, pio_err);

        /*  L_IN_CONTEXT := NULL;
          L_OUT_CONTEXT := NULL;
          PIO_ERR := NULL;


          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);

           INSIS_CUST.SRV_CUST_POL_DM.INSERTANTICIMEXDATA(L_IN_CONTEXT, L_OUT_CONTEXT, PIO_ERR);
                 */
           l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

          IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS THEN
            l_policyRec.logMsg := 'Anticimex Data inserted successfully. ';
            MIGR_LOG.LOG_INFO(l_policyRec);
            i:=6;

          ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
            l_policyRec.logMsg := 'Anticimex Data returned with warning -RESULT:' || NULL;
            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
            i:=6;

          ELSE
            l_policyRec.logMsg := 'Failed to insert Anticimex Data ' ;
            MIGR_LOG.LOG_ERROR(l_policyRec);
            MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
            i:=i+1;
            DBMS_LOCK.SLEEP(1);
          END IF;


      END LOOP;

      IF i=5 THEN --valex.15/3/2017 - if we had 4 not successful attempts
            l_policyRec.continue_migr:=FALSE;
            l_policyRec.policy_final_step:= 'CONFIRMED' ;
      END IF;


   RETURN  l_policyRec;
  EXCEPTION
    WHEN OTHERS THEN
         l_policyRec.logMsg:='Could not insert Anticimex Data: '||SQLERRM;
         MIGR_LOG.LOG_EXCEPTION(l_policyRec) ;
         l_policyRec.continue_migr :=FALSE;
         l_policyRec.policy_final_step:= 'CONFIRMED' ;
        RETURN  l_policyRec;
   END;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Migrate Policy Agent: BelongsTo is a mandatory role for the policy consistency
  FUNCTION SET_POLICY_AGENT_BELONGSTO (p_policyRec IN  MIGR_GVAR.PolicyRecTyp ) RETURN  MIGR_GVAR.PolicyRecTyp

  IS
     l_policyRec               MIGR_GVAR.PolicyRecTyp ;
     l_PolicyAgentRecord  INSIS_GEN_V10.P_AGENT_TYPE;
     PIO_ERR                  SRVERR;
   BEGIN

          l_policyRec:= p_policyRec;
          l_policyRec.migrArea   :='MIGR_API_POLICY.SET_POLICY_AGENT_BELONGSTO';
      IF p_policyRec.agent_belongsTo IS NOT NULL THEN

          l_PolicyAgentRecord :=  NEW INSIS_GEN_V10.P_AGENT_TYPE;
          l_PolicyAgentRecord.agent_id :=p_policyRec.agent_belongsTo;
          l_PolicyAgentRecord.policy_id:= l_policyRec.policy_id;
          l_PolicyAgentRecord.annex_id := MIGR_GVAR.GV_ANNEX_ID;
          l_PolicyAgentRecord.agent_role:=INSIS_CUST.GVAR_CUST.AGENTRL_BELONGS;
          l_PolicyAgentRecord.comm_share:=  INSIS_CUST.GVAR_CUST.COMM_SHARE_100;
          l_PolicyAgentRecord. valid_from:= l_policyRec.insr_begin ;

          IF NOT l_PolicyAgentRecord.InsertPAgent( PIO_ERR )  THEN
                MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
          END IF;

           l_policyRec.logMsg:='BelongsTo agent added succesfully';
           MIGR_LOG.LOG_INFO(l_policyRec) ;

      ELSE
            l_policyRec.logMsg:='BelongsTo is required role for policy consistency and cannot be null';
            MIGR_LOG.LOG_ERROR(l_policyRec) ;
            l_policyRec.continue_migr :=FALSE;
       END IF;

      RETURN  l_policyRec;

     EXCEPTION
        WHEN OTHERS THEN
             l_policyRec.logMsg:='Could not add required agent role:BelongsTo: '||SQLERRM;
             MIGR_LOG.LOG_EXCEPTION(l_policyRec) ;
             l_policyRec.continue_migr :=FALSE;
             RETURN  l_policyRec;

    END SET_POLICY_AGENT_BELONGSTO;

--------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------
--    --KT 20180911 defect 750239 - set agent's name
--    --params:
--    --p_policyRec MIGR_GVAR.PolicyRecTyp in out Policy Record
--    procedure SET_POLICY_AGENTS_NAMES (p_policyRec in out MIGR_GVAR.PolicyRecTyp)
--  IS
--     l_policyRec                MIGR_GVAR.PolicyRecTyp;
--     l_PolicyAgentNameRecord    INSIS_GEN_V10.P_AGENT_NAMES_TYPE;
--     v_agent_man_id             insis_gen_v10.p_people.man_id%type;
--     v_agent_name               insis_gen_v10.p_people.name%type;
--     v_agent_no                 insis_people_v10.p_agents.agent_no%type;
--     PIO_ERR                    SRVERR;
--     v_policy_agent_id          insis_gen_v10.policy_agents.policy_agent_id%type;
--     v_agent_id                 insis_gen_v10.policy_agents.agent_id%type;
--   BEGIN
--          l_policyRec                               := p_policyRec;
--          l_policyRec.migrArea                      := 'MIGR_API_POLICY.SET_POLICY_AGENTS_NAMES';
--            select policy_agent_id, agent_id into v_policy_agent_id,v_agent_id
--                from INSIS_GEN_V10.policy_agents
--            where
--                    policy_id = l_policyRec.policy_id
--                        and agent_role = 'BELONGS'
--                        and annex_id = 0;--1st annex
--
--          select pp.man_id, pp.name, pa.agent_no into v_agent_man_id, v_agent_name, v_agent_no
--              from insis_gen_v10.p_people pp
--                left join insis_gen_v10.p_agents pa on pa.man_id = pp.man_id
--         where
--                pa.agent_id = v_agent_id;
--
--          l_PolicyAgentNameRecord                   := NEW INSIS_GEN_V10.P_AGENT_NAMES_TYPE;
--          l_PolicyAgentNameRecord.policy_agent_id   := v_policy_agent_id;
--          l_PolicyAgentNameRecord.agent_no          := v_agent_no;
--          l_PolicyAgentNameRecord.agent_id          := l_policyRec.agent_id;
--          l_PolicyAgentNameRecord.agent_man_id      := v_agent_man_id;
--          l_PolicyAgentNameRecord.agent_pid         := to_char(v_agent_man_id);
--          l_PolicyAgentNameRecord.agent_name        := v_agent_name;
--          if not l_PolicyAgentNameRecord.InsertPAgentNames( PIO_ERR )  then
--                MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
--          end if;
--           l_policyRec.logMsg:='Names of agent added succesfully with agent_id('||l_policyRec.agent_id||')';
--           MIGR_LOG.LOG_INFO(l_policyRec);
--     exception
--        when others then
--             l_policyRec.logMsg:='Could not add the name of agent with agent_id('||l_policyRec.agent_id||') : '||SQLERRM;
--             MIGR_LOG.LOG_EXCEPTION(l_policyRec);
--             p_policyRec.continue_migr := FALSE;
--    end SET_POLICY_AGENTS_NAMES;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--EZ 20190207 defect 750239 - set agent's name for 'Belongs' and 'Sales_2'
                           --Update code with 'Sales_2' Agent's Name
--params:
--p_policyRec MIGR_GVAR.PolicyRecTyp in out Policy Record

    procedure SET_POLICY_AGENTS_NAMES (p_policyRec in out MIGR_GVAR.PolicyRecTyp)
  IS
     l_policyRec                MIGR_GVAR.PolicyRecTyp;
     l_PolicyAgentNameRecord    INSIS_GEN_V10.P_AGENT_NAMES_TYPE;
     PIO_ERR                    SRVERR;
   BEGIN
          l_policyRec                               := p_policyRec;
          l_policyRec.migrArea                      := 'MIGR_API_POLICY.SET_POLICY_AGENTS_NAMES';

         for c IN (
                  select pola.policy_agent_id, pola.agent_id, pp.man_id, pp.name, pa.AGENT_NO, pola.AGENT_ROLE
                    from INSIS_GEN_V10.policy_agents pola
                         ,insis_gen_v10.p_people pp
                          left join insis_gen_v10.p_agents pa on pa.man_id = pp.man_id
                  where 1=1
                      and pa.agent_id = pola.agent_id
                      and pola.policy_id =l_policyRec.policy_id
                      and pola.agent_role IN ('BELONGS','SALES_2')
                      and pola.annex_id = 0
         )
         LOOP
          l_PolicyAgentNameRecord                   := NEW INSIS_GEN_V10.P_AGENT_NAMES_TYPE;
          l_PolicyAgentNameRecord.policy_agent_id   := c.policy_agent_id;
          l_PolicyAgentNameRecord.agent_no          := c.agent_no;
          l_PolicyAgentNameRecord.agent_id          := l_policyRec.agent_id;
          l_PolicyAgentNameRecord.agent_man_id      := c.agent_id;
          l_PolicyAgentNameRecord.agent_pid         := to_char(c.agent_id);
          l_PolicyAgentNameRecord.agent_name        := c.name;
          if not l_PolicyAgentNameRecord.InsertPAgentNames( PIO_ERR )  then
                MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
          end if;

           l_policyRec.logMsg:='Names of agent added succesfully with agent_id('||l_policyRec.agent_id||'),role:'||c.agent_role;
           MIGR_LOG.LOG_INFO(l_policyRec);

         END LOOP;

     exception
        when others then
             l_policyRec.logMsg:='Could not add the name of agent with agent_id('||l_policyRec.agent_id||') : '||SQLERRM;
             MIGR_LOG.LOG_EXCEPTION(l_policyRec);
             p_policyRec.continue_migr := FALSE;
    end SET_POLICY_AGENTS_NAMES;

--EZ 20190207 end
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--Migrate Policy Agent sales2 if provided by MIGG  - Should be moved to common
  FUNCTION SET_POLICY_AGENT_SALES2 (p_policyRec IN  MIGR_GVAR.PolicyRecTyp ) RETURN  MIGR_GVAR.PolicyRecTyp
  IS
     l_policyRec               MIGR_GVAR.PolicyRecTyp ;
     l_PolicyAgentRecord  INSIS_GEN_V10.P_AGENT_TYPE;
     PIO_ERR                  SRVERR;
   BEGIN
      l_policyRec:= p_policyRec;
                l_policyRec.migrArea   :='Set Policy Agents';
      IF p_policyRec.agent_sales2 IS NOT null THEN

          l_PolicyAgentRecord :=  NEW INSIS_GEN_V10.P_AGENT_TYPE;
          l_PolicyAgentRecord.agent_id :=p_policyRec.agent_sales2;
          l_PolicyAgentRecord.policy_id:= l_policyRec.policy_id;
          l_PolicyAgentRecord.annex_id := MIGR_GVAR.GV_ANNEX_ID;
          l_PolicyAgentRecord.agent_role:=INSIS_CUST.GVAR_CUST.AGENTRL_SALES2;
          l_PolicyAgentRecord.comm_share:=  INSIS_CUST.GVAR_CUST.COMM_SHARE_100;
          l_PolicyAgentRecord. valid_from:= l_policyRec.insr_begin ;

          IF NOT l_PolicyAgentRecord.InsertPAgent( PIO_ERR )  THEN
                MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
          END IF;

           l_policyRec.logMsg:='Sales2 agent added succesfully';
           MIGR_LOG.LOG_INFO(l_policyRec) ;

      END IF;
      RETURN  l_policyRec;
     EXCEPTION
        WHEN OTHERS THEN
             l_policyRec.logMsg:='Could not add  agent role:BelongsTo2: '||SQLERRM;
             MIGR_LOG.LOG_EXCEPTION(l_policyRec) ;
             l_policyRec.continue_migr :=FALSE;
             RETURN  l_policyRec;

    END SET_POLICY_AGENT_SALES2;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


---Set migrated policy values: Policy Id and step
---Is called to retrieve phase 1 policy values when phase 2 is triggered
FUNCTION  SET_MIGRATED_POLICY_VAL (p_policyRec IN  MIGR_GVAR.PolicyRecTyp) RETURN    MIGR_GVAR.PolicyRecTyp
  IS
     l_policyRec   MIGR_GVAR.PolicyRecTyp ;
      l_cnt  NUMBER;
  BEGIN
     l_policyRec:= p_policyRec;
     l_cnt:=0;

     SELECT POLICY_STEP,POLICY_ID
      INTO   l_policyRec.policy_final_step, l_policyRec.policy_id
      FROM MIGR_POLICY  WHERE POLICY_IDPL =  l_policyRec.policy_idpl;

     --Check if discount has been applied to policy so to rerun calaculate premium step
      SELECT COUNT('*') INTO l_cnt  FROM IA_MD_DISCOUNTS WHERE   IA_IDPL =   l_policyRec.policy_idpl AND IA_DISCOUNT IS NOT NULL AND IA_DISCOUNT<>0;

       IF l_cnt =1 THEN
           l_policyRec.has_discount:= TRUE;
         ELSE
              l_policyRec.has_discount:= FALSE;
        END IF;

      RETURN  l_policyRec;
    EXCEPTION
    WHEN OTHERS THEN
             l_policyRec.logMsg:='Could not retrieve migrated policy data from MIGR_POLICY table: '||SQLERRM;
             MIGR_LOG.LOG_EXCEPTION(l_policyRec) ;
             l_policyRec.continue_migr :=FALSE;
             RETURN  l_policyRec;

END SET_MIGRATED_POLICY_VAL;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--Clients should be migrated prior to policy registration and this function returns INSIS ids from MIGR_CLIENT table
   FUNCTION  GET_POLICY_CLIENT (p_policyRec IN  MIGR_GVAR.PolicyRecTyp)  RETURN    MIGR_GVAR.PolicyRecTyp
   IS
        l_policyRec  MIGR_GVAR.PolicyRecTyp ;
    BEGIN
        l_policyRec:= p_policyRec;
        SELECT  mc.CLIENT_ID, mc.MAN_ID,mc.MIGRATED
         INTO   l_policyRec.CLIENT_ID, l_policyRec.MAN_ID, l_policyRec.client_migrated
         FROM  MIGR_CLIENT mc
         WHERE  mc.EGN  =l_policyRec.egn AND mc.MIGRATED='Y';

         RETURN  l_policyRec;

    EXCEPTION
    WHEN OTHERS THEN
       l_policyRec.logMsg:='Client was not migrated succesfully in MIGR_CLIENT table -Next action is to search INSIS People Module ';
       MIGR_LOG.LOG_INFO(l_policyRec) ;

         BEGIN
             SELECT  mc.CLIENT_ID, mc.MAN_ID,'Y'
             INTO   l_policyRec.CLIENT_ID, l_policyRec.MAN_ID, l_policyRec.client_migrated
             FROM  INSIS_GEN_V10.P_CLIENTS   mc ,  INSIS_GEN_V10.P_PEOPLE PP
             WHERE  PP.EGN  =l_policyRec.egn  AND PP.MAN_ID=mc.MAN_ID;
             RETURN  l_policyRec;

          EXCEPTION
          WHEN OTHERS THEN
             l_policyRec.logMsg:='Client was not found in INSIS table: '|| l_policyRec.egn ||' ' ||SQLERRM;
             MIGR_LOG.LOG_EXCEPTION(l_policyRec) ;
             RETURN  l_policyRec;
           END;
  END GET_POLICY_CLIENT;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--Get policy agent_No: If is null or zero then use bolag's default value else search in INSIS for the agent id. If not found in INSIS reject policy.
--if default agent is set to 'Y' in etl_setup_info then use for all policies bolag's default value
   /* FUNCTION GET_AGENT_ID(p_agentNo IN NUMBER )
    RETURN  INSIS_PEOPLE_V10.P_AGENTS.AGENT_ID % TYPE
    IS
      l_agent_id MIGR_AGENT.AGENT_ID % TYPE;
    BEGIN
      l_agent_id :=null;

      IF NVL(p_agentNo,0)<> 0 AND MIGR_GVAR.GV_DEFAULT_AGENT <>'Y' THEN

          SELECT pa.AGENT_ID
            INTO l_agent_id
            FROM INSIS_PEOPLE_V10.P_AGENTS pa
            WHERE pa.AGENT_NO=  p_agentNo  AND AGENT_STATE='1';
      ELSE
         MIGR_API_COMMON.SET_DEFAULT_AGENT_ID(MIGR_GVAR.GV_DEFAULT_AGENT_NO);
         l_agent_id := MIGR_GVAR.GV_DEFAULT_AGENT_ID;

      END IF;
      RETURN l_agent_id;
    END GET_AGENT_ID;  */
 -------------------------------------------------------------------------------------------------------------------------------------------------------------------
 -------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Set default values to mandatory roles- - Should be moved to common
  FUNCTION SET_DEFAULT_AGENT_IDS(p_policy_rec in  MIGR_GVAR.PolicyRecTyp) RETURN  MIGR_GVAR.PolicyRecTyp
    IS

      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_agent_id    INSIS_PEOPLE_V10.P_AGENTS.AGENT_ID%TYPE;
    BEGIN
      l_policyRec :=p_policy_rec;

       SELECT pa.AGENT_ID INTO l_agent_id   FROM INSIS_PEOPLE_V10.P_AGENTS pa WHERE pa.AGENT_NO = MIGR_GVAR.GV_DEFAULT_AGENT_NO AND AGENT_STATE='1';

       l_policyRec.agent_id:=l_agent_id;
       l_policyRec.agent_belongsTo:=l_agent_id;

       RETURN l_policyRec;

    EXCEPTION
      WHEN OTHERS THEN
            l_policyRec.logMsg:='Could not retrieve default agent id due to exception:' || SQLCODE||  ' - '  ||SQLERRM   ;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr:=FALSE;
            RETURN l_policyRec;
    END SET_DEFAULT_AGENT_IDS;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Set policy record agent ids for, sales, sales2 and belongs to-- Should be moved to common
 FUNCTION SET_POLICY_AGENT_IDS(p_policyRec IN  MIGR_GVAR.PolicyRecTyp, p_ia_policy_rec IA_POLICY%ROWTYPE) RETURN    MIGR_GVAR.PolicyRecTyp
    IS
      l_agent_id  INSIS_PEOPLE_V10.P_AGENTS.AGENT_ID % TYPE;
      l_policyRec  MIGR_GVAR.PolicyRecTyp;
    BEGIN
      l_policyRec:= p_policyRec;
      l_policyRec.agent_id:=null;
      l_policyRec.agent_belongsTo :=null;
      --If etl_setup_info has set to use the default agent then set mandatory agents to bolag's default.If sales1 and belongs to is null then assign default bolag agent no
      IF  MIGR_GVAR.GV_DEFAULT_AGENT <>'Y' THEN
          BEGIN
               --FA.20170703 If agent does not exist then set agent to bolag's default
              BEGIN
                  SELECT pa.AGENT_ID   INTO l_policyRec.agent_id   FROM INSIS_PEOPLE_V10.P_AGENTS pa       WHERE pa.AGENT_NO=NVL(p_ia_policy_rec.IA_AGENT_NO,MIGR_GVAR.GV_DEFAULT_AGENT_NO)    AND AGENT_STATE='1';
              EXCEPTION
                  WHEN NO_DATA_FOUND THEN
                        SELECT pa.AGENT_ID   INTO l_policyRec.agent_id   FROM INSIS_PEOPLE_V10.P_AGENTS pa       WHERE pa.AGENT_NO=MIGR_GVAR.GV_DEFAULT_AGENT_NO  AND AGENT_STATE='1';
                         l_policyRec.logMsg:='MIGG Policy Agent: ' ||  p_ia_policy_rec.IA_AGENT_NO || ' does not exist- The default: '|| MIGR_GVAR.GV_DEFAULT_AGENT_NO ||  ' will be used.'  ;
                         MIGR_LOG.LOG_ERROR(l_policyRec);
                  WHEN TOO_MANY_ROWS THEN
                       l_policyRec.logMsg:='MIGG Policy Agent: ' ||  p_ia_policy_rec.IA_AGENT_NO || ' exists more than once in P_Agents table.'  ;
                       MIGR_LOG.LOG_ERROR(l_policyRec);
              END;

              --FA.20170703 If agent does not exist then set belongs to agent to bolag's default
              BEGIN
                  SELECT pa.AGENT_ID   INTO l_policyRec.agent_belongsTo   FROM INSIS_PEOPLE_V10.P_AGENTS pa       WHERE pa.AGENT_NO=  NVL(p_ia_policy_rec.IA_BELONGS_TO,MIGR_GVAR.GV_DEFAULT_AGENT_NO)  AND AGENT_STATE='1';
              EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     SELECT pa.AGENT_ID   INTO l_policyRec.agent_belongsTo   FROM INSIS_PEOPLE_V10.P_AGENTS pa       WHERE pa.AGENT_NO=  MIGR_GVAR.GV_DEFAULT_AGENT_NO  AND AGENT_STATE='1';
                     l_policyRec.logMsg:='MIGG Policy Belongs To Agent: ' ||  p_ia_policy_rec.IA_BELONGS_TO || ' does not exist- The default: '|| MIGR_GVAR.GV_DEFAULT_AGENT_NO ||  ' will be used.'  ;
                     MIGR_LOG.LOG_ERROR(l_policyRec);
                WHEN TOO_MANY_ROWS THEN
                     l_policyRec.logMsg:='MIGG Policy Belongs To Agent: ' ||   p_ia_policy_rec.IA_BELONGS_TO || ' exists more than once in P_Agents table.'  ;
                     MIGR_LOG.LOG_ERROR(l_policyRec);
               END;

         EXCEPTION

            WHEN OTHERS THEN
                l_policyRec.logMsg:='Could not retrieve agent id for mandatory agents due to exception:' || SQLCODE||  ' - '  ||SQLERRM   ;
                MIGR_LOG.LOG_ERROR(l_policyRec);
                l_policyRec.continue_migr:=FALSE;
            END;

          BEGIN
             SELECT pa.AGENT_ID   INTO l_policyRec.agent_sales2   FROM INSIS_PEOPLE_V10.P_AGENTS pa       WHERE pa.AGENT_NO=  p_ia_policy_rec.IA_AGENT2  AND AGENT_STATE='1';

          EXCEPTION
            WHEN OTHERS THEN
                l_policyRec.logMsg:='Could not retrieve agent id for sales2 agents due to exception:' || SQLCODE||  ' - '  ||SQLERRM || '  .Policy will continue since this is not a mandatory role'  ;
                MIGR_LOG.LOG_WARNING(l_policyRec);

            END;

      ELSE
           l_policyRec:=  SET_DEFAULT_AGENT_IDS(l_policyRec);

      END IF;

      RETURN l_policyRec;
    END SET_POLICY_AGENT_IDS;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
--Call INSIS event to apply automatic rule discounts on policy level
  PROCEDURE APPLY_RULE_POLICY_DISC(p_policyrec IN OUT  MIGR_GVAR.PolicyRecTyp)

    AS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Apply Rule Policy Discounts';
      p_policyrec.migrArea := 'MIGR_API_POLICY.APPLIED_RULE_POLICY_DISC';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);

      v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('APPLY_RULE_POLICY_DISC');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS    THEN
          p_policyrec.logMsg := 'Applied Rule Policy discounts succesfully' || ' -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_INFO(p_policyrec);

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
          p_policyrec.logMsg := 'Apply Rule Policy discounts returned with warning -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);

      ELSE
          p_policyrec.logMsg := 'PIO_ERR APPLY_RULE_POLICY_DISC Failed to apply rule policy discounts-RESULT: ' || L_RESULT;
          MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
          p_policyrec.continue_migr:=FALSE;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr:= FALSE;
    END APPLY_RULE_POLICY_DISC;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--Call INSIS event to retreive policy conditions through Rule Bus and fill in POLICY_CONDITIONS table.
  PROCEDURE FILL_POLICY_CONDITIONS(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    AS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Fill Policy Conditions';
      p_policyrec.migrArea := 'MIGR_API_POLICY.FILLED_POLICY_CONDITIONS';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);     -- Policy Id
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_policyrec.insr_type);           -- Boat
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);

      v_event:= MIGR_API_COMMON.GET_INSIS_EVENT( 'FILL_POLICY_CONDITIONS');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS     THEN
          p_policyrec.logMsg := 'Policy Conditions were filled succesfully ' || ' -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_INFO(p_policyrec);

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
        p_policyrec.logMsg := 'Policy Conditions returned with warning -RESULT:' || L_RESULT;
        MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);

      ELSE
        p_policyrec.logMsg := 'PIO_ERR FILL_POLICY_CONDITIONS Failed to fill policy conditions RESULT: ' || L_RESULT;
        MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
       p_policyrec.continue_migr:=FALSE;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
           p_policyrec.continue_migr:=FALSE;

    END FILL_POLICY_CONDITIONS;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

   --Call INSIS event to Check Record Policy to check record and  fill required values
  /*  PROCEDURE CHECK_RECORD_POLICY(p_policyrec   IN OUT MIGR_GVAR.PolicyRecTyp, L_OUT_CONTEXT OUT  SRVCONTEXT )
    IS
      L_IN_CONTEXT  SRVCONTEXT;
    --  L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT :=NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Check Record Policy';
      p_policyrec.migrArea := 'MIGR_API_POLICY.CHECK_RECORD_POLICY';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';


      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_policyrec.insr_type);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'CLIENT_ID', SRV_CONTEXT.Integers_Format, p_policyrec.CLIENT_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'AGENT_ID', SRV_CONTEXT.Integers_Format, p_policyrec.AGENT_ID);

      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'INSR_BEGIN', SRV_CONTEXT.Date_Format, p_policyrec.insr_begin);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_TYPE', SRV_CONTEXT.Integers_Format, NULL);

      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'POLICY_REF', p_policyrec.POLICY_REF);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'OFFICE_ID', SRV_CONTEXT.Integers_Format, p_policyrec.office_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_DURATION', SRV_CONTEXT.Integers_Format, '12');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'DUR_DIMENSION', 'm');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'NUM_INSTALMENTS', SRV_CONTEXT.Integers_Format, p_policyrec.numInstalments);

      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR3', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR4', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR5', '');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR6',null);
      --Package changed policy deductible field SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR7', p_policyrec.deduct_val);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR8', p_policyrec.policyYear);

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_NO', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);
      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'DATE_GIVEN', SRV_CONTEXT.Date_Format, INSIS_SYS_V10.SYS_DAYS.GET_OPEN_DATE() );


      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('CHECK_RECORD_POLICY') ;

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS   THEN
          p_policyrec.logMsg := 'Check Record Policy completed succesfully -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_INFO(p_policyrec);

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
          p_policyrec.logMsg := 'Check Record Policy completed with warning -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);

      ELSE
        p_policyrec.logMsg := 'PIO_ERR CHECK_RECORD_POLICY Failed to check record-RESULT: ' || L_RESULT;
        MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
        p_policyrec.continue_migr:=FALSE;
      END IF;

      EXCEPTION
      WHEN OTHERS THEN
          p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr:=FALSE;
    END CHECK_RECORD_POLICY;
  */
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20161121 Move insert Policy Address to autonomous module
 --FA 20160704 instead of calling customized event that calls webservice we call event to store policy address
 --FA. 20161118  Retrieve address directly from INSIS instead of using an event

  ---Updates INSIS policy with migg values regarding insurance begin, installments etc.
  PROCEDURE UPDATE_POLICY_old(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT    SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR             SRVERR;
      l_evres                  PLS_INTEGER;
      v_stmst                VARCHAR2(400);
      v_event                 MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
      l_policyrecord        INSIS_GEN_V10.P_POLICY_TYPE;
      L_RESULT      VARCHAR2(50);
      l_policyState   INSIS_GEN_V10.POLICY.POLICY_STATE%TYPE;
    l_POLICY_LOT      INSIS_GEN_V10.POLICY.POLICY_lot%TYPE ;
    l_attr6          INSIS_GEN_V10.POLICY.ATTR6%TYPE;
    BEGIN
      ---check record policy to calculate renewal date an feed context to update policy
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT :=NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Check Record Policy';
      p_policyrec.migrArea := 'MIGR_API_POLICY.CHECK_RECORD_POLICY';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';


      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'POLICY_REF', p_policyrec.POLICY_REF);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'OFFICE_ID', SRV_CONTEXT.Integers_Format, p_policyrec.office_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_policyrec.insr_type);
      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'INSR_BEGIN', SRV_CONTEXT.Date_Format, p_policyrec.insr_begin);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_DURATION', SRV_CONTEXT.Integers_Format, '12');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'DUR_DIMENSION', 'm');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'NUM_INSTALMENTS', SRV_CONTEXT.Integers_Format, p_policyrec.numInstalments);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR3', null);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR4',  null);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR5',  null);

      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR8', p_policyrec.policyYear);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_NO', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);

      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PAYMENT_WAY',  p_policyrec.IA_PAYM_WAY);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'CLIENT_ID', SRV_CONTEXT.Integers_Format, p_policyrec.CLIENT_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'AGENT_ID', SRV_CONTEXT.Integers_Format, p_policyrec.AGENT_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_TYPE', SRV_CONTEXT.Integers_Format, NULL);
      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'DATE_GIVEN', SRV_CONTEXT.Date_Format, INSIS_SYS_V10.SYS_DAYS.GET_OPEN_DATE() );
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR6',null);
      --Package changed policy deductible field SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR7', p_policyrec.deduct_val);
        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('UPD_POLICY') ;
       v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
       EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

       v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('CHECK_RECORD_POLICY') ;
       v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
       EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;


         v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('UPD_POLICY') ;
       v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
       EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_OUT_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;



       SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

       l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

       IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS   THEN
          p_policyrec.logMsg := 'Check Record Policy completed succesfully -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_INFO(p_policyrec);

       ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
          p_policyrec.logMsg := 'Check Record Policy completed with warning -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);

       ELSE
          p_policyrec.logMsg := 'PIO_ERR CHECK_RECORD_POLICY Failed to check record-RESULT: ' || L_RESULT;
          MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
          p_policyrec.continue_migr:=FALSE;
      END IF;



      IF  p_policyrec.continue_migr THEN
          p_policyrec.migrStep := 'Update Policy';
          p_policyrec.migrArea := 'MIGR_API_POLICY.POLICY_UPDATED';
          p_policyrec.migrRelTbl := 'INSIS_EVENT';
           SRV_CONTEXT.gETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR6',l_attr6);
          --Check record turns policy state to null so will retrieve it directly from db
          SELECT POLICY_STATE, POLICY_LOT into l_policyState,l_POLICY_LOT FROM INSIS_GEN_V10.POLICY WHERE POLICY_ID=p_policyrec.POLICY_ID   ;

              p_policyrec.logMsg := 'l_policyState'||l_policyState ||'l_POLICY_LOT'|| l_POLICY_LOT ;
              MIGR_LOG.LOG_INFO(p_policyrec);

         SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_OUT_CONTEXT, 'POLICY_STATE', SRV_CONTEXT.Integers_Format,l_policyState);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'POLICY_LOT',l_POLICY_LOT);
        ---  IF  MIGR_GVAR.GV_MIGRATION_METHOD='EVENT' THEN

            PIO_ERR := NULL;

     /*     l_policyrecord :=INSIS_GEN_V10.POL_TYPES.GET_POLICY( p_policyrec.policy_id );

            p_policyrec.logMsg := '1' ;
              MIGR_LOG.LOG_INFO(p_policyrec);

          l_policyrecord.OFFICE_ID:=p_policyrec.office_id;
                      p_policyrec.logMsg := '2' ;
              MIGR_LOG.LOG_INFO(p_policyrec);

          l_policyrecord.POLICY_REF:= p_policyrec.POLICY_REF;
                            p_policyrec.logMsg := '3' ;
              MIGR_LOG.LOG_INFO(p_policyrec);
         --- l_policyrecord.INSR_BEGIN := TO_DATE(p_policyrec.insr_begin,SRV_CONTEXT.Date_Format);
                            p_policyrec.logMsg := '4' ;
              MIGR_LOG.LOG_INFO(p_policyrec);
          l_policyrecord.INSR_DURATION := TO_NUMBER( '12',SRV_CONTEXT.Integers_Format);
          l_policyrecord.DUR_DIMENSION := 'm';
                            p_policyrec.logMsg := '5' ;
              MIGR_LOG.LOG_INFO(p_policyrec);
          l_policyrecord.NUM_INSTALMENTS := TO_NUMBER( p_policyrec.numInstalments,SRV_CONTEXT.Integers_Format);
          ---l_policyrecord.ATTR3 := '';
         ---- l_policyrecord.ATTR4 := '';
         ---- l_policyrecord.ATTR5 := '';
           l_policyrecord.ATTR6:=   l_attr6;
                            p_policyrec.logMsg := '6' ;
              MIGR_LOG.LOG_INFO(p_policyrec);
          l_policyrecord.DATE_GIVEN:= INSIS_SYS_V10.SYS_DAYS.GET_OPEN_DATE();
          l_policyrecord.POLICY_NO:= p_policyrec.POLICY_ID;
          l_policyrecord.PAYMENT_WAY:=p_policyrec.IA_PAYM_WAY;
         ---- l_policyrecord.ATTR7 := p_policyrec.deduct_val;
          l_policyrecord.ATTR8 := p_policyrec.policyYear;

          IF NOT l_policyrecord.UPDATEPOLICY( PIO_ERR )   THEN
              p_policyrec.logMsg := 'PIO_ERR UPD_POLICY Failed to update  policy';
              MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
              p_policyrec.continue_migr:=FALSE;
          ELSE
              p_policyrec.logMsg := 'Policy updated succesfully';
              MIGR_LOG.LOG_INFO(p_policyrec);
          END IF;    */


            --v_event:='UPD_POLICY' ;
           --- v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
            --EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_OUT_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

                /*
            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, NULL);

            IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS  THEN
              p_policyrec.logMsg := 'Policy updated succesfully';
              MIGR_LOG.LOG_INFO(p_policyrec);

            ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
              p_policyrec.logMsg := 'Policy update returned with warning ';
              MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);

            ELSE
              p_policyrec.logMsg := 'PIO_ERR UPD_POLICY Failed to update  policy';
              MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
              p_policyrec.continue_migr:=FALSE;
            END IF; */
          END IF;
            /*
       ELSE
          l_policyrecord :=INSIS_GEN_V10.POL_TYPES.GET_POLICY( p_policyrec.policy_id );
          l_policyrecord.OFFICE_ID:=p_policyrec.office_id;
          l_policyrecord.POLICY_REF:= p_policyrec.POLICY_REF;
          l_policyrecord.INSR_BEGIN := TO_DATE(p_policyrec.insr_begin,SRV_CONTEXT.Date_Format);
          l_policyrecord.INSR_DURATION := TO_NUMBER( '12',SRV_CONTEXT.Integers_Format);
          l_policyrecord.DUR_DIMENSION := 'm';
          l_policyrecord.NUM_INSTALMENTS := TO_NUMBER( p_policyrec.numInstalments,SRV_CONTEXT.Integers_Format);
          l_policyrecord.ATTR3 := '';
          l_policyrecord.ATTR4 := '';
          l_policyrecord.ATTR5 := '';
           l_policyrecord.ATTR:=
          l_policyrecord.DATE_GIVEN:= INSIS_SYS_V10.SYS_DAYS.GET_OPEN_DATE();
          l_policyrecord.POLICY_NO:= p_policyrec.POLICY_ID;
          l_policyrecord.PAYMENT_WAY:=p_policyrec.IA_PAYM_WAY;
         ---- l_policyrecord.ATTR7 := p_policyrec.deduct_val;
          l_policyrecord.ATTR8 := p_policyrec.policyYear;

          IF NOT l_policyrecord.UPDATEPOLICY( PIO_ERR )   THEN
              p_policyrec.logMsg := 'PIO_ERR UPD_POLICY Failed to update  policy';
              MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
              p_policyrec.continue_migr:=FALSE;
          ELSE
              p_policyrec.logMsg := 'Policy updated succesfully';
              MIGR_LOG.LOG_INFO(p_policyrec);
          END IF;

       END IF;    */

         UPDATE  INSIS_CUST.POLICY_EXTRA_ATTR SET DEDUCT=  p_policyrec.deduct_val WHERE POLICY_ID = p_policyrec.POLICY_ID ;

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr:=FALSE;
    END UPDATE_POLICY_old;
  ---------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------

---Updates INSIS policy with migg values regarding insurance begin, installments etc.
  PROCEDURE UPDATE_POLICY(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT    SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR             SRVERR;
      l_evres                  PLS_INTEGER;
      v_stmst                VARCHAR2(400);
      v_event                 MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
      l_policyrecord        INSIS_GEN_V10.P_POLICY_TYPE;
      L_RESULT      VARCHAR2(50);
      l_policyState   INSIS_GEN_V10.POLICY.POLICY_STATE%TYPE;
    l_POLICY_LOT      INSIS_GEN_V10.POLICY.POLICY_lot%TYPE ;
    l_attr6          INSIS_GEN_V10.POLICY.ATTR6%TYPE;
    BEGIN

     --FA.update insr_begin in policy table
       l_policyrecord :=INSIS_GEN_V10.POL_TYPES.GET_POLICY(p_policyrec.POLICY_ID );

       l_policyrecord.INSR_BEGIN := p_policyrec.insr_begin;
       l_policyrecord.ATTR6:=NULL;
      --LM - 20170921 - DATE_COVERED should be equal to INSR_BEGIN
       l_policyrecord.DATE_COVERED := p_policyrec.insr_begin;
      --LM - 20170921 - END

        IF NOT l_policyrecord.UPDATEPOLICY( PIO_ERR )   THEN
              p_policyrec.logMsg := 'PIO_ERR UPD_POLICY Failed to update insured begin date';
              MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
              p_policyrec.continue_migr:=FALSE;
       /*   ELSE
              p_policyrec.logMsg := 'Insured begin date updated succesfully';
              MIGR_LOG.LOG_INFO(p_policyrec);    */
          END IF;

     IF  p_policyrec.continue_migr THEN
     ---check record policy to calculate renewal date an feed context to update policy
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT :=NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Check Record Policy';
      p_policyrec.migrArea := 'MIGR_API_POLICY.CHECK_RECORD_POLICY';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';


      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'POLICY_REF', p_policyrec.POLICY_REF);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'OFFICE_ID', SRV_CONTEXT.Integers_Format, p_policyrec.office_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_policyrec.insr_type);
      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'INSR_BEGIN', SRV_CONTEXT.Date_Format, p_policyrec.insr_begin);
      --LM - 20170921 - DATE_COVERED should be equal to INSR_BEGIN
      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'DATE_COVERED', SRV_CONTEXT.Date_Format, p_policyrec.insr_begin);
      --LM - 20170921 - END
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_DURATION', SRV_CONTEXT.Integers_Format, '12');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'DUR_DIMENSION', 'm');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'NUM_INSTALMENTS', SRV_CONTEXT.Integers_Format, p_policyrec.numInstalments);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR3', null);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR4',  null);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR5',  null);
      --LM 12062017 - PRODUCT LABEL - OFFERING CODES DEACTIVATED - START
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR7', p_policyrec.productLabel);
      --LM 12062017 - END
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR8', p_policyrec.policyYear);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_NO', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PAYMENT_WAY',  p_policyrec.IA_PAYM_WAY);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'CLIENT_ID', SRV_CONTEXT.Integers_Format, p_policyrec.CLIENT_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'AGENT_ID', SRV_CONTEXT.Integers_Format, p_policyrec.AGENT_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_TYPE', SRV_CONTEXT.Integers_Format, NULL);
      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'DATE_GIVEN', SRV_CONTEXT.Date_Format, INSIS_SYS_V10.SYS_DAYS.GET_OPEN_DATE() );
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ATTR6',null);

       v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('CHECK_RECORD_POLICY') ;
       v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
       EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;


       SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

       l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

       IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS   THEN
          p_policyrec.logMsg := 'Check Record Policy completed succesfully -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_INFO(p_policyrec);

       ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
          p_policyrec.logMsg := 'Check Record Policy completed with warning -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);

       ELSE
          p_policyrec.logMsg := 'PIO_ERR CHECK_RECORD_POLICY Failed to check record-RESULT: ' || L_RESULT;
          MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
          p_policyrec.continue_migr:=FALSE;
      END IF;


     IF  p_policyrec.continue_migr THEN
          p_policyrec.migrStep := 'Update Policy';
          p_policyrec.migrArea := 'MIGR_API_POLICY.POLICY_UPDATED';
          SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'ATTR6',l_attr6);

          l_policyrecord :=INSIS_GEN_V10.POL_TYPES.GET_POLICY( p_policyrec.policy_id );
          l_policyrecord.OFFICE_ID:=p_policyrec.office_id;
          l_policyrecord.POLICY_REF:= p_policyrec.POLICY_REF;
          l_policyrecord.INSR_DURATION := TO_NUMBER( '12',SRV_CONTEXT.Integers_Format);
          l_policyrecord.DUR_DIMENSION := 'm';
          l_policyrecord.NUM_INSTALMENTS := TO_NUMBER( p_policyrec.numInstalments,SRV_CONTEXT.Integers_Format);
          --  l_policyrecord.ATTR3 := '';
          --  l_policyrecord.ATTR4 := '';
          --   l_policyrecord.ATTR5 := '';
          l_policyrecord.ATTR6:=  l_attr6;
          l_policyrecord.DATE_GIVEN:= INSIS_SYS_V10.SYS_DAYS.GET_OPEN_DATE();
          l_policyrecord.POLICY_NO:= p_policyrec.POLICY_ID;
          l_policyrecord.PAYMENT_WAY:=p_policyrec.IA_PAYM_WAY;
          l_policyrecord.ATTR8 := p_policyrec.policyYear;
          --LM 12062017 - PRODUCT LABEL - OFFERING CODES DEACTIVATED - START
          l_policyrecord.ATTR7 := p_policyrec.productLabel;
          --LM 12062017 - END
          --LM - 20170921 - DATE_COVERED should be equal to INSR_BEGIN
          l_policyrecord.DATE_COVERED := p_policyrec.insr_begin;
          --LM - 20170921 - END

          IF NOT l_policyrecord.UPDATEPOLICY( PIO_ERR )   THEN
              p_policyrec.logMsg := 'PIO_ERR UPD_POLICY Failed to update  policy';
              MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
              p_policyrec.continue_migr:=FALSE;
          ELSE
              p_policyrec.logMsg := 'Policy updated succesfully';
              MIGR_LOG.LOG_INFO(p_policyrec);
          END IF;

       END IF;

         UPDATE  INSIS_CUST.POLICY_EXTRA_ATTR SET DEDUCT=  p_policyrec.deduct_val WHERE POLICY_ID = p_policyrec.POLICY_ID ;



     END IF;
    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr:=FALSE;
    END UPDATE_POLICY;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- Retrieves address directly from INSIS and store primary address as policy address
    PROCEDURE INSERT_POLICY_ADDRESS (p_policyrec IN OUT  MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
      l_address_id  NUMBER;
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);

   BEGIN

   ---FA.20161118 Check if clients were migrated by policy migration process instead of client migration proces
    --if migrated by policy migration process since process does not insert primary address just get a randoim address
        IF MIGR_GVAR.GV_DEFAULT_MIGRATE_CLIENT ='N'  THEN
            SELECT ADDRESS_ID  INTO l_address_id
            FROM P_ADDRESS A
            WHERE  A.MAN_ID = p_policyrec.MAN_ID   and primary_flag = 'Y'   AND  A.NOTE IS NOT NULL AND A.NOTE <>  'C/O' ;

        ELSE
              SELECT ADDRESS_ID  INTO l_address_id
              FROM P_ADDRESS A
              WHERE  A.MAN_ID = p_policyrec.MAN_ID     AND ROWNUM = 1  ;

        END IF;

        L_IN_CONTEXT := NULL;
        L_OUT_CONTEXT := NULL;
        PIO_ERR := NULL;

        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ADDRESS_ID', SRV_CONTEXT.Integers_Format, NULL);     -- must be null!!
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, l_address_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'ADDRESS_PURPOSE', 'CORRESP');
        SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'VALID_FROM', SRV_CONTEXT.Date_Format, p_policyrec.insr_begin); -- valid from date

        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT( 'INS_POLICY_ADDRESS') ;

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

        EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

        IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS    THEN
          p_policyrec.logMsg := 'Policy Address was added succesfully';
          MIGR_LOG.LOG_INFO(p_policyrec);

        ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
          p_policyrec.logMsg := 'INS_POLICY_ADDRESS  returned with warning';
          MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);

        ELSE
          p_policyrec.logMsg := 'PIO_ERR INS_POLICY_ADDRESS Failed to add adrress to policy';
          MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
          p_policyrec.continue_migr:=FALSE;
        END IF;

        EXCEPTION
            WHEN NO_DATA_FOUND then
                   p_policyrec.logMsg :=  ' Client has no primary  address  in INSIS ';
                   MIGR_LOG.LOG_EXCEPTION(p_policyrec);
                   p_policyrec.continue_migr:=FALSE;
             WHEN TOO_MANY_ROWS THEN
                   p_policyrec.logMsg :=  ' More than one primary  addresses were found in INSIS ';
                   MIGR_LOG.LOG_EXCEPTION(p_policyrec);
                  p_policyrec.continue_migr:=FALSE;

      END INSERT_POLICY_ADDRESS;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Call to INSIS event to insert dummy policy for specified product and client
  PROCEDURE CREATE_DUMMY_POL(p_policyrec IN OUT  MIGR_GVAR.PolicyRecTyp)
    AS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      l_policyId    POLICY.POLICY_ID % TYPE;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      L_ADDRESS_ID  NUMBER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

    BEGIN

      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Create Dummy Policy';
      p_policyrec.migrArea := 'MIGR_API_POLICY.CREATE_DUMMY_POL';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_policyrec.insr_type);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'CLIENT_ID', SRV_CONTEXT.Integers_Format, p_policyrec.CLIENT_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'AGENT_ID', SRV_CONTEXT.Integers_Format, p_policyrec.AGENT_ID);
      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'INSR_BEGIN', SRV_CONTEXT.Date_Format, p_policyrec.insr_begin);

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT( 'DUMMY_POL') ;

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'POLICY_ID', l_policyId);
      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);
      p_policyrec.POLICY_ID := l_policyId;

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS THEN
        p_policyrec.logMsg := 'Dummy Policy created succesfully with policy_id: ' || l_policyId || ' -RESULT ' || L_RESULT;
        MIGR_LOG.LOG_INFO(p_policyrec);

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
        p_policyrec.logMsg := 'Dummy Policy returned with warning -RESULT:' || L_RESULT;
        MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);

      ELSE
        p_policyrec.logMsg := 'PIO_ERR DUMMY_POL Failed to create dummy policy-RESULT: ' || L_RESULT;
        MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
        p_policyrec.continue_migr:=FALSE;
      END IF;

       --FA.20170330 When an INSIS Policy id is assigned make sure to update policy ref since this field is critical for all gluing integration batches and should always be populated
       IF  l_policyId is not NULL THEN
          UPDATE INSIS_GEN_V10.POLICY p SET p.POLICY_REF=p_policyrec.policy_ref WHERE p.POLICY_ID=  l_policyId;

       END IF;
    ---INSIS_CUST.CUST_POL_DM.SETBELONGSTOAGENT(l_policyId, 0, pio_Err);


     EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
           p_policyrec.continue_migr:=FALSE;
    END CREATE_DUMMY_POL;
  -------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------

  --Register MIGG data to INSIS - There is one package per each product that handles registration of object's data and product's specific required info
  --Common package handles the common registration actions according to produt configuration: covers, questions, endorsemenets , deductibles etc.
  PROCEDURE  MIGRATE_POLICY_OBJECTS(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      l_eventTimer TIMESTAMP;
      vsql  varchar2(4000);

      --- +++ anb 2018-11-07 doc set values
--      l_evres       PLS_INTEGER;
--      v_idpl        NUMBER(20,0);
--      v_Doc_State   varchar2(100);
--      v_Rcv_Date    Date;
--      rDoc_id       SYS_REFCURSOR;
--      l_doc_id      VARchar2(4000);
--      v_Date_clause Varchar2(1000);
      --- +++ end anb 2018-11-07 doc set values


    BEGIN
      l_eventTimer := SYSTIMESTAMP;

      CASE p_policyrec.INSRPRD
        WHEN 'BOAT' THEN p_policyrec.logMsg := 'Start migrating Boat Product';
            p_policyrec := MIGR_API_BOAT.MIGRATE_BOAT(p_policyrec);

        WHEN 'VILLAHEM' THEN p_policyrec.logMsg := 'Start migrating Villahem Product';
            p_policyrec := MIGR_API_VILLAHEM.MIGRATE_VILLAHEM(p_policyrec);

        WHEN 'LEISURE_HOME' THEN p_policyrec.logMsg := 'Start migrating Leisure Home  Product';
            p_policyrec := MIGR_API_LEISURE_HOME.MIGRATE_LEISURE_HOME(p_policyrec);

        WHEN 'LEISURE_MOBILE_HOME' THEN p_policyrec.logMsg := 'Start migrating Leisure Mobile Home Product';
            p_policyrec := MIGR_API_LEISURE_MOBILE_HOME.MIGRATE_LEISURE_MOBILE_HOME(p_policyrec);

        WHEN 'CONTENT_COOP' THEN p_policyrec.logMsg := 'Start migrating Content and Cooperative Product';
            p_policyrec := MIGR_API_CONTENT_COOP.MIGRATE_CONTENT_COOP(p_policyrec);

        WHEN 'INDIVIDUAL_COVERS' THEN p_policyrec.logMsg := 'Start migrating Individual Covers Product';
            p_policyrec := MIGR_API_INDIVIDUAL_COVERS.MIGRATE_INDIVIDUAL_COVERS(p_policyrec);

        WHEN 'CHILD_ACC' THEN p_policyrec.logMsg := 'Start migrating Children Accident Product';
            p_policyrec := MIGR_API_ACCIDENT.MIGRATE_CHILD_ACC(p_policyrec);

        WHEN 'INDIV_ACC_60' THEN p_policyrec.logMsg := 'Start migrating Children Accident Product';
            p_policyrec := MIGR_API_ACCIDENT.MIGRATE_INDIV60_ACC(p_policyrec);

        WHEN 'RED_CHILD_ACC' THEN p_policyrec.logMsg := 'Start migrating Children Accident Product';
            p_policyrec := MIGR_API_ACCIDENT.MIGRATE_RED_CHILD_ACC(p_policyrec);

        WHEN 'INDIV_ACC' THEN p_policyrec.logMsg := 'Start migrating Children Accident Product';
            p_policyrec := MIGR_API_ACCIDENT.MIGRATE_INDIV_ACC(p_policyrec);

        WHEN 'RED_ACC' THEN p_policyrec.logMsg := 'Start migrating Children Accident Product';
            p_policyrec := MIGR_API_ACCIDENT.MIGRATE_RED_ACC(p_policyrec);

        WHEN 'TRAVEL' THEN p_policyrec.logMsg := 'Start migrating Travel Product';
            p_policyrec := MIGR_API_TRAVEL.MIGRATE_TRAVEL(p_policyrec);

        WHEN 'BUILDING_VILLA' THEN p_policyrec.logMsg := 'Start migrating Building Villa  Product';
            p_policyrec := MIGR_API_BUILDING_VILLA.MIGRATE_BUILDING_VILLA(p_policyrec);

        WHEN 'CONTENT_ONLY' THEN p_policyrec.logMsg := 'Start migrating Content Only Product';
            p_policyrec := MIGR_API_CONTENT_ONLY.MIGRATE_CONTENT_ONLY(p_policyrec);

        WHEN 'LEISURE_COOP' THEN p_policyrec.logMsg := 'Start migrating Content Only Product';
            p_policyrec := MIGR_API_LEISURE_COOP.MIGRATE_LEISURE_COOP(p_policyrec);

        WHEN 'LEISURE_CONT_ONLY' THEN p_policyrec.logMsg := 'Start migrating Content Only Product';
            p_policyrec := MIGR_API_LEISURE_CONT_ONLY.MIGRATE_LEISURE_CONT_ONLY(p_policyrec);

        ELSE p_policyrec.logMsg := 'Policy Failed due to UNDEFINED OBJECT';
          MIGR_LOG.LOG_ERROR(p_policyrec);
          p_policyrec.continue_migr:=FALSE;

       END CASE;
      p_policyrec.migrArea := 'MIGR_API_POLICY.MIGRATE_POLICY_OBJECTS';
      IF p_policyrec.continue_migr THEN
           p_policyrec.logMsg := 'All objects were migrated successfully for POLICY_ID : ' || p_policyrec.POLICY_ID;
           MIGR_LOG.LOG_INFO(p_policyrec);

      ELSE
           p_policyrec.logMsg := 'Not all objects were migrated successfully for POLICY_ID : ' || p_policyrec.POLICY_ID || ' Policy stopped in policy data migration step';
           MIGR_LOG.LOG_INFO(p_policyrec);
      END IF;

      --FA.20160603 Migrate Policy questions after policy data migration
      ---FA.20160614 Also migrate deductibels questions
      -- LM - 20170315 - question for customer memberships are active when p_policyRec.require_quest = 'Y'
      --IF p_policyrec.ia_questionsTbl IS NULL THEN
    p_policyrec.migrArea:= 'MIGR_API_QUESTIONS.MIGRATE_POLICY_QUESTIONS';
    IF p_policyRec.require_quest = 'N' THEN
            p_policyrec.logMsg := 'Questions migration is skipped ';
            MIGR_LOG.LOG_INFO(p_policyrec);
      ELSE
            MIGR_API_QUESTIONS.MIGRATE_POLICY_QUESTIONS(p_policyrec);
      END IF;

-- LM - 20170302 - ENDORSEMENTS - START
      p_policyrec.migrArea:= 'MIGR_API_COMMON.MIGRATE_ENDORSMENTS';
      IF p_policyrec.ia_endorsementsTbl IS NULL THEN
            p_policyrec.logMsg := 'Endorsements migration is skipped ';
            MIGR_LOG.LOG_INFO(p_policyrec);
      ELSE
            p_policyrec := MIGR_API_COMMON.MIGRATE_ENDORSMENTS(p_policyrec);
      END IF;
-- LM - 20170302 - ENDORSEMENTS - END

--valex.10/2/2017 - migrate discounts
       p_policyrec.migrArea:= ' MIGR_MD_DISCOUNTS.RUN_DISCOUNTS';
      IF p_policyrec.ia_discountsTbl IS NULL THEN
            p_policyrec.logMsg := 'No Discounts table in MIGR IA. Discounts are skipped ';
            MIGR_LOG.LOG_exception(p_policyrec);
      ELSE
            MIGR_MD_DISCOUNTS.RUN_DISCOUNTS(p_policyrec);
      END IF;
--valex.10/2/2017 - end


      -- 20170307 -FA.Migrate policy documents when required at policy and objetc level
       p_policyrec.migrArea:= 'MIGR_API_COMMON.LOAD_POLICY_DOCUMENTS';
      IF  p_policyrec.require_documents = 'Y' AND p_policyRec.ia_coversInsValTbl IS NOT NULL
      THEN

            p_policyrec := MIGR_API_COMMON.LOAD_POLICY_DOCUMENTS(p_policyrec,'POLICY');
      ELSE
            p_policyrec.logMsg := 'No mandatory documents at policy level exist for migration ';
            MIGR_LOG.LOG_INFO(p_policyrec);
      END IF;


       p_policyrec.migrArea:= 'MIGR_API_POLICY.MIGRATE_POLICY_OBJECTS';
       p_policyrec.migrStep:=  'Migrate Policy Objects';
       p_policyrec.logMsg :=p_policyrec.insrprd ||  ':' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
       MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM();
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
    END MIGRATE_POLICY_OBJECTS;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 --INSIS set of operations that should be executed to migrate policy header prior to policy data registration
  PROCEDURE MIGRATE_POLICY_GENERAL(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
        l_eventTimer TIMESTAMP;

    BEGIN
      p_policyrec.migrArea := 'Policy General Migration ';

      p_policyrec.POLICY_ID := NULL;
      l_eventTimer := SYSTIMESTAMP;

      CREATE_DUMMY_POL(p_policyrec);

      p_policyrec.logMsg := 'CREATE DUMMY:  ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
      MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

      --Add policy agents
      p_policyrec:=SET_POLICY_AGENT_BELONGSTO (p_policyRec);
      p_policyrec:=SET_POLICY_AGENT_SALES2(p_policyRec) ; --EZ-defect 750239 Add policy names
      SET_POLICY_AGENTS_NAMES(p_policyRec);--KT-defect 750239 Add policy names


       ----Do not start migration if policy id was not returned by insis
      IF p_policyrec.continue_migr THEN
          --FA.Policy addresses are added vis created dummy pol  INSERT_POLICY_ADDRESS(p_policyrec);

            l_eventTimer := SYSTIMESTAMP;

             --FA. 20170302 In order to calculate renewal date correctly we have to call check record policy prior to  update policy and provide as update input context thecheck record output context
            UPDATE_POLICY  (p_policyrec);

                IF  p_policyrec.continue_migr  THEN
                          p_policyrec.logMsg := 'POLICY UPDATE:  ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
                          MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
                          l_eventTimer := SYSTIMESTAMP;

                IF p_policyRec.continue_migr THEN

            --LM - 20170425 - UPDATE_CUST_CORRESPONDENCE - START
                  MIGR_API_COMMON.UPDATE_CUST_CORRESPONDENCE (p_policyrec);

                  IF  p_policyrec.continue_migr  THEN
                      p_policyrec.logMsg := 'CUST_CORRESPONDENCE UPDATE:  ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
                      MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
                      l_eventTimer := SYSTIMESTAMP;
             --LM - 20170425 - UPDATE_CUST_CORRESPONDENCE - END

              --LM 20170224 - Update POLICY_ENGAGEMENT_BILLING table (P_ENGAGEMENT_BILLING_TYPE) - START
                          MIGR_API_COMMON.UPDATE_ENG_BILLING (p_policyrec);

                          IF  p_policyrec.continue_migr  THEN
                              p_policyrec.logMsg := 'POLICY_ENGAGEMENT_BILLING UPDATE:  ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
                              MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
                              l_eventTimer := SYSTIMESTAMP;
              --LM 20170224 - Update ENGAGEMENT_BILLING table (P_ENGAGEMENT_BILLING_TYPE) - END

                    --FA.20161118 Turned to configurable to decide if property is mandatory
                       IF  p_policyrec.require_property='Y' THEN

                              MIGR_API_COMMON.REGISTER_PROPERTY_ID(p_policyrec);

                              IF p_policyrec.continue_migr    THEN
                                  p_policyrec.logMsg := 'REGISTER_PROPERTY: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
                                  MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

                              END IF;
                             l_eventTimer := SYSTIMESTAMP;
                       END IF;

                               FILL_POLICY_CONDITIONS(p_policyrec);

                                IF p_policyrec.continue_migr  THEN
                                    p_policyrec.logMsg := 'FILL POLICY CONDITIONS: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
                                    MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
                                    l_eventTimer := SYSTIMESTAMP;

                              --fa      APPLY_RULE_POLICY_DISC(p_policyrec)  ;

                                  /*fa  IF p_policyrec.continue_migr   THEN
                                        p_policyrec.logMsg := 'APPLY RULE POLICY DISCOUNTS: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
                                        MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
                                        l_eventTimer := SYSTIMESTAMP;

                                    END IF;   */
                                END IF;
                          END IF;
                   END IF;
              END IF;
              END IF;
        ----    END IF;
        --  END IF;

      END IF;

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;

    END MIGRATE_POLICY_GENERAL ;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Checks if agent, insurance type and client exist in policy  and in INSIS
  PROCEDURE IS_VALID_POLICY(P_POLICYREC IN OUT MIGR_GVAR.PolicyRecTyp,
                            is_valid    OUT    BOOLEAN)
    IS
    BEGIN
      is_valid := TRUE;
      P_POLICYREC.logMsg:=NULL;
      IF P_POLICYREC.AGENT_ID IS NULL THEN
        --P_POLICYREC.logMsg := P_POLICYREC.logMsg || '-Policy cannot be created because Agent NO: ' || P_POLICYREC.AGENT_NO || ' and default agent are not registered';
        is_valid := FALSE;
      END IF;

      ----20170308 FA.add check for mandatory role agent belongs to
       IF P_POLICYREC.agent_belongsTo IS NULL THEN
        --P_POLICYREC.logMsg := P_POLICYREC.logMsg || '-Policy cannot be created because Agent NO for belongs to and default agent are not registered';
        is_valid := FALSE;
      END IF;

      IF P_POLICYREC.CLIENT_ID IS NULL THEN
        P_POLICYREC.logMsg := P_POLICYREC.logMsg || '-Policy cannot be created because CLIENT EGN: ' || P_POLICYREC.EGN || ' is not registered';
        is_valid := FALSE;

      --FA.20161027 Check if all client's data has been migrated succesfully
     /*  ELSE
          IF  NVL(P_POLICYREC.client_migrated,'N' ) <> 'Y' THEN
                  P_POLICYREC.logMsg := P_POLICYREC.logMsg || '-Policy cannot be created because CLIENT : ' || P_POLICYREC.EGN || ' was not migrated succesfully. Check client_id, man_id, address_id.';
                   is_valid := FALSE;
          END IF;   */
      END IF;

      IF P_POLICYREC.insr_type IS NULL THEN
        P_POLICYREC.logMsg := P_POLICYREC.logMsg || '-Policy cannot be created because insured type: ' || P_POLICYREC.insr_type || ' is not defined';
        is_valid := FALSE;
      END IF;

      IF NOT is_valid   THEN
        MIGR_LOG.LOG_ERROR(P_POLICYREC);

      END IF;
    END IS_VALID_POLICY;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA.20160531 Approve Underwriting Task --Policies that require underwriting will be updated to approved instead of creating a task
  FUNCTION APPROVE_UW(P_POLICYREC IN MIGR_GVAR.PolicyRecTyp)  RETURN BOOLEAN
    IS

      CURSOR c_uwlist (PI_POLICY_ID IN POLICY.POLICY_ID % TYPE) IS
          SELECT ul.ID,
                 ul.POLICY_ID,
                 ul.UW_ID,
                 ul.object_id,
                 ul.ANNEX_ID,
                 ul.INSURED_OBJ_ID,
                 ul.COVER_TYPE,
                 ul.APPROVED
            FROM INSIS_CUST.UW_LIST ul
            WHERE ul.POLICY_ID = PI_POLICY_ID;

      l_policyRec       MIGR_GVAR.PolicyRecTyp;
      l_uw_list_r       c_uwlist % ROWTYPE;
      l_ins_obj_id      INSURED_OBJECT.INSURED_OBJ_ID % TYPE;
      l_object_id       INSURED_OBJECT.object_id % TYPE;
      l_org_uwlist_type INSIS_CUST.P_CUST_UWLIST_TYPE;
      l_SrvErrMsg       SRVERRMSG;
      PIO_ERR           SRVERR;
    BEGIN

      l_policyRec := P_POLICYREC;
      l_policyRec.migrStep := 'Approve Underwriting';
      l_policyRec.migrArea := 'MIGR_API_POLICY.APPROVE_UW';
      l_policyRec.migrRelTbl := 'CUST_OBJECT';

      OPEN c_uwlist (l_policyRec.POLICY_ID);
      LOOP
        FETCH c_uwlist
        INTO l_uw_list_r;
        EXIT WHEN c_uwlist % NOTFOUND;

        l_org_uwlist_type := INSIS_CUST.P_CUST_UWLIST_TYPE(l_uw_list_r.ID);
        l_org_uwlist_type.APPROVED := INSIS_CUST.GVAR_CUST.FLG_APPROVE;
         l_org_uwlist_type.NOTES := 'Automated migration approval';
        IF NOT l_org_uwlist_type.UPDATEUWISSUE(PIO_ERR)
        THEN

          l_policyRec.logMsg := 'CUST APPROVE_UW  Failed to update uw_list';
          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
          RETURN FALSE;
        END IF;

      END LOOP;
      CLOSE c_uwlist;

      l_policyRec.logMsg := 'UnderWriting List has been aproved';
      MIGR_LOG.LOG_INFO(l_policyRec);
      RETURN TRUE;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN FALSE;
    END APPROVE_UW;
       ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Caclulates policy premium
  PROCEDURE  CALCULATE_PREMIUM(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    AS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);

      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Calculate Policy Premium';
      p_policyrec.migrArea := 'MIGR_API_POLICY.PREMIUM_CALCULATED';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_TYPE', SRV_CONTEXT.Integers_Format, NULL);
      SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'INSR_BEGIN', SRV_CONTEXT.Date_Format, p_policyrec.insr_begin);

       v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('CALC_PREM');

       v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

       EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS     THEN
          p_policyrec.logMsg := 'Premium was calculated succesfully' || '-RESULT:' || L_RESULT;
          MIGR_LOG.LOG_INFO(p_policyrec);
          p_policyrec.policy_final_step:='PREMIUM_CALCULATED';
      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
          p_policyrec.logMsg := 'Premium calculation returned with warning -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);
          p_policyrec.policy_final_step:='PREMIUM_CALCULATED';

      ELSE
          p_policyrec.logMsg := 'PIO_ERR CALC_PREM Failed to calculate premium-RESULT: ' || L_RESULT;
          MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
          p_policyrec.continue_migr:=FALSE;
      END IF;

        --TEMPORARY WORKAROUND
    ---p_policyrec:=SET_POLICY_AGENT_COMMISSIONS(p_policyrec);
    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
         p_policyrec.continue_migr  :=FALSE;
    END CALCULATE_PREMIUM;
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  ---Check if policy should be sent to  underwriter
  PROCEDURE  START_AUTO_UW(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT   SRVCONTEXT;
      L_OUT_CONTEXT  SRVCONTEXT;
      PIO_ERR        SRVERR;
      L_RESULT       VARCHAR2(50);
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Start UnderWriting Process';
      p_policyrec.migrArea := 'MIGR_API_POLICY.START_AUTO_UW';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';


      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);     -- Policy Id
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);           --  0
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_policyrec.insr_type);

      v_event:= MIGR_API_COMMON.GET_INSIS_EVENT('START_AUTO_UW');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS  THEN
            p_policyrec.logMsg := 'Underwriting process returned with RESULT' || L_RESULT || '-Policy should be set in status Pending';
            MIGR_LOG.LOG_INFO(p_policyrec);

            --FA.20160531 Skip underwriting and approve underwriting task
            IF APPROVE_UW(p_policyrec)  THEN
              p_policyrec.policy_final_step := 'TO_BE_CONFIRMED';
            ELSE
              p_policyrec.policy_final_step  := 'REQUIRE_UNDERWITING';
            END IF;

      ELSE
            p_policyrec.logMsg := 'Underwriting process returned with RESULT: ' || L_RESULT || '-Policy should be confirmed';
            MIGR_LOG.LOG_INFO(p_policyrec);
            p_policyrec.policy_final_step  := 'TO_BE_CONFIRMED';

      END IF;


    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
           p_policyrec.continue_migr:=FALSE;
    END START_AUTO_UW;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------
   --FA.20170808 Check if consistency error is the Premium not calculated error and if so re-calculate premium and re-execute the consistency check
   PROCEDURE  CHECK_CALC_PREM_CONSISTECY_ERR(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp ,PIO_ERROR IN SRVERR)
    IS

      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
      l_calcPremErr BOOLEAN;
    BEGIN
         l_calcPremErr :=FALSE;

         FOR I IN PIO_ERROR.FIRST .. PIO_ERROR.LAST     LOOP

            IF  PIO_ERROR(I).ERRCODE ='PolConsist_PremNotCalculated' AND PIO_ERROR(I).ERRTYPE='ERROR'  THEN

                l_calcPremErr :=  TRUE;
                  p_policyrec.logMsg := 'Consistency failed because premium should be re-calculated';
                  MIGR_LOG.LOG_WARNING(p_policyrec);

                  CALCULATE_PREMIUM(p_policyrec );

                  IF  p_policyrec.continue_migr   THEN
                        BEGIN
                          L_IN_CONTEXT := NULL;
                          L_OUT_CONTEXT := NULL;
                          PIO_ERR := NULL;

                          p_policyrec.migrStep := 'Check Policy Consistency';
                          p_policyrec.migrArea := 'MIGR_API_POLICY.CHECK_POLICY_CONSISTENCY';
                          p_policyrec.migrRelTbl := 'INSIS_EVENT';

                        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);
                        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);

                        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('POL_CONS');

                        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                        EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

                        SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

                         l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

                         IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS  THEN
                              p_policyrec.logMsg := 'Policy consistency was checked succesfully-RESULT' || L_RESULT;
                              MIGR_LOG.LOG_INFO(p_policyrec);
                              p_policyrec.policy_final_step:= 'CONSISTENCY_CHECKED';
                        ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
                              p_policyrec.logMsg := 'Policy consistency returned with warning -RESULT:' || L_RESULT;
                              MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);
                              p_policyrec.policy_final_step:= 'CONSISTENCY_CHECKED';
                        ELSE

                            p_policyrec.logMsg := 'PIO_ERR POL_CONS Failed to check policy consistency -RESULT: ' || L_RESULT;
                            MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
                            p_policyrec.continue_migr := FALSE;
                        END IF;


                       EXCEPTION
                           WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
                                 MIGR_LOG.LOG_EXCEPTION(p_policyrec);
                                 p_policyrec.continue_migr:= FALSE;


                       END;
                     END IF;
             END IF;
         END LOOP;

             --Log the failure if failed due to another error
          IF  NOT  l_calcPremErr THEN

             p_policyrec.logMsg := 'PIO_ERR POL_CONS Failed to check policy consistency -RESULT: ' || L_RESULT;
             MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERROR);
             p_policyrec.continue_migr := FALSE;
          END IF;

    END   CHECK_CALC_PREM_CONSISTECY_ERR;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --  Check policy consistency
  PROCEDURE  CHECK_POLICY_CONSISTENCY(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Check Policy Consistency';
      p_policyrec.migrArea := 'MIGR_API_POLICY.CHECK_POLICY_CONSISTENCY';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('POL_CONS');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS  THEN
          p_policyrec.logMsg := 'Policy consistency was checked succesfully-RESULT' || L_RESULT;
          MIGR_LOG.LOG_INFO(p_policyrec);
          p_policyrec.policy_final_step:= 'CONSISTENCY_CHECKED';
      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
          p_policyrec.logMsg := 'Policy consistency returned with warning -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);
          p_policyrec.policy_final_step:= 'CONSISTENCY_CHECKED';
      ELSE

        --FA.20170808 If policy is running Phase 2 and calc prem error is received then recalculate premium and re-check consistency
        IF  p_policyrec.mig_flag = MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS THEN
               CHECK_CALC_PREM_CONSISTECY_ERR(p_policyrec,PIO_ERR)  ;

        ELSE
            p_policyrec.logMsg := 'PIO_ERR POL_CONS Failed to check policy consistency -RESULT: ' || L_RESULT;
            MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
            p_policyrec.continue_migr := FALSE;
        END IF;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr:= FALSE;

    END CHECK_POLICY_CONSISTENCY;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 ---Confirm application -If succeded turn policy status to : -2
  PROCEDURE CONFIRM_APPLICATION(p_policyrec IN OUT  MIGR_GVAR.PolicyRecTyp)
    AS
      L_IN_CONTEXT       SRVCONTEXT;
      L_OUT_CONTEXT      SRVCONTEXT;
      PIO_ERR            SRVERR;
      L_RESULT           VARCHAR2(50);
      l_evres            PLS_INTEGER;
      v_stmst            VARCHAR2(400);
      v_event            MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;
       SAVEPOINT pol_conf;
      p_policyrec.migrStep := 'Confirm Application';
      p_policyrec.migrArea := 'MIGR_API_POLICY.APPLICATION_CONFIRMED';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';


      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.POLICY_ID);     -- Policy Id
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);           --  0

      --SAVEPOINT confirm_rollback;

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT( 'APPL_CONF') ;

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS    THEN
        p_policyrec.logMsg := 'Application confirmed succesfully -RESULT:' || L_RESULT;
        MIGR_LOG.LOG_INFO(p_policyrec);
        p_policyrec.policy_final_step:= 'CONFIRMED' ;

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
        p_policyrec.logMsg := 'Application confirmed returned with warning -RESULT:' || L_RESULT;
        MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);
        p_policyrec.policy_final_step:= 'CONFIRMED' ;

      ELSE
        ROLLBACK TO pol_conf;
        p_policyrec.logMsg := 'PIO_ERR APPL_CONF Failed to confirm application-RESULT: ' || L_RESULT;
        MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
        p_policyrec.continue_migr:=FALSE;

      END IF;

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
           p_policyrec.continue_migr:=FALSE;
           ROLLBACK TO pol_conf;
    END CONFIRM_APPLICATION;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---Last step of application operation to convert it to contract
 PROCEDURE CONVERT_APPLICATION (p_policyrec   IN OUT MIGR_GVAR.PolicyRecTyp)
 IS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
      l_renewalDate VARCHAR2(20);
    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT :=NULL;
      PIO_ERR := NULL;
    SAVEPOINT pol_conv;
      p_policyrec.migrStep := 'Convert Application to Contract';
      p_policyrec.migrArea := 'MIGR_API_POLICY.CONVERT_APPLICATION';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyrec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('APPL_CONV') ;

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

      EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_IN_CONTEXT, IN MIGR_GVAR.GV_DEBUG, OUT L_OUT_CONTEXT, IN OUT PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS   THEN
         p_policyrec.logMsg := 'Convert Application to Contract completed succesfully -RESULT:' || L_RESULT;
         MIGR_LOG.LOG_INFO(p_policyrec);
         p_policyrec.policy_final_step:= 'CONVERTED' ;
      ELSIF
          l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
          p_policyrec.logMsg := 'Convert Application to Contract completed with warning -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_WARNING_EVENT(p_policyrec, PIO_ERR);
          p_policyrec.policy_final_step:= 'CONVERTED' ;
      ELSE
          ROLLBACK TO pol_conv;
          p_policyrec.logMsg := 'PIO_ERR APPL_CONV Failed to convert application-RESULT: ' || L_RESULT;
          MIGR_LOG.LOG_ERROR_EVENT(p_policyrec, PIO_ERR);
          p_policyrec.continue_migr:=FALSE;
      END IF;


     --FA.20170313 Call insert data for Anticimex
     IF p_policyrec.continue_migr THEN

       --FA.20170315 Insert data for Ettkund synchronization
        BEGIN
              INSERT INTO  INSIS_CUST.POLICY_RENEWALS_MIG (ID, INSIS_POLICY_ID ,INSIS_ANNEX_ID,CREATION_DATE,STATUS)
              VALUES( INSIS_CUST.POLICY_RENEWALS_MIG_SEQ.NEXTVAL,p_policyrec.policy_id,MIGR_GVAR.GV_ANNEX_ID,SYSDATE,0);

                p_policyrec :=INSERT_ANTICIMEX_DATA (p_policyrec);
                 IF   p_policyrec.continue_migr=FALSE  THEN
                      ROLLBACK TO pol_conv;
                     p_policyrec.logMsg :='Failed to insert anticimex data - Convert operation and EttKund Operation are rolled back';
                      MIGR_LOG.LOG_ERROR(p_policyrec);

                 END IF;

        EXCEPTION
          WHEN OTHERS THEN
                p_policyrec.logMsg :='Failed to Synchronize data with EttKund due to error:' || SQLERRM || '  - Convert operation is rolled back';
                MIGR_LOG.LOG_EXCEPTION(p_policyrec);
                 p_policyrec.policy_final_step:= 'CONFIRMED' ;
                ROLLBACK TO pol_conv;
                p_policyrec.continue_migr:=FALSE;
        END;



     END IF;


      EXCEPTION
      WHEN OTHERS THEN
         p_policyrec.logMsg := SQLERRM;
         MIGR_LOG.LOG_EXCEPTION(p_policyrec);
         p_policyrec.continue_migr:=FALSE;
         ROLLBACK TO pol_conv;
   END CONVERT_APPLICATION;


  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Check LANSBONUS: pl 20170518
  PROCEDURE CHECK_LANSBONUS(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      v_max_tries     INTEGER := 0;
      v_exit          BOOLEAN := FALSE;
      v_continue_migr BOOLEAN := TRUE;

      v_cond_value     VARCHAR2(50);
      v_discount_value NUMBER;

    BEGIN
      p_policyrec.migrStep   := 'Check Lansbonus';
      p_policyrec.migrArea   := 'MIGR_API_POLICY.CHECK_LANSBONUS';
      p_policyrec.migrRelTbl := '';

      WHILE ( v_exit = FALSE )
      LOOP

        BEGIN
            SELECT pc.COND_VALUE, grd.DISCOUNT_VALUE
              INTO v_cond_value, v_discount_value
              FROM INSIS_GEN_V10.POLICY_CONDITIONS pc, INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
             WHERE pc.POLICY_ID = grd.POLICY_ID
               AND grd.DISCOUNT_TYPE = '1050'
               AND pc.COND_TYPE = 'LANSBONUS_P'
               AND pc.POLICY_ID = p_policyrec.policy_id;

            IF (v_cond_value IS NULL) THEN
                v_continue_migr := FALSE;
                p_policyrec.logMsg := 'Lansbonus Record in INSIS_GEN_V10.POLICY_CONDITIONS table with null value in ''LANSBONUS_P''';
                --FA.20170801 if in phase 1 the premium was not calculated succesfully, log it as warning, next time log it as error
                IF v_max_tries =0 THEN
                    MIGR_LOG.LOG_WARNING(p_policyrec) ;
                 ELSE
                   MIGR_LOG.LOG_ERROR(p_policyrec);
                END IF;
            ELSIF (NOT v_cond_value IS NULL AND TO_NUMBER(v_cond_value) <> v_discount_value) THEN
                v_continue_migr := FALSE;
-- ++ anb 20170717 -- error reporting must happen after executing CALCULATE_PREMIUM and looping for the 2nd time and still having errors.
--                p_policyrec.logMsg := 'POLICY_CONDITIONS.Cond_Value: ' || v_cond_value
--                                   || ' - GEN_RISK_DISCOUNT.Discount_Value: ' || v_discount_value
--                                   || ': Inconsistency between the two values.';
--                MIGR_LOG.LOG_ERROR(p_policyrec);

                    p_policyrec.logMsg := 'POLICY_CONDITIONS.Cond_Value: ' || v_cond_value
                                       || ' - GEN_RISK_DISCOUNT.Discount_Value: ' || v_discount_value
                                       || ': Inconsistency between the two values.';
                --FA.20170801 if in phase 1 the premium was not calculated succesfully, log it as warning, next time log it as error
                IF v_max_tries =0 THEN
                    MIGR_LOG.LOG_WARNING(p_policyrec)  ;
                 ELSE
                   MIGR_LOG.LOG_ERROR(p_policyrec);
                END IF;
-- ++ anb 20170717  end

-- ++ anb 20170717
            ELSE -- matches IF-ELSEIF
--                  -- all other cases mean that COND_VALUE = DISCOUNT_VALUE,
--                            so v_continue_migr=TRUE ie exit the loop because PREMIUM is calculated correctly
                v_continue_migr :=TRUE;
-- ++ anb 20170717 end
            END IF;
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
-- ++ anb 20170717 NO_DATA_FOUND when no records returned, so both tables have no records
--            p_policyrec.logMsg := 'No record of Lansbonus in INSIS_GEN_V10.POLICY_CONDITIONS table or No data found for DISCOUNT_TYPE = 1050 in INSIS_GEN_V10.GEN_RISK_DISCOUNT table';
            p_policyrec.logMsg := 'No record of Lansbonus in INSIS_GEN_V10.POLICY_CONDITIONS table and No data found for DISCOUNT_TYPE = 1050 in INSIS_GEN_V10.GEN_RISK_DISCOUNT table';
-- ++ anb 20170717 end
              --FA.20170801 if in phase 1 the premium was not calculated succesfully, log it as warning, next time log it as error
                IF v_max_tries =0 THEN
                    MIGR_LOG.LOG_WARNING(p_policyrec)  ;
                 ELSE
                   MIGR_LOG.LOG_ERROR(p_policyrec);
                END IF;
            v_continue_migr := FALSE;
          WHEN OTHERS THEN
            p_policyrec.logMsg := SQLCODE || '-' || SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(p_policyrec);
            v_continue_migr := FALSE;
        END;

        IF v_continue_migr = FALSE THEN
            --update to zero the policy net premium in INSIS_GEN_V10.POLICY_CONDITIONS table
            UPDATE INSIS_GEN_V10.POLICY_CONDITIONS pc
               SET pc.COND_VALUE = '0'
             WHERE pc.COND_TYPE = 'POLICY_NET_PREMIUM' AND pc.POLICY_ID = p_policyrec.policy_id;
            p_policyrec.continue_migr := v_continue_migr;
            v_continue_migr := TRUE;
        ELSE
            p_policyrec.continue_migr := v_continue_migr;

        END IF;

        v_max_tries := v_max_tries + 1;

        IF v_max_tries > 1 OR p_policyrec.continue_migr THEN
            v_exit := TRUE;
        ELSIF v_max_tries = 1 AND p_policyrec.continue_migr = FALSE THEN
            CALCULATE_PREMIUM(p_policyrec);
        END IF;

      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN
        p_policyrec.logMsg := SQLCODE || '-' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(p_policyrec);
        p_policyrec.continue_migr := FALSE;
    END CHECK_LANSBONUS;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --In case of an EttKund client's data update netween the two phases, the policy holder's address may have been remobed from the address table
 --The old address id is kept in policy address table
  --in order to avoid the consitency failure of the rule that checks is policy holder's address is regoistered in people module it has been agreed to update the policy address with client's  primary address
     PROCEDURE UPDATE_POLICY_ADDRESS (p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp, p_man_id  IN INSIS_GEN_V10.P_PEOPLE.man_id%TYPE)
      IS
          v_address_id       INSIS_GEN_V10.P_ADDRESS.ADDRESS_ID%type;
          PRAGMA AUTONOMOUS_TRANSACTION;
      BEGIN

      p_policyrec.migrStep   := 'Update Policy Address';
      p_policyrec.migrArea   := 'MIGR_API_POLICY.UPDATE_POLICY_ADDRESS';
      p_policyrec.migrRelTbl := '';

      SELECT ADDRESS_ID INTO v_address_id
      FROM INSIS_PEOPLE_V10.P_ADDRESS A
      WHERE A.MAN_ID = p_man_id
      AND sysdate BETWEEN NVL(A.VALID_FROM, sysdate) AND NVL(A.VALID_TO, sysdate)
      AND primary_flag = 'Y' ;

      FOR c IN ( SELECT PA.POLICY_ADDRESS_ID , PA.ADDRESS_ID
                        FROM INSIS_GEN_V10.POLICY_ADDRESSES PA
                        JOIN   INSIS_GEN_V10.POLICY_PARTICIPANTS PP ON PA.POLICY_ID=PP.POLICY_ID AND PP.PARTICPANT_ROLE='PHOLDER'
                        LEFT JOIN INSIS_PEOPLE_V10.P_ADDRESS  AD   ON PA.ADDRESS_ID = AD.ADDRESS_ID   AND PP.MAN_ID=AD.MAN_ID
                        WHERE
                        PP.POLICY_ID=p_policyrec.POLICY_ID
                        AND PA.AUX_ANNEX_ID IS NULL
                        and nvl(pa.valid_to, sysdate+1) >= sysdate
                        AND  AD.ADDRESS_ID IS NULL  )
      LOOP
           p_policyrec.logMsg:= 'About to update POLICY_ADDRESSES table for the policy_id:'||p_policyrec.POLICY_ID || '. The policy_address_id: '||c.POLICY_ADDRESS_ID || ' with address_id:'|| c.ADDRESS_ID || ' will be updated with the primary address:' || v_address_id ;
           MIGR_LOG.LOG_INFO(p_policyrec);
           UPDATE  INSIS_GEN_V10.POLICY_ADDRESSES SET address_id= v_address_id WHERE POLICY_ADDRESS_ID= c.POLICY_ADDRESS_ID;

      END LOOP;
       COMMIT;
      EXCEPTION
      WHEN OTHERS THEN
          p_policyrec.logMsg := 'Failed to update policy address with the new client''s address- Could not retrieve the primary address due to the following error:' ||   SQLCODE || '-' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          ROLLBACK;
      END;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 -- Call all required INSIS operation events to turn a policy to a contract
--In order to decide whether to execute a step the api migration plan is checked from mig_process_steps: step_code phase A and api_resume_steps phase B
--Check if step exists in phase plan and if last policy's succesfull step was at least one step before the current

  PROCEDURE MIGRATE_APPLICATION(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      is_migrated  BOOLEAN;
      l_eventTimer TIMESTAMP;
      v_cnt_addr NUMBER;
      v_holder_man_id     INSIS_GEN_V10.POLICY_PARTICIPANTS.MAN_ID%TYPE;
    BEGIN
      IF p_policyrec.process_steps.EXISTS('PREM')  AND p_policyrec.continue_migr
        AND   ( p_policyrec.api_steps_order('PREMIUM_CALCULATED') -p_policyrec.api_steps_order( p_policyrec.policy_final_step) <=1)   THEN

                ---skip recalculate premium if no discount was provided
                --if last step is policy data migration  re-run calc prem
                IF  p_policyrec.mig_flag= MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS AND  NOT  p_policyrec.has_discount
                  and    ( p_policyrec.api_steps_order('PREMIUM_CALCULATED') -p_policyrec.api_steps_order( p_policyrec.policy_final_step) !=1)   THEN
                     p_policyrec.logMsg := 'PREMIUM_CALCULATED will not run due to zero premium adjustment. ' ;
                     MIGR_LOG.LOG_INFO(p_policyrec);

              ELSE
                      l_eventTimer := SYSTIMESTAMP;
                      CALCULATE_PREMIUM(p_policyrec);
                      p_policyrec.logMsg := 'PREMIUM_CALCULATED: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
                      MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

            END IF;
      END IF;

      IF ( p_policyrec.mig_flag = MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS AND p_policyrec.continue_migr ) THEN

            l_eventTimer := SYSTIMESTAMP;
            CHECK_LANSBONUS(p_policyrec);
            p_policyrec.logMsg := 'CHECK LANSBONUS: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
            MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

      END IF;

      IF   p_policyrec.process_steps.EXISTS('CONS')   AND p_policyrec.continue_migr
      AND   ( p_policyrec.api_steps_order('CONSISTENCY_CHECKED') -p_policyrec.api_steps_order( p_policyrec.policy_final_step) <=1)  THEN

            l_eventTimer := SYSTIMESTAMP;
            ---FA.20180306 Check only at Phase 2 if policy address has changed in people module because of client' data update in EttKund
            IF p_policyrec.mig_flag = MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS THEN

                  SELECT  COUNT(1) ,   MAX(PP.MAN_ID)  into v_cnt_addr, v_holder_man_id
                  FROM INSIS_GEN_V10.POLICY_ADDRESSES PA
                  JOIN   INSIS_GEN_V10.POLICY_PARTICIPANTS PP ON PA.POLICY_ID=PP.POLICY_ID AND PP.PARTICPANT_ROLE='PHOLDER'
                  LEFT JOIN INSIS_PEOPLE_V10.P_ADDRESS  AD   ON PA.ADDRESS_ID = AD.ADDRESS_ID   AND PP.MAN_ID=AD.MAN_ID
                  WHERE    PP.POLICY_ID=p_policyrec.policy_id
                        AND PA.AUX_ANNEX_ID IS NULL
                        AND nvl(pa.valid_to, sysdate+1) >= sysdate
                        AND  AD.ADDRESS_ID IS NULL  ;

                 IF v_cnt_addr >0 THEN
                      p_policyrec.logMsg:= 'Addresses that do not exist in people module found at policy addresses data. About to update policy holder''s address with his/her primary address.';
                      MIGR_LOG.LOG_INFO(p_policyrec);
                     UPDATE_POLICY_ADDRESS (p_policyrec, v_holder_man_id) ;
                 END IF;

            END IF;


            CHECK_POLICY_CONSISTENCY(p_policyrec) ;
            p_policyrec.logMsg := 'CHECK_POLICY_CONSISTENCY: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
            MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

      END IF;


      IF  p_policyrec.process_steps.EXISTS('UW')   AND p_policyrec.continue_migr
        AND   ( p_policyrec.api_steps_order('REQUIRE_UNDERWITING') -p_policyrec.api_steps_order( p_policyrec.policy_final_step) <=1) THEN

            l_eventTimer := SYSTIMESTAMP;
            START_AUTO_UW(p_policyrec);
            p_policyrec.logMsg := 'START_AUTO_UW: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
            MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
       END IF;

       IF p_policyrec.process_steps.EXISTS('CONF')  ---AND  p_policyrec.policy_final_step = 'TO_BE_CONFIRMED'
         AND   ( p_policyrec.api_steps_order('CONFIRMED') -p_policyrec.api_steps_order( p_policyrec.policy_final_step) <=1)  AND p_policyrec.continue_migr THEN

            l_eventTimer := SYSTIMESTAMP;
            CONFIRM_APPLICATION(p_policyrec);
            p_policyrec.logMsg := 'CONFIRMED: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
            MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
        END IF;

        IF p_policyrec.process_steps.EXISTS('CONV')  ---AND  p_policyrec.policy_final_step = 'TO_BE_CONFIRMED'
         AND   ( p_policyrec.api_steps_order('CONVERT') -p_policyrec.api_steps_order( p_policyrec.policy_final_step) <=1)  AND p_policyrec.continue_migr THEN

            l_eventTimer := SYSTIMESTAMP;
            CONVERT_APPLICATION(p_policyrec);
            p_policyrec.logMsg := 'CONVERTED: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
            MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
        END IF;

    END MIGRATE_APPLICATION;
  --------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA.20161220 Migrate Policy Flow should support autonomus step migration funcionality
  --API job serves next pending policy to be migrate to INSIS
  PROCEDURE MIGRATE_POLICY(P_MIGRBATCHID IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,P_IDPL        IN VARCHAR2)
    AS
        p_ia_policy_rec    IA_POLICY%ROWTYPE;
        l_beginTimer       TIMESTAMP WITH TIME ZONE;
        l_beginStepTimer   TIMESTAMP WITH TIME ZONE;
        l_eventTimer       TIMESTAMP WITH TIME ZONE;
        is_migrated        BOOLEAN;
        is_valid           BOOLEAN;
        l_policyRec        MIGR_GVAR.PolicyRecTyp;
        l_migrated         BOOLEAN;
        v_allowed_products VARCHAR2(2100);
        l_has_failed       BOOLEAN;
       -- v_mig_default_user CHAR(1);
        v_mig_insis_user   ETL_BOLAG_INFO.BOLAG_USERNAME%TYPE;
        v_cnt NUMBER;
    v_alrt NUMBER;
    BEGIN

          l_policyRec.migrArea     := 'MIGR_API_POLICY.MIGRATE_POLICY';
          l_policyRec.migrRelTbl   := 'IA_POLICY';
          l_policyRec.migrStep     := 'Create Policy Application';
          l_policyRec.MIG_BATCH_ID := P_MIGRBATCHID;

          SELECT * INTO p_ia_policy_rec FROM IA_POLICY ip WHERE ip.MIG_BATCH_ID = P_MIGRBATCHID AND ip.IA_IDPL = P_IDPL;


          l_beginTimer := SYSTIMESTAMP;
          l_eventTimer := SYSTIMESTAMP;
          l_has_failed := FALSE;
          l_policyRec.policy_idpl := p_ia_policy_rec.IA_IDPL;
         -- MIGR_LOG.LOG_INFO(l_policyRec);


         --Due to layers functionality only bolag users are able to view offerings, tariffs etc for their bolag
         --if FADATA provides a solution for this then a super user is rewuired to be added to MIG_DEFAULT_USER at setup info
         --if not one account per each bolag should be created by Client and aad their usernames in  ETL_BOLAG_INFO
        -- SELECT esi.MIG_DEFAULT_USER INTO v_mig_default_user FROM ETL_SETUP_INFO esi;

       ---  IF v_mig_default_user = 'Y' THEN
        ---    SELECT esi.MIGRATION_USER INTO v_mig_insis_user FROM ETL_SETUP_INFO esi;
        ---  ELSE
            SELECT ebi.BOLAG_USERNAME INTO v_mig_insis_user FROM ETL_BOLAG_INFO ebi WHERE ebi.BOLAG_ID = SUBSTR(l_policyRec.MIG_BATCH_ID, 1, 2);
        ----  END IF;

          -- Initializes the connection session
          INSIS_SYS_V10.INSIS_CONTEXT.Prepare_Session(Pi_App       => 'GEN',
                                                      Pi_Action    => 'InsisPolicyGen',
                                                      Pi_Username  => v_mig_insis_user,
                                                      Pi_User_Role => 'InsisStaff',
                                                      Pi_Lang      => NULL,
                                                      Pi_Country   => NULL);

          --set default values according to etl_setup_info configuration
          MIGR_API_COMMON.SET_DEFAULT_VALUES(SUBSTR(l_policyRec.MIG_BATCH_ID, 1, 2));

          -- LM 20170119 - Check if specific product should be migrated or skipped: 1 = migrate, 0 = skip
          v_allowed_products := MIGR_PROCESS.SKIP_INSIS_REG(l_policyRec.MIG_BATCH_ID, p_ia_policy_rec.MIG_FLAG, p_ia_policy_rec.IA_INSRPRD);
          -- LM 20170119 - end
           IF  v_allowed_products ='1' THEN

                --Initialize Policy Record
                l_policyRec.mig_flag :=p_ia_policy_rec.MIG_FLAG;
                l_policyRec.INSRPRD := p_ia_policy_rec.IA_INSRPRD;
                l_policyRec.POLICY_IDPL := p_ia_policy_rec.IA_IDPL;
                l_policyRec.office_id := p_ia_policy_rec.IA_OFFICE_ID;
                l_policyRec.numInstalments := p_ia_policy_rec.IA_NUMINSTALLMENTS;
                l_policyRec.policyYear := p_ia_policy_rec.IA_POLICY_YEAR;
                --LM 12062017 - PRODUCT LABEL - OFFERING CODES DEACTIVATED - START
                l_policyRec.productLabel := p_ia_policy_rec.IA_PRODUCT_LABEL;
                --LM 12062017 - END
                l_policyRec.insr_begin := p_ia_policy_rec.IA_INSR_BEGIN;
                l_policyRec.POLICY_REF := p_ia_policy_rec.IA_POLICY_REF;
                l_policyRec.EGN := p_ia_policy_rec.IA_EGN;
                l_policyRec.AGENT_NO := p_ia_policy_rec.IA_AGENT_NO;
                --Due to offerings solution the insr_type is the offrncode and the insured product is stored at parent_insr_type
                l_policyRec.insr_type := p_ia_policy_rec.IA_INSR_TYPE;
                l_policyRec.parent_insr_type := p_ia_policy_rec.IA_PARENT_INSR_TYPE;
                l_policyRec.object_fail_log := '';
                l_policyRec.deduct_val := p_ia_policy_rec.IA_DEDUCT_VALUE;
                l_policyRec.IA_PAYM_WAY := p_ia_policy_rec.IA_PAYM_WAY;
                l_policyRec.IA_BANK_ID := p_ia_policy_rec.IA_BANK_ID;
                l_policyRec.IA_INVOICE := p_ia_policy_rec.IA_INVOICE;
                l_policyRec.IA_DISTR_METHOD := p_ia_policy_rec.IA_DISTR_METHOD;
                l_policyRec.continue_migr:=TRUE;
                l_policyRec.has_discount:=FALSE;

                is_valid := TRUE;
                l_policyRec.continue_migr  :=TRUE;

                --FA.20170519 Set agents and client only at phase A
                IF  l_policyRec.MIG_FLAG= MIGR_GVAR.GV_MIG_FLAG_RUNNING THEN
                    l_policyRec:= GET_POLICY_CLIENT(l_policyRec);

                     --since new roles were added call to set the policy records  l_policyRec.AGENT_ID := GET_AGENT_ID(l_policyRec.AGENT_NO);
                     l_policyRec:=SET_POLICY_AGENT_IDS(l_policyRec,p_ia_policy_rec) ;
               END IF;

                IF  l_policyRec.MIG_FLAG= MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS THEN
                      l_policyRec :=SET_MIGRATED_POLICY_VAL( l_policyRec );
                END IF;

                --Get api steps to execute- if mig_flag =0 get steps else get resume api steps
                  l_policyRec.process_steps   := MIGR_PROCESS.GET_API_PROCESS_PLAN( l_policyRec.MIG_BATCH_ID, l_policyRec.INSRPRD, l_policyRec.MIG_FLAG) ;

                --Get api steps order
                 l_policyRec.api_steps_order :=  MIGR_PROCESS.GET_API_STEPS_ORDER;

                l_policyRec := MIGR_API_COMMON.GET_IA_CONFIGURATION(l_policyRec);

                --each api step should be completely autonomous
                --if step is xecuted according to plan then if succeeds should update the policy fina step record field

                IF l_policyRec.process_steps.EXISTS('VALIDATE') THEN
                      IS_VALID_POLICY(l_policyRec, is_valid);

                     IF is_valid  THEN
                         l_policyRec.policy_final_step := 'VALIDATE';
                     END IF;
                END IF;

               IF is_valid  THEN
                    IF  l_policyRec.process_steps .EXISTS('POL_REG') AND (  l_policyRec.api_steps_order('POLICY_GENERAL') - l_policyRec.api_steps_order(l_policyRec.policy_final_step ) <=1)   THEN

                         l_policyRec.POLICY_ID := NULL;

                         l_policyRec.logMsg := ' Start migrating Policy with insurance type: ' ||  l_policyRec.INSR_TYPE || ' CLIENT_ID= ' ||  l_policyRec.CLIENT_ID || ' AGENT_ID= ' ||  l_policyRec.AGENT_ID;
                         MIGR_LOG.LOG_INFO(l_policyRec);

                         is_migrated := FALSE;
                         l_beginStepTimer := SYSTIMESTAMP;

                         MIGRATE_POLICY_GENERAL(l_policyRec);


                         IF l_policyRec.policy_id IS NOT NULL  THEN
                                l_policyRec.policy_final_step := 'POLICY_GENERAL';
                         ELSE
                                l_has_failed:= TRUE;
                                MIGR_LOG.LOG_FAILED_POLICY(l_policyRec, l_beginTimer,  l_policyRec.policy_final_step);
                         END IF;
                     ELSE
                         l_policyRec.logMsg:= 'Step Policy registration was skipped' ;
                         MIGR_LOG.LOG_INFO(l_policyRec);
                    END IF;
               ELSE
                  l_has_failed:= TRUE;
                  l_policyRec.continue_migr  :=FALSE;
                  l_policyRec.logMsg:= 'Policy was not valid';
                  MIGR_LOG.LOG_INFO(l_policyRec);
                  MIGR_LOG.LOG_FAILED_POLICY(l_policyRec, l_beginTimer,  l_policyRec.policy_final_step);
               END IF;

               IF l_policyRec.process_steps .EXISTS('POL_DATA') AND l_policyRec.policy_id IS NOT NULL AND  l_policyRec.continue_migr
                    AND (  l_policyRec.api_steps_order('POLICY_DATA_MIGRATION') - l_policyRec.api_steps_order( l_policyRec.policy_final_step) <=1)    THEN

                          MIGRATE_POLICY_OBJECTS(l_policyRec);

                          IF l_policyRec.continue_migr THEN
                                l_policyRec.policy_final_step := 'POLICY_DATA_MIGRATION';
                               --FA.20170510 Integration opens a new transaction for lansbonus -must commit prior to calculate premium call  to release any locks held by INSIS policy data registration events else timeouts will be received due to lock db objects
                               COMMIT;
                          END IF;

               END IF;

               --FA.20161121 Continue only if all policy data were migrated succesfully
                IF l_policyRec.continue_migr    THEN
                     IF   l_policyRec.MIG_FLAG= MIGR_GVAR.GV_MIG_FLAG_RUNNING THEN
                           l_policyRec.logMsg:= 'All policy data has been succesfully migrated so we are about to call application operations';
                        MIGR_LOG.LOG_INFO(l_policyRec);
                     END IF;
                     MIGRATE_APPLICATION(l_policyRec);

               END IF;

              --insert into migr_policy
              IF NOT l_has_failed THEN
                MIGR_LOG.LOG_POLICY(l_policyRec, l_beginTimer, l_policyRec.policy_final_step);
              END IF;

         ELSE
              MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG( l_policyRec.policy_idpl, MIGR_GVAR.GV_MIG_FLAG_SKIPPED,P_MIGRBATCHID);
         END IF;

        EXCEPTION
            WHEN OTHERS THEN
                  l_policyRec.continue_migr  :=FALSE;
                  MIGR_LOG.LOG_FAILED_POLICY(l_policyRec, l_beginTimer,  l_policyRec.policy_final_step);
                  l_policyRec.logMsg :=  l_policyRec.policy_final_step || ' - ' || SQLERRM || ' for policy' || P_IDPL;
                  MIGR_LOG.LOG_EXCEPTION(l_policyRec);
    END MIGRATE_POLICY;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


END MIGR_API_POLICY;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_QUESTIONS
  AS
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --- Load the list of questions into Global Table srv_question_data.gQuestionTable.
  --- We will need it in order to get System Question ID for updating particular question with UPD_QUEST service.
  FUNCTION LOAD_QUESTIONS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN BOOLEAN
    IS

      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_evres       PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN
          l_policyRec := p_policyRec;
          l_policyRec.migrStep := 'Load Questions';
          l_policyRec.migrArea := 'MIGR_API_QUESTIONS.LOAD_QUESTIONS';
          l_policyRec.migrRelTbl := 'INSIS_EVENT';

          l_in_context := NULL;
          l_out_context := NULL;
          PIO_ERR := NULL;
          L_RESULT := NULL;

          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'REFERENCE_TYPE', 'POLICY');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'TO_LOAD', 'Y');
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.insr_type);
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSURED_ID', SRV_CONTEXT.Integers_Format, l_policyRec.insured_object_id);

          v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('LOAD_QUEST');

          v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

          EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

          SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'PROCEDURE_RESULT', L_RESULT);

          l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

          IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS  THEN
              l_policyRec.logMsg := 'Questions were loaded succesfully with result : ' || L_RESULT;
              MIGR_LOG.LOG_INFO(l_policyRec);
              RETURN TRUE;

          ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
              l_policyRec.logMsg := 'LOAD_QUEST returned with warning -RESULT:' || L_RESULT;
              MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);
              RETURN TRUE;
          ELSE
              l_policyRec.logMsg := 'PIO_ERR LOAD_QUEST Questions FAILED to load with result : ' || L_RESULT;
              MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
              RETURN FALSE;
          END IF;


    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN FALSE;

    END LOAD_QUESTIONS;

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    PROCEDURE LOAD_OBJECT_LEVEL_QUESTIONS(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS

      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      TYPE q_rec IS RECORD (
          INS_OBJECT_ID NUMBER(20, 0)
        );
      TYPE t_q_type_tab IS TABLE OF q_rec;
      v_q_tab       t_q_type_tab;
      l_evres       PLS_INTEGER;
      vsql          VARCHAR2(2000);
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

    BEGIN
      p_policyRec.migrStep := 'Load Object Level Questions';
      p_policyRec.migrArea := 'MIGR_API_QUESTIONS.LOAD_OBJECT_LEVEL_QUESTIONS';
      p_policyRec.migrRelTbl := 'INSIS_EVENT';

      l_in_context := NULL;
      l_out_context := NULL;
      PIO_ERR := NULL;
      L_RESULT := NULL;
      IF  p_policyRec.ia_questionsTbl  IS NOT NULL THEN
            vsql := ' SELECT mov.INS_OBJECT_ID  FROM ' || p_policyRec.ia_questionsTbl || ' iaq , ' || p_policyRec.migrTbl
              || ' mov WHERE  mov.IA_OBJECT_ID=iaq.IA_OBJECT_ID  and mov.OBJECT_ID is not null and iaq.IA_Q_LEVEL=''OBJECT'' AND  iaq.IA_IDPL = ' || P_policyRec.policy_idpl;

            EXECUTE IMMEDIATE vsql    BULK COLLECT INTO v_q_tab;

            FOR i IN 1 .. v_q_tab.COUNT
            LOOP

                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'REFERENCE_TYPE', 'POLICY');
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'TO_LOAD', 'Y');
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyRec.policy_id);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_policyRec.insr_type);
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSURED_ID', SRV_CONTEXT.Integers_Format, v_q_tab(i).INS_OBJECT_ID);

                    v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('LOAD_QUEST');

                    v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                    EXECUTE IMMEDIATE v_stmst
                    USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                    SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'PROCEDURE_RESULT', L_RESULT);

                    l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

                    IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS  THEN
                        p_policyRec.logMsg := 'Questions were loaded succesfully with result : ' || L_RESULT;
                        MIGR_LOG.LOG_INFO(p_policyRec);

                    ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING THEN
                        p_policyRec.logMsg := 'LOAD_QUEST returned with warning -RESULT:' || L_RESULT;
                        MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);

                    ELSE
                        p_policyRec.logMsg := 'PIO_ERR LOAD_QUEST Questions FAILED to load with result : ' || L_RESULT;
                        MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, PIO_ERR);
                        p_policyRec.continue_migr:=FALSE;

                    END IF;
            END LOOP;

      END IF;

    EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
                MIGR_LOG.LOG_EXCEPTION(p_policyRec);
                 p_policyRec.continue_migr:=FALSE;

    END LOAD_OBJECT_LEVEL_QUESTIONS;
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  -----------FA.20160603 Load object Level Questions
  FUNCTION LOAD_OBJECT_LEVEL_QUESTIONS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN BOOLEAN
    IS

      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      TYPE q_rec IS RECORD (
          INS_OBJECT_ID NUMBER(20, 0)
        );
      TYPE t_q_type_tab IS TABLE OF q_rec;
      v_q_tab       t_q_type_tab;
      l_evres       PLS_INTEGER;
      vsql          VARCHAR2(2000);
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

    BEGIN

      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Load Object Level Questions';
      l_policyRec.migrArea := 'MIGR_API_QUESTIONS.LOAD_OBJECT_LEVEL_QUESTIONS';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

      l_in_context := NULL;
      l_out_context := NULL;
      PIO_ERR := NULL;
      L_RESULT := NULL;
      IF  l_policyRec.ia_questionsTbl  IS NOT NULL THEN
      vsql := ' SELECT mov.INS_OBJECT_ID  FROM ' || l_policyRec.ia_questionsTbl || ' iaq , ' || l_policyRec.migrTbl || ' mov WHERE  mov.IA_OBJECT_ID=iaq.IA_OBJECT_ID  and mov.OBJECT_ID is not null and iaq.IA_Q_LEVEL=''OBJECT'' AND  iaq.IA_IDPL = ' || l_policyRec.policy_idpl;

      EXECUTE IMMEDIATE vsql
        BULK COLLECT INTO v_q_tab;

      FOR i IN 1 .. v_q_tab.COUNT
      LOOP

        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'REFERENCE_TYPE', 'POLICY');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'TO_LOAD', 'Y');
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.insr_type);
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSURED_ID', SRV_CONTEXT.Integers_Format, v_q_tab(i).INS_OBJECT_ID);

        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('LOAD_QUEST');

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
        EXECUTE IMMEDIATE v_stmst
        USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'PROCEDURE_RESULT', L_RESULT);

        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

        IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS

        THEN
          l_policyRec.logMsg := 'Questions were loaded succesfully with result : ' || L_RESULT;
          MIGR_LOG.LOG_INFO(l_policyRec);

        ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
        THEN

          l_policyRec.logMsg := 'LOAD_QUEST returned with warning -RESULT:' || L_RESULT;
          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);

        ELSE
          l_policyRec.logMsg := 'PIO_ERR LOAD_QUEST Questions FAILED to load with result : ' || L_RESULT;
          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
          RETURN FALSE;
        END IF;
      END LOOP;

      END IF;
      RETURN TRUE;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN FALSE;

    END LOAD_OBJECT_LEVEL_QUESTIONS;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   --FA.20161123 If policy level then load questions for policy
  PROCEDURE LOAD_POLICY_LEVEL_QUESTIONS(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp)

    IS
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN


      p_policyRec.migrStep := 'Load Policy Level Questions';
      p_policyRec.migrArea := 'MIGR_API_QUESTIONS.LOAD_POLICY_LEVEL_QUESIONS';
      p_policyRec.migrRelTbl := 'INSIS_EVENT';

      l_in_context := NULL;
      l_out_context := NULL;
      PIO_ERR := NULL;
      L_RESULT := NULL;

      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'REFERENCE_TYPE', 'POLICY');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'TO_LOAD', 'Y');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyRec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_policyRec.insr_type);

     v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('LOAD_QUEST');
     --LM.20160829 Change event call to dynamic- Call migrate custom evens or insis default events according to etl_setup_info
      --MIGR_SYSTEM.CALL_EVENT('LOAD_QUEST', l_in_context, MIGR_API_COMMON.GV_DEBUG, l_out_context, PIO_ERR);
      SELECT DECODE (MIGR_GVAR.GV_DEFAULT_EVENT,'Y',INSIS_EVENT_NAME, migr_event_name   )   INTO v_event
        FROM MIGR_SRV_EVENT_LIST  WHERE MIGR_EVENT_KEY = 'LOAD_QUEST';
      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
      EXECUTE IMMEDIATE v_stmst
      USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
      THEN
        p_policyRec.logMsg := 'Questions were loaded succesfully with result : ' || L_RESULT;
        MIGR_LOG.LOG_INFO(p_policyRec);


      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
      THEN
        p_policyRec.logMsg := 'LOAD_QUEST returned with warning -RESULT:' || L_RESULT;
        MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, PIO_ERR);

      ELSE
        p_policyRec.logMsg := 'PIO_ERR LOAD_QUEST Questions FAILED to load with result : ' || L_RESULT;
        MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, PIO_ERR);
        p_policyRec.continue_migr:=FALSE;

      END IF;



    EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyRec);
         p_policyRec.continue_migr:=FALSE;
    END LOAD_POLICY_LEVEL_QUESTIONS;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




 --FA.20160602 If policy level then load questions for policy
  FUNCTION LOAD_POLICY_LEVEL_QUESTIONS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN BOOLEAN
    IS
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_evres       PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN
      l_policyRec := p_policyRec;

      l_policyRec.migrStep := 'Load Policy Level Questions';
      l_policyRec.migrArea := 'MIGR_API_QUESTIONS.LOAD_POLICY_LEVEL_QUESIONS';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

      l_in_context := NULL;
      l_out_context := NULL;
      PIO_ERR := NULL;
      L_RESULT := NULL;

      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'REFERENCE_TYPE', 'POLICY');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'TO_LOAD', 'Y');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.insr_type);

     v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('LOAD_QUEST');
     --LM.20160829 Change event call to dynamic- Call migrate custom evens or insis default events according to etl_setup_info
      --MIGR_SYSTEM.CALL_EVENT('LOAD_QUEST', l_in_context, MIGR_API_COMMON.GV_DEBUG, l_out_context, PIO_ERR);
      SELECT DECODE (MIGR_GVAR.GV_DEFAULT_EVENT,'Y',INSIS_EVENT_NAME, migr_event_name   )   INTO v_event
        FROM MIGR_SRV_EVENT_LIST  WHERE MIGR_EVENT_KEY = 'LOAD_QUEST';
      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
      EXECUTE IMMEDIATE v_stmst
      USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'PROCEDURE_RESULT', L_RESULT);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(PIO_ERR, L_RESULT);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
      THEN
        l_policyRec.logMsg := 'Questions were loaded succesfully with result : ' || L_RESULT;
        MIGR_LOG.LOG_INFO(l_policyRec);


      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
      THEN
        l_policyRec.logMsg := 'LOAD_QUEST returned with warning -RESULT:' || L_RESULT;
        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, PIO_ERR);

      ELSE
        l_policyRec.logMsg := 'PIO_ERR LOAD_QUEST Questions FAILED to load with result : ' || L_RESULT;
        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, PIO_ERR);
        RETURN FALSE;

      END IF;

      RETURN TRUE;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN FALSE;
    END LOAD_POLICY_LEVEL_QUESTIONS;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160602 If policy level then load question - if object level load quest for insured object id
  PROCEDURE LOAD_POLICY_QUESTIONS(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
    BEGIN

      p_policyRec.migrStep := 'Load Questions';
      p_policyRec.migrArea := 'MIGR_API_QUESTIONS.LOAD_QUESTIONS';
      p_policyRec.migrRelTbl := 'INSIS_EVENT';

      IF LOAD_POLICY_LEVEL_QUESTIONS(p_policyRec)
      THEN

        IF LOAD_OBJECT_LEVEL_QUESTIONS(p_policyRec)
        THEN
          p_policyRec.logMsg := 'All policy questions were loaded!!';
          MIGR_LOG.LOG_INFO(p_policyRec);

        ELSE
          p_policyRec.continue_migr:= FALSE;
        END IF;

      ELSE
        p_policyRec.continue_migr:= FALSE;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyRec);
          p_policyRec.continue_migr:= FALSE;
    END LOAD_POLICY_QUESTIONS;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  FUNCTION GET_POL_QUESTIONS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN BOOLEAN
    IS
      l_in_context    SRVCONTEXT;
      l_out_context   SRVCONTEXT;
      l_error_message VARCHAR2(256);
      pio_err         SRVERR;
      l_result        VARCHAR2(50);
      l_evres         PLS_INTEGER;
      l_policyRec     MIGR_GVAR.PolicyRecTyp;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_result := NULL;
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Get Policy Questions';
      l_policyRec.migrArea := 'MIGR_API_QUESTIONS.GET_POL_QUESTIONS';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'REFERENCE_TYPE', 'POLICY');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'TO_LOAD', 'Y');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.insr_type);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSURED_ID', SRV_CONTEXT.Integers_Format, l_policyRec.insured_object_id);

    v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('GET_POL_ALLQUEST');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
      EXECUTE IMMEDIATE v_stmst
      USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      --FA.20160421 Handle Event Response
      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, l_result);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
      THEN
        l_policyRec.logMsg := 'Got Policy Questions succesfully ';
        MIGR_LOG.LOG_INFO(l_policyRec);
        RETURN TRUE;

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
      THEN

        l_policyRec.logMsg := 'GET_POL_ALLQUEST returned with warning -RESULT:' || l_result;
        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
        RETURN TRUE;

      ELSE
        l_policyRec.logMsg := 'PIO_ERR GET_POL_ALLQUEST Failed to get Policy Questions succesfully ';
        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
        RETURN FALSE;

      END IF;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN FALSE;
    END GET_POL_QUESTIONS;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160603 load policy questions to populate global table
  PROCEDURE GET_POLICY_QUESTIONS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)

    IS
      l_in_context    SRVCONTEXT;
      l_out_context   SRVCONTEXT;
      l_error_message VARCHAR2(256);
      pio_err         SRVERR;
      l_result        VARCHAR2(50);
      l_evres         PLS_INTEGER;
      l_policyRec     MIGR_GVAR.PolicyRecTyp;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_result := NULL;
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Get Policy Questions';
      l_policyRec.migrArea := 'MIGR_API_QUESTIONS.GET_POL_QUESTIONS';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'REFERENCE_TYPE', 'POLICY');
      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'TO_LOAD', 'Y');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.insr_type);
      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('GET_POL_ALLQUEST');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
      EXECUTE IMMEDIATE v_stmst
      USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, l_result);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
      THEN
        l_policyRec.logMsg := 'Got Policy Questions succesfully ';
        MIGR_LOG.LOG_INFO(l_policyRec);

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
      THEN
        l_policyRec.logMsg := 'GET_POL_ALLQUEST returned with warning -RESULT:' || l_result;
        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);

      ELSE
        l_policyRec.logMsg := 'PIO_ERR GET_POL_ALLQUEST Failed to get Policy Questions succesfully ';
        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);

      END IF;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);

    END GET_POLICY_QUESTIONS;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION UPDATE_QUESTIONS(p_ia_q_level  IN VARCHAR2,
                            P_q_id        IN VARCHAR2,
                            P_q_ord       IN VARCHAR2,
                            p_ia_quest_id IN VARCHAR2,
                            p_ia_q_answer IN VARCHAR2,
                            p_policyRec   IN MIGR_GVAR.PolicyRecTyp)
    RETURN BOOLEAN
    IS
      l_evres       PLS_INTEGER;
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      pio_err       SRVERR;
      l_result      VARCHAR2(50);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN
      l_policyRec := p_policyRec;
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      l_result := NULL;

      l_policyRec.migrStep := 'Update Policy Questions';
      l_policyRec.migrArea := 'MIGR_API_QUESTIONS.UPDATE_QUESTIONS';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ID', SRV_CONTEXT.Integers_Format, TO_NUMBER(P_q_id));
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'QUEST_ID', p_ia_quest_id);

      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'QUEST_ANSWER', p_ia_q_answer);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'QUEST_ORDER', SRV_CONTEXT.Integers_Format, TO_NUMBER(P_q_ord));
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'REFERENCE_TYPE', 'POLICY');
      --    SRV_CONTEXT.SETCONTEXTATTRCHAR    (L_IN_CONTEXT, 'TO_LOAD',  'Y');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.insr_type);

      IF UPPER(p_ia_q_level) = 'POLICY'
      THEN
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_ID', SRV_CONTEXT.Integers_Format, NULL);
      ELSE
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_ID', SRV_CONTEXT.Integers_Format, l_policyRec.insured_object_id);
      END IF;
     v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('UPD_QUEST');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
      EXECUTE IMMEDIATE v_stmst
      USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', l_result);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, l_result);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
      THEN
        l_policyRec.logMsg := 'Policy Questions Updated succesfully ' || '-RESULT' || l_result;
        MIGR_LOG.LOG_INFO(l_policyRec);
        RETURN TRUE;

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
      THEN

        l_policyRec.logMsg := 'UPD_QUEST returned with warning -RESULT:' || l_result;
        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
        RETURN TRUE;

      ELSE
        l_policyRec.logMsg := 'PIO_ERR UPD_QUEST Failed to update Policy Questions-RESULT:' || l_result;
        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
        RETURN FALSE;
      END IF;


    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN FALSE;
    END UPDATE_QUESTIONS;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160603 UPDATE policy level questions
  PROCEDURE UPDATE_POLICY_LEVEL_QUESTIONS(p_ia_q_level  IN VARCHAR2,
                                         P_q_id        IN VARCHAR2,
                                         P_q_ord       IN VARCHAR2,
                                         p_ia_quest_id IN VARCHAR2,
                                         p_ia_q_answer IN VARCHAR2,
                                         p_policyRec   IN OUT MIGR_GVAR.PolicyRecTyp)

    IS
      l_evres       PLS_INTEGER;
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      pio_err       SRVERR;
      l_result      VARCHAR2(50);

      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      l_result := NULL;

      p_policyRec.migrStep := 'Update Policy Level Questions';
      p_policyRec.migrArea := 'MIGR_API_QUESTIONS.UPDATE_POLICY_LEVEL_QUESTIONS';
      p_policyRec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ID', SRV_CONTEXT.Integers_Format, TO_NUMBER(P_q_id));
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'QUEST_ID', p_ia_quest_id);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'QUEST_ANSWER', p_ia_q_answer);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'QUEST_ORDER', SRV_CONTEXT.Integers_Format, TO_NUMBER(P_q_ord));
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'REFERENCE_TYPE', 'POLICY');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyRec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_policyRec.insr_type);

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_ID', SRV_CONTEXT.Integers_Format, NULL);

       v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('UPD_QUEST');

       v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

       EXECUTE IMMEDIATE v_stmst USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

       SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', l_result);
        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, l_result);

        IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS  THEN
            p_policyRec.logMsg := 'Policy Level Questions Updated succesfully ' || '-RESULT' || l_result ||  ' Set Question IA_QUEST_ID:' ||p_ia_quest_id || ' , id:' || P_q_id;
            MIGR_LOG.LOG_INFO(p_policyRec);

        ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
            p_policyRec.logMsg := 'UPD_QUEST returned with warning -RESULT:' || l_result||  ' Set Question IA_QUEST_ID:' || p_ia_quest_id || ' , id:' || P_q_id;
            MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, pio_err);

        ELSE
            p_policyRec.logMsg := 'PIO_ERR UPD_QUEST Failed to update Policy  Level  Questions-RESULT:' || l_result;
            MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, pio_err);
            p_policyRec.continue_migr :=FALSE;
        END IF;


    EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyRec);
         p_policyRec.continue_migr :=FALSE;
    END UPDATE_POLICY_LEVEL_QUESTIONS;


  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160614 UPDATE policy level questions for deductibles
  PROCEDURE UPDATE_POLICY_DEDUCT_QUESTIONS(P_q_id              IN VARCHAR2,
                                          P_q_ord             IN VARCHAR2,
                                          p_ia_quest_id       IN VARCHAR2,
                                          p_policyRec         IN MIGR_GVAR.PolicyRecTyp,
                                          p_insured_object_id IN NUMBER,
                                          p_deduct_val        IN VARCHAR2)
   --- RETURN BOOLEAN
    IS
      l_evres       PLS_INTEGER;
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      pio_err       SRVERR;
      l_result      VARCHAR2(50);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN
      l_policyRec := p_policyRec;
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      l_result := NULL;

      l_policyRec.migrStep := 'Update Policy Level Questions';
      l_policyRec.migrArea := 'MIGR_API_QUESTIONS.UPDATE_POLICY_LEVEL_QUESTIONS';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ID', SRV_CONTEXT.Integers_Format, TO_NUMBER(P_q_id));
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'QUEST_ID', p_ia_quest_id);

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'QUEST_ORDER', SRV_CONTEXT.Integers_Format, TO_NUMBER(P_q_ord));
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'REFERENCE_TYPE', 'POLICY');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.insr_type);

      l_policyRec.logMsg := 'p_insured_object_id:' || p_insured_object_id;
      MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);


      IF p_insured_object_id IS NULL
      THEN
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_ID', SRV_CONTEXT.Integers_Format, NULL);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'QUEST_ANSWER', l_policyRec.deduct_val);
      ELSE
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_ID', SRV_CONTEXT.Integers_Format, p_insured_object_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'QUEST_ANSWER', p_deduct_val);
      END IF;

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('UPD_QUEST');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
      EXECUTE IMMEDIATE v_stmst
      USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', l_result);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, l_result);
      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
      THEN
        l_policyRec.logMsg := 'Policy Level Questions Updated succesfully ' || '-RESULT' || l_result;
        MIGR_LOG.LOG_INFO(l_policyRec);
     ----   RETURN TRUE;

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
      THEN
        l_policyRec.logMsg := 'UPD_QUEST returned with warning -RESULT:' || l_result;
        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
      ----  RETURN TRUE;

      ELSE
        l_policyRec.logMsg := 'PIO_ERR UPD_QUEST Failed to update Policy  Level  Questions-RESULT:' || l_result;
        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
    ---    RETURN FALSE;
      END IF;


    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
        ---  RETURN FALSE;
    END UPDATE_POLICY_DEDUCT_QUESTIONS;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160603 UPDATE policy level questions
  PROCEDURE  UPDATE_OBJECT_LEVEL_QUESTIONS(p_ia_q_level  IN VARCHAR2,
                                         P_q_id        IN VARCHAR2,
                                         P_q_ord       IN VARCHAR2,
                                         p_ia_quest_id IN VARCHAR2,
                                         p_ia_q_answer IN VARCHAR2,
                                         p_policyRec   IN OUT MIGR_GVAR.PolicyRecTyp)

    IS
      l_evres       PLS_INTEGER;
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      pio_err       SRVERR;
      l_result      VARCHAR2(50);

      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN

      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      l_result := NULL;

      p_policyRec.migrStep := 'Update Object  Level  Questions';
      p_policyRec.migrArea := 'MIGR_API_QUESTIONS.UPDATE_OBJECT_LEVEL_QUESTIONS';
      p_policyRec.migrRelTbl := 'INSIS_EVENT';

      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ID', SRV_CONTEXT.Integers_Format, TO_NUMBER(P_q_id));
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'QUEST_ID', p_ia_quest_id);
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'QUEST_ANSWER', p_ia_q_answer);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'QUEST_ORDER', SRV_CONTEXT.Integers_Format, TO_NUMBER(P_q_ord));
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'REFERENCE_TYPE', 'POLICY');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policyRec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, p_policyRec.insr_type);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_ID', SRV_CONTEXT.Integers_Format, p_policyRec.insured_object_id);

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('UPD_QUEST');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
      EXECUTE IMMEDIATE v_stmst
      USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', l_result);

      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, l_result);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
      THEN
        p_policyRec.logMsg := 'Policy Object Level Questions Updated succesfully ' || '-RESULT' || l_result;
        MIGR_LOG.LOG_INFO(p_policyRec);


      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
      THEN
        p_policyRec.logMsg := 'UPD_QUEST returned with warning -RESULT:' || l_result;
        MIGR_LOG.LOG_WARNING_EVENT(p_policyRec, pio_err);


      ELSE
        p_policyRec.logMsg := 'PIO_ERR UPD_QUEST Failed to update Policy Object  Level Questions-RESULT:' || l_result;
        MIGR_LOG.LOG_ERROR_EVENT(p_policyRec, pio_err);
        p_policyRec.continue_migr:=FALSE;

      END IF;


    EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyRec);
          p_policyRec.continue_migr:=FALSE;
    END UPDATE_OBJECT_LEVEL_QUESTIONS;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE SUBMIT_QUESTIONS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      pio_err       SRVERR;
      l_result      VARCHAR2(50);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_evres       PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      l_policyRec := p_policyRec;

      l_policyRec.migrStep := 'Submit Policy Questions';
      l_policyRec.migrArea := 'MIGR_API_QUESTIONS.SUBMIT_QUESTIONS';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';
      SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'REFERENCE_TYPE', 'POLICY');
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, l_policyRec.policy_id);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'ANNEX_ID', SRV_CONTEXT.Integers_Format, MIGR_GVAR.GV_ANNEX_ID);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSR_TYPE', SRV_CONTEXT.Integers_Format, l_policyRec.insr_type);
      SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'INSURED_ID', SRV_CONTEXT.Integers_Format, l_policyRec.insured_object_id);
         v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('SUBMIT_QUEST');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
      EXECUTE IMMEDIATE v_stmst
      USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

      SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', l_result);
      --FA.20160421 Handle Event Response
      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, l_result);

      IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
      THEN
        l_policyRec.logMsg := 'Policy Questions Submited succesfully -RESULT:' || l_result;
        MIGR_LOG.LOG_INFO(l_policyRec);

      ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
      THEN
        l_policyRec.logMsg := 'SUBMIT_QUEST returned with warning -RESULT:' || l_result;
        MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);

      ELSE
        l_policyRec.logMsg := 'PIO_ERR SUBMIT_QUEST Failed to submit Policy Questions-RESULT: ' || l_result;
        MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);

      END IF;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_ERROR(l_policyRec);
    END SUBMIT_QUESTIONS;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160602 Questions migration should be done after product objects migration
  PROCEDURE MIGRATE_POLICY_QUESTIONS_old(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    IS

      L_RESULT      VARCHAR2(50);
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      l_q_id        VARCHAR2(1024);
      l_q_ord       VARCHAR2(1024);
      v_QuestCount  VARCHAR2(256);
      vsql          VARCHAR2(2000);
      TYPE q_rec IS RECORD (
          IA_QUEST_ID   VARCHAR2(200),
          IA_Q_LEVEL    VARCHAR2(200),
          IA_Q_ANSWER   VARCHAR2(200),
          INS_OBJECT_ID NUMBER(20, 0)
        );
      TYPE t_q_type_tab IS TABLE OF q_rec;
      v_q_tab       t_q_type_tab;
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
    BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Migrate Object Questions';
      l_policyRec.migrArea := 'MIGR_API_QUESTIONS.MIGRATE_QUESTIONS';
      l_policyRec.migrRelTbl := l_policyRec.ia_questionsTbl;

      --get all policy questions
      vsql := 'SELECT COUNT(*)  FROM  ' || l_policyRec.ia_questionsTbl || ' WHERE IA_IDPL = ' || l_policyRec.policy_idpl;

      EXECUTE IMMEDIATE vsql
        INTO v_QuestCount;

      IF v_QuestCount > 0
      THEN

         LOAD_POLICY_QUESTIONS(l_policyRec);

        IF l_policyRec.continue_migr  THEN

          GET_POLICY_QUESTIONS(l_policyRec);

          vsql := 'SELECT DISTINCT  IA_QUEST_ID,IA_Q_LEVEL,IA_Q_ANSWER, '''' AS INS_OBJECT_ID FROM ' || l_policyRec.ia_questionsTbl || ' WHERE IA_IDPL = ' || l_policyRec.policy_idpl || ' and IA_Q_LEVEL=''POLICY'' ';

          EXECUTE IMMEDIATE vsql
            BULK COLLECT INTO v_q_tab;

          FOR i IN 1 .. v_q_tab.COUNT
          LOOP

            SELECT COUNT(1)
              INTO v_QuestCount
              FROM TABLE (SRV_QUESTION_DATA.gQuestionTable)
              WHERE TRIM(QUEST_ID) = TRIM(v_q_tab(i).IA_QUEST_ID);

            IF v_QuestCount = 0  THEN

              l_policyRec.logMsg := 'Could not find question: ' || v_q_tab(i).IA_QUEST_ID;
              MIGR_LOG.LOG_WARNING(l_policyRec);

            ELSE

              SELECT gt.ID,gt.QUEST_ORDER
                INTO l_q_id, l_q_ord
                FROM TABLE (SRV_QUESTION_DATA.gQuestionTable) gt
                WHERE gt.QUEST_ID = v_q_tab(i).IA_QUEST_ID;

               UPDATE_POLICY_LEVEL_QUESTIONS(v_q_tab(i).IA_Q_LEVEL, l_q_id, l_q_ord, v_q_tab(i).IA_QUEST_ID, v_q_tab(i).IA_Q_ANSWER, l_policyRec) ;
            END IF;

            ---FA.20160606 Need to populate questions
            GET_POLICY_QUESTIONS(l_policyRec);
          END LOOP quest_table_loop;

          --get all object level question
          vsql := ' SELECT  IA_QUEST_ID,IA_Q_LEVEL,IA_Q_ANSWER, mov.INS_OBJECT_ID  FROM ' || l_policyRec.ia_questionsTbl || ' iaq , ' || l_policyRec.migrTbl || ' mov WHERE mov.IA_OBJECT_ID =iaq.IA_OBJECT_ID and  mov.OBJECT_ID  and iaq.IA_Q_LEVEL=''OBJECT'' AND  iaq.IA_IDPL = ' || l_policyRec.policy_idpl;

          EXECUTE IMMEDIATE vsql
            BULK COLLECT INTO v_q_tab;

          FOR i IN 1 .. v_q_tab.COUNT
          LOOP
            ---FA.20160606 Need to populate questions
            GET_POLICY_QUESTIONS(l_policyRec);

            SELECT COUNT(1)
              INTO v_QuestCount
              FROM TABLE (SRV_QUESTION_DATA.gQuestionTable)
              WHERE QUEST_ID = v_q_tab(i).IA_QUEST_ID;

            IF v_QuestCount = 0
            THEN

              l_policyRec.logMsg := 'Could not find question: ' || v_q_tab(i).IA_QUEST_ID;
              MIGR_LOG.LOG_WARNING(l_policyRec);
            ELSE

              SELECT gt.ID,
                     gt.QUEST_ORDER
                INTO l_q_id,
                     l_q_ord
                FROM TABLE (SRV_QUESTION_DATA.gQuestionTable) gt
                WHERE gt.QUEST_ID = v_q_tab(i).IA_QUEST_ID;

              l_policyRec.insured_object_id := v_q_tab(i).INS_OBJECT_ID;
              UPDATE_OBJECT_LEVEL_QUESTIONS(v_q_tab(i).IA_Q_LEVEL, l_q_id, l_q_ord, v_q_tab(i).IA_QUEST_ID, v_q_tab(i).IA_Q_ANSWER, l_policyRec);

            END IF;
          END LOOP quest_table_loop;

          SUBMIT_QUESTIONS(l_policyRec);
        END IF;
      ELSE
        l_policyRec.logMsg := ' No Questions found';
        MIGR_LOG.LOG_INFO(l_policyRec);

      END IF;

    EXCEPTION
      WHEN OTHERS THEN NULL;

    END MIGRATE_POLICY_QUESTIONS_old;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----FA.20160614 Add deductibles questions functionaliy
  PROCEDURE MIGRATE_POLICY_QUESTIONS(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS

      l_q_id            VARCHAR2(1024);
      l_q_ord           VARCHAR2(1024);
      PIO_ERR           SRVERR;
      vsql              VARCHAR2(32000);
--      v_deduct_sql      VARCHAR2(2000);
      TYPE quest_rec IS RECORD (
          IA_QUEST_ID   VARCHAR2(200),
          IA_Q_LEVEL    VARCHAR2(200),
          IA_Q_ANSWER   VARCHAR2(200),
          INS_OBJECT_ID NUMBER(20, 0)
        );
      TYPE Q_INS_OBJ IS RECORD (
          INS_OBJECT_ID NUMBER(20, 0)
        );

      TYPE t_quest_type_tab IS TABLE OF quest_rec;
--      v_deduct_val      VARCHAR2(10);
      TYPE q_rec_obj IS RECORD (
          INS_OBJECT_ID NUMBER(20, 0),
          OBJECT_ID     NUMBER(20, 0),
          obj_deduct    NVARCHAR2(100),
          ia_OBJECT_ID  NVARCHAR2(300)

        );
      TYPE t_q_obj_tab IS TABLE OF q_rec_obj;
      v_obj_tab         t_q_obj_tab;

      TYPE INSR_OBJ_TAB IS TABLE OF Q_INS_OBJ;
      v_quest_tab       t_quest_type_tab;
      V_INSR_OBJ_TAB    INSR_OBJ_TAB;

      l_quest_deduct_id INSIS_SYS_V10.QUEST_QUESTIONS.QUEST_ID % TYPE;
      l_eventTimer TIMESTAMP;

    BEGIN

       l_eventTimer := SYSTIMESTAMP;


      p_policyRec.migrStep := 'Migrate Object Questions';
      p_policyRec.migrArea := 'MIGR_API_QUESTIONS.MIGRATE_QUESTIONS';
      p_policyRec.migrRelTbl := p_policyRec.ia_questionsTbl;

     ----  LOAD_POLICY_QUESTIONS(p_policyRec) ;

        IF  p_policyRec.ia_questionsTbl IS NOT NULL THEN
            vsql := 'SELECT DISTINCT  IA_QUEST_ID,IA_Q_LEVEL,IA_Q_ANSWER, '''' AS INS_OBJECT_ID FROM ' || p_policyRec.ia_questionsTbl ||
              ' WHERE IA_IDPL = ' || p_policyRec.policy_idpl || ' and IA_Q_LEVEL=''POLICY'' ';

            BEGIN
                  EXECUTE IMMEDIATE vsql    BULK COLLECT INTO v_quest_tab;
                   --FA.20161123 Load policy questions only if policy has Q_LEVEL=''POLICY'
                   IF v_quest_tab.COUNT >0 THEN

                        LOAD_POLICY_LEVEL_QUESTIONS  (p_policyRec);

                        IF p_policyRec.continue_migr THEN

                            FOR i IN 1 .. v_quest_tab.COUNT    LOOP
                              ---FA.20160606 Need to populate questions every time
                              GET_POLICY_QUESTIONS(p_policyRec);

                              BEGIN
                                  SELECT gt.ID,  gt.QUEST_ORDER    INTO l_q_id,   l_q_ord
                                  FROM TABLE (SRV_QUESTION_DATA.gQuestionTable) gt
                                  WHERE TRIM(gt.QUEST_ID) = TRIM(v_quest_tab(i).IA_QUEST_ID);

                                 UPDATE_POLICY_LEVEL_QUESTIONS(v_quest_tab(i).IA_Q_LEVEL, l_q_id, l_q_ord, v_quest_tab(i).IA_QUEST_ID, v_quest_tab(i).IA_Q_ANSWER, p_policyRec);

                              EXCEPTION
                                WHEN NO_DATA_FOUND THEN p_policyRec.logMsg := 'Could not find question: ' || v_quest_tab(i).IA_QUEST_ID;
                                    MIGR_LOG.LOG_WARNING(p_policyRec);
                              END;

                            END LOOP;

                        END IF;

                  END IF;

                EXCEPTION
                  WHEN NO_DATA_FOUND THEN p_policyRec.logMsg := ' No Questions found for policy';
                      MIGR_LOG.LOG_INFO(p_policyRec);
            END;

      END IF;
        --get all object level question
           IF  p_policyRec.ia_questionsTbl IS NOT NULL AND p_policyRec.product_group <> 'ACCIDENT' THEN
               vsql := ' SELECT  IA_QUEST_ID,IA_Q_LEVEL,IA_Q_ANSWER, mov.INS_OBJECT_ID  FROM ' || p_policyRec.ia_questionsTbl || ' iaq , ' || p_policyRec.migrTbl || ' mov WHERE mov.IA_OBJECT_ID =iaq.IA_OBJECT_ID  and mov.OBJECT_ID  is not null and iaq.IA_Q_LEVEL=''OBJECT'' AND  iaq.IA_IDPL = ' || p_policyRec.policy_idpl;
                BEGIN
                  EXECUTE IMMEDIATE vsql   BULK COLLECT INTO v_quest_tab;

                     IF v_quest_tab.COUNT >0 THEN

                        LOAD_OBJECT_LEVEL_QUESTIONS(p_policyRec);

                        IF p_policyRec.continue_migr THEN

                            FOR i IN 1 .. v_quest_tab.COUNT    LOOP
                              ---FA.20160606 Need to populate questions
                              GET_POLICY_QUESTIONS(p_policyRec);

                              BEGIN
                                      SELECT gt.ID, gt.QUEST_ORDER    INTO l_q_id,     l_q_ord
                                        FROM TABLE (SRV_QUESTION_DATA.gQuestionTable) gt
                                        WHERE TRIM(gt.QUEST_ID) = TRIM(v_quest_tab(i).IA_QUEST_ID);

                                        p_policyRec.insured_object_id := v_quest_tab(i).INS_OBJECT_ID;

                                        UPDATE_OBJECT_LEVEL_QUESTIONS(v_quest_tab(i).IA_Q_LEVEL, l_q_id, l_q_ord, v_quest_tab(i).IA_QUEST_ID, v_quest_tab(i).IA_Q_ANSWER, p_policyRec);

                              EXCEPTION
                                WHEN NO_DATA_FOUND THEN p_policyRec.logMsg := 'Could not find question: ' || v_quest_tab(i).IA_QUEST_ID;
                                    MIGR_LOG.LOG_WARNING(p_policyRec);
                              END;

                            END LOOP;
                       END IF;

                     END IF;
                EXCEPTION
                  WHEN NO_DATA_FOUND THEN p_policyRec.logMsg := 'Could not find object level question: ';
                      MIGR_LOG.LOG_WARNING(p_policyRec);
                END;
           END IF;

-- LM - 20170314 - GET ALL OFFERING QUESTIONS FOR CUSTOMER MEMBERSHIP DISCOUNTS - START
          vsql := 'SELECT  IA_QUEST_ID,IA_Q_LEVEL,IA_Q_ANSWER, '''' AS INS_OBJECT_ID FROM IA_OFFER_QUESTIONS WHERE IA_IDPL = ' || p_policyRec.policy_idpl || ' and IA_Q_LEVEL=''POLICY'' ';

          BEGIN
                EXECUTE IMMEDIATE vsql    BULK COLLECT INTO v_quest_tab;
                 -- Load policy questions only if policy has Q_LEVEL='POLICY'
                 IF v_quest_tab.COUNT >0 THEN

                      LOAD_POLICY_LEVEL_QUESTIONS  (p_policyRec);

                      IF p_policyRec.continue_migr THEN

                          FOR i IN 1 .. v_quest_tab.COUNT    LOOP
                            ---Need to populate questions every time
                            GET_POLICY_QUESTIONS(p_policyRec);

                            BEGIN
                                SELECT gt.ID,  gt.QUEST_ORDER    INTO l_q_id,   l_q_ord
                                FROM TABLE (SRV_QUESTION_DATA.gQuestionTable) gt
                                WHERE TRIM(gt.QUEST_ID) = TRIM(v_quest_tab(i).IA_QUEST_ID);

                               UPDATE_POLICY_LEVEL_QUESTIONS(v_quest_tab(i).IA_Q_LEVEL, l_q_id, l_q_ord, v_quest_tab(i).IA_QUEST_ID, v_quest_tab(i).IA_Q_ANSWER, p_policyRec);

                            EXCEPTION
                              WHEN NO_DATA_FOUND THEN p_policyRec.logMsg := 'Could not find question: ' || v_quest_tab(i).IA_QUEST_ID;
                                  MIGR_LOG.LOG_WARNING(p_policyRec);
                            END;

                          END LOOP;

                      END IF;

                 END IF;

              EXCEPTION
                WHEN NO_DATA_FOUND THEN p_policyRec.logMsg := ' No Questions found for policy';
                    MIGR_LOG.LOG_INFO(p_policyRec);
          END;
-- LM - 20170314 - GET ALL OFFERING QUESTIONS FOR CUSTOMER MEMBERSHIP DISCOUNTS - END


-- pl 20161122 To be deleted
----        ---get deductibles Policy level questions
----        l_quest_deduct_id := INSIS_CUST.CUST_POL_DS.GPRODUCTPARAM(l_policyRec.insr_type, INSIS_SYS_V10.SYS_DAYS.GET_OPEN_DATE(), INSIS_CUST.CUST_POL_DS.GGVARCUST_VALUE('LF_POL_DEDUCT'), '0');
----
----          IF l_quest_deduct_id = '0'    THEN
----              l_policyRec.logMsg := 'Could not get deductible question for policy. ';
----              MIGR_LOG.LOG_ERROR(l_policyRec);
----              l_policyRec.continue_migr:=FALSE;
----          ELSE
----              ---FA.20160606 Need to populate questions
----              GET_POLICY_QUESTIONS(l_policyRec);
----                BEGIN
----                  SELECT gt.ID, gt.QUEST_ORDER
----                    INTO l_q_id, l_q_ord
----                    FROM TABLE (SRV_QUESTION_DATA.gQuestionTable) gt
----                    WHERE TRIM(gt.QUEST_ID) = TRIM(l_quest_deduct_id);
----
----                   UPDATE_POLICY_DEDUCT_QUESTIONS(l_q_id, l_q_ord, l_quest_deduct_id, l_policyRec, NULL, NULL)   ;
----
----                EXCEPTION
----                  WHEN NO_DATA_FOUND THEN l_policyRec.logMsg := 'Could not find question: ' || l_quest_deduct_id;
----                      MIGR_LOG.LOG_WARNING(l_policyRec);
----                END;
----          END IF;

----        ---get deductibles for object level
----         --FA. 20160928 ADDITION: get only the objects that  have been migrated :condiiton  mov.OBJECT_ID IS NOT NULL
----          vsql := ' SELECT mov.INS_OBJECT_ID,mov.OBJECT_ID, iaq.IA_obj_deduct,iaq.ia_OBJECT_ID  FROM ' || l_policyRec.ia_policyTbl || ' iaq , ' || l_policyRec.migrTbl
----          || ' mov WHERE mov.IA_OBJECT_ID=iaq.IA_OBJECT_ID  AND mov.OBJECT_ID IS NOT NULL AND  iaq.IA_IDPL = ' || l_policyRec.policy_idpl ;
----
----        EXECUTE IMMEDIATE vsql  BULK COLLECT INTO v_obj_tab;
----
----        FOR i IN 1 .. v_obj_tab.COUNT   LOOP
----
----            l_quest_deduct_id := INSIS_CUST.CUST_POL_DS.gObject_Deduct_Question(l_policyRec.policy_id, l_policyRec.insr_type, MIGR_GVAR.GV_ANNEX_ID, v_obj_tab(i).OBJECT_ID);
----
----            IF l_quest_deduct_id = '0'   THEN
----                  l_policyRec.logMsg := 'Could not get deductible question for object :  ' ||  v_obj_tab(i).INS_OBJECT_ID;
----                  MIGR_LOG.LOG_ERROR(l_policyRec);
----                  l_policyRec.continue_migr:=FALSE;
----            ELSE
----                  v_deduct_sql := ' SELECT iaq.IA_OBJ_DEDUCT   FROM ' || l_policyRec.ia_policyTbl || ' iaq  WHERE  iaq.IA_OBJECT_ID   =''' || v_obj_tab(i).ia_OBJECT_ID || '''';
----                  EXECUTE IMMEDIATE v_deduct_sql   INTO v_deduct_val;
----                  UPDATE INSIS_GEN_V10.INSURED_OBJECT io    SET io.IOP3 = v_deduct_val    WHERE io.INSURED_OBJ_ID = v_obj_tab(i).INS_OBJECT_ID;
----
----            END IF;
----        END LOOP;

        SUBMIT_QUESTIONS(p_policyRec);

          p_policyrec.logMsg := 'Migrating questions: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(p_policyrec);


    EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := 'Error: ' || SQLERRM();
          MIGR_LOG.LOG_ERROR(p_policyRec);

    END MIGRATE_POLICY_QUESTIONS;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--  PROCEDURE MIGRATE_QUESTIONS(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
--    IS
--
--      L_RESULT      VARCHAR2(50);
--      L_IN_CONTEXT  SRVCONTEXT;
--      L_OUT_CONTEXT SRVCONTEXT;
--      PIO_ERR       SRVERR;
--      l_q_id        VARCHAR2(1024);
--      l_q_ord       VARCHAR2(1024);
--      v_QuestCount  VARCHAR2(256);
--      vsql          VARCHAR2(2000);
--      TYPE q_rec IS RECORD (
--          IA_QUEST_ID VARCHAR2(200),
--          IA_Q_LEVEL  VARCHAR2(200),
--          IA_Q_ANSWER VARCHAR2(200)
--        );
--      TYPE t_q_type_tab IS TABLE OF q_rec;
--      v_q_tab       t_q_type_tab;
--      l_policyRec   MIGR_GVAR.PolicyRecTyp;
--    BEGIN
--      l_policyRec := p_policyRec;
--      l_policyRec.migrStep := 'Migrate Object Questions';
--      l_policyRec.migrArea := 'MIGR_API_QUESTIONS.MIGRATE_QUESTIONS';
--      l_policyRec.migrRelTbl := l_policyRec.ia_questionsTbl;
--
--      vsql := 'SELECT COUNT(*)  FROM  ' || l_policyRec.ia_questionsTbl || ' WHERE IA_IDPLPS = ' || l_policyRec.policy_idplps;
--
--      EXECUTE IMMEDIATE vsql
--        INTO v_QuestCount;
--
--      IF v_QuestCount > 0
--      THEN
--
--        IF LOAD_QUESTIONS(l_policyRec)
--        THEN
--
--          vsql := 'SELECT IA_QUEST_ID,IA_Q_LEVEL,IA_Q_ANSWER FROM ' || l_policyRec.ia_questionsTbl || ' WHERE IA_IDPLPS = ' || l_policyRec.policy_idplps;
--
--          EXECUTE IMMEDIATE vsql
--            BULK COLLECT INTO v_q_tab;
--
--          FOR i IN 1 .. v_q_tab.COUNT
--          LOOP
--
--          << quest_table_loop >>
--            IF GET_POL_QUESTIONS(l_policyRec)
--            THEN
--
--              SELECT COUNT(1)
--                INTO v_QuestCount
--                FROM TABLE (SRV_QUESTION_DATA.gQuestionTable)
--                WHERE QUEST_ID = v_q_tab(i).IA_QUEST_ID;
--
--              IF v_QuestCount = 0
--              THEN
--
--                l_policyRec.logMsg := 'Could not find question: ' || v_q_tab(i).IA_QUEST_ID;
--                MIGR_LOG.LOG_WARNING(l_policyRec);
--
--              ELSE
--
--                SELECT gt.ID,
--                       gt.QUEST_ORDER
--                  INTO l_q_id,
--                       l_q_ord
--                  FROM TABLE (SRV_QUESTION_DATA.gQuestionTable) gt
--                  WHERE gt.QUEST_ID = v_q_tab(i).IA_QUEST_ID;
--
--                IF UPDATE_QUESTIONS(v_q_tab(i).IA_Q_LEVEL, l_q_id, l_q_ord, v_q_tab(i).IA_QUEST_ID, v_q_tab(i).IA_Q_ANSWER, l_policyRec)
--                THEN
--
--                  l_policyRec.logMsg := ' Set Question IA_QUEST_ID:' || v_q_tab(i).IA_QUEST_ID || ' , id:' || l_q_id;
--                  MIGR_LOG.LOG_INFO(l_policyRec);
--                END IF;
--
--              END IF;
--
--            END IF;
--
--          END LOOP quest_table_loop;
--
--        END IF;
--
--        SUBMIT_QUESTIONS(l_policyRec);
--
--      ELSE
--        l_policyRec.logMsg := ' No Questions found';
--        MIGR_LOG.LOG_INFO(l_policyRec);
--
--      END IF;
--
--    EXCEPTION
--      WHEN OTHERS THEN NULL;
--
--    END MIGRATE_QUESTIONS;
END MIGR_API_QUESTIONS;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_API_TRAVEL
AS
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_TRAVEL_INS_PERS(p_policyRec IN OUT  MIGR_GVAR.PolicyRecTyp)
IS

      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      v_begintimer  TIMESTAMP WITH TIME ZONE;
      L_MAN_ID      P_PEOPLE.MAN_ID % TYPE;
      v_gender      VARCHAR2(10);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_evres       PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

      CURSOR c_iaObj (v_OBJECT_ID IA_TRAVEL_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT itip.IA_OBJECT_TYPE,
      itip.IA_TRAVEL_TYPE,
      itip.IA_TRAVEL_SUBTYPE,
      itip.IA_POLICY_REF,
      itip.IA_PURPOSE,
      itip.IA_DESTINATION,
      itip.IA_HOUSEHOLD,
      itip.IA_INS_PERS,
      itip.IA_GNAME,
      itip.IA_SNAME,
      itip.IA_PID,
      itip.IA_AGE,
      itip.IA_GENDER,
      itip.IA_FULL_NAME,
      itip.IA_BIRTH_DATE,
      itip.IA_NAME,
      itip.IA_IDPLPS ,
      mc.MAN_ID
      FROM IA_TRAVEL_INSURED_PERS itip
      LEFT JOIN MIGR_CLIENT mc ON mc.EGN=itip.IA_PID
      WHERE 1 = 1
      AND itip.IA_OBJECT_ID = v_OBJECT_ID;

 BEGIN
        l_policyRec := p_policyRec;
        v_begintimer := SYSTIMESTAMP;
        l_in_context := NULL;
        l_out_context := NULL;
        pio_err := NULL;
        l_policyRec.migrStep := 'Create Object Travel Insured Person';
        l_policyRec.migrArea := 'MIGR_API_TRAVEL.MIGRATE_O_TRAVEL_INS_PERS';
        l_policyRec.migrRelTbl := 'IA_TRAVEL_POLICY';

        FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)    LOOP

                l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
                l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
                IF r_c_iaObj.IA_GENDER = 1     THEN   v_gender := 'M';
                ELSE   v_gender := 'F';    END IF;

                 --FA. 20161031 First check if person has been migrated by client migration and if not search INSIS
                IF r_c_iaObj.MAN_ID IS NOT NULL THEN
                  L_MAN_ID:=r_c_iaObj.MAN_ID;
                ELSE
                    L_MAN_ID := MIGR_API_CLIENTS.GET_PEOPLE_BY_PID(r_c_iaObj.IA_PID);

                    IF L_MAN_ID IS NULL   THEN

                      l_in_context := NULL;
                      l_out_context := NULL;
                      pio_err := NULL;

                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GNAME', r_c_iaObj.IA_GNAME);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'FNAME', r_c_iaObj.IA_SNAME);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_FULL_NAME);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'EGN', r_c_iaObj.IA_PID);
                      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'SEX', SRV_CONTEXT.Integers_Format, r_c_iaObj.IA_GENDER);
                      SRV_CONTEXT.SETCONTEXTATTRDATE(l_in_context, 'BIRTH_DATE', SRV_CONTEXT.Date_Format, r_c_iaObj.IA_BIRTH_DATE);
                      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_COMP', SRV_CONTEXT.Integers_Format, 1);    --1 person 2--Legal entity

                      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PEOPLE');

                      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                      EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

                      IF l_evres = MIGR_GVAR.GV_EVRES_ERROR THEN
                            l_policyRec.logMsg := 'PIO_ERR INS_PEOPLE Failed to INSERT People';
                            MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                             l_policyRec.continue_migr :=FALSE;
                             l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '- FAILED to  INSERT People';
                      ELSE

                            SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'MAN_ID', L_MAN_ID);
                            l_policyRec.logMsg := 'People: ' || r_c_iaObj.IA_PID || ' was inserted succesfully with man_id:' || L_MAN_ID;
                            MIGR_LOG.LOG_INFO(l_policyRec);

                           IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                                  l_policyRec.logMsg := 'INS_PEOPLE returned with warning -RESULT:' || NULL;
                                  MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                            END IF;
                      END IF;

                END IF;

                END IF;

                IF L_MAN_ID IS NOT NULL  THEN
                      l_in_context := NULL;
                      l_out_context := NULL;
                      pio_err := NULL;

                      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
                      SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'AGE', '');
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_SUBTYPE', r_c_iaObj.IA_TRAVEL_TYPE);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_TYPE', r_c_iaObj.IA_TRAVEL_SUBTYPE);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GENDER', v_gender);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP1', r_c_iaObj.IA_PURPOSE);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP2', r_c_iaObj.IA_DESTINATION);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP3', r_c_iaObj.IA_HOUSEHOLD);
                      SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP4', r_c_iaObj.IA_PID);
                      --- Commented @20170828 Bug 446236:SITSIT: Migrated policy P10 - annex and change purpose of travel - get error "Attribute set with value...."
                      --SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP5', r_c_iaObj.IA_FULL_NAME);

                      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_ACCINSURED');

                      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

                      EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

                      SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

                     l_policyRec.logMsg := 'INS_ACCINSURED';
                      MIGR_LOG.LOG_INFO(l_policyRec);

                      l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

                       IF l_evres = MIGR_GVAR.GV_EVRES_ERROR  THEN
                               l_policyRec.logMsg := 'PIO_ERR INS_ACCINSURED Failed to register OBJECT';
                              MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                               l_policyRec.continue_migr :=FALSE;
                               l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '- FAILED to  register OBJECT';

                      ELSE
                            l_policyRec.logMsg := 'Travel Insured Person was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                            MIGR_LOG.LOG_INFO(l_policyRec);

                            l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                            IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                                  l_policyRec.logMsg := 'INS_ACCINSURED returned with warning -RESULT:' || NULL;
                                  MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                            END IF;
                      END IF;
              ELSE
                    l_policyRec.logMsg := 'Failed to call event INS_ACCINSURED due to null MAN_ID';
                    MIGR_LOG.LOG_ERROR(l_policyRec);
                    l_policyRec.continue_migr :=FALSE;
                    l_policyRec.object_fail_log  :=l_policyRec.object_fail_log|| '-Failed to Insert accident insured';
               END IF;

              INSERT INTO MIGR_O_TRAVEL (  NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG)
              VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

        END LOOP;
         p_policyRec:=l_policyRec;
EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          p_policyRec:=l_policyRec;
END MIGRATE_O_TRAVEL_INS_PERS;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_TRAVEL_CONTENT(p_policyRec     IN  OUT   MIGR_GVAR.PolicyRecTyp,
p_addressTab    IN OUT MIGR_GVAR.PropertyAddressTabTyp,
p_num_Insr_pers IN     NUMBER)
IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_Id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;

      CURSOR c_iaObj (v_OBJECT_ID IA_TRAVEL_POLICY.IA_OBJECT_ID % TYPE) IS
      SELECT itp.IA_OBJECT_TYPE,
      itp.IA_TRAVEL_TYPE,
      itp.IA_TRAVEL_SUBTYPE,
      itp.IA_NAME,
      itp.IA_PURPOSE,
      itp.IA_DESTINATION,
      itp.IA_DEST_ADDRESS,
      itp.IA_HOUSEHOLD,
      itp.IA_COUNTRY_CODE,
      itp.IA_CITY,
      itp.IA_ADDRESS,
      itp.IA_POST_CODE,
      itp.IA_POLICY_REF,
      itp.IA_IDPLPS
      FROM IA_TRAVEL_POLICY itp
      WHERE 1 = 1
      AND itp.IA_OBJECT_ID = v_OBJECT_ID
      AND itp.IA_PSTP = 'EG'
      FETCH FIRST ROW ONLY;
      v_is_Migrated  BOOLEAN;
      l_evres        PLS_INTEGER;
      v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

BEGIN
      l_policyRec := p_policyRec;
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Travel Content';
      l_policyRec.migrArea := 'MIGR_API_TRAVEL.MIGRATE_O_TRAVEL_CONTENT';
      l_policyRec.migrRelTbl := 'IA_TRAVEL_POLICY';


      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

            l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
            l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

            l_address := r_c_iaObj.IA_ADDRESS;
            l_postCode := r_c_iaObj.IA_POST_CODE;
            l_city := r_c_iaObj.IA_CITY;
            l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

            IF (l_address IS NULL  OR l_postCode IS NULL  OR l_city IS NULL   OR l_country_code IS NULL)  THEN
                  l_address := p_addressTab(1).r_address;
                  l_postCode := p_addressTab(1).r_postCode;
                  l_city := p_addressTab(1).r_city;
                  l_country_code := p_addressTab(1).r_countryCode;
            END IF;

            v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

            SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
            IF v_address_Id IS NOT NULL    THEN
                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
            ELSE

                  SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                  SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
            END IF;

            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_TRAVEL_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_TRAVEL_SUBTYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', r_c_iaObj.IA_PURPOSE);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_DESTINATION);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', p_num_Insr_pers);   ---- r_c_iaObj.IA_INS_PERS);
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_DEST_ADDRESS);

            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
            SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

            v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

            v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

           EXECUTE IMMEDIATE v_stmst USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

            SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

           IF v_address_Id IS NULL   THEN
                  SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
                  MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
            END IF;

            l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

              IF l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                    l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                    l_policyRec.continue_migr :=FALSE;
                    l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';


              ELSE
                    l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                    MIGR_LOG.LOG_INFO(l_policyRec);
                    l_policyRec:= MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                   IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                         l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                         MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                  END IF;
            END IF;

             INSERT INTO MIGR_O_TRAVEL (  NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG)
              VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer),v_begintimer,SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL,l_policyRec.object_fail_log);

      END LOOP;

      MIGRATE_O_TRAVEL_INS_PERS(p_policyRec);

       p_policyRec:=l_policyRec;

EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            p_policyRec:=l_policyRec;

END MIGRATE_O_TRAVEL_CONTENT;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE MIGRATE_O_EXTEND_TRAVEL(p_policyRec  IN OUT     MIGR_GVAR.PolicyRecTyp,
p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
IS

        l_in_context   SRVCONTEXT;
        l_out_context  SRVCONTEXT;
        pio_err        SRVERR;
        v_begintimer   TIMESTAMP WITH TIME ZONE;
        l_address      VARCHAR2(256);
        l_postCode     VARCHAR2(256);
        l_city         VARCHAR2(256);
        l_country_code VARCHAR2(256);
        v_address_id   NUMBER;
        l_policyRec    MIGR_GVAR.PolicyRecTyp;

        CURSOR c_iaObj (v_OBJECT_ID IA_TRAVEL_POLICY.IA_OBJECT_ID % TYPE) IS
        SELECT itp.IA_OBJECT_TYPE,
        itp.IA_TRAVEL_TYPE,
        itp.IA_TRAVEL_SUBTYPE,
        itp.IA_NAME,
        itp.IA_PURPOSE,
        itp.IA_DESTINATION,
        itp.IA_DEST_ADDRESS,
        itp.IA_HOUSEHOLD,
        itp.IA_COUNTRY_CODE,
        itp.IA_CITY,
        itp.IA_ADDRESS,
        itp.IA_POST_CODE,
        itp.IA_POLICY_REF,
        itp.IA_IDPLPS
        FROM IA_TRAVEL_POLICY itp
        WHERE 1 = 1
        AND itp.IA_OBJECT_ID = v_OBJECT_ID;
        v_is_Migrated  BOOLEAN;
        l_evres        PLS_INTEGER;
        v_stmst    VARCHAR2( 400);
        v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
BEGIN
        v_begintimer := SYSTIMESTAMP;
        v_address_id := NULL;
        l_in_context := NULL;
        l_out_context := NULL;
        pio_err := NULL;
        l_policyRec := p_policyRec;
        l_policyRec.migrStep := 'Create Object Extended Travel';
        l_policyRec.migrArea := 'MIGR_API_TRAVEL.MIGRATE_O_EXTEND_TRAVEL';
        l_policyRec.migrRelTbl := 'IA_TRAVEL_POLICY';

        FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
        LOOP

              l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
              l_policyRec.object_type := r_c_iaObj.IA_OBJECT_TYPE;
              SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
              l_address := r_c_iaObj.IA_ADDRESS;
              l_postCode := r_c_iaObj.IA_POST_CODE;
              l_city := r_c_iaObj.IA_CITY;
              l_country_code := r_c_iaObj.IA_COUNTRY_CODE;
              IF (l_address IS NULL   OR l_postCode IS NULL   OR l_city IS NULL  OR l_country_code IS NULL)  THEN
                    l_address := p_addressTab(1).r_address;
                    l_postCode := p_addressTab(1).r_postCode;
                    l_city := p_addressTab(1).r_city;
                    l_country_code := p_addressTab(1).r_countryCode;
              END IF;

              v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

              IF v_address_id IS NOT NULL     THEN
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
              ELSE
                    SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
                    SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
              END IF;
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_TRAVEL_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_TRAVEL_SUBTYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);

              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

              v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY');

              v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

              EXECUTE IMMEDIATE v_stmst  USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

              SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

              IF v_address_id IS NULL    THEN
                    SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
                    MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
              END IF;

              l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

                IF l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
                    l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                     l_policyRec.continue_migr :=FALSE;
                    l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  'FAILED to insert property';

              ELSE
                    l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                    MIGR_LOG.LOG_INFO(l_policyRec);
                    l_policyRec:=MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                   IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
                          l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                    END IF;

              END IF;

             INSERT INTO MIGR_O_TRAVEL (  NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS,MIG_START,MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG)
             VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer,SYSTIMESTAMP,l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

       END LOOP;

      p_policyRec:=l_policyRec;
EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_policyRec);
            l_policyRec.continue_migr :=FALSE;
            p_policyRec:=l_policyRec;
END MIGRATE_O_EXTEND_TRAVEL;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

FUNCTION  MIGRATE_TRAVEL(p_policyRec IN  MIGR_GVAR.PolicyRecTyp) RETURN MIGR_GVAR.PolicyRecTyp    AS

      v_in_context        SRVCONTEXT;
      v_out_context       SRVCONTEXT;
      v_errmsg            SRVERRMSG;
      v_srverrmsg         SRVERRMSG;
      pio_err             SRVERR;
      v_beginTimer        TIMESTAMP WITH TIME ZONE;
      v_is_obj_ok         BOOLEAN;
      v_address_id        NUMBER;

      CURSOR c_iaObj (vPOLICY_IDPL IA_TRAVEL_POLICY.IA_IDPL % TYPE) IS
      SELECT ivp.IA_POLICY_REF,
      ivp.IA_IDPL,
      ivp.IA_IDPLPS,
      ivp.IA_PSTP,
      ivp.IA_OBJECT_ID,
      ivp.IA_OBJECT_TYPE,
      ia.IA_ADDRESS,
      ia.IA_CITY,
      ia.IA_POST_CODE,
      ia.IA_COUNTRY,
        ivp.IA_OBJ_DEDUCT --,
    --FA 20161007 no needed check  mov.OBJECT_ID,   mov.INS_OBJECT_ID
      FROM IA_TRAVEL_POLICY ivp
     --FA 20161007 no needed check  LEFT JOIN MIGR_O_TRAVEL mov ON ivp.IA_OBJECT_ID = mov.IA_OBJECT_ID
      JOIN IA_ADDRESS ia
      ON ia.IA_IDPL = ivp.IA_IDPL
      WHERE 1 = 1
      AND ivp.IA_IDPL = vPOLICY_IDPL
      ORDER BY SUBSTR(ivp.IA_OBJECT_ID, LENGTH(ivp.IA_OBJECT_ID)) ASC;

      r_c_iaObj           c_iaObj % ROWTYPE;
      l_policyRec         MIGR_GVAR.PolicyRecTyp;
      vPropertyAddressTab MIGR_GVAR.PropertyAddressTabTyp;
      l_numInsrPer        NUMBER;
BEGIN

      l_policyRec := p_policyRec;
      vPropertyAddressTab.DELETE();
      l_policyRec.migrArea := 'MIGR_API_TRAVEL.MIGRATE_TRAVEL';
      l_policyRec.migrStep := 'Create Policy Travel';
      l_policyRec.migrRelTbl := 'IA_TRAVEL_POLICY';

      SELECT COUNT('x')     INTO l_numInsrPer
      FROM IA_TRAVEL_INSURED_PERS itip
      WHERE IA_IDPL = l_policyRec.POLICY_IDPL;

      OPEN c_iaObj (l_policyRec.POLICY_IDPL);
      << TRAVEL_loop >>
      LOOP

            FETCH c_iaObj INTO r_c_iaObj;
            EXIT WHEN c_iaObj % NOTFOUND;

            --add default client address
            MIGR_API_COMMON.ADD_ADDRESS_ID(vPropertyAddressTab, NULL, r_c_iaObj.IA_ADDRESS, r_c_iaObj.IA_POST_CODE, r_c_iaObj.IA_CITY, r_c_iaObj.IA_COUNTRY);

          --FA 20161007 no needed check  IF r_c_iaObj.OBJECT_ID IS NULL   AND r_c_iaObj.INS_OBJECT_ID IS NULL   THEN
                  l_policyRec.IA_OBJECT_ID := r_c_iaObj.IA_OBJECT_ID;
                  --FA.2060912 Added for cover level functionality
                   l_policyRec.objDeduct_val :=    r_c_iaObj.IA_OBJ_DEDUCT;

                   l_policyRec.object_fail_log  :=NULL;

                  CASE r_c_iaObj.IA_OBJECT_TYPE

                        WHEN '301' THEN  ---Travel Content
                          MIGRATE_O_TRAVEL_CONTENT(l_policyRec, vPropertyAddressTab, l_numInsrPer);

                        WHEN '2609' THEN  ---Extended Travel
                          MIGRATE_O_EXTEND_TRAVEL(l_policyRec, vPropertyAddressTab);

                        WHEN '20' THEN  ---Travel Insured Person
                          MIGRATE_O_TRAVEL_INS_PERS(l_policyRec);

                        ELSE l_policyRec.logMsg := 'Travel object with  ' || r_c_iaObj.IA_OBJECT_ID || ' failed due to invalid object type';
                              MIGR_LOG.LOG_ERROR(l_policyRec);
                              l_policyRec.continue_migr :=FALSE;
                              l_policyRec.object_fail_log :=l_policyRec.object_fail_log ||  '-FAILED due  invalid object type';
                              INSERT INTO MIGR_O_TRAVEL ( POLICY_ID, OBJECT_ID,  INS_DATE,   MIG_BATCH_ID, POLICY_IDPL,OBJ_ERROR_LOG )
                               VALUES ( l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, SYSDATE, l_policyRec.MIG_BATCH_ID, l_policyRec.policy_idpl,l_policyRec.object_fail_log);

                  END CASE;

      END LOOP TRAVEL_loop;

      CLOSE c_iaObj;
      RETURN l_policyRec;

EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
      l_policyRec.continue_migr :=FALSE;
       RETURN l_policyRec;
END MIGRATE_TRAVEL;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_API_TRAVEL;
/

CREATE OR REPLACE PACKAGE BODY                   MIGR_API_VILLAHEM
  AS

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_COLLECTION(p_policyRec  IN OUT MIGR_GVAR.PolicyRecTyp,
                                 p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS

      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      v_address_id   NUMBER;
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavp.IA_IDPLPS,
                 iavc.IA_COLLECTION_TYPE,
                 iavc.IA_PROTECTION_POINTS,
                 iavc.IA_PROPERTY_ID,
                 iavc.IA_DESCRIPTION,
                 iavc.IA_POLICY_REF,
                 iavc.IA_NAME,
                 iavc.IA_COUNTRY_CODE,
                 iavc.IA_CITY,
                 iavc.IA_ADDRESS,
                 iavc.IA_POST_CODE,
                 iavp.IA_OBJ_DEDUCT
            FROM IA_VILLAHEM_POLICY iavp
              JOIN IA_VILLAHEM_COLLECTION iavc
                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_eventTimer TIMESTAMP;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      l_policyRec := p_policyRec;
        l_eventTimer := SYSTIMESTAMP;
      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Villahem Collection';
      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_O_COLLECTION';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_COLLECTION';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;

        l_address := r_c_iaObj.IA_ADDRESS;
        l_postCode := r_c_iaObj.IA_POST_CODE;
        l_city := r_c_iaObj.IA_CITY;
        l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

        IF (l_address IS NULL
          OR l_postCode IS NULL
          OR l_city IS NULL
          OR l_country_code IS NULL)
        THEN
          l_address := p_addressTab(1).r_address;
          l_postCode := p_addressTab(1).r_postCode;
          l_city := p_addressTab(1).r_city;
          l_country_code := p_addressTab(1).r_countryCode;
        END IF;

        v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
        IF v_address_id IS NOT NULL
        THEN
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);

        ELSE
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

        END IF;
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_COLLECTION_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', r_c_iaObj.IA_DESCRIPTION);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', r_c_iaObj.IA_PROTECTION_POINTS);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY') ;

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

        EXECUTE IMMEDIATE v_stmst USING IN v_event, IN l_in_context, IN MIGR_GVAR.GV_DEBUG, OUT l_out_context, IN OUT pio_err;

        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);
             l_policyRec.logMsg := 'Migrating collection property: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(l_policyRec);
        IF v_address_id IS NULL   THEN
          SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
          MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
        END IF;

        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

        IF l_evres = MIGR_GVAR.GV_EVRES_ERROR     THEN
              l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
              MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
              l_policyRec.continue_migr :=FALSE;
              l_policyRec.object_fail_log := l_policyRec.object_fail_log || 'FAILED to insert property';

             INSERT INTO MIGR_O_VILLAHEM ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG   )
              VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

        ELSE
              l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
              MIGR_LOG.LOG_INFO(l_policyRec);

              l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

              INSERT INTO MIGR_O_VILLAHEM ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG  )
              VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);


              IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                  l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                  MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
              END IF;

        END IF;

      END LOOP;
      p_policyRec := l_policyRec;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          p_policyRec := l_policyRec;
    END MIGRATE_O_COLLECTION;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_PRIV_ACCIDENT_INS(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      l_eventTimer TIMESTAMP;
      l_in_context  SRVCONTEXT;
      l_out_context SRVCONTEXT;
      pio_err       SRVERR;
      v_begintimer  TIMESTAMP WITH TIME ZONE;
      L_MAN_ID      P_PEOPLE.MAN_ID % TYPE;
      v_gender      VARCHAR2(10);
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavb.IA_GNAME,
                 iavb.IA_SNAME,
                 iavb.IA_NAME,
                 iavb.IA_POLICY_REF,
                 iavb.IA_PID,
                 iavb.IA_AGE,
                 iavb.IA_GENDER,
                 iavb.IA_FULL_NAME,
                 iavb.IA_IND_BENEFICIARY,
                 iavb.IA_BIRTH_DATE,
                 iavp.IA_OBJ_DEDUCT,
                mc.MAN_ID
            FROM IA_VILLAHEM_POLICY iavp
              JOIN IA_VILLAHEM_PRIV_ACCIDENT iavb ON iavp.IA_OBJECT_ID = iavb.IA_OBJECT_ID
             LEFT JOIN MIGR_CLIENT mc ON mc.EGN=iavb.IA_PID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      l_policyRec := p_policyRec;
        l_eventTimer := SYSTIMESTAMP;
      v_begintimer := SYSTIMESTAMP;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Villahem Private Accident Insured Person';
      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_O_PRIV_ACCIDENT_INS';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_PRIV_ACCIDENT';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP
        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
        IF r_c_iaObj.IA_GENDER = 1
        THEN
          v_gender := 'M';
        ELSE
          v_gender := 'F';
        END IF;

         --FA. 20161031 First check if person has been migrated by client migration and if not search INSIS
        IF r_c_iaObj.MAN_ID IS NOT NULL THEN
              L_MAN_ID:=r_c_iaObj.MAN_ID;
        ELSE
              L_MAN_ID := MIGR_API_CLIENTS.GET_PEOPLE_BY_PID(r_c_iaObj.IA_PID);


        END IF;

        IF L_MAN_ID IS NOT NULL  THEN
              l_in_context := NULL;
              l_out_context := NULL;
              pio_err := NULL;

              SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
              SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'MAN_ID', SRV_CONTEXT.Integers_Format, L_MAN_ID);
              --LM - 22082016 - age autocalculated
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'AGE', '');
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_SUBTYPE', r_c_iaObj.IA_HOME_TYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ACCINS_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'GENDER', v_gender);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP1',  p_policyRec.property_id);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP2', r_c_iaObj.IA_FULL_NAME);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP3', r_c_iaObj.IA_PID);
              SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OAIP4', r_c_iaObj.IA_IND_BENEFICIARY);

              v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_ACCINSURED') ;

              v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

              EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN l_in_context, IN MIGR_GVAR.GV_DEBUG, OUT l_out_context, IN OUT pio_err;

              SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

              l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

              IF l_evres = MIGR_GVAR.GV_EVRES_ERROR    THEN
                    l_policyRec.logMsg := 'PIO_ERR INS_ACCINSURED Failed to register OBJECT';
                    MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                     l_policyRec.continue_migr :=FALSE;
                    l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  register OBJECT';
              ELSE
                      l_policyRec.logMsg := 'Private Accident Insurd Person was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
                      MIGR_LOG.LOG_INFO(l_policyRec);

                      l_policyRec.logMsg := 'Migrating accinsured: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
                      MIGR_LOG.LOG_EVENT_TIME(l_policyRec);

                      l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

                      IF    l_policyRec.require_pinsured ='Y' THEN
                          IF NOT MIGR_API_CLIENTS.ADD_PRIV_INS_PARTICIPANTS(l_policyRec, L_MAN_ID)   THEN
                               l_policyRec.continue_migr :=FALSE;
                               l_policyRec.object_fail_log := l_policyRec.object_fail_log || '- FAILED to  add policy participant';
                          END IF;
                      END IF;

                      IF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                            l_policyRec.logMsg := 'INS_ACCINSURED returned with warning -RESULT:' || NULL;
                            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
                      END IF;
                END IF;

        ELSE
              l_policyRec.logMsg := 'Failed to call event INS_ACCINSURED due to null MAN_ID';
              MIGR_LOG.LOG_ERROR(l_policyRec);
              l_policyRec.continue_migr :=FALSE;
              l_policyRec.object_fail_log := l_policyRec.object_fail_log || '-Failed to Insert accident insured';

        END IF;

        INSERT INTO MIGR_O_VILLAHEM ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG   )
        VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

      END LOOP;

      p_policyRec := l_policyRec;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          p_policyRec := l_policyRec;
    END MIGRATE_O_PRIV_ACCIDENT_INS;
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_OUTHOUSE(p_policyRec  IN OUT MIGR_GVAR.PolicyRecTyp,
                               p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
       l_eventTimer TIMESTAMP;
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      v_address_Id   NUMBER;
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavb.IA_PROPERTY_ID,
                 iavb.IA_COUNTRY_CODE,
                 iavb.IA_CITY,
                 iavb.IA_ADDRESS,
                 iavb.IA_POST_CODE,
                 iavb.IA_NAME,
                 iavb.IA_POLICY_REF,
                 iavb.IA_BUILDING_AREA,
                 iavb.IA_FURNISHED,
                 iavb.IA_FLOORS_NO,
                 iavb.IA_GEO_COORDINATES,
                 iavb.IA_OUTHOUSE_LABEL,
                 iavb.IA_OUTHOUSE_LABEL_OTHER,
                 iavb.IA_INSULATED,
                 iavp.IA_OBJ_DEDUCT
            FROM IA_VILLAHEM_POLICY iavp
              JOIN IA_VILLAHEM_OUTHOUSE iavb
                ON iavp.IA_OBJECT_ID = iavb.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Villahem Outhouse';
      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_O_OUTHOUSE';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_OUTHOUSE';
          l_eventTimer := SYSTIMESTAMP;

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
        v_begintimer := SYSTIMESTAMP;

        l_address := r_c_iaObj.IA_ADDRESS;
        l_postCode := r_c_iaObj.IA_POST_CODE;
        l_city := r_c_iaObj.IA_CITY;
        l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

        IF (l_address IS NULL
          OR l_postCode IS NULL
          OR l_city IS NULL
          OR l_country_code IS NULL)
        THEN
          l_address := p_addressTab(1).r_address;
          l_postCode := p_addressTab(1).r_postCode;
          l_city := p_addressTab(1).r_city;
          l_country_code := p_addressTab(1).r_countryCode;
        END IF;

        v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');

        IF v_address_Id IS NOT NULL  THEN
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
        ELSE
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
        END IF;

        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', r_c_iaObj.IA_BUILDING_AREA);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_FURNISHED);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', r_c_iaObj.IA_INSULATED);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_FLOORS_NO);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_GEO_COORDINATES);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', l_policyRec.property_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', r_c_iaObj.IA_OUTHOUSE_LABEL);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', r_c_iaObj.IA_OUTHOUSE_LABEL_OTHER);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY') ;

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

        EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN l_in_context, IN MIGR_GVAR.GV_DEBUG, OUT l_out_context, IN OUT pio_err;

        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

        IF v_address_Id IS NULL  THEN
          SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
          MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
        END IF;

        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

        IF l_evres = MIGR_GVAR.GV_EVRES_ERROR    THEN
          l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
          l_policyRec.continue_migr :=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || 'FAILED to insert property';

          INSERT INTO MIGR_O_VILLAHEM ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG   )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

        ELSE
          l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
          MIGR_LOG.LOG_INFO(l_policyRec);

              l_policyRec.logMsg := 'Migrating outhouse property: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(l_policyRec);

          l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

          INSERT INTO MIGR_O_VILLAHEM (NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG  )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);


          IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
            l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
          END IF;
        END IF;

      END LOOP;
      p_policyRec := l_policyRec;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          p_policyRec := l_policyRec;
    END MIGRATE_O_OUTHOUSE;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_BUILDING(p_policyRec  IN OUT MIGR_GVAR.PolicyRecTyp,
                               p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
      l_eventTimer TIMESTAMP;
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;

      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavb.IA_PROPERTY_ID,
                 iavb.IA_LIVING_AREA,
                 iavb.IA_ADDITIONAL_AREA,
                 iavb.IA_CHIMNEY,
                 iavb.IA_BATHROOMS_NO,
                 iavb.IA_BUILT_YEAR,
                 iavb.IA_WATER_INSIDE,
                 iavb.IA_RENOVATION_YEAR,
                 iavb.IA_GEO_COORDINATES,
                 iavb.IA_COUNTRY_CODE,
                 iavb.IA_CITY,
                 iavb.IA_ADDRESS,
                 iavb.IA_POST_CODE,
                 iavb.IA_NAME,
                 iavb.IA_BUILDING_ID,
                 iavb.IA_BUILDING_LABEL,
                 iavb.IA_BUILDING_USAGE,
                 iavb.IA_PURCHASE_DATE,
                 iavb.IA_STANDARD_POINTS,
                 iavb.IA_BUILDING_TYPE,
                 iavb.IA_TAXABLE_VALUE,
                 iavb.IA_POLICY_REF,
                 iavp.IA_OBJ_DEDUCT
            FROM IA_VILLAHEM_POLICY iavp
              JOIN IA_VILLAHEM_BUILDING iavb
                ON iavp.IA_OBJECT_ID = iavb.IA_OBJECT_ID
            WHERE iavp.IA_OBJECT_ID = v_OBJECT_ID;
      v_address_Id   NUMBER;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

    BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_policyRec := p_policyRec;
        l_eventTimer := SYSTIMESTAMP;
      l_policyRec.migrStep := 'Create Object Villahem Building';
      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_O_BUILDING';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_BUILDING';



      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP
        l_in_context := NULL;
        l_out_context := NULL;
        pio_err := NULL;

        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
        l_address := r_c_iaObj.IA_ADDRESS;
        l_postCode := r_c_iaObj.IA_POST_CODE;
        l_city := r_c_iaObj.IA_CITY;
        l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

        IF (l_address IS NULL
          OR l_postCode IS NULL
          OR l_city IS NULL
          OR l_country_code IS NULL)
        THEN

          l_address := p_addressTab(1).r_address;
          l_postCode := p_addressTab(1).r_postCode;
          l_city := p_addressTab(1).r_city;
          l_country_code := p_addressTab(1).r_countryCode;
        END IF;

        v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_LIVING_AREA);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', r_c_iaObj.IA_ADDITIONAL_AREA);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_CHIMNEY);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', r_c_iaObj.IA_BATHROOMS_NO);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', r_c_iaObj.IA_BUILT_YEAR);
        --2/2/2016 - Renovation year is no longer valid
        --FA. 6/5/2016 uncomment due to cr
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', r_c_iaObj.IA_RENOVATION_YEAR);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', r_c_iaObj.IA_WATER_INSIDE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', r_c_iaObj.IA_BUILDING_USAGE);  --1: Residence 2: Store
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', r_c_iaObj.IA_BUILDING_ID);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', r_c_iaObj.IA_GEO_COORDINATES);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', r_c_iaObj.IA_BUILDING_LABEL);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', r_c_iaObj.IA_PURCHASE_DATE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', r_c_iaObj.IA_STANDARD_POINTS);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', r_c_iaObj.IA_BUILDING_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', r_c_iaObj.IA_TAXABLE_VALUE);
        IF v_address_Id IS NULL
        THEN
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
        ELSE
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
        END IF;

        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY') ;

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

        EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN l_in_context, IN MIGR_GVAR.GV_DEBUG, OUT l_out_context, IN OUT pio_err;

        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

          p_policyrec.logMsg := 'Migrating building property: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

        IF v_address_Id IS NULL     THEN
          SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
          MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
        END IF;

        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

        IF l_evres = MIGR_GVAR.GV_EVRES_ERROR    THEN
          l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
          l_policyRec.continue_migr :=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || '-FAILED to insert property';

        ELSE
          l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
          MIGR_LOG.LOG_INFO(l_policyRec);

          l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

          l_policyRec := MIGR_API_COMMON.CALCULATE_RECONSTRUCTION_COST(l_policyRec);

          IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
            l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
          END IF;
        END IF;

        INSERT INTO MIGR_O_VILLAHEM (NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG   )
        VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

      END LOOP;
      p_policyRec := l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
           l_policyRec.continue_migr :=FALSE;
          p_policyRec := l_policyRec;
    END MIGRATE_O_BUILDING;
  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_CONTENT(p_policyRec  IN OUT MIGR_GVAR.PolicyRecTyp,
                              p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
       l_eventTimer TIMESTAMP;
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_Id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavc.IA_UNION_HOME_INSURANCE,
                 iavc.IA_LIVING_AREA,
                 iavc.IA_CERTAIN_LOCKS,
                 iavc.IA_UNION_NAME,
                 iavc.IA_PROPERTY_ID,
                 iavc.IA_POLICY_REF,
                 iavc.IA_NAME,
                 iavc.IA_COUNTRY_CODE,
                 iavc.IA_CITY,
                 iavc.IA_ADDRESS,
                 iavc.IA_POST_CODE,
                 iavp.IA_OBJ_DEDUCT
            FROM IA_VILLAHEM_POLICY iavp
              JOIN IA_VILLAHEM_CONTENT iavc
                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec.migrStep := 'Create Object Villahem Content';
      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_O_CONTENT';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_CONTENT';
          l_eventTimer := SYSTIMESTAMP;
      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

        l_address := r_c_iaObj.IA_ADDRESS;
        l_postCode := r_c_iaObj.IA_POST_CODE;
        l_city := r_c_iaObj.IA_CITY;
        l_country_code := r_c_iaObj.IA_COUNTRY_CODE;
        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
        IF (l_address IS NULL
          OR l_postCode IS NULL
          OR l_city IS NULL
          OR l_country_code IS NULL)
        THEN
          l_address := p_addressTab(1).r_address;
          l_postCode := p_addressTab(1).r_postCode;
          l_city := p_addressTab(1).r_city;
          l_country_code := p_addressTab(1).r_countryCode;
        END IF;
        v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);
        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
        IF v_address_Id IS NOT NULL
        THEN
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
        ELSE

          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
        END IF;
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', r_c_iaObj.IA_LIVING_AREA);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', r_c_iaObj.IA_LIVING_AREA);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', r_c_iaObj.IA_CERTAIN_LOCKS);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', r_c_iaObj.IA_UNION_HOME_INSURANCE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', r_c_iaObj.IA_UNION_NAME);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');
          v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY') ;

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
        EXECUTE IMMEDIATE v_stmst
        USING IN v_event, IN l_in_context, IN MIGR_GVAR.GV_DEBUG, OUT l_out_context, IN OUT pio_err;

        -- MIGR_SYSTEM.CALL_EVENT('INS_PROPERTY', l_in_context, MIGR_API_COMMON.GV_DEBUG, l_out_context, pio_err);

        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);
        IF v_address_Id IS NULL
        THEN
          SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
          MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
        END IF;

        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);
        IF l_evres = MIGR_GVAR.GV_EVRES_ERROR
        THEN
          l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
          l_policyRec.continue_migr :=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || 'FAILED to insert property';
          INSERT INTO MIGR_O_VILLAHEM (
            NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG
          )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

        ELSE
          l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
          MIGR_LOG.LOG_INFO(l_policyRec);

              l_policyRec.logMsg := 'Migrating content property: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(l_policyRec);


          l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

          INSERT INTO MIGR_O_VILLAHEM (
            NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG
          )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

          IF l_evres = MIGR_GVAR.GV_EVRES_WARNING
          THEN
            l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
          END IF;


        END IF;

      END LOOP;
      p_policyRec := l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
           l_policyRec.continue_migr :=FALSE;
          p_policyRec := l_policyRec;
    END MIGRATE_O_CONTENT;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  PROCEDURE MIGRATE_O_SPECIAL_OBJECT(p_policyRec  IN OUT MIGR_GVAR.PolicyRecTyp,
                                     p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
        l_eventTimer TIMESTAMP;
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_Id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavc.IA_PROPERTY_ID,
                 iavc.IA_POLICY_REF,
                 iavc.IA_RISK_TYPE,
                 iavc.IA_DESCRIPTION,
                 iavc.IA_NAME,
                 iavc.IA_COUNTRY_CODE,
                 iavc.IA_CITY,
                 iavc.IA_ADDRESS,
                 iavc.IA_POST_CODE,
                 iavc.IA_EVALUATION_CERTIFICATE,
                 iavp.IA_OBJ_DEDUCT
            FROM IA_VILLAHEM_POLICY iavp
              JOIN IA_VILLAHEM_SPECIAL_OBJ iavc
                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      v_begintimer := SYSTIMESTAMP;
      v_address_Id := NULL;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Create Object Villahem Special Object';
      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_O_SPECIAL_OBJECT';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_SPECIAL_OBJ';

          l_eventTimer := SYSTIMESTAMP;
      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;

        l_address := r_c_iaObj.IA_ADDRESS;
        l_postCode := r_c_iaObj.IA_POST_CODE;
        l_city := r_c_iaObj.IA_CITY;
        l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

        IF (l_address IS NULL
          OR l_postCode IS NULL
          OR l_city IS NULL
          OR l_country_code IS NULL)
        THEN
          l_address := p_addressTab(1).r_address;
          l_postCode := p_addressTab(1).r_postCode;
          l_city := p_addressTab(1).r_city;
          l_country_code := p_addressTab(1).r_countryCode;
        END IF;

        v_address_Id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
        IF v_address_Id IS NOT NULL
        THEN
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_Id);
        ELSE
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);
        END IF;
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', r_c_iaObj.IA_RISK_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', r_c_iaObj.IA_DESCRIPTION);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', r_c_iaObj.IA_EVALUATION_CERTIFICATE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');
        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY') ;

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
        EXECUTE IMMEDIATE v_stmst
        USING IN v_event, IN l_in_context, IN MIGR_GVAR.GV_DEBUG, OUT l_out_context, IN OUT pio_err;

        --   MIGR_SYSTEM.CALL_EVENT('INS_PROPERTY', l_in_context, MIGR_API_COMMON.GV_DEBUG, l_out_context, pio_err);

        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);
        IF v_address_Id IS NULL
        THEN
          SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_Id);
          MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_Id, l_address, l_postCode, l_city, l_country_code);
        END IF;

        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

        IF l_evres = MIGR_GVAR.GV_EVRES_ERROR     THEN
              l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
              MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
              l_policyRec.continue_migr :=FALSE;
              l_policyRec.object_fail_log := l_policyRec.object_fail_log || 'FAILED to insert property';

              INSERT INTO MIGR_O_VILLAHEM (  NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG   )
              VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

        ELSE

              l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
              MIGR_LOG.LOG_INFO(l_policyRec);

                  l_policyRec.logMsg := 'Migrating special object property: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(l_policyRec);

              l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

              INSERT INTO MIGR_O_VILLAHEM (NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG )
              VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

              IF l_evres = MIGR_GVAR.GV_EVRES_WARNING    THEN
                l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
                MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
              END IF;

        END IF;

      END LOOP;
      p_policyRec := l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          p_policyRec := l_policyRec;
    END MIGRATE_O_SPECIAL_OBJECT;

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  PROCEDURE MIGRATE_O_STORED_CONTENT(p_policyRec  IN OUT MIGR_GVAR.PolicyRecTyp,
                                     p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
      l_eventTimer TIMESTAMP;
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavc.IA_THEFT_ATTRACTIVE,
                 iavc.IA_CERTAIN_LOCKS,
                 iavc.IA_PROPERTY_ID,
                 iavc.IA_STORED_ADDRESS,
                 iavc.IA_POLICY_REF,
                 iavc.IA_NAME,
                 iavc.IA_COUNTRY_CODE,
                 iavc.IA_CITY,
                 iavc.IA_ADDRESS,
                 iavc.IA_POST_CODE,
                 iavc.IA_IS_INHABITATED,
                 iavp.IA_OBJ_DEDUCT
            FROM IA_VILLAHEM_POLICY iavp
              JOIN IA_VILLAHEM_STORED_CONTENT iavc
                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

    BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
        l_eventTimer := SYSTIMESTAMP;
      l_policyRec.migrStep := 'Create Object Villahem Stored Content';
      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_O_STORED_CONTENT';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_STORED_CONTENT';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
        l_address := r_c_iaObj.IA_ADDRESS;
        l_postCode := r_c_iaObj.IA_POST_CODE;
        l_city := r_c_iaObj.IA_CITY;
        l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

        IF (l_address IS NULL
          OR l_postCode IS NULL
          OR l_city IS NULL
          OR l_country_code IS NULL)
        THEN
          l_address := p_addressTab(1).r_address;
          l_postCode := p_addressTab(1).r_postCode;
          l_city := p_addressTab(1).r_city;
          l_country_code := p_addressTab(1).r_countryCode;
        END IF;

        v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
        IF v_address_id IS NOT NULL
        THEN
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
        ELSE
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

        END IF;
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', r_c_iaObj.IA_STORED_ADDRESS);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', r_c_iaObj.IA_THEFT_ATTRACTIVE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', r_c_iaObj.IA_CERTAIN_LOCKS);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', r_c_iaObj.IA_IS_INHABITATED);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

        v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY') ;

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

        EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN l_in_context, IN MIGR_GVAR.GV_DEBUG, OUT l_out_context, IN OUT pio_err;

        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

        IF v_address_id IS NULL   THEN
            SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
            MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
        END IF;

        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

        IF l_evres = MIGR_GVAR.GV_EVRES_ERROR   THEN
          l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
           l_policyRec.continue_migr :=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || 'FAILED to insert property';

          INSERT INTO MIGR_O_VILLAHEM (NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG   )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

        ELSE
          l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
          MIGR_LOG.LOG_INFO(l_policyRec);

              l_policyRec.logMsg := 'Migrating stored content property: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(l_policyRec);

          l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

          INSERT INTO MIGR_O_VILLAHEM ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

          IF l_evres = MIGR_GVAR.GV_EVRES_WARNING   THEN
              l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
              MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
          END IF;

        END IF;

      END LOOP;

      p_policyRec := l_policyRec;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          p_policyRec := l_policyRec;
    END MIGRATE_O_STORED_CONTENT;
  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  --FA.20160512 Create new objects villahem

  PROCEDURE MIGRATE_O_MISCELLANEOUS(p_policyRec  IN OUT MIGR_GVAR.PolicyRecTyp,
                                    p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
      l_eventTimer TIMESTAMP;
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavc.IA_PROPERTY_ID,
                 iavc.IA_POLICY_REF,
                 iavc.IA_ADDRESS,
                 iavc.IA_POST_CODE,
                 iavc.IA_CITY,
                 iavc.IA_COUNTRY_CODE,
                 iavc.IA_NAME,
                 iavp.IA_OBJ_DEDUCT
            FROM IA_VILLAHEM_POLICY iavp
              JOIN IA_VILLAHEM_MISCELLANEOUS iavc
                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN

      v_begintimer := SYSTIMESTAMP;
        l_eventTimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Villahem Miscellaneous';
      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_O_MISCELLANEOUS';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_MISCELLANEOUS';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
        l_address := r_c_iaObj.IA_ADDRESS;
        l_postCode := r_c_iaObj.IA_POST_CODE;
        l_city := r_c_iaObj.IA_CITY;
        l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

        IF (l_address IS NULL
          OR l_postCode IS NULL
          OR l_city IS NULL
          OR l_country_code IS NULL)
        THEN
          l_address := p_addressTab(1).r_address;
          l_postCode := p_addressTab(1).r_postCode;
          l_city := p_addressTab(1).r_city;
          l_country_code := p_addressTab(1).r_countryCode;
        END IF;

        v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
        IF v_address_id IS NOT NULL
        THEN
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
        ELSE
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

        END IF;
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

         v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY') ;

         v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';

         EXECUTE IMMEDIATE v_stmst  USING IN v_event, IN l_in_context, IN MIGR_GVAR.GV_DEBUG, OUT l_out_context, IN OUT pio_err;

         SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

         IF v_address_id IS NULL THEN
            SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
            MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
         END IF;

        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

        IF l_evres = MIGR_GVAR.GV_EVRES_ERROR     THEN
          l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
          l_policyRec.continue_migr :=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || 'FAILED to insert property';

          INSERT INTO MIGR_O_VILLAHEM ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

        ELSE
          l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
          MIGR_LOG.LOG_INFO(l_policyRec);

              l_policyRec.logMsg := 'Migrating miscellaneous property: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(l_policyRec);

          l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);
          INSERT INTO MIGR_O_VILLAHEM ( NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG     )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

          IF l_evres = MIGR_GVAR.GV_EVRES_WARNING
          THEN
            l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
          END IF;

        END IF;

      END LOOP;
      p_policyRec := l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          p_policyRec := l_policyRec;
    END MIGRATE_O_MISCELLANEOUS;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_HOBBY(p_policyRec  IN OUT MIGR_GVAR.PolicyRecTyp,
                            p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
      l_eventTimer TIMESTAMP;
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavc.IA_PROPERTY_ID,
                 iavc.IA_POLICY_REF,
                 iavc.IA_ADDRESS,
                 iavc.IA_POST_CODE,
                 iavc.IA_CITY,
                 iavc.IA_COUNTRY_CODE,
                 iavc.IA_NAME,
                 iavp.IA_OBJ_DEDUCT
            FROM IA_VILLAHEM_POLICY iavp
              JOIN IA_VILLAHEM_HOBBY iavc
                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
         l_eventTimer := SYSTIMESTAMP;
      l_policyRec.migrStep := 'Create Object Villahem Hobby';
      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_O_HOBBY';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_HOBBY';
      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
        l_address := r_c_iaObj.IA_ADDRESS;
        l_postCode := r_c_iaObj.IA_POST_CODE;
        l_city := r_c_iaObj.IA_CITY;
        l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

        IF (l_address IS NULL
          OR l_postCode IS NULL
          OR l_city IS NULL
          OR l_country_code IS NULL)
        THEN
          l_address := p_addressTab(1).r_address;
          l_postCode := p_addressTab(1).r_postCode;
          l_city := p_addressTab(1).r_city;
          l_country_code := p_addressTab(1).r_countryCode;
        END IF;

        v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
        IF v_address_id IS NOT NULL
        THEN
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
        ELSE
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

        END IF;
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');

       v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY') ;

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
        EXECUTE IMMEDIATE v_stmst
        USING IN v_event, IN l_in_context, IN MIGR_GVAR.GV_DEBUG, OUT l_out_context, IN OUT pio_err;

        --   MIGR_SYSTEM.CALL_EVENT('INS_PROPERTY', l_in_context, MIGR_API_COMMON.GV_DEBUG, l_out_context, pio_err);

        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

        IF v_address_id IS NULL
        THEN
          SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
          MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
        END IF;
        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);
        IF l_evres = MIGR_GVAR.GV_EVRES_ERROR
        THEN
          l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
          l_policyRec.continue_migr :=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || 'FAILED to insert property';
          INSERT INTO MIGR_O_VILLAHEM (
            NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG
          )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

        ELSE
          l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
          MIGR_LOG.LOG_INFO(l_policyRec);


              l_policyRec.logMsg := 'Migrating hobby property: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(l_policyRec);

          l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

          INSERT INTO MIGR_O_VILLAHEM (
            NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG
          )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

          IF l_evres = MIGR_GVAR.GV_EVRES_WARNING
          THEN
            l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
          END IF;

        END IF;

      END LOOP;
      p_policyRec := l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          p_policyRec := l_policyRec;
    END MIGRATE_O_HOBBY;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_O_EXTENDED_TRAVEL(p_policyRec  IN OUT MIGR_GVAR.PolicyRecTyp,
                                      p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
      l_eventTimer TIMESTAMP;
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavc.IA_PROPERTY_ID,
                 iavc.IA_POLICY_REF,
                 iavc.IA_ADDRESS,
                 iavc.IA_POST_CODE,
                 iavc.IA_CITY,
                 iavc.IA_COUNTRY_CODE,
                 iavc.IA_NAME,
                 iavp.IA_OBJ_DEDUCT
            FROM IA_VILLAHEM_POLICY iavp
              JOIN IA_VILLAHEM_EXTENDED_TRV iavc
                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;
         l_eventTimer := SYSTIMESTAMP;
      l_policyRec.migrStep := 'Create Object Villahem Extended Travel';
      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_O_EXTENDED_TRAVEL';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_EXTENDED_TRV';

      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
        l_address := r_c_iaObj.IA_ADDRESS;
        l_postCode := r_c_iaObj.IA_POST_CODE;
        l_city := r_c_iaObj.IA_CITY;
        l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

        IF (l_address IS NULL
          OR l_postCode IS NULL
          OR l_city IS NULL
          OR l_country_code IS NULL)
        THEN
          l_address := p_addressTab(1).r_address;
          l_postCode := p_addressTab(1).r_postCode;
          l_city := p_addressTab(1).r_city;
          l_country_code := p_addressTab(1).r_countryCode;
        END IF;

        v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
        IF v_address_id IS NOT NULL
        THEN
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
        ELSE
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

        END IF;
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');
          v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY') ;


        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
        EXECUTE IMMEDIATE v_stmst
        USING IN v_event, IN l_in_context, IN MIGR_GVAR.GV_DEBUG, OUT l_out_context, IN OUT pio_err;

        --     MIGR_SYSTEM.CALL_EVENT('INS_PROPERTY', l_in_context, MIGR_API_COMMON.GV_DEBUG, l_out_context, pio_err);

        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

        IF v_address_id IS NULL
        THEN
          SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
          MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
        END IF;


        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

        IF l_evres = MIGR_GVAR.GV_EVRES_ERROR
        THEN

          l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
          l_policyRec.continue_migr :=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || 'FAILED to insert property';
          INSERT INTO MIGR_O_VILLAHEM (
            NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG
          )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

        ELSE
          l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
          MIGR_LOG.LOG_INFO(l_policyRec);

              l_policyRec.logMsg := 'Migrating extended travel property: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(l_policyRec);

          l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

          INSERT INTO MIGR_O_VILLAHEM (
            NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG
          )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

          IF l_evres = MIGR_GVAR.GV_EVRES_WARNING
          THEN
            l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
          END IF;

        END IF;

      END LOOP;
      p_policyRec := l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          p_policyRec := l_policyRec;
    END MIGRATE_O_EXTENDED_TRAVEL;

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  PROCEDURE MIGRATE_O_ALL_RISK(p_policyRec  IN OUT MIGR_GVAR.PolicyRecTyp,
                               p_addressTab IN OUT MIGR_GVAR.PropertyAddressTabTyp)
    IS
      l_eventTimer TIMESTAMP;
      l_in_context   SRVCONTEXT;
      l_out_context  SRVCONTEXT;
      pio_err        SRVERR;
      v_begintimer   TIMESTAMP WITH TIME ZONE;
      v_address_id   NUMBER;
      l_address      VARCHAR2(256);
      l_postCode     VARCHAR2(256);
      l_city         VARCHAR2(256);
      l_country_code VARCHAR2(256);
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      CURSOR c_iaObj (v_OBJECT_ID IA_VILLAHEM_POLICY.IA_OBJECT_ID % TYPE) IS
          SELECT iavp.IA_OBJECT_TYPE,
                 iavp.IA_IDPLPS,
                 iavp.IA_HOME_TYPE,
                 iavp.IA_HOME_SUBTYPE,
                 iavc.IA_PROPERTY_ID,
                 iavc.IA_TOTAL_LIVING_AREA,
                 iavc.IA_POLICY_REF,
                 iavc.IA_ADDRESS,
                 iavc.IA_POST_CODE,
                 iavc.IA_CITY,
                 iavc.IA_COUNTRY_CODE,
                 iavc.IA_NAME,
                 iavp.IA_OBJ_DEDUCT
            FROM IA_VILLAHEM_POLICY iavp
              JOIN IA_VILLAHEM_ALL_RISK_PROP iavc
                ON iavp.IA_OBJECT_ID = iavc.IA_OBJECT_ID
            WHERE 1 = 1
              AND iavp.IA_OBJECT_ID = v_OBJECT_ID;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN

      v_begintimer := SYSTIMESTAMP;
      v_address_id := NULL;
      l_policyRec := p_policyRec;
      l_in_context := NULL;
      l_out_context := NULL;
      pio_err := NULL;

      l_policyRec.migrStep := 'Create Object Villahem All Risk';
      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_O_ALL_RISK';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_ALL_RISK_PROP';
       l_eventTimer  :=SYSTIMESTAMP;
      FOR r_c_iaObj IN c_iaObj(l_policyRec.IA_OBJECT_ID)
      LOOP

        l_policyRec.OBJECT_TYPE := r_c_iaObj.IA_OBJECT_TYPE;
        l_policyRec.policy_idplps := r_c_iaObj.IA_IDPLPS;
        l_address := r_c_iaObj.IA_ADDRESS;
        l_postCode := r_c_iaObj.IA_POST_CODE;
        l_city := r_c_iaObj.IA_CITY;
        l_country_code := r_c_iaObj.IA_COUNTRY_CODE;

        IF (l_address IS NULL
          OR l_postCode IS NULL
          OR l_city IS NULL
          OR l_country_code IS NULL)
        THEN
          l_address := p_addressTab(1).r_address;
          l_postCode := p_addressTab(1).r_postCode;
          l_city := p_addressTab(1).r_city;
          l_country_code := p_addressTab(1).r_countryCode;
        END IF;

        v_address_id := MIGR_API_COMMON.GET_ADDRESS_ID(p_addressTab, l_address, l_postCode, l_city, l_country_code);

        SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'OBJECT_ID', SRV_CONTEXT.Integers_Format, '');
        IF v_address_id IS NOT NULL
        THEN
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, v_address_id);
        ELSE
          SRV_CONTEXT.SETCONTEXTATTRNUMBER(l_in_context, 'ADDRESS_ID', SRV_CONTEXT.Integers_Format, '');
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'COUNTRY_CODE', l_country_code);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'CITY', l_city);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'ADDRESS', l_address);
          SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'POST_CODE', l_postCode);

        END IF;
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_KIND', r_c_iaObj.IA_HOME_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'PROPERTY_TYPE', r_c_iaObj.IA_HOME_SUBTYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'NAME', r_c_iaObj.IA_NAME);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OBJECT_TYPE', r_c_iaObj.IA_OBJECT_TYPE);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP1', l_policyRec.property_id);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP2', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP3', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP4', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP5', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP6', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP7', r_c_iaObj.IA_TOTAL_LIVING_AREA);
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP8', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP9', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP10', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP11', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP12', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP13', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP14', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP15', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP16', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP17', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP18', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP19', '');
        SRV_CONTEXT.SETCONTEXTATTRCHAR(l_in_context, 'OPP20', '');
         v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('INS_PROPERTY') ;

        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
        EXECUTE IMMEDIATE v_stmst
        USING IN v_event, IN l_in_context, IN MIGR_GVAR.GV_DEBUG, OUT l_out_context, IN OUT pio_err;

        --   MIGR_SYSTEM.CALL_EVENT('INS_PROPERTY', l_in_context, MIGR_API_COMMON.GV_DEBUG, l_out_context, pio_err);
        SRV_CONTEXT.GETCONTEXTATTRCHAR(l_out_context, 'OBJECT_ID', l_policyRec.OBJECT_ID);

        IF v_address_id IS NULL
        THEN
          SRV_CONTEXT.GETCONTEXTATTRNUMBER(l_out_context, 'ADDRESS_ID', v_address_id);
          MIGR_API_COMMON.ADD_ADDRESS_ID(p_addressTab, v_address_id, l_address, l_postCode, l_city, l_country_code);
        END IF;
        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, NULL);

        IF l_evres = MIGR_GVAR.GV_EVRES_ERROR
        THEN

          l_policyRec.logMsg := 'PIO_ERR INS_PROPERTY Failed to register OBJECT';
          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
          l_policyRec.continue_migr :=FALSE;
          l_policyRec.object_fail_log := l_policyRec.object_fail_log || 'FAILED to insert property';
          INSERT INTO MIGR_O_VILLAHEM (
            NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG
          )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);
        ELSE
          l_policyRec.logMsg := 'Property was inserted succesfully with object_id: ' || l_policyRec.OBJECT_ID;
          MIGR_LOG.LOG_INFO(l_policyRec);

              l_policyRec.logMsg := 'Migrating all risk property: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
           MIGR_LOG.LOG_EVENT_TIME(l_policyRec);

          l_policyRec := MIGR_API_COMMON.MIGRATE_OBJECT(l_policyRec);

          INSERT INTO MIGR_O_VILLAHEM (
            NAME, POLICY_REF, POLICY_ID, OBJECT_ID, INS_OBJECT_ID, INS_DATE, INS_MS, MIG_START, MIG_END, IA_OBJECT_ID, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG
          )
          VALUES (r_c_iaObj.IA_NAME, r_c_iaObj.IA_POLICY_REF, l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, l_policyRec.insured_object_id, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, v_begintimer), v_begintimer, SYSTIMESTAMP, l_policyRec.IA_OBJECT_ID, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

          IF l_evres = MIGR_GVAR.GV_EVRES_WARNING
          THEN
            l_policyRec.logMsg := 'INS_PROPERTY returned with warning -RESULT:' || NULL;
            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
          END IF;

        END IF;

      END LOOP;
      p_policyRec := l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          p_policyRec := l_policyRec;
    END MIGRATE_O_ALL_RISK;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA.2060707 migrate anything can be migrated and log all failures
  FUNCTION MIGRATE_VILLAHEM(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    AS

      v_address_id        NUMBER;
      CURSOR c_iaObj (vPOLICY_IDPL IA_VILLAHEM_POLICY.IA_IDPL % TYPE) IS
          SELECT ivp.IA_POLICY_REF,
                 ivp.IA_IDPL,
                 ivp.IA_PSTP,
                 ivp.IA_OBJECT_ID,
                 ivp.IA_OBJECT_TYPE,
                 ia.IA_ADDRESS,
                 ia.IA_CITY,
                 ivp.IA_OBJ_DEDUCT,
                 ia.IA_POST_CODE,
                 ia.IA_COUNTRY
              --FA 20161007 no needed check   mov.OBJECT_ID,   mov.INS_OBJECT_ID
            FROM IA_VILLAHEM_POLICY ivp
          --FA 20161007 no needed check    LEFT JOIN MIGR_O_VILLAHEM mov     ON ivp.IA_OBJECT_ID = mov.IA_OBJECT_ID
                JOIN IA_ADDRESS ia
                  ON ia.IA_IDPL = ivp.IA_IDPL
            WHERE 1 = 1
              AND ivp.IA_IDPL = vPOLICY_IDPL
            ORDER BY SUBSTR(ivp.IA_OBJECT_ID, LENGTH(ivp.IA_OBJECT_ID)) ASC;

      r_c_iaObj           c_iaObj % ROWTYPE;
      vPropertyAddressTab MIGR_GVAR.PropertyAddressTabTyp;
      l_policyRec         MIGR_GVAR.PolicyRecTyp;

    BEGIN
      l_policyRec := p_policyRec;

      vPropertyAddressTab.DELETE();

      l_policyRec.migrArea := 'MIGR_API_VILLAHEM.MIGRATE_VILLAHEM';
      l_policyRec.migrStep := 'Create Villahem Policy';
      l_policyRec.migrRelTbl := 'IA_VILLAHEM_POLICY';

      OPEN c_iaObj (l_policyRec.POLICY_IDPL);

    << villahem_loop >>
      LOOP

        FETCH c_iaObj INTO r_c_iaObj;
        EXIT WHEN c_iaObj % NOTFOUND;
        --add default client address
        MIGR_API_COMMON.ADD_ADDRESS_ID(vPropertyAddressTab, NULL, r_c_iaObj.IA_ADDRESS, r_c_iaObj.IA_POST_CODE, r_c_iaObj.IA_CITY, r_c_iaObj.IA_COUNTRY);

      --FA 20161007 no needed check  IF r_c_iaObj.OBJECT_ID IS NULL    AND r_c_iaObj.INS_OBJECT_ID IS NULL   THEN
          l_policyRec.IA_OBJECT_ID := r_c_iaObj.IA_OBJECT_ID;

          --FA.2060912 Added for cover level functionality
          l_policyRec.objDeduct_val := r_c_iaObj.IA_OBJ_DEDUCT;
          l_policyRec.object_fail_log := NULL;
          CASE r_c_iaObj.IA_OBJECT_TYPE
            WHEN '1761' THEN  ---Building
                MIGRATE_O_BUILDING(l_policyRec, vPropertyAddressTab);
            WHEN '114' THEN  ---Content
                MIGRATE_O_CONTENT(l_policyRec, vPropertyAddressTab);
            WHEN '2100' THEN  ---Stored Content
                MIGRATE_O_STORED_CONTENT(l_policyRec, vPropertyAddressTab);
            WHEN '2200' THEN  ---Collection
                MIGRATE_O_COLLECTION(l_policyRec, vPropertyAddressTab);
            WHEN '2300' THEN  ---Special Object
                MIGRATE_O_SPECIAL_OBJECT(l_policyRec, vPropertyAddressTab);
            WHEN '115' THEN  ---Outhouse
                MIGRATE_O_OUTHOUSE(l_policyRec, vPropertyAddressTab);
            WHEN '224' THEN  ---Private Accident Insured Person
                MIGRATE_O_PRIV_ACCIDENT_INS(l_policyRec);
            WHEN '2400' THEN  ---Content
                MIGRATE_O_MISCELLANEOUS(l_policyRec, vPropertyAddressTab);
            WHEN '2500' THEN  ---Content
                MIGRATE_O_HOBBY(l_policyRec, vPropertyAddressTab);
            WHEN '2600' THEN  ---Content
                MIGRATE_O_EXTENDED_TRAVEL(l_policyRec, vPropertyAddressTab);
            WHEN '3000' THEN  ---Content
                MIGRATE_O_ALL_RISK(l_policyRec, vPropertyAddressTab);

            ELSE l_policyRec.logMsg := 'Villahem object with  ' || r_c_iaObj.IA_OBJECT_ID || ' failed due to invalid object type';
                  MIGR_LOG.LOG_ERROR(l_policyRec);
                  l_policyRec.continue_migr :=FALSE;
                  l_policyRec.object_fail_log := l_policyRec.object_fail_log || '-FAILED due  invalid object type';
                  INSERT INTO MIGR_O_VILLAHEM ( POLICY_ID, OBJECT_ID, INS_DATE, MIG_BATCH_ID, POLICY_IDPL, OBJ_ERROR_LOG )
                  VALUES (l_policyRec.POLICY_ID, l_policyRec.OBJECT_ID, SYSDATE, l_policyRec.MIG_BATCH_ID, l_policyRec.POLICY_IDPL, l_policyRec.object_fail_log);

          END CASE;

       END LOOP villahem_loop;

      CLOSE c_iaObj;

      RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr :=FALSE;
          RETURN l_policyRec;
    END MIGRATE_VILLAHEM;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------


END MIGR_API_VILLAHEM;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_ARCHIVE
  AS

  ------------------------------------------------------------------------------------------------------------------------
  -- valex.7/9/16 - Altered to get dynamically the archive mode from ETL_SETUP_INFO.ARCHIVE_MODE. Valid values-modes: Copy --> copy to archive dir, Remove --> copy to archive dir and remove from containing folder
  -- Main procedure which archives the Mutual Source Files. Takes the Mutual ID
  -- and Migration Batch ID as arguments
  FUNCTION ARCHIVE_MUTUAL_DATA(vBatchID IN VARCHAR2)
    RETURN BOOLEAN
    AS
      l_create_st    VARCHAR2(2100);
      l_file_name    NVARCHAR2(200);
      l_bolag_name   NVARCHAR2(50);
      l_dir_obj      NVARCHAR2(100);
      l_dir_arch_obj NVARCHAR2(100);
      l_delimiter    VARCHAR2(10);

      l_tfile_etx    VARCHAR2(10);
      l_source_file  NVARCHAR2(100);
      l_dest_file    NVARCHAR2(100);
      vBolagID       VARCHAR2(10);
      v_mode         VARCHAR2(30);
      l_failed       BOOLEAN;



      CURSOR fetch_file_names IS
          SELECT DISTINCT (etd.TBLNAME)
            FROM ETL_TBL_DEF etd
            WHERE 1 = 1
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
              AND FILE_ROLE NOT IN ( 'Derived' ,'Discounts')        -- exclude B_PRSN (not an actual file)
      -- AND FILE_NAME = 'KF100F'           -- use for testing
      ;

      CURSOR fetch_bolag_names IS
          SELECT BOLAG_NAME
            FROM ETL_BOLAG_INFO
            WHERE 1 = 1
              AND BOLAG_ID = vBolagID;

      CURSOR fetch_migg_filename IS
          SELECT MIGG_FILE_NAME
            FROM ETL_SETUP_INFO;

      vDebug         BOOLEAN := FALSE;
      vMigg_filename VARCHAR2(100);

      -- Flags to: Perform actual copy and Delete when enabled
      vCopy          BOOLEAN := FALSE;
      vDelete        BOOLEAN := FALSE;
      l_LogRec       MIGR_GVAR.LogRecTyp;
      l_ext VARCHAR2(100);

    BEGIN
      l_failed:=FALSE;
      l_LogRec.mig_batch_id := vBatchID;
      l_LogRec.migrArea := 'ARCHIVE';
      l_LogRec.migrStep := 'MIGR_ARCHIVE.ARCHIVE_MUTUAL_DATA';
      l_LogRec.migrRelTbl := NULL;
      l_LogRec.migrRelKey := NULL;

      SELECT BOLAG_ID
        INTO vBolagID
        FROM MIG_MIGRATION_INFO
        WHERE MIGRATION_BATCH_ID = vBatchID;

      -- valex.7/9/16 - get archive mode dynamically from etl_setup_info
      SELECT ARCHIVE_MODE
        INTO v_mode
        FROM ETL_SETUP_INFO;
      -- valex.7/9/16 - end


      -- Fetch bolaG info from ETL_BOLAG_INFO
      OPEN fetch_bolag_names;
      FETCH fetch_bolag_names INTO l_bolag_name;
      CLOSE fetch_bolag_names;

      l_dir_obj := 'READ_DIR_' || l_bolag_name;
      l_dir_arch_obj := 'READ_DIR_' || l_bolag_name || '_ARCHIVE';

      --valex.23/2/17 -   below cursor archives not only KF files, but their log and bad files also (if exist)
      FOR c in (SELECT '' lprefix,'.txt' lsuffix FROM DUAL
                  UNION ALL
                SELECT 'LA_' lprefix,'_LOAD.bad' lsuffix FROM DUAL
                  UNION ALL
                SELECT 'LA_' lprefix,'_LOAD.log' lsuffix FROM DUAL
      )
      loop
        l_ext:=c.lsuffix;
        OPEN fetch_file_names;
        LOOP

        << file_name_loop >>
          FETCH fetch_file_names INTO l_file_name;

          EXIT WHEN fetch_file_names % NOTFOUND;
          l_source_file :=  c.lprefix || l_bolag_name || '_' || l_file_name  || c.lsuffix;
          l_dest_file := vBatchID || '_' || c.lprefix || l_bolag_name || '_' || l_file_name  || c.lsuffix;
          IF vDebug
          THEN
            DBMS_OUTPUT.PUT_LINE('l_source_file: ' || l_source_file || ' -- ' || 'l_dest_file: ' || l_dest_file);
          END IF;



          --valex.7/9/16 - logic for archive mode
          CASE
            WHEN v_mode = 'Copy' THEN vCopy := TRUE;
            WHEN v_mode = 'Remove' THEN vCopy := TRUE;
                vDelete := TRUE;
            ELSE l_LogRec.logMsg := 'Incorrect archive mode parameter in ETL_SETUP_INFO';
              MIGR_LOG.LOG_ERROR(l_LogRec);

          END CASE;
              --valex.7/9/16 - end

          --valex.23/2/17 -  block which provides exception handling when a file does not exist, instead of exiting
          begin
              IF vCopy
              THEN
                l_LogRec.logMsg := 'Archive Copy operation';    -- +++ anb 2019-05-22 debug
                MIGR_LOG.LOG_INFO(l_LogRec);                    -- +++ anb 2019-05-22 debug

                -- Copy the file in the archive location
                UTL_FILE.FCOPY(
                src_location => l_dir_obj,
                src_filename => l_source_file,
                dest_location => l_dir_arch_obj,
                dest_filename => l_dest_file
                );
              END IF;

              IF vDelete
              THEN
                l_LogRec.logMsg := 'Archive Remove operation';    -- +++ anb 2019-05-22 debug
                MIGR_LOG.LOG_INFO(l_LogRec);                    -- +++ anb 2019-05-22 debug

                UTL_FILE.FREMOVE(
                location => l_dir_obj,
                filename => l_source_file
                );
              END IF;

          EXCEPTION WHEN OTHERS THEN
            if l_ext='.txt' then --if KF file then log it, else do nothing
              l_LogRec.logMsg := 'File: '||l_file_name|| ', error:' || SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec);
              l_failed:=TRUE;
            else
              NULL;
          end if;
          END;
       --valex.23/2/17 -  end

        -- TODO: ADD EXCEPTION DELETE_FAILED
        END LOOP file_name_loop;
        CLOSE fetch_file_names;
      END LOOP;


      l_LogRec.logMsg := 'Finished archive process for KF files';
      MIGR_LOG.LOG_INFO(l_LogRec);

   --valex.23/2/17 - if one or more KF files were not archived, return FALSE. Relative flag in MIG_MIGRATION_INFO (i.e. ARCHIVED) will be 'Failed'
      IF l_failed=TRUE then
       RETURN FALSE;
      ELSE
       RETURN TRUE;
      END IF;

   EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := 'Could not archive files:' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

          RETURN FALSE;

    END ARCHIVE_MUTUAL_DATA;
  ------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------
  PROCEDURE UNDO_ARCHIVE_MUTUAL_DATA(vBolagID IN VARCHAR2,
                                     vBatchID IN VARCHAR2)
    AS
      l_create_st    VARCHAR2(2100);
      l_file_name    NVARCHAR2(200);
      l_bolag_name   NVARCHAR2(50);
      l_dir_obj      NVARCHAR2(100);
      l_dir_arch_obj NVARCHAR2(100);
      l_delimiter    VARCHAR2(10);
      l_file_prefix  VARCHAR2(20);
      l_tfile_etx    VARCHAR2(10);
      l_source_file  NVARCHAR2(100);
      l_dest_file    NVARCHAR2(100);

      CURSOR fetch_fextn IS
          SELECT FILE_EXTN
            FROM ETL_SETUP_INFO;

      CURSOR fetch_file_names IS
          SELECT DISTINCT (etd.TBLNAME)
            FROM ETL_TBL_DEF etd
            WHERE 1 = 1
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
      --            AND FILE_NAME = 'KF100F'            -- use for testing
      ;

      CURSOR fetch_bolag_names IS
          SELECT BOLAG_NAME
            FROM ETL_BOLAG_INFO
            WHERE 1 = 1
              AND BOLAG_ID = vBolagID                   -- use for testing
      ;

      CURSOR fetch_migg_filename IS
          SELECT MIGG_FILE_NAME
            FROM ETL_SETUP_INFO;

      vDebug         BOOLEAN := TRUE;
      vMigg_filename VARCHAR2(100);

      -- Flags to: Perform actual copy and Delete when enabled
      vCopy          BOOLEAN := FALSE;
      vDelete        BOOLEAN := FALSE;

    BEGIN

      l_file_prefix := '';

      -- Fetch name of trigger file from ETL_SETUP_INFO (MIGG_FILE_NAME)
      OPEN fetch_migg_filename;
      FETCH fetch_migg_filename INTO vMigg_filename;
      CLOSE fetch_migg_filename;

      --Fetch file extension from ETL_SETUP_INFO (FILE_EXTN)
      OPEN fetch_fextn;
      FETCH fetch_fextn INTO l_tfile_etx;
      CLOSE fetch_fextn;

      -- Fetch bolaG info from ETL_BOLAG_INFO
      OPEN fetch_bolag_names;
      FETCH fetch_bolag_names INTO l_bolag_name;
      CLOSE fetch_bolag_names;

      -- These two must be reversed for the Undo function
      l_dir_arch_obj := 'READ_DIR_' || l_bolag_name;
      l_dir_obj := 'READ_DIR_' || l_bolag_name || '_ARCHIVE';

      IF vDebug
      THEN
        DBMS_OUTPUT.PUT_LINE('l_bolag_name: ' || l_bolag_name || '-- l_tfile_etx: ' || l_tfile_etx);
        DBMS_OUTPUT.PUT_LINE('l_dir_obj: ' || l_dir_obj || '-- l_dir_arch_obj:' || l_dir_arch_obj);
      END IF;

      IF vDebug
      THEN
        DBMS_OUTPUT.PUT_LINE('l_bolag_name: ' || l_bolag_name || ' -- l_tfile_etx: ' || l_tfile_etx);
        DBMS_OUTPUT.PUT_LINE('l_dir_obj: ' || l_dir_obj || ' -- l_dir_arch_obj:' || l_dir_arch_obj);
      END IF;

      ------------ undo completed.txt -----------------------------
      l_dest_file := l_file_prefix || vMigg_filename;
      l_source_file := vBatchID || '_' || l_file_prefix || vMigg_filename; -- || '_' || '.' || l_tfile_etx;

      IF vDebug
      THEN
        DBMS_OUTPUT.PUT_LINE('l_source_file: ' || l_source_file || CHR(10) || 'l_dest_file: ' || l_dest_file);
      END IF;

      IF vCopy
      THEN
        -- Copy completed.txt FROM the archive location BACK to the original location
        UTL_FILE.FCOPY(
        src_location => l_dir_obj,
        src_filename => l_source_file,
        dest_location => l_dir_arch_obj,
        dest_filename => l_dest_file
        );
      END IF;

      IF vDelete
      THEN
        -- Remove completed.txt FROM the ARCHIVE location
        UTL_FILE.FREMOVE(
        location => l_dir_obj,
        filename => l_source_file
        );
      END IF;

      -- Proceed to restore the remaining files
      -- Simply switch l_dest_file with l_source_file
      OPEN fetch_file_names;
      LOOP

      << file_name_loop >>
        FETCH fetch_file_names INTO l_file_name;

        EXIT WHEN fetch_file_names % NOTFOUND;
        l_dest_file := l_file_prefix || l_bolag_name || '_' || l_file_name || '.' || l_tfile_etx;
        l_source_file := vBatchID || '_' || l_file_prefix || l_bolag_name || '_' || l_file_name || '.' || l_tfile_etx;
        IF vDebug
        THEN
          DBMS_OUTPUT.PUT_LINE('l_source_file: ' || l_source_file || ' -- ' || 'l_dest_file: ' || l_dest_file);
        END IF;

        IF vCopy
        THEN
          -- Copy the file in the archive location
          UTL_FILE.FCOPY(
          src_location => l_dir_obj,
          src_filename => l_source_file,
          dest_location => l_dir_arch_obj,
          dest_filename => l_dest_file
          );
        END IF;

        IF vDelete
        THEN
          UTL_FILE.FREMOVE(
          location => l_dir_obj,
          filename => l_source_file
          );
        END IF;
      END LOOP file_name_loop;
      CLOSE fetch_file_names;

    END UNDO_ARCHIVE_MUTUAL_DATA;


  ------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------
  PROCEDURE ARCHIVE_COMPLETED_FILE(vBatchID IN VARCHAR2)
    AS
      l_create_st      VARCHAR2(2100);
      l_file_name      NVARCHAR2(200);
      l_bolag_name     NVARCHAR2(50);
      l_dir_obj        NVARCHAR2(100);
      l_dir_arch_obj   NVARCHAR2(100);
      l_delimiter      VARCHAR2(10);
      l_file_prefix    VARCHAR2(20);
      l_tfile_etx      VARCHAR2(10);
      l_source_file    NVARCHAR2(100);
      l_dest_file      NVARCHAR2(100);
      vBolagID         VARCHAR2(10);
      v_mode           VARCHAR2(30);
      vsql             VARCHAR2(500);
      vDebug           BOOLEAN := TRUE;
      vMigg_filename   VARCHAR2(100);
      vCopy            BOOLEAN := FALSE;
      vDelete          BOOLEAN := FALSE;
      vRemoveCompleted BOOLEAN := FALSE;

      l_LogRec         MIGR_GVAR.LogRecTyp;
      ex_no_file EXCEPTION;

    BEGIN

      l_LogRec.mig_batch_id := vBatchID;
      l_LogRec.migrArea := 'ARCHIVE COMPLETED FILE';
      l_LogRec.migrStep := 'MIGR_ARCHIVE.ARCHIVE_COMPLETED_FILE';
      l_LogRec.migrRelTbl := NULL;
      l_LogRec.migrRelKey := NULL;
      l_file_prefix := '';

      SELECT MIGG_FILE_NAME
        INTO vMigg_filename
        FROM ETL_SETUP_INFO;

      FOR c IN (SELECT b.BOLAG_NAME
          FROM (SELECT BOLAG_ID
              FROM MIG_MIGRATION_INFO
              WHERE MIGRATION_BATCH_ID = vBatchID) a
            JOIN (SELECT BOLAG_NAME,
                         BOLAG_ID
                FROM ETL_BOLAG_INFO) b
              ON a.BOLAG_ID = b.BOLAG_ID)
      LOOP
        l_dir_obj := 'READ_DIR_' || c.BOLAG_NAME;
        l_dir_arch_obj := 'READ_DIR_' || c.BOLAG_NAME || '_ARCHIVE';

        if MIGR_SIGNAL.IS_FILE_EXISTS(l_dir_obj,vMigg_filename)=1 THEN    --exists as completed.txt
          l_source_file := vMigg_filename;
          l_dest_file := vBatchID || '_' || vMigg_filename;
        ELSIF MIGR_SIGNAL.IS_FILE_EXISTS(l_dir_obj,c.BOLAG_NAME || vMigg_filename)=1 THEN  --exists as M**_completed.txt
          l_source_file := c.BOLAG_NAME || vMigg_filename;
          l_dest_file := vBatchID || '_' || c.BOLAG_NAME || vMigg_filename;
        else
          RAISE ex_no_file;
        END if;

        -- Copy completed.txt in the archive location
        UTL_FILE.FCOPY(
        src_location => l_dir_obj,
        src_filename => l_source_file,
        dest_location => l_dir_arch_obj,
        dest_filename => l_dest_file
        );

        -- Remove completed.txt from source location
        UTL_FILE.FREMOVE(
        location => l_dir_obj,
        filename => l_source_file
        );
      END LOOP;

      update MIG_MIGRATION_INFO set COMPLETED_TXT_ARCHIVED=MIGR_GVAR.GV_STATUS_FINISHED where MIGRATION_BATCH_ID= vBatchID ;


      l_LogRec.logMsg := 'Archived completed.txt';
      MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION
      WHEN ex_no_file THEN
          l_LogRec.logMsg := 'Cannot identify a trigger file in accepted forms, in Bolag ' ||SUBSTR(vBatchID,1,2);
          MIGR_LOG.LOG_ERROR(l_LogRec);
          UPDATE MIG_MIGRATION_INFO mmi SET mmi.COMPLETED_TXT_ARCHIVED=MIGR_GVAR.GV_STATUS_FAILED WHERE mmi.MIGRATION_BATCH_ID=vBatchID;
      WHEN OTHERS THEN l_LogRec.logMsg := 'Could not archive files:' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END ARCHIVE_COMPLETED_FILE;

  ------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------
  -- pl 20170406
  --FA.20180222 Addition to archive discounts log and bad file
  PROCEDURE ARCHIVE_MD_DISCOUNTS_FILE(vBatchID IN VARCHAR2)
    AS
      l_dir_obj        NVARCHAR2(100);
      l_dir_arch_obj   NVARCHAR2(100);
      l_source_file    NVARCHAR2(100);
      l_dest_file      NVARCHAR2(100);
      vMigg_filename   VARCHAR2(100);
      v_time           VARCHAR2(50) := TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD@HH24-MI-SS');
      l_LogRec         MIGR_GVAR.LogRecTyp;
      l_failArc BOOLEAN;
    BEGIN
      l_failArc:= FALSE;
      l_LogRec.mig_batch_id := vBatchID;
      l_LogRec.migrArea     := 'MIGR_ARCHIVE.ARCHIVE_MD_DISCOUNTS_FILE';
      l_LogRec.migrStep     := 'MIGR_ARCHIVE.ARCHIVE_MD_DISCOUNTS_FILE';
      l_LogRec.migrRelTbl   := NULL;
      l_LogRec.migrRelKey   := NULL;

     -- SELECT DISCOUNTS_FILE_NAME INTO vMigg_filename FROM ETL_SETUP_INFO;
      SELECT REPLACE(DISCOUNTS_FILE_NAME,'.txt', '') INTO vMigg_filename FROM ETL_SETUP_INFO;

      FOR c IN (SELECT b.BOLAG_NAME
                  FROM (SELECT BOLAG_ID
                          FROM MIG_MIGRATION_INFO
                         WHERE MIGRATION_BATCH_ID = vBatchID) a
                  JOIN (SELECT BOLAG_NAME, BOLAG_ID
                          FROM ETL_BOLAG_INFO) b
                    ON a.BOLAG_ID = b.BOLAG_ID)
      LOOP
        l_dir_obj      := 'READ_DIR_' || c.BOLAG_NAME;
        l_dir_arch_obj := 'READ_DIR_' || c.BOLAG_NAME || '_ARCHIVE';

         l_source_file := c.BOLAG_NAME || '_' || vMigg_filename;
       -- l_dest_file   := vBatchID || '_' || SUBSTR(l_source_file, 1, LENGTH(l_source_file)-4) || '_' || v_time || '.txt';

      FOR c in (SELECT ''|| l_source_file||'.txt'  l_source , l_source_file|| '_' || v_time || '.txt'  l_dest_file FROM DUAL
                  UNION ALL
                SELECT 'LA_'||l_source_file||'_LOAD.bad'  l_source , vBatchID || '_LA_'||l_source_file||'_LOAD.bad'  l_dest_file FROM DUAL
                  UNION ALL
                SELECT 'LA_' ||l_source_file||'_LOAD.log'  l_source, vBatchID || '_LA_'||l_source_file||'_LOAD.log'  l_dest_file FROM DUAL
      )
      loop
         begin
         UTL_FILE.FCOPY(
            src_location  => l_dir_obj,
            src_filename  => c.l_source,
            dest_location => l_dir_arch_obj,
            dest_filename => c.l_dest_file
        );

        -- Remove MD_DISCOUNTS.txt from source location
        UTL_FILE.FREMOVE(
            location => l_dir_obj,
            filename => c.l_source
        );
        EXCEPTION
             WHEN OTHERS THEN
                   l_LogRec.logMsg := 'Could not archive file - '|| c.l_source  ||' due to error: ' || SQLERRM;
                    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                    l_failArc:= TRUE;
        END;
        end LOOP;
      END LOOP;


      --FA.20170904 New added status
      IF  l_failArc THEN
        UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNTS_TXT_ARCHIVED=MIGR_GVAR.GV_STATUS_FAILED WHERE mmi.MIGRATION_BATCH_ID=vBatchID;
      ELSE
        UPDATE MIG_MIGRATION_INFO set DISCOUNTS_TXT_ARCHIVED=MIGR_GVAR.GV_STATUS_FINISHED where MIGRATION_BATCH_ID= vBatchID ;
      END IF;
      l_LogRec.logMsg := 'MD_DISCOUNTS.txt archived.';
      MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION
      WHEN OTHERS THEN
        --FA.20170904 New added status
        UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNTS_TXT_ARCHIVED=MIGR_GVAR.GV_STATUS_FAILED WHERE mmi.MIGRATION_BATCH_ID=vBatchID;
          l_LogRec.logMsg := 'Could not archive files - ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END ARCHIVE_MD_DISCOUNTS_FILE;

  ------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------

  --valex.7/7/2016 - moves batch mutual data to archive folder
  -------FA.20180220 !!!!Keep the Completed file until the end of batch as MIGG may upload new files if the compl file is missing
  --- +++ anb 20180927  Added COMMIT at the end of ARCHIVE_MUTUAL - there was none !!
  PROCEDURE ARCHIVE_MUTUAL    AS
    l_LogRec MIGR_GVAR.LogRecTyp;

    l_eventTimer       TIMESTAMP;

    BEGIN

      l_LogRec.migrArea := 'MIGR_ARCHIVE.ARCHIVE_MUTUAL';
      l_LogRec.migrStep := 'MIGR_ARCHIVE.ARCHIVE_MUTUAL';
      l_LogRec.migrRelTbl := NULL;
      l_LogRec.migrRelKey := NULL;

      l_eventTimer := SYSTIMESTAMP;

      FOR c IN (SELECT MIGRATION_BATCH_ID, LA_COMPLETED,STATUS
                    FROM MIG_MIGRATION_INFO
                    WHERE COMPLETED_TXT_ARCHIVED = MIGR_GVAR.GV_STATUS_PENDING   ---AND LA_COMPLETED <> MIGR_GVAR.GV_STATUS_PENDING
                           AND STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_FINISHED,MIGR_GVAR.GV_BATCH_STATUS_FAILED,MIGR_GVAR.GV_BATCH_STATUS_REJECTED)
          )
      LOOP
               l_LogRec.mig_batch_id := c.MIGRATION_BATCH_ID;
               ARCHIVE_COMPLETED_FILE(c.MIGRATION_BATCH_ID);
               l_LogRec.logMsg := 'Archived completed file for batch: ' || c.MIGRATION_BATCH_ID || ' cause LA step was complete with status: ' || c.LA_COMPLETED || ' and Batch status: '||c.STATUS;
               MIGR_LOG.LOG_INFO(l_LogRec);

      END LOOP;


      ---FA.20170904 Addition to archive descounts file when discounts data loading has finished.
       FOR c IN (SELECT MIGRATION_BATCH_ID, DISCOUNT_COMPLETED
                    FROM MIG_MIGRATION_INFO
                    WHERE DISCOUNTS_TXT_ARCHIVED = MIGR_GVAR.GV_STATUS_PENDING    AND DISCOUNT_COMPLETED <> MIGR_GVAR.GV_STATUS_PENDING

          )
      LOOP
               l_LogRec.mig_batch_id := c.MIGRATION_BATCH_ID;
               ARCHIVE_MD_DISCOUNTS_FILE(c.MIGRATION_BATCH_ID);
               l_LogRec.logMsg := 'Archived discounts file for batch: ' || c.MIGRATION_BATCH_ID || ' cause Discounts Loading step was complete with status: ' || c.DISCOUNT_COMPLETED;
               MIGR_LOG.LOG_INFO(l_LogRec);

      END LOOP;


      ---FA.20170904 Change to archive  all files at the end of phase 1
      FOR c IN (SELECT MIGRATION_BATCH_ID
                     FROM MIG_MIGRATION_INFO
                    WHERE   ---STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_INCOMPLETE,  MIGR_GVAR.GV_BATCH_STATUS_FAILED, MIGR_GVAR.GV_BATCH_STATUS_FINISHED, MIGR_GVAR.GV_BATCH_STATUS_REJECTED )
                      (LA_COMPLETED <>    MIGR_GVAR.GV_STATUS_PENDING    or STATUS=MIGR_GVAR.GV_BATCH_STATUS_REJECTED)
        AND ARCHIVED = MIGR_GVAR.GV_STATUS_PENDING   and BOLAG_ID IS NOT NULL
                   )
      LOOP
             l_LogRec.mig_batch_id := c.MIGRATION_BATCH_ID;
              IF (MIGR_ARCHIVE.ARCHIVE_MUTUAL_DATA(c.MIGRATION_BATCH_ID))   THEN
             --FA.20170124 No need for dynamic sql   vsql := 'update MIG_MIGRATION_INFO set ARCHIVED=''Finished'' where MIGRATION_BATCH_ID=''' || c.MIGRATION_BATCH_ID || ''' and  LA_COMPLETED <> ''Pending'' and ARCHIVED=''Pending''';
                  UPDATE MIG_MIGRATION_INFO
                    SET ARCHIVED=MIGR_GVAR.GV_STATUS_FINISHED WHERE MIGRATION_BATCH_ID= c.MIGRATION_BATCH_ID;
--                    AND  LA_COMPLETED <> 'Pending' AND ARCHIVED='Pending';

                    l_LogRec.logMsg := 'Archived mutual data for batch: ' || c.MIGRATION_BATCH_ID;
                    MIGR_LOG.LOG_INFO(l_LogRec);
        --valex.27/1/2017 -- if ARCHIVE_MUTUAL_DATA returns FALSE then update ARCHIVED field as FAILED
              ELSE
                  UPDATE MIG_MIGRATION_INFO
                    SET ARCHIVED=MIGR_GVAR.GV_STATUS_FAILED WHERE MIGRATION_BATCH_ID= c.MIGRATION_BATCH_ID;
              END IF;

      END LOOP;

  --- +++ anb 20180927  Added COMMIT at the end of ARCHIVE_MUTUAL - there was none !!
      COMMIT;

    l_LogRec.logMsg := 'Total Archive Mutual process runtime: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
    MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION
      WHEN OTHERS THEN
          l_LogRec.logMsg := 'Could not archive files: ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);


    END ARCHIVE_MUTUAL;

  ------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------
  PROCEDURE   MOVE_TO_ARCHIVE_SCHEMA

    AS
      vsql             VARCHAR2(2000);
      --cnt pls_integer :=0;
      l_LogRec         MIGR_GVAR.LogRecTyp;
      v_archive_schema VARCHAR2(30);
      v_fields         VARCHAR2(500);
      v_tbl            VARCHAR2(20);
      v_suf            VARCHAR2(10);
      l_running NUMBER;
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      l_LogRec.migrStep := 'Move Data to Archive Schema';
      l_LogRec.logMsg := 'Process Starts';
      l_LogRec.migrArea := 'MIGR_ARCHIVE.MOVE_TO_ARCHIVE_SCHEMA';
      MIGR_LOG.LOG_INFO(l_LogRec);

      SELECT ARCHIVE_SCHEMA
        INTO v_archive_schema
        FROM ETL_SETUP_INFO;

        --FA2070919   Check if there is running archive process. If there is skip action
      SELECT COUNT(1) into l_running FROM MIG_MIGRATION_INFO mmi WHERE mmi.DATA_MOVED_TO_ARCHIVE = 'Running';

        IF l_running =0 THEN
             UPDATE MIG_MIGRATION_INFO mmi SET mmi.DATA_MOVED_TO_ARCHIVE='Running' WHERE  mmi.DATA_MOVED_TO_ARCHIVE <> MIGR_GVAR.GV_STATUS_FINISHED;


             -- pl 20170208: Archiving as table fact and prem views
              l_LogRec.logMsg := 'Archiving FACT and PREMIUMS Views';

              SELECT REPLACE(TO_CHAR(RENEWAL_DATE), '-') INTO v_suf FROM (SELECT * FROM ETL_MIGRATION_CONDITIONS emc WHERE emc.ITERATION_STATUS = 'Pending' ORDER BY emc.ID) A WHERE ROWNUM = 1;

              v_tbl := 'MIGR_FACT';
              vsql  := 'CREATE TABLE ' || v_archive_schema || '.' || v_tbl || '_' || v_suf || ' AS ' --SELECT * FROM MIGR_FACT mf';
                    || 'SELECT "BOLAG", "BATCH_ID", CAST("POLICY_ID" AS NUMBER) AS "POLICY_ID", "POLICY_REF", "INSRPRD", "OFFRNCODE", "POLICY_IDPL", CAST("OBJECTS" AS NUMBER) AS "OBJECTS", CAST("ALL_OBJECTS_INS_MS" AS NUMBER) AS "ALL_OBJECTS_INS_MS", CAST("MIN_OBJECTS_INS_MS" AS NUMBER) AS "MIN_OBJECTS_INS_MS", CAST("MAX_OBJECTS_INS_MS" AS NUMBER) AS "MAX_OBJECTS_INS_MS", CAST("MEAN_OBJECTS_INS_MS" AS NUMBER) AS "MEAN_OBJECTS_INS_MS","FINAL_STEP", CAST("POLICY_MS_PHASE_1" AS NUMBER) AS "POLICY_MS_PHASE_1", CAST("POLICY_MS_PHASE_2" AS NUMBER) AS "POLICY_MS_PHASE_2", CAST("RELATED_KEY" AS NUMBER) AS "RELATED_KEY", CAST("CHECK_RECORD_POLICY" AS NUMBER) AS "CHECK_RECORD_POLICY",CAST("INSERT_POLICY_ADDRESS" AS NUMBER) AS "INSERT_POLICY_ADDRESS",CAST("CREATE_DUMMY" AS NUMBER) AS "CREATE_DUMMY",CAST("REGISTER_PROPERTY" AS NUMBER) AS "REGISTER_PROPERTY",CAST("POLICY_UPDATE" AS NUMBER) AS "POLICY_UPDATE",CAST("FILLED_POLICY_CONDITIONS" AS NUMBER) AS "FILLED_POLICY_CONDITIONS",CAST("APPLIED_RULE_POLICY_DISC" AS NUMBER) AS "APPLIED_RULE_POLICY_DISC",CAST("POLICY_DATA_MIGRATION" AS NUMBER) AS "POLICY_DATA_MIGRATION",CAST("PREMIUM_CALCULATED" AS NUMBER) AS "PREMIUM_CALCULATED",CAST("CHECK_POLICY_CONSISTENCY" AS NUMBER) AS "CHECK_POLICY_CONSISTENCY",CAST("START_AUTO_UW" AS NUMBER) AS "START_AUTO_UW",CAST("CONFIRMED" AS NUMBER) AS "CONFIRMED", CAST("MIG_START_PHASE_1" AS VARCHAR2(50)) AS "MIG_START_PHASE_1", CAST("MIG_END_PHASE_1" AS VARCHAR2(50)) AS "MIG_END_PHASE_1", CAST("MIG_START_PHASE_2" AS VARCHAR2(50)) AS "MIG_START_PHASE_2", CAST("MIG_END_PHASE_2" AS VARCHAR2(50)) AS "MIG_END_PHASE_2", "MIGR_POLICY_TIME", "INSIS_PREMIUM_A", "INSIS_PREMIUM_B"'
                    || 'FROM V_MIGR_FACT mf';
              EXECUTE IMMEDIATE vsql;
             COMMIT;

              v_tbl := 'MIGR_PREMIUMS';
              vsql  := 'CREATE TABLE ' || v_archive_schema || '.' || v_tbl || '_' || v_suf || ' AS ' --SELECT * FROM MIGR_PREMIUMS mp';
                    || 'SELECT "BOLAG", MIG_BATCH_ID, "INSURED PRODUCT", "OFFERING CODE", FNR, FVNR, CAST("INSIS POLICY_ID" AS NUMBER) AS "INSIS POLICY_ID", CAST("MIGG POLICY IDPL" AS NUMBER) as "MIGG POLICY IDPL", "MIGG POLICY REF", "POLICY STATUS", CAST("MIGG_NET_PREM" AS NUMBER) as "MIGG_NET_PREM", CAST("INSIS_PREM" AS NUMBER) AS "INSIS_PREM", CAST("INSIS_PREM_FINAL" AS NUMBER) AS "INSIS_PREM_FINAL", CAST("VARIANCE_PCT" AS VARCHAR2(20)) AS "VARIANCE_PCT", CAST("OUTSIDE (-5%..+5%) LIMITS" AS VARCHAR2(30)) "OUTSIDE (-5%..+5%) LIMITS", CAST("DISCOUNT" AS NUMBER) as "DISCOUNT" '
                    || 'FROM V_MIGR_PREMIUMS mp';
              EXECUTE IMMEDIATE vsql;
              COMMIT;

              v_fields := MIGR_SETUP.fetch_attr('B_ADDRESS', TRUE, TRUE, FALSE, TRUE);

              FOR c IN (SELECT DISTINCT TO_CHAR(dest_table) AS dest_table,
                                        TO_CHAR(FIELD_LIST || ADDFLDS) AS FIELD_LIST
                  FROM ETL_ENGINE
                  UNION ALL
                SELECT TO_CHAR(dest_table) AS dest_table,
                       TO_CHAR(FIELD_LIST)--,'IA' tbl
                  FROM ETL_SA_IA esi
                  WHERE esi.IS_ACTIVE = 'TRUE'
                  UNION ALL
                SELECT 'SA_B_ADDRESS' AS dest_table,
                       v_fields AS FIELD_LIST--,'SA_B_ADDRESS' tbl,'SA_B_ADDRESS' AS tbl
                  FROM DUAL
                  UNION ALL
                SELECT 'MIGR_API_DETAIL_LOG' AS dest_table,
                       'LOG_ID,MIGRATION_BATCH_ID,EVENT_TIMESTAMP,MIGRATION_AREA,EVENT_TYPE,EVENT_MESSAGE,MIGRATION_STEP,RELATED_TABLE,RELATED_KEY' AS FIELD_LIST--,'LOG' AS tbl
                  FROM DUAL
                  UNION ALL
                SELECT 'MIG_DETAIL_ERROR_LOG' AS dest_table,
                       'MIGRATION_BATCH_ID,ERROR_TIMESTAMP,MIGRATION_AREA,ERROR_TYPE,ERROR_MESSAGE,MIGRATION_STEP,RELATED_TABLE,RELATED_KEY' AS FIELD_LIST--,'LOG' AS tbl
                  FROM DUAL
                  UNION ALL
                SELECT 'MIG_VOLUMETRIC_ANALYSIS' AS dest_table,
                       'MIGRATION_BATCH_ID,LOG_TIMESTAMP,MIGRATION_AREA,TABLE_NAME,STATUS,VOLUME' AS FIELD_LIST--,'LOG' AS tbl
                  FROM DUAL
                  UNION ALL
                SELECT 'MIGR_EMAIL_NOTIFICATIONS_LOG' AS dest_table,
                       'MSG_ID,MIGRATION_BATCH_ID,MSG_REGISTRATION_TIMESTAMP,MSG_RCPT,MSG_CODE,MSG_TYPE,MSG_DESCRIPTION,MSG_BODY,MSG_ATT_NAME,MSG_ATT_DIR,MSG_STATUS,MSG_SENDING_TIMESTAMP' AS FIELD_LIST
                  FROM DUAL)
              LOOP
                vsql := 'insert /* +append */ into ' || v_archive_schema || '.' || c.dest_table || '(' || c.FIELD_LIST || ') select ' || c.FIELD_LIST || ' from ' || c.dest_table;
                EXECUTE IMMEDIATE vsql;
                  COMMIT;
              END LOOP;



              l_LogRec.logMsg := '';
              -- pl 20170208 end

              vsql := 'MERGE INTO ' || v_archive_schema || '.SA_B_PRSN t '
              || '   USING SA_B_PRSN S '
              || '    ON (t.G_EGN = s.G_EGN)'
              || '   WHEN NOT MATCHED THEN '
              || '    insert (t.G_EGN, t.PENR, t.PENRS, t.IA_COMPANY, t.CENTURY_OK, t.YEAR_OK, t.MONTH_OK, t.DAY_OK, t.IA_BIRTH_DATE, t.IA_AGE, t.IA_SEX, t.kf100f,t.kf170f, t.kf221f,t.kf152f, t.MIG_FLAG,t.MIG_BATCH_ID, t.MIG_TIMESTAMP )'
              || '    values (s.G_EGN, s.PENR, s.PENRS,s.IA_COMPANY, s.CENTURY_OK, s.YEAR_OK, s.MONTH_OK, s.DAY_OK, s.IA_BIRTH_DATE, s.IA_AGE, s.IA_SEX, s.kf100f,s.kf170f, s.kf221f,s.kf152f, s.MIG_FLAG,s.MIG_BATCH_ID, s.MIG_TIMESTAMP )';
              EXECUTE IMMEDIATE vsql;

              FOR c IN (SELECT DISTINCT TO_CHAR(dest_table) AS dest_table
                  FROM ETL_ENGINE
                  UNION ALL
                SELECT TO_CHAR(dest_table) AS dest_table
                  FROM ETL_SA_IA esi
                  WHERE esi.IS_ACTIVE = 'TRUE'
                  UNION ALL
                SELECT 'SA_B_ADDRESS' AS dest_table
                  FROM DUAL
                  UNION ALL
                SELECT 'SA_B_PRSN' AS dest_table
                  FROM DUAL
                  UNION ALL
                SELECT 'MIGR_API_DETAIL_LOG' AS dest_table
                  FROM DUAL
                  UNION ALL
                SELECT 'MIG_DETAIL_ERROR_LOG' AS dest_table
                  FROM DUAL
                  UNION ALL
                SELECT 'MIG_VOLUMETRIC_ANALYSIS' AS dest_table
                  FROM DUAL
                  UNION ALL
                SELECT 'MIGR_EMAIL_NOTIFICATIONS_LOG' AS dest_table
                  FROM DUAL)
              LOOP
                vsql := 'truncate table ' || c.dest_table;
                EXECUTE IMMEDIATE vsql;
                  COMMIT;
              END LOOP;

              ---vsql := 'UPDATE MIG_MIGRATION_INFO mmi SET mmi.DATA_MOVED_TO_ARCHIVE=MIGR_GVAR.GV_STATUS_FINISHED WHERE  mmi.DATA_MOVED_TO_ARCHIVE <> MIGR_GVAR.GV_STATUS_FINISHED';
               UPDATE MIG_MIGRATION_INFO mmi SET mmi.DATA_MOVED_TO_ARCHIVE=MIGR_GVAR.GV_STATUS_FINISHED WHERE  mmi.DATA_MOVED_TO_ARCHIVE <> MIGR_GVAR.GV_STATUS_FINISHED;
             --- EXECUTE IMMEDIATE vsql;
              l_LogRec.logMsg := 'Process Ended';
              MIGR_LOG.LOG_INFO(l_LogRec);

     ELSE
            l_LogRec.logMsg := 'Archive Process has been triggered by previous condition and is already running-This request is skipped';
            MIGR_LOG.LOG_INFO(l_LogRec);
     END IF;

              COMMIT;
    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || ' vsql:' || vsql;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
           ROLLBACK;
           UPDATE MIG_MIGRATION_INFO mmi SET mmi.DATA_MOVED_TO_ARCHIVE=MIGR_GVAR.GV_STATUS_FAILED WHERE  mmi.DATA_MOVED_TO_ARCHIVE <> MIGR_GVAR.GV_STATUS_FINISHED;

              COMMIT;
    END MOVE_TO_ARCHIVE_SCHEMA;
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE GRANT_ARCHIVE_SCHEMA(ARCHIVE_SCHEMA IN VARCHAR2)
    AS
      EvLog MIGR_GVAR.LogRecTyp;
      vSQL  VARCHAR2(2100);
      vUSER VARCHAR2(255);

    BEGIN

      EvLog.mig_batch_id := '0-1';
      EvLog.migrArea := 'MIGR_ARCHIVE.GRANT_ARCHIVE_SCHEMA';
      EvLog.migrStep := NULL;
      EvLog.migrRelTbl := NULL;
      EvLog.migrRelKey := NULL;

      SELECT SYS_CONTEXT('userenv', 'current_schema')
        INTO vUSER
        FROM DUAL;

      vSQL := 'BEGIN ' || ARCHIVE_SCHEMA || '.GRANT_ALL_TBL(''' || vUSER || '''); END;';
      EXECUTE IMMEDIATE vSQL;

      EvLog.logMsg := 'Grant statement: ' || vSQL;
      MIGR_LOG.LOG_INFO(EvLog);

    EXCEPTION
      WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
          EvLog.migrArea := 'MIGR_ARCHIVE.GRANT_ARCHIVE_SCHEMA';
          EvLog.migrStep := NULL;
          EvLog.logMsg := SQLERRM || ' - ' || vSQL;
          EvLog.migrRelTbl := NULL;
          EvLog.migrRelKey := NULL;
          MIGR_LOG.LOG_EXCEPTION(EvLog);
    END GRANT_ARCHIVE_SCHEMA;

  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  PROCEDURE TBL_OPERATION_IA_ARCHIVE(ARCHIVE_SCHEMA IN VARCHAR2)
    AS
      EvLog   MIGR_GVAR.LogRecTyp;
      vFldLst VARCHAR2(2100);
      vSQL    VARCHAR2(2100);
      vSQL1   VARCHAR2(2100);
      vSQL2   VARCHAR2(2100);

    BEGIN

      -- pl 20161013: Create ia archive tables
      FOR tRec IN (SELECT STEP,
                          SOURCE_VIEW,
                          DEST_TABLE,
                          FIELD_LIST,
                          UNIQ_KEY,
                          ALLOW_DUPL
          FROM ETL_SA_IA
          WHERE 1 = 1
            AND MIGRATION_AREA = 'SA_IA'
            AND IS_ACTIVE = 'TRUE'
          ORDER BY ETL_ID ASC)
      LOOP

      << ETL_ARCHIVE_TBL_LOOP >>
        --
        --vSQL := ' DROP TABLE ' || ARCHIVE_SCHEMA || '.' || tRec.DEST_TABLE;
        vSQL := 'BEGIN ' || ARCHIVE_SCHEMA || '.DROP_TBL( ''' || ARCHIVE_SCHEMA || '.' || tRec.DEST_TABLE || ''' );  END;';

        BEGIN
          EXECUTE IMMEDIATE vSQL;
        EXCEPTION
          WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
              EvLog.migrArea := 'MIGR_ARCHIVE.TBL_OPERATION_IA_ARCHIVE';
              EvLog.migrStep := NULL;
              EvLog.logMsg := SQLERRM || ' - Drop Statement: ' || vSQL;
              EvLog.migrRelTbl := NULL;
              EvLog.migrRelKey := NULL;
              MIGR_LOG.LOG_EXCEPTION(EvLog);
        END;

        --FA.20160824 Add NOLOGGING mode to minimize redo information size.
        vSQL := ' CREATE TABLE ' || ARCHIVE_SCHEMA || '.' || tRec.DEST_TABLE || '  NOLOGGING  AS ('
        || 'SELECT' || tRec.FIELD_LIST
        || ' FROM ' || tRec.SOURCE_VIEW
        || ' WHERE 1=2 )';

        BEGIN
          EXECUTE IMMEDIATE vSQL;
        EXCEPTION
          WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
              EvLog.migrArea := 'MIGR_ARCHIVE.TBL_OPERATION_IA_ARCHIVE';
              EvLog.migrStep := NULL;
              EvLog.logMsg := SQLERRM || ' - Create Statement: ' || vSQL;
              EvLog.migrRelTbl := NULL;
              EvLog.migrRelKey := NULL;
              MIGR_LOG.LOG_EXCEPTION(EvLog);
        END;

      END LOOP ETL_ARCHIVE_TBL_LOOP;

--LM - 10-04-2018 - Modify IA_DESCRIPTION in all tables with Specified Items - START
      FOR ctab IN (SELECT epo.IA_OBJ_TABLE
               FROM ETL_PRODUCT_OBJECTS epo
              WHERE epo.HAS_SPECIFIED = 'Y'
                AND epo.IS_ACTIVE = 'Y'
             )
      LOOP

        VSQL2 := 'ALTER table ' || ARCHIVE_SCHEMA || '.' || ctab.IA_OBJ_TABLE || ' MODIFY ( IA_DESCRIPTION VARCHAR2(2000))' ;
        EXECUTE IMMEDIATE VSQL2;

      END LOOP;
--LM - 10-04-2018 - END

    EXCEPTION
      WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
          EvLog.migrArea := 'MIGR_ARCHIVE.TBL_OPERATION_IA_ARCHIVE';
          EvLog.migrStep := NULL;
          EvLog.logMsg := SQLERRM;
          EvLog.migrRelTbl := NULL;
          EvLog.migrRelKey := NULL;
          MIGR_LOG.LOG_EXCEPTION(EvLog);
    END TBL_OPERATION_IA_ARCHIVE;
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- pl 20161013
  --PROCEDURE THAT CREATES, DROP AND TRUNCATES SA ARCHIVE TABLES
  PROCEDURE TBL_OPERATION_SA_ARCHIVE(OPERATION      IN VARCHAR2,
                                     ARCHIVE_SCHEMA IN VARCHAR2)
    AS
      l_create_st     VARCHAR(2100);
      l_file_name     NVARCHAR2(50);
      l_addtnl_fields VARCHAR2(10);
      l_file_role     VARCHAR2(50);
      EvLog           MIGR_GVAR.LogRecTyp;

      CURSOR fetch_file_names IS
          SELECT DISTINCT (etd.TBLNAME),
                          NVL(etd.ADDTNL, 'N') AS ADDTNL,
                          etd.FILE_ROLE -- valex.2/6/2016 different create for B_PRSN (Derived)
            FROM ETL_TBL_DEF etd
            WHERE NVL(etd.SA, 'N') = 'Y'
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y' --- +++ anb 2016-02-03 skip reconciliation file
      ;
    BEGIN

      OPEN fetch_file_names;
      LOOP
        FETCH fetch_file_names INTO l_file_name, l_addtnl_fields, l_file_role;
        EXIT WHEN fetch_file_names % NOTFOUND;
        --valex.2/6/16 different create stmnt for derived tables
        CASE
          WHEN OPERATION = 'CREATE' AND
            l_file_role <> 'Derived' THEN l_create_st := 'CREATE TABLE ' || ARCHIVE_SCHEMA || '.SA_' || l_file_name || '( ' || MIGR_SETUP.FETCH_ATTR(l_file_name, FALSE, TRUE, TRUE, TRUE) || ' ) NOLOGGING';

          WHEN OPERATION = 'CREATE' AND
            l_file_role = 'Derived' THEN l_create_st := 'CREATE TABLE ' || ARCHIVE_SCHEMA || '.SA_' || l_file_name || '( ' || MIGR_SETUP.FETCH_ATTR(l_file_name, FALSE, FALSE, TRUE, FALSE) || ' ) NOLOGGING';

          WHEN OPERATION = 'DROP' THEN
              --
              -- l_create_st := 'DROP TABLE ' || ARCHIVE_SCHEMA || '.SA_' || l_file_name || ' CASCADE CONSTRAINTS PURGE';
              l_create_st := 'BEGIN ' || ARCHIVE_SCHEMA || '.DROP_TBL( ''' || ARCHIVE_SCHEMA || '.SA_' || l_file_name || ''' );  END;';

          WHEN OPERATION = 'TRUNCATE' THEN l_create_st := 'TRUNCATE TABLE ' || ARCHIVE_SCHEMA || '.SA_' || l_file_name;

          ELSE l_create_st := 'SELECT ' || CHR(39) || 'ERROR-Wrong Operation' || CHR(39) || ' FROM DUAL';

        END CASE;

        IF OPERATION = 'CREATE'  THEN
          BEGIN
            EXECUTE IMMEDIATE l_create_st;

          EXCEPTION
            WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
                EvLog.migrArea := 'MIGR_ARCHIVE.TBL_OPERATION_SA_ARCHIVE';
                EvLog.migrStep := NULL;
                EvLog.logMsg := SQLERRM || ' - Create Statement: ' || l_create_st;
                EvLog.migrRelTbl := NULL;
                EvLog.migrRelKey := NULL;
                MIGR_LOG.LOG_EXCEPTION(EvLog);
          END;

        ELSIF OPERATION = 'DROP'
        THEN
          BEGIN
            EXECUTE IMMEDIATE l_create_st;
          EXCEPTION
            WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
                EvLog.migrArea := 'MIGR_ARCHIVE.TBL_OPERATION_SA_ARCHIVE';
                EvLog.migrStep := NULL;
                EvLog.logMsg := SQLERRM || ' - Drop Statement: ' || l_create_st;
                EvLog.migrRelTbl := NULL;
                EvLog.migrRelKey := NULL;
                MIGR_LOG.LOG_EXCEPTION(EvLog);
          END;

        END IF;

      END LOOP;
      CLOSE fetch_file_names;

    EXCEPTION
      WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
          EvLog.migrArea := 'MIGR_ARCHIVE.TBL_OPERATION_SA_ARCHIVE';
          EvLog.migrStep := NULL;
          EvLog.logMsg := SQLERRM;
          EvLog.migrRelTbl := NULL;
          EvLog.migrRelKey := NULL;
          MIGR_LOG.LOG_EXCEPTION(EvLog);

    END TBL_OPERATION_SA_ARCHIVE;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --PROCEDURE THAT CREATES,DROP AND TRUNCATES LA ARCHIVE TABLES
  PROCEDURE TBL_OPERATION_LA_ARCHIVE(OPERATION      IN VARCHAR2,
                                     ARCHIVE_SCHEMA IN VARCHAR2)
    AS
      l_create_st   VARCHAR(2100);
      l_file_name   NVARCHAR2(50);
      l_bolag_name  NVARCHAR2(50);
      l_addtnl_flds VARCHAR2(10);
      EvLog         MIGR_GVAR.LogRecTyp;

      CURSOR fetch_file_names IS
          SELECT DISTINCT (etd.TBLNAME),
                          NVL(etd.ADDTNL, 'N') AS ADDTNL
            FROM ETL_TBL_DEF etd
            WHERE NVL(etd.LA, 'N') = 'Y'
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y'              --- +++ anb 2016-02-03 skip reconciliation file
      ;
      CURSOR fetch_bolag_names IS
          SELECT BOLAG_NAME
            FROM ETL_BOLAG_INFO;

    BEGIN

      OPEN fetch_bolag_names;
      LOOP
        FETCH fetch_bolag_names INTO l_bolag_name;
        EXIT WHEN fetch_bolag_names % NOTFOUND;

        OPEN fetch_file_names;
        LOOP
          FETCH fetch_file_names INTO l_file_name, l_addtnl_flds;
          EXIT WHEN fetch_file_names % NOTFOUND;
          CASE OPERATION
            WHEN 'CREATE' THEN l_create_st := 'CREATE TABLE ' || ARCHIVE_SCHEMA || '.LA_' || l_bolag_name || '_' || l_file_name || '( '
                || MIGR_SETUP.FETCH_ATTR(l_file_name, FALSE, FALSE, TRUE, (CASE
                  WHEN l_addtnl_flds = 'Y' THEN TRUE
                  ELSE FALSE END))
                || ' ) NOLOGGING';

            WHEN 'DROP' THEN
                --
                -- l_create_st := 'DROP TABLE ' || ARCHIVE_SCHEMA || '.LA_' || l_bolag_name || '_' || l_file_name || ' CASCADE CONSTRAINTS PURGE'; -- +++ anb 2016-04-18
                l_create_st := 'BEGIN ' || ARCHIVE_SCHEMA || '.DROP_TBL( ''' || ARCHIVE_SCHEMA || '.LA_' || l_bolag_name || '_' || l_file_name || ''' );  END;';

            WHEN 'TRUNCATE' THEN l_create_st := 'TRUNCATE TABLE ' || ARCHIVE_SCHEMA || '.LA_' || l_bolag_name || '_' || l_file_name;
            ELSE l_create_st := 'SELECT ' || CHR(39) || 'ERROR-Wrong Operation' || CHR(39) || ' FROM DUAL';
          END CASE;

          IF OPERATION = 'CREATE'
          THEN
            BEGIN
              EXECUTE IMMEDIATE l_create_st;

            EXCEPTION
              WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
                  EvLog.migrArea := 'MIGR_ARCHIVE.TBL_OPERATION_LA_ARCHIVE';
                  EvLog.migrStep := NULL;
                  EvLog.logMsg := SQLERRM || ' - Create Statement: ' || l_create_st;
                  EvLog.migrRelTbl := NULL;
                  EvLog.migrRelKey := NULL;
                  MIGR_LOG.LOG_EXCEPTION(EvLog);
            END;

          ELSIF OPERATION = 'DROP'
          THEN
            BEGIN
              EXECUTE IMMEDIATE l_create_st;
            EXCEPTION
              WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
                  EvLog.migrArea := 'MIGR_ARCHIVE.TBL_OPERATION_LA_ARCHIVE';
                  EvLog.migrStep := NULL;
                  EvLog.logMsg := SQLERRM || ' - Drop Statement: ' || l_create_st;
                  EvLog.migrRelTbl := NULL;
                  EvLog.migrRelKey := NULL;
                  MIGR_LOG.LOG_EXCEPTION(EvLog);
            END;

          END IF;

        END LOOP;
        CLOSE fetch_file_names;
      END LOOP;
      CLOSE fetch_bolag_names;

    EXCEPTION
      WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
          EvLog.migrArea := 'MIGR_ARCHIVE.TBL_OPERATION_LA_ARCHIVE';
          EvLog.migrStep := NULL;
          EvLog.logMsg := SQLERRM;
          EvLog.migrRelTbl := NULL;
          EvLog.migrRelKey := NULL;
          MIGR_LOG.LOG_EXCEPTION(EvLog);

    END TBL_OPERATION_LA_ARCHIVE;
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE THAT DROPS ALL TABLE OBJECTS
  PROCEDURE DROP_ARCHIVE_TABLES_OBJS(ARCHIVE_SCHEMA IN VARCHAR2)
    AS
      EvLog MIGR_GVAR.LogRecTyp;

    BEGIN

      TBL_OPERATION_LA_ARCHIVE('DROP', ARCHIVE_SCHEMA); -- pl 20161013 drop archive tables
      TBL_OPERATION_SA_ARCHIVE('DROP', ARCHIVE_SCHEMA); -- pl 20161013 drop archive tables

    EXCEPTION
      WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
          EvLog.migrArea := 'MIGR_ARCHIVE.DROP_ARCHIVE_TABLES_OBJS';
          EvLog.migrStep := NULL;
          EvLog.logMsg := SQLERRM;
          EvLog.migrRelTbl := NULL;
          EvLog.migrRelKey := NULL;
          MIGR_LOG.LOG_EXCEPTION(EvLog);
    END DROP_ARCHIVE_TABLES_OBJS;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE THAT CREATES LA,SA and DF TABLES
  PROCEDURE CREATE_ARCHIVE_TABLES(ARCHIVE_SCHEMA IN VARCHAR2)
    AS
      EvLog MIGR_GVAR.LogRecTyp;

    BEGIN

      TBL_OPERATION_LA_ARCHIVE('CREATE', ARCHIVE_SCHEMA); -- pl 20161013 create archive tables
      TBL_OPERATION_SA_ARCHIVE('CREATE', ARCHIVE_SCHEMA); -- pl 20161013 create archive tables

    EXCEPTION
      WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
          EvLog.migrArea := 'MIGR_ARCHIVE.CREATE_ARCHIVE_TABLES';
          EvLog.migrStep := NULL;
          EvLog.logMsg := SQLERRM;
          EvLog.migrRelTbl := NULL;
          EvLog.migrRelKey := NULL;
          MIGR_LOG.LOG_EXCEPTION(EvLog);
    END CREATE_ARCHIVE_TABLES;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE BUILD_MIG_ARCHIVE_TBL(ARCHIVE_SCHEMA IN VARCHAR2)
    AS

      EvLog   MIGR_GVAR.LogRecTyp;
      vFldLst VARCHAR2(2100);
      vSQL    VARCHAR2(2100);

    BEGIN

      -- pl 20161013 create MIG% archive tables
      FOR tRec IN (SELECT TABLE_NAME
          FROM USER_TABLES
          WHERE TABLE_NAME LIKE 'MIG%')
      LOOP

      << ETL_ARCHIVE_TBL_LOOP >>
        --
        -- vSQL := ' DROP TABLE ' || ARCHIVE_SCHEMA || '.' || tRec.TABLE_NAME;
        vSQL := 'BEGIN ' || ARCHIVE_SCHEMA || '.DROP_TBL( ''' || ARCHIVE_SCHEMA || '.' || tRec.TABLE_NAME || ''' );  END;';

        BEGIN
          EXECUTE IMMEDIATE vSQL;
        EXCEPTION
          WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
              EvLog.migrArea := 'MIGR_ARCHIVE.BUILD_MIG_ARCHIVE_TBL';
              EvLog.migrStep := 'BUILD_MIG_ARCHIVE_TBL';
              EvLog.logMsg := SQLERRM || ' - Drop Statement: ' || vSQL;
              EvLog.migrRelTbl := NULL;
              EvLog.migrRelKey := NULL;
              MIGR_LOG.LOG_EXCEPTION(EvLog);
        END;

        --FA.20160824 Add NOLOGGING mode to minimize redo information size.
        vSQL := ' CREATE TABLE ' || ARCHIVE_SCHEMA || '.' || tRec.TABLE_NAME || '  NOLOGGING  AS ('
        || 'SELECT *'
        || ' FROM ' || tRec.TABLE_NAME
        || ' WHERE 1=2 )';

        BEGIN
          EXECUTE IMMEDIATE vSQL;
        EXCEPTION
          WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
              EvLog.migrArea := 'MIGR_ARCHIVE.BUILD_MIG_ARCHIVE_TBL';
              EvLog.migrStep := 'BUILD_MIG_ARCHIVE_TBL';
              EvLog.logMsg := SQLERRM || ' - Create Statement: ' || vSQL;
              EvLog.migrRelTbl := NULL;
              EvLog.migrRelKey := NULL;
              MIGR_LOG.LOG_EXCEPTION(EvLog);
        END;

      END LOOP ETL_ARCHIVE_TBL_LOOP;

    EXCEPTION
      WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
          EvLog.migrArea := 'MIGR_ARCHIVE.BUILD_MIG_ARCHIVE_TBL';
          EvLog.migrStep := NULL;
          EvLog.logMsg := SQLERRM;
          EvLog.migrRelTbl := NULL;
          EvLog.migrRelKey := NULL;
          MIGR_LOG.LOG_EXCEPTION(EvLog);
    END BUILD_MIG_ARCHIVE_TBL;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --PROCEDURE Run Archive Setup
  PROCEDURE RUN_SETUP_ARCHIVE(ARCHIVE_SCHEMA IN VARCHAR2)
    AS
      vDeleteTableObjs BOOLEAN := TRUE;
      vCreateTables    BOOLEAN := TRUE;
      EvLog            MIGR_GVAR.LogRecTyp;

      vSQL             VARCHAR2(500);
    BEGIN
      EvLog.mig_batch_id := '0-1';
      EvLog.migrArea := 'MIGR_ARCHIVE.RUN_ARCHIVE_SETUP';
      EvLog.migrStep := NULL;
      EvLog.logMsg := 'Start of RUN_ARCHIVE_SETUP';
      EvLog.migrRelTbl := NULL;
      EvLog.migrRelKey := NULL;
      MIGR_LOG.LOG_INFO(EvLog);

      GRANT_ARCHIVE_SCHEMA(ARCHIVE_SCHEMA);
      EvLog.migrArea := 'MIGR_ARCHIVE.GRANT_ARCHIVE_SCHEMA';
      EvLog.logMsg := 'Completed';
      MIGR_LOG.LOG_INFO(EvLog);

      --Deletes all table objects (SA, LA)
      IF vDeleteTableObjs = TRUE
      THEN
        DROP_ARCHIVE_TABLES_OBJS(ARCHIVE_SCHEMA);              -- LA and SA tables
        EvLog.migrArea := 'MIGR_ARCHIVE.DROP_ARCHIVE_TABLES_OBJS';
        EvLog.logMsg := 'Completed';
        MIGR_LOG.LOG_INFO(EvLog);
      END IF;

      --Creates tables SA, LA based on ETL_MIGG_SOURCES
      IF vCreateTables = TRUE
      THEN
        CREATE_ARCHIVE_TABLES(ARCHIVE_SCHEMA);                 -- LA and SA tables
        EvLog.migrArea := 'MIGR_ARCHIVE.CREATE_ARCHIVE_TABLES';
        EvLog.logMsg := 'Completed';
        MIGR_LOG.LOG_INFO(EvLog);
      END IF;

      TBL_OPERATION_IA_ARCHIVE(ARCHIVE_SCHEMA);                -- Build IA% archive tables
      EvLog.migrArea := 'MIGR_ARCHIVE.TBL_OPERATION_IA_ARCHIVE';
      EvLog.logMsg := 'Completed';
      MIGR_LOG.LOG_INFO(EvLog);

      BUILD_MIG_ARCHIVE_TBL(ARCHIVE_SCHEMA);                   -- Build MIG% archive tables
      EvLog.migrArea := 'MIGR_ARCHIVE.BUILD_MIG_ARCHIVE_TBL';
      EvLog.logMsg := 'Completed';
      MIGR_LOG.LOG_INFO(EvLog);

      GRANT_ARCHIVE_SCHEMA(ARCHIVE_SCHEMA);
      EvLog.migrArea := 'MIGR_ARCHIVE.GRANT_ARCHIVE_SCHEMA';
      EvLog.logMsg := 'Completed';
      MIGR_LOG.LOG_INFO(EvLog);

      EvLog.migrArea := 'MIGR_ARCHIVE.RUN_ARCHIVE_SETUP';
      EvLog.logMsg := 'End of RUN_ARCHIVE_SETUP';
      MIGR_LOG.LOG_INFO(EvLog);

      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN EvLog.mig_batch_id := '0-1';
          EvLog.migrArea := 'MIGR_ARCHIVE.RUN_ARCHIVE_SETUP';
          EvLog.migrStep := NULL;
          EvLog.logMsg := SQLERRM;
          EvLog.migrRelTbl := NULL;
          EvLog.migrRelKey := NULL;
          MIGR_LOG.LOG_EXCEPTION(EvLog);

    END RUN_SETUP_ARCHIVE;

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_ARCHIVE;
/

CREATE OR REPLACE PACKAGE BODY                   MIGR_EMAIL_NOTIFICATION AS

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE CREATE_EMAIL_NOTIFICATION(p_MIGRATION_BATCH_ID IN VARCHAR2, p_MSG_CODE IN VARCHAR2
                                    , p_ATT_FILE_NAME IN VARCHAR2 DEFAULT NULL, p_ATT_FILE_DIR IN VARCHAR2 DEFAULT NULL)
  AS
    PRAGMA AUTONOMOUS_TRANSACTION;

    l_MSG_ID    NUMBER;
    l_LogRec    MIGR_GVAR.LogRecTyp;
      V_SQL VARCHAR2(2000);
    l_renewal   DATE;
  BEGIN

    l_LogRec.migrArea     := 'MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION';
    l_LogRec.migrStep     := 'MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION';
    l_LogRec.mig_batch_id := p_MIGRATION_BATCH_ID;
    l_LogRec.migrRelTbl   := p_MSG_CODE;
    l_LogRec.logMsg       := '';


   BEGIN
   SELECT TRUNC(RENEWAL_DATE) INTO l_renewal FROM (SELECT * FROM ETL_MIGRATION_CONDITIONS WHERE 1=1 AND ITERATION_STATUS='Pending' ORDER BY id) WHERE ROWNUM=1;

      EXCEPTION
        WHEN NO_DATA_FOUND THEN    l_renewal :=NULL;
        END;


    FOR c IN (SELECT b.EMAIL_ADDRESS
                   , a.MSG_CODE, a.MSG_TYPE, a.MSG_DESCRIPTION, a.MSG_BODY
                FROM ETL_EMAIL_NOTIFICATIONS a
                JOIN ETL_EMAIL_LIST b
                  ON ',' || a.GROUP_IDS || ',' LIKE '%,' || b.GROUP_ID || ',%'
               WHERE a.MSG_CODE = p_MSG_CODE
                 AND b.IS_ACTIVE = 'Y'
                 AND (b.GROUP_ID<>'100' OR (b.GROUP_ID='100' AND (TRIM(LEADING '0' FROM SUBSTR(p_MIGRATION_BATCH_ID, 1, 2))=b.USERNAME OR p_MIGRATION_BATCH_ID  ='0-0' OR p_MIGRATION_BATCH_ID LIKE '00-0%')))
    )
    LOOP

      l_LogRec.logMsg := c.EMAIL_ADDRESS || ' | ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION || ' | ' || c.MSG_BODY;

      INSERT INTO MIGR_EMAIL_NOTIFICATIONS_LOG (MSG_ID, MIGRATION_BATCH_ID, MSG_REGISTRATION_TIMESTAMP, MSG_RCPT, MSG_CODE, MSG_TYPE, MSG_DESCRIPTION, MSG_BODY, MSG_ATT_NAME, MSG_ATT_DIR, MSG_STATUS, MSG_SENDING_TIMESTAMP, RENEWAL_DATE) VALUES
        (MIGR_EMAIL_NOTIF_SEQ.NEXTVAL, p_MIGRATION_BATCH_ID, SYSTIMESTAMP, c.EMAIL_ADDRESS, c.MSG_CODE, c.MSG_TYPE, c.MSG_DESCRIPTION, c.MSG_BODY, p_ATT_FILE_NAME, p_ATT_FILE_DIR, MIGR_GVAR.GV_MSG_STATUS_NEW, NULL, l_renewal);


      COMMIT;

    END LOOP;

  EXCEPTION
    WHEN OTHERS THEN
      l_LogRec.logMsg := SQLCODE || ' - ' || SQLERRM || ' - ' || l_LogRec.logMsg;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
      ROLLBACK;

  END CREATE_EMAIL_NOTIFICATION;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20170615 override create email notification to accept dynamically migration process output data
  PROCEDURE CREATE_EMAIL_WITH_DYNAMIC_MSG(p_MIGRATION_BATCH_ID IN VARCHAR2, p_MSG_CODE IN VARCHAR2, p_MIGR_INFO IN VARCHAR2, p_ATT_FILE_NAME IN VARCHAR2 DEFAULT NULL, p_ATT_FILE_DIR IN VARCHAR2 DEFAULT NULL)
  AS
    PRAGMA AUTONOMOUS_TRANSACTION;

    l_MSG_ID    NUMBER;
    l_LogRec    MIGR_GVAR.LogRecTyp;
      V_SQL VARCHAR2(2000);
    l_renewal   DATE;
  BEGIN

    l_LogRec.migrArea     := 'MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION';
    l_LogRec.migrStep     := 'MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION';
    l_LogRec.mig_batch_id := p_MIGRATION_BATCH_ID;
    l_LogRec.migrRelTbl   := p_MSG_CODE;
    l_LogRec.logMsg       := '';


    BEGIN
    SELECT TRUNC(RENEWAL_DATE) INTO l_renewal FROM (SELECT * FROM ETL_MIGRATION_CONDITIONS WHERE 1=1 AND ITERATION_STATUS='Pending' ORDER BY id) WHERE ROWNUM=1;
     EXCEPTION
        WHEN NO_DATA_FOUND THEN    l_renewal :=NULL;
        END;


    FOR c IN (SELECT b.EMAIL_ADDRESS
                   , a.MSG_CODE, a.MSG_TYPE, a.MSG_DESCRIPTION, a.MSG_BODY
                FROM ETL_EMAIL_NOTIFICATIONS a
                JOIN ETL_EMAIL_LIST b
                  ON ',' || a.GROUP_IDS || ',' LIKE '%,' || b.GROUP_ID || ',%'
               WHERE a.MSG_CODE = p_MSG_CODE
                 AND b.IS_ACTIVE = 'Y'
                 AND (b.GROUP_ID<>'100' OR (b.GROUP_ID='100' AND (TRIM(LEADING '0' FROM SUBSTR(p_MIGRATION_BATCH_ID, 1, 2))=b.USERNAME OR p_MIGRATION_BATCH_ID='0-0' OR p_MIGRATION_BATCH_ID LIKE '00-0%')))
    )
    LOOP

      l_LogRec.logMsg := c.EMAIL_ADDRESS || ' | ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION || ' | ' || c.MSG_BODY || ' | ' || p_MIGR_INFO;

      INSERT INTO MIGR_EMAIL_NOTIFICATIONS_LOG (MSG_ID, MIGRATION_BATCH_ID, MSG_REGISTRATION_TIMESTAMP, MSG_RCPT, MSG_CODE, MSG_TYPE, MSG_DESCRIPTION, MSG_BODY, MSG_ATT_NAME, MSG_ATT_DIR, MSG_STATUS, MSG_SENDING_TIMESTAMP, RENEWAL_DATE) VALUES
        (MIGR_EMAIL_NOTIF_SEQ.NEXTVAL, p_MIGRATION_BATCH_ID, SYSTIMESTAMP, c.EMAIL_ADDRESS, c.MSG_CODE, c.MSG_TYPE, c.MSG_DESCRIPTION, c.MSG_BODY || p_MIGR_INFO, p_ATT_FILE_NAME, p_ATT_FILE_DIR, MIGR_GVAR.GV_MSG_STATUS_NEW, NULL, l_renewal);

      --MIGR_LOG.LOG_INFO(l_LogRec);

      COMMIT;

    END LOOP;

  EXCEPTION
    WHEN OTHERS THEN
      l_LogRec.logMsg := SQLCODE || ' - ' || SQLERRM || ' - ' || l_LogRec.logMsg;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
      ROLLBACK;

  END CREATE_EMAIL_WITH_DYNAMIC_MSG;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE SEND_EMAIL (p_MSG_ID IN NUMBER)
    AS
    l_LogRec    MIGR_GVAR.LogRecTyp;

    l_mail_conn  utl_smtp.connection;
    l_smtp_host  VARCHAR2(255);
    l_smtp_port  PLS_INTEGER;
    l_sender     VARCHAR2(255);
    l_recipient  VARCHAR2(255);
    l_message    VARCHAR2(4000);

    v_my_schema   VARCHAR2(30);
    v_environment VARCHAR2(30);
     v_host_name VARCHAR2(100);
    v_instance_name VARCHAR2(100);
    --l_renewal    DATE;
  BEGIN
    l_LogRec.migrArea := 'MIGR_EMAIL_NOTIFICATION.SEND_EMAIL';
    l_LogRec.migrStep := 'MIGR_EMAIL_NOTIFICATION.SEND_EMAIL';

    SELECT SMTP_HOST, SMTP_PORT, SMTP_SENDER INTO l_smtp_host, l_smtp_port, l_sender FROM ETL_SETUP_INFO;
    ----DBMS_OUTPUT.PUT_LINE(l_smtp_host || l_smtp_port || l_sender);

    SELECT SYS_CONTEXT('userenv', 'current_schema') INTO v_my_schema FROM DUAL;

    ---SELECT UPPER(INSTANCE) INTO v_environment FROM V$THREAD;
          SELECT UPPER(value) INTO v_environment FROM V$PARAMETER WHERE name LIKE '%service_name%';

--          BEGIN
--          SELECT host_name,instance_name  INTO v_host_name, v_instance_name  FROM v$instance  WHERE instance_number=USERENV('instance');
--          EXCEPTION
--            WHEN OTHERS THEN
--                    l_LogRec.logMsg := SQLCODE || ' - ' || SQLERRM;
--                    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
--           END ;

    --SELECT TRUNC(RENEWAL_DATE) INTO l_renewal FROM (SELECT * FROM ETL_MIGRATION_CONDITIONS WHERE 1=1 AND ITERATION_STATUS='Pending' ORDER BY id) WHERE ROWNUM=1;

    FOR c IN (SELECT *
                FROM (SELECT * FROM MIGR_EMAIL_NOTIFICATIONS_LOG, ETL_SETUP_INFO) A
              --JOIN ETL_EMAIL_LIST D ON A.MSG_RCPT = D.EMAIL_ADDRESS
               WHERE MSG_ID = p_MSG_ID
    )
    LOOP
      l_LogRec.mig_batch_id := c.MIGRATION_BATCH_ID;
      l_LogRec.migrRelKey   := c.MSG_CODE;
      -- l_smtp_host := 'mailint.lfnet.se'; --c.SMTP_HOST;
      -- l_smtp_port := 25; --c.SMTP_PORT;
      -- l_sender    := 'konsult.Andreas.Boyatzoglou@lansforsakringar.se'; --c.SMTP_SENDER;

      -- l_message := c.MIGRATION_BATCH_ID || ' | ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION || ' | ' || c.MSG_BODY;
      l_message := c.MIGRATION_BATCH_ID || ' | Message Code: ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION;

      l_mail_conn := utl_smtp.open_connection(l_smtp_host, l_smtp_port);
      utl_smtp.helo(l_mail_conn, l_smtp_host);
      utl_smtp.mail(l_mail_conn, l_sender);


      FOR cur IN (SELECT A.*
                    FROM (SELECT * FROM MIGR_EMAIL_NOTIFICATIONS_LOG, ETL_SETUP_INFO) A
                  --JOIN ETL_EMAIL_LIST D ON A.MSG_RCPT = D.EMAIL_ADDRESS
                   WHERE A.MIGRATION_BATCH_ID = c.MIGRATION_BATCH_ID
                     AND A.MSG_CODE = c.MSG_CODE
                     AND A.MSG_STATUS = 'New'
      )
      LOOP
        utl_smtp.rcpt(l_mail_conn, cur.MSG_RCPT);
      END LOOP;

      utl_smtp.open_data(l_mail_conn);
      -- utl_smtp.write_data(l_mail_conn, 'From: ' || '"' || c.USERNAME || '" <' || l_sender || '>' || UTL_TCP.CRLF);
      utl_smtp.write_data(l_mail_conn, 'From: <' || l_sender || '>' || UTL_TCP.CRLF);
      -- utl_smtp.write_data(l_mail_conn, 'To: ' || '"Recipient" <' || c.MSG_RCPT || '>' || UTL_TCP.CRLF);
      utl_smtp.write_data(l_mail_conn, 'Reply-To: ' || l_sender  || UTL_TCP.CRLF);
      utl_smtp.write_data(l_mail_conn, 'Subject: '  || l_message || UTL_TCP.CRLF);

      -- Message Body
      l_message := 'Migration Environment: ' || v_environment || ' - ' || v_my_schema || chr(13) || chr(10) || chr(13) || chr(10) ||
                   'Migration Batch ID: ' || c.MIGRATION_BATCH_ID || chr(13) || chr(10) ||
                   'Message Code: ' || c.MSG_CODE || chr(13) || chr(10) ||
                   'Message Type: ' || c.MSG_TYPE || chr(13) || chr(10) ||
                   'Message Description: ' || c.MSG_DESCRIPTION || chr(13) || chr(10) ||
                   'Message Registration Date: ' || TO_CHAR(c.MSG_REGISTRATION_TIMESTAMP, 'DD/MM/YYYY HH24:MI:SS') || chr(13) || chr(10) ||
                   (CASE WHEN c.MSG_CODE NOT IN ('M80000','M80005','M80010')
                         THEN chr(13) || chr(10) || 'Renewal Date: ' || c.RENEWAL_DATE || chr(13) || chr(10)
                         ELSE NULL END) ||
                   chr(13) || chr(10) || c.MSG_BODY;

      utl_smtp.write_data(l_mail_conn, UTL_TCP.CRLF || l_message);
      utl_smtp.close_data(l_mail_conn);
      utl_smtp.quit(l_mail_conn);


      -- UPDATE MIGR_EMAIL_NOTIFICATIONS_LOG SET MSG_STATUS = MIGR_GVAR.GV_MSG_STATUS_SENT, MSG_SENDING_TIMESTAMP = SYSTIMESTAMP WHERE MSG_ID = c.MSG_ID;
--      FOR cur IN (SELECT A.*
--                    FROM (SELECT * FROM MIGR_EMAIL_NOTIFICATIONS_LOG, ETL_SETUP_INFO) A
--                    JOIN ETL_EMAIL_LIST D ON A.MSG_RCPT = D.EMAIL_ADDRESS
--                   WHERE A.MIGRATION_BATCH_ID = c.MIGRATION_BATCH_ID
--                     AND A.MSG_CODE = c.MSG_CODE
--                     AND A.MSG_STATUS = 'New'
--      )
--      LOOP
--        UPDATE MIGR_EMAIL_NOTIFICATIONS_LOG SET MSG_STATUS = MIGR_GVAR.GV_MSG_STATUS_SENT, MSG_SENDING_TIMESTAMP = SYSTIMESTAMP WHERE MIGRATION_BATCH_ID = cur.MIGRATION_BATCH_ID AND MSG_CODE = cur.MSG_CODE AND MSG_STATUS = 'New';
--      END LOOP;
      UPDATE MIGR_EMAIL_NOTIFICATIONS_LOG SET MSG_STATUS = MIGR_GVAR.GV_MSG_STATUS_SENT, MSG_SENDING_TIMESTAMP = SYSTIMESTAMP WHERE MIGRATION_BATCH_ID = c.MIGRATION_BATCH_ID AND MSG_CODE = c.MSG_CODE AND MSG_STATUS = 'New';

      ----DBMS_OUTPUT.PUT_LINE('Message send to the user successfully! | ' || c.EMAIL_ADDRESS || ' | ' || c.MIGRATION_BATCH_ID || ' | ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION || ' | ' || c.MSG_BODY);
      --l_LogRec.logMsg := 'Message send to the user successfully! | ' || c.EMAIL_ADDRESS || ' | ' || c.MIGRATION_BATCH_ID || ' | ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION || ' | ' || c.MSG_BODY;
      l_LogRec.logMsg := 'Message send to the users successfully! | ' || c.MIGRATION_BATCH_ID || ' | ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION || ' | ' || c.MSG_BODY;
      MIGR_LOG.LOG_INFO(l_LogRec);

      COMMIT;

    END LOOP;

    EXCEPTION
      WHEN OTHERS THEN
        ----DBMS_OUTPUT.PUT_LINE(SQLCODE || ' - ' || SQLERRM);
        l_LogRec.logMsg := SQLCODE || ' - ' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END SEND_EMAIL;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE SEND_EMAIL_WITH_ATT (p_MSG_ID IN NUMBER, p_attach_name IN VARCHAR2, p_FILE_DIR IN VARCHAR2)
    AS
    l_LogRec    MIGR_GVAR.LogRecTyp;

    l_mail_conn  utl_smtp.connection;
    l_smtp_host  VARCHAR2(255);
    l_smtp_port  PLS_INTEGER;
    l_sender     VARCHAR2(255);
    l_recipient  VARCHAR2(255);
    l_message    VARCHAR2(4000);

    v_my_schema   VARCHAR2(30);
    v_environment VARCHAR2(30);

    vInhandle_read utl_file.file_type;
    vPrevLine      LONG;
    vNewLine       LONG;

    l_boundary     VARCHAR2(50) := '----=*#abc1234321cba#*=';
    l_step         PLS_INTEGER  := 12000;
    l_attach_mime  VARCHAR2(50) := 'text/plain';

    l_clob         CLOB;

    counter        PLS_INTEGER := 0;
    l_attach_name  VARCHAR2(100);

    --l_renewal      DATE;
  BEGIN
    l_LogRec.migrArea := 'MIGR_EMAIL_NOTIFICATION.SEND_EMAIL_WITH_ATT';
    l_LogRec.migrStep := 'MIGR_EMAIL_NOTIFICATION.SEND_EMAIL_WITH_ATT';

    SELECT SMTP_HOST, SMTP_PORT, SMTP_SENDER INTO l_smtp_host, l_smtp_port, l_sender FROM ETL_SETUP_INFO;
    ----DBMS_OUTPUT.PUT_LINE(l_smtp_host || l_smtp_port || l_sender);

    SELECT SYS_CONTEXT('userenv', 'current_schema') INTO v_my_schema FROM DUAL;

    --SELECT UPPER(INSTANCE) INTO v_environment FROM V$THREAD;
          SELECT UPPER(value) INTO v_environment FROM V$PARAMETER WHERE name LIKE '%service_name%';

    --SELECT TRUNC(RENEWAL_DATE) INTO l_renewal FROM (SELECT * FROM ETL_MIGRATION_CONDITIONS WHERE 1=1 AND ITERATION_STATUS='Pending' ORDER BY id) WHERE ROWNUM=1;

    FOR c IN (SELECT *
                FROM (SELECT * FROM MIGR_EMAIL_NOTIFICATIONS_LOG, ETL_SETUP_INFO) A
              --JOIN ETL_EMAIL_LIST D ON A.MSG_RCPT = D.EMAIL_ADDRESS
               WHERE MSG_ID = p_MSG_ID
    )
    LOOP
      l_LogRec.mig_batch_id := c.MIGRATION_BATCH_ID;
      l_LogRec.migrRelKey   := c.MSG_CODE;
      -- l_smtp_host := 'mailint.lfnet.se'; --c.SMTP_HOST;
      -- l_smtp_port := 25; --c.SMTP_PORT;
      -- l_sender    := 'konsult.Andreas.Boyatzoglou@lansforsakringar.se'; --c.SMTP_SENDER;

      -- l_message := c.MIGRATION_BATCH_ID || ' | ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION || ' | ' || c.MSG_BODY;
      l_message := c.MIGRATION_BATCH_ID || ' | Message Code: ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION;

      l_mail_conn := utl_smtp.open_connection(l_smtp_host, l_smtp_port);
      utl_smtp.helo(l_mail_conn, l_smtp_host);
      utl_smtp.mail(l_mail_conn, l_sender);

      FOR cur IN (SELECT A.*
                    FROM (SELECT * FROM MIGR_EMAIL_NOTIFICATIONS_LOG, ETL_SETUP_INFO) A
                  --JOIN ETL_EMAIL_LIST D ON A.MSG_RCPT = D.EMAIL_ADDRESS
                   WHERE A.MIGRATION_BATCH_ID = c.MIGRATION_BATCH_ID
                     AND A.MSG_CODE = c.MSG_CODE
                     AND A.MSG_STATUS = 'New'
      )
      LOOP
        utl_smtp.rcpt(l_mail_conn, cur.MSG_RCPT);
      END LOOP;

      utl_smtp.open_data(l_mail_conn);
      -- utl_smtp.write_data(l_mail_conn, 'From: ' || '"' || c.USERNAME || '" <' || l_sender || '>' || UTL_TCP.CRLF);
      utl_smtp.write_data(l_mail_conn, 'From: <' || l_sender || '>' || UTL_TCP.CRLF);
      -- utl_smtp.write_data(l_mail_conn, 'To: ' || '"Recipient" <' || c.MSG_RCPT || '>' || UTL_TCP.CRLF);
      utl_smtp.write_data(l_mail_conn, 'Reply-To: ' || l_sender || UTL_TCP.CRLF);
      utl_smtp.write_data(l_mail_conn, 'Subject: ' || l_message || UTL_TCP.CRLF);

      IF c.MSG_CODE IN ( MIGR_GVAR.GV_MSG_CODE_MIGR_DISC_REPORT, MIGR_GVAR.GV_MSG_CODE_MIGR_FINAL_REPORT ) THEN
          utl_smtp.write_data(l_mail_conn, 'MIME-Version: 1.0' || UTL_TCP.crlf);
          utl_smtp.write_data(l_mail_conn, 'Content-Type: multipart/mixed; boundary="' || l_boundary || '"' || UTL_TCP.crlf || UTL_TCP.crlf);
      END IF;

      IF l_message IS NOT NULL THEN
        utl_smtp.write_data(l_mail_conn, '--' || l_boundary || UTL_TCP.crlf);
        utl_smtp.write_data(l_mail_conn, 'Content-Type: text/plain; charset="iso-8859-1"' || UTL_TCP.crlf || UTL_TCP.crlf);

        -- Message Body
        l_message := 'Migration Environment: ' || v_environment || ' - ' || v_my_schema || chr(13) || chr(10) || chr(13) || chr(10) ||
                     'Migration Batch ID: ' || c.MIGRATION_BATCH_ID || chr(13) || chr(10) ||
                     'Message Code: ' || c.MSG_CODE || chr(13) || chr(10) ||
                     'Message Type: ' || c.MSG_TYPE || chr(13) || chr(10) ||
                     'Message Description: ' || c.MSG_DESCRIPTION || chr(13) || chr(10) ||
                     'Message Registration Date: ' || TO_CHAR(c.MSG_REGISTRATION_TIMESTAMP, 'DD/MM/YYYY HH24:MI:SS') || chr(13) || chr(10) ||
                     (CASE WHEN c.MSG_CODE NOT IN ('M80000','M80005','M80010')
                           THEN chr(13) || chr(10) || 'Renewal Date: ' || c.RENEWAL_DATE || chr(13) || chr(10)
                           ELSE NULL END) ||
                     chr(13) || chr(10) || c.MSG_BODY;

        utl_smtp.write_data(l_mail_conn, l_message);
        utl_smtp.write_data(l_mail_conn, UTL_TCP.crlf || UTL_TCP.crlf);
      END IF;

      IF c.MSG_CODE IN ( MIGR_GVAR.GV_MSG_CODE_MIGR_DISC_REPORT, MIGR_GVAR.GV_MSG_CODE_MIGR_FINAL_REPORT ) THEN

          BEGIN
               vInHandle_read := utl_file.fopen( p_FILE_DIR, p_attach_name, 'R');
               LOOP
                  BEGIN
                       utl_file.GET_LINE(vInHandle_read, vNewLine);
                       l_clob := l_clob || vNewLine || chr(13) || chr(10);
                  EXCEPTION
                    WHEN NO_DATA_FOUND
                      THEN
                        EXIT;
                  END;

              END LOOP;
              utl_file.fclose(vInHandle_read);
              --dbms_output.put_line( 'The clob has ' || length(l_clob) || ' bytes.' );
              l_clob := SUBSTR(l_clob, 1, length(l_clob)-1);
          EXCEPTION
            WHEN OTHERS
              THEN
                  IF (utl_file.is_open(vInHandle_read))
                  THEN
                      utl_file.fclose(vInHandle_read);
                  END IF;
                  RAISE;
          END;


          IF p_attach_name IS NOT NULL THEN
            l_attach_name := SUBSTR(p_attach_name, 1, 16) || '.txt';  --removal of datetime reference
            UTL_SMTP.write_data(l_mail_conn, '--' || l_boundary || UTL_TCP.crlf);
            UTL_SMTP.write_data(l_mail_conn, 'Content-Type: ' || l_attach_mime || '; name="' || l_attach_name || '"' || UTL_TCP.crlf);
            UTL_SMTP.write_data(l_mail_conn, 'Content-Disposition: attachment; filename="' || l_attach_name || '"' || UTL_TCP.crlf || UTL_TCP.crlf);

            FOR i IN 0 .. TRUNC((DBMS_LOB.getlength(l_clob) - 1 )/l_step) LOOP
              UTL_SMTP.write_data(l_mail_conn, DBMS_LOB.substr(l_clob, l_step, i * l_step + 1));
            END LOOP;

            UTL_SMTP.write_data(l_mail_conn, UTL_TCP.crlf || UTL_TCP.crlf);
          END IF;
      END IF;


      utl_smtp.write_data(l_mail_conn, '--' || l_boundary || '--' || UTL_TCP.crlf);

      utl_smtp.close_data(l_mail_conn);
      utl_smtp.quit(l_mail_conn);

      -- UPDATE MIGR_EMAIL_NOTIFICATIONS_LOG SET MSG_STATUS = MIGR_GVAR.GV_MSG_STATUS_SENT, MSG_SENDING_TIMESTAMP = SYSTIMESTAMP WHERE MSG_ID = c.MSG_ID;
--      FOR cur IN (SELECT A.*
--                    FROM (SELECT * FROM MIGR_EMAIL_NOTIFICATIONS_LOG, ETL_SETUP_INFO) A
--                    JOIN ETL_EMAIL_LIST D ON A.MSG_RCPT = D.EMAIL_ADDRESS
--                   WHERE A.MIGRATION_BATCH_ID = c.MIGRATION_BATCH_ID
--                     AND A.MSG_CODE = c.MSG_CODE
--                     AND A.MSG_STATUS = 'New'
--                     AND ROWNUM = 1
--      )
--      LOOP
--        UPDATE MIGR_EMAIL_NOTIFICATIONS_LOG SET MSG_STATUS = MIGR_GVAR.GV_MSG_STATUS_SENT, MSG_SENDING_TIMESTAMP = SYSTIMESTAMP WHERE MIGRATION_BATCH_ID = cur.MIGRATION_BATCH_ID AND MSG_CODE = cur.MSG_CODE AND MSG_STATUS = 'New';
--      END LOOP;
      UPDATE MIGR_EMAIL_NOTIFICATIONS_LOG SET MSG_STATUS = MIGR_GVAR.GV_MSG_STATUS_SENT, MSG_SENDING_TIMESTAMP = SYSTIMESTAMP WHERE MIGRATION_BATCH_ID = c.MIGRATION_BATCH_ID AND MSG_CODE = c.MSG_CODE AND MSG_STATUS = 'New';

      ----DBMS_OUTPUT.PUT_LINE('Message send to the user successfully! | ' || c.EMAIL_ADDRESS || ' | ' || c.MIGRATION_BATCH_ID || ' | ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION || ' | ' || c.MSG_BODY);
      --l_LogRec.logMsg := 'Message send to the user successfully! | ' || c.EMAIL_ADDRESS || ' | ' || c.MIGRATION_BATCH_ID || ' | ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION || ' | ' || c.MSG_BODY;
      l_LogRec.logMsg := 'Message send to the users successfully! | ' || c.MIGRATION_BATCH_ID || ' | ' || c.MSG_CODE || ' | ' || c.MSG_TYPE || ' | ' || c.MSG_DESCRIPTION || ' | ' || c.MSG_BODY;
      MIGR_LOG.LOG_INFO(l_LogRec);

-- as long as we create the file in ARCHIVE folder there is no need for deletion
--      SELECT COUNT('X')
--        INTO counter
--        FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl
--       WHERE menl.MSG_ATT_NAME = l_attach_name AND menl.MSG_ATT_DIR = p_FILE_DIR AND menl.MSG_STATUS = MIGR_GVAR.GV_MSG_STATUS_NEW;
--
--      IF counter = 0 THEN
--        -- Remove attachment's source file
--        UTL_FILE.FREMOVE(p_FILE_DIR, p_attach_name);
--        ----DBMS_OUTPUT.PUT_LINE('Counter: ' || counter);
--      END IF;

      COMMIT;

    END LOOP;

    EXCEPTION
      WHEN OTHERS THEN
        ----DBMS_OUTPUT.PUT_LINE(SQLCODE || ' - ' || SQLERRM);
        l_LogRec.logMsg := SQLCODE || ' - ' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END SEND_EMAIL_WITH_ATT;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   PROCEDURE SEND_EMAIL_IMMEDIATE (p_LogRecMsg IN VARCHAR2, p_Msg_Code IN VARCHAR2)
    AS
    l_LogRec    MIGR_GVAR.LogRecTyp;

    l_mail_conn  utl_smtp.connection;
    l_smtp_host  VARCHAR2(255);
    l_smtp_port  PLS_INTEGER;
    l_sender     VARCHAR2(255);
    l_recipient  VARCHAR2(255);
    l_message    VARCHAR2(4000);

    v_my_schema   VARCHAR2(30);
    v_environment VARCHAR2(30);

    l_msg_type               ETL_EMAIL_NOTIFICATIONS.MSG_TYPE%TYPE;
    l_msg_description        ETL_EMAIL_NOTIFICATIONS.MSG_DESCRIPTION%TYPE;
    l_msg_body               ETL_EMAIL_NOTIFICATIONS.MSG_BODY%TYPE;
    l_migration_environment  ETL_SETUP_INFO.MIGRATION_ENVIRONMENT%TYPE;
  BEGIN
    l_LogRec.migrArea := 'MIGR_EMAIL_NOTIFICATION.SEND_EMAIL_IMMEDIATE';
    l_LogRec.migrStep := 'MIGR_EMAIL_NOTIFICATION.SEND_EMAIL_IMMEDIATE';

    SELECT SMTP_HOST, SMTP_PORT, SMTP_SENDER  INTO l_smtp_host, l_smtp_port, l_sender FROM ETL_SETUP_INFO;


    SELECT SYS_CONTEXT('userenv', 'current_schema') INTO v_my_schema FROM DUAL;

    --SELECT UPPER(INSTANCE) INTO v_environment FROM V$THREAD;
          SELECT UPPER(value) INTO v_environment FROM V$PARAMETER WHERE name LIKE '%service_name%';


    SELECT MSG_TYPE, MSG_DESCRIPTION, MSG_BODY
      INTO l_msg_type, l_msg_description, l_msg_body
      FROM ETL_EMAIL_NOTIFICATIONS
     WHERE MSG_CODE = p_Msg_Code;

      l_LogRec.mig_batch_id := '0-0';
      l_LogRec.migrRelKey   := p_Msg_Code;

      l_message :=  'Message Code: ' ||  p_Msg_Code || ' | ' || l_MSG_TYPE || ' | ' || l_MSG_DESCRIPTION;

      l_mail_conn := utl_smtp.open_connection(l_smtp_host, l_smtp_port);
      utl_smtp.helo(l_mail_conn, l_smtp_host);
      utl_smtp.mail(l_mail_conn, l_sender);


      FOR cur IN (SELECT b.EMAIL_ADDRESS
                    FROM ETL_EMAIL_LIST b
                   WHERE b.IS_ACTIVE = 'Y'
                     AND b.GROUP_ID = '200'
      )
      LOOP
        utl_smtp.rcpt(l_mail_conn, cur.EMAIL_ADDRESS);
      END LOOP;

      utl_smtp.open_data(l_mail_conn);

      utl_smtp.write_data(l_mail_conn, 'From: <' || l_sender || '>' || UTL_TCP.CRLF);

      utl_smtp.write_data(l_mail_conn, 'Reply-To: ' || l_sender  || UTL_TCP.CRLF);
      utl_smtp.write_data(l_mail_conn, 'Subject: '  || l_message || UTL_TCP.CRLF);

      -- Message Body
      l_message := 'Migration Environment: ' || v_environment || ' - ' || v_my_schema || chr(13) || chr(10) || chr(13) || chr(10) ||

                   'Message Code: ' ||p_Msg_Code || chr(13) || chr(10) ||
                   'Message Type: ' || l_MSG_TYPE || chr(13) || chr(10) ||
                   'Message Description: ' || l_MSG_DESCRIPTION || chr(13) || chr(10) ||   chr(13) || chr(10) ||
                   'Message Registration Date: ' || TO_CHAR(SYSTIMESTAMP(), 'DD/MM/YYYY HH24:MI:SS') || chr(13) || chr(10) ||
                    l_msg_body || ': ' || chr(13) || chr(10) || p_LogRecMsg;

      utl_smtp.write_data(l_mail_conn, UTL_TCP.CRLF || l_message);
      utl_smtp.close_data(l_mail_conn);
      utl_smtp.quit(l_mail_conn);


      l_LogRec.logMsg := 'Message send to the users successfully! | ' ||  ' | ' || p_MSG_CODE || ' | ' ||  l_MSG_TYPE || ' | ' ||  l_MSG_DESCRIPTION || ' | ' ||  l_MSG_BODY;
      MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION
      WHEN OTHERS THEN

        l_LogRec.logMsg := SQLCODE || ' - ' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END SEND_EMAIL_IMMEDIATE;


  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 --FA.20170920 Check if there are pending emails in the queue and send
 PROCEDURE SERVICE_EMAIL_QUEUE
  IS

BEGIN
            FOR cur IN (SELECT *
                                FROM (SELECT MIGRATION_BATCH_ID, MSG_CODE, MIN(MSG_ID) M_ID
                                        FROM (SELECT * FROM MIGR_EMAIL_NOTIFICATIONS_LOG WHERE MSG_STATUS = 'New' ORDER BY MSG_ID ASC)
                                       GROUP BY MIGRATION_BATCH_ID, MSG_CODE
                                       ORDER BY M_ID ) a
                                JOIN MIGR_EMAIL_NOTIFICATIONS_LOG b ON a.M_ID = b.MSG_ID ORDER BY  a.M_ID   ASC
                  )
        LOOP


                    IF cur.MSG_ATT_NAME IS NULL THEN
                      MIGR_EMAIL_NOTIFICATION.SEND_EMAIL(cur.MSG_ID);
                    ELSE
                      MIGR_EMAIL_NOTIFICATION.SEND_EMAIL_WITH_ATT(cur.MSG_ID, cur.MSG_ATT_NAME, cur.MSG_ATT_DIR);
                    END IF;
        END LOOP;


END;
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_EMAIL_NOTIFICATION;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_IA
  AS
  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  -- Transfer data from SA_ tables to IA tables
  -- requires ETL_SA_IA table.
  --          ETL_SA_IA fields      ETL_ID       - define the order that the process will run
  --                                SOURCE_VIEW  - the view from SA->MAP that contains the IA_ fields
  --                                DEST_TABLE   - the name of the IA_ table to be created/insert upon
  --                                UNIQ_KEY     - IA_ field name that will be used for checking for duplicates
  --                                ALLOW_DUPL   - 'TRUE'/'FALSE' to signify if IA_ table can have duplicate UNIQ_KEY records
  --                                MIGRATION_AREA - Always = SA_IA
  --                                STEP          - user-friendly Name of table (appears in MIGR_LOGs)
  --
  --                                FIELD_LIST   - will be filled automatically by the REBUILD_SA_IA routine (takes SOURCE_VIEW.IA_fields)
  --
  -- requires ETL_VIEW_TBLS table.  SOURCE_VIEW, TABLE_NAME - contains SA_ tables used in view. It is rebuilt in REBUILD_SA_IA()
  --
  --  REBUILD_SA_IA()   -- for each record from ETL_SA_IA table, reads SOURCE_VIEW.IA_  columns and builds the field list. then UPDATE set FIELD_LIST =.
  --                    --   It also populates the ETL_VIEW_TBLS to be used by IA_UPD_SA()
  --  RUN_IA_SETUP();   -- for each record from ETL_SA_IA table, executes 'CREATE TABLE' statement for creation of IA_ tables.
  --  RUN_IA_MAIN();    -- each record from ETL_SA_IA table, log step, if no dupl then log dupl, insert records in IA_ , log accepted.
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE TRUNCATE_IA_TABLES
    AS
      vSQL VARCHAR2(2100);
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN

      vSQL := 'TRUNCATE TABLE MIGR_IA_SA_LIST';
      EXECUTE IMMEDIATE vSQL;
    EXCEPTION
      WHEN OTHERS THEN

        l_LogRec.mig_batch_id:= '0-0';
        l_LogRec.migrArea      :=   'TRUNCATE IA TABLES' ;
        l_LogRec.migrStep      :=   'MIGR_IA.TRUNCATE_IA_TABLES' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=     SQLERRM || '-vsql:'  ||vSQL  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END TRUNCATE_IA_TABLES;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE IA_LOG_VOL(Migration_area    IN VARCHAR2,
                       Step_message      IN VARCHAR2,
                       Status            IN VARCHAR2,
                       TableName         IN VARCHAR2,
                       vMigrationBatchId IN VARCHAR2)
    AS
      vSQL VARCHAR2(2100);
      PRAGMA AUTONOMOUS_TRANSACTION;

    BEGIN

      vSQL := ' INSERT INTO MIG_VOLUMETRIC_ANALYSIS (MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME)'
      || ' SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID, SYSTIMESTAMP AS LOG_TIMESTAMP '
      || '  , ' || CHR(39) || Migration_area || CHR(39) || ' AS MIGRATION_AREA '
      || '  , ' || CHR(39) || Step_message || CHR(39) || ' AS STEP_MESSAGE '
      || '  , ' || CHR(39) || Status || CHR(39) || ' AS STATUS '
      || '  , MVA.CNT AS VOLUME '
      || 'FROM ( SELECT  MIGRATION_BATCH_ID '
      || '  FROM MIG_MIGRATION_INFO '
      || '  WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || vMigrationBatchId || CHR(39)
      || ' ) MMI, ( '
      || '          SELECT COUNT(*) AS CNT '
      || '          FROM ' || TableName
      || '          WHERE  MIG_FLAG = 0 '
      || ' ) MVA '
      || ' WHERE 1=1';

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END IA_LOG_VOL;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --  REBUILD_SA_IA()   -- for each record from ETL_SA_IA table, reads SOURCE_VIEW.IA_  columns and builds the field list. then UPDATE set FIELD_LIST =.
  --  PROCEDURE REBUILD_SA_IA (p_schema IN VARCHAR2) -- +++ anb 2016-04-18 no need for parameter passing
  PROCEDURE REBUILD_SA_IA
    AS
      L_ERRMSG    SRVERRMSG;
      L_SRVERRMSG SRVERRMSG;
      PIO_ERR     SRVERR;
      vFldLst     VARCHAR2(2100);
      vSQL        VARCHAR2(2100);
      v_my_schema VARCHAR2(50);         -- +++ anb 2016-04-18
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN

      EXECUTE IMMEDIATE 'TRUNCATE TABLE ETL_VIEW_TBLS';
      EXECUTE IMMEDIATE 'TRUNCATE TABLE MIGR_IA_SA_LIST';

      -- +++ anb 2016-04-18 no need for parameter passing
      SELECT SYS_CONTEXT('userenv', 'current_schema')
        INTO v_my_schema
        FROM DUAL;

      FOR tRec IN (SELECT SOURCE_VIEW,
                          VIEW_NAME,
                          DEST_TABLE
          FROM ETL_SA_IA,
               ETL_MIGR_MAPS_INTERMEDIATE
          WHERE 1 = 1
            AND Migration_area = 'SA_IA'
            AND SOURCE_VIEW = TABLE_NAME
            AND ETL_SA_IA.IS_ACTIVE = 'TRUE'
            AND ETL_MIGR_MAPS_INTERMEDIATE.IS_ACTIVE ='Y'   --EZ 2019-02-28
          ORDER BY ETL_SA_IA.ETL_ID)
      LOOP

      << ETL_tbl_loop >>
        vFldLst := ' ';

        FOR cRec IN (SELECT COLUMN_NAME
                    FROM ALL_TAB_COLUMNS
                    WHERE OWNER = v_my_schema   --'       +++ anb 2016-04-18
                      AND TABLE_NAME = tRec.SOURCE_VIEW
                      AND (COLUMN_NAME LIKE 'IA_%')
                    ORDER BY COLUMN_ID    --valex.6/3/2017 - so as to ensure that we keep the same column order with corresponding temporary tables
          )
        LOOP

        << field_loop >>
          IF vFldLst <> ' '
          THEN
            vFldLst := vFldLst || ' , ';
          END IF;

          vFldLst := vFldLst || cRec.COLUMN_NAME;

        END LOOP field_loop;
        vFldLst := vFldLst || ', MIG_MUTUAL_ID, MIG_BATCH_ID, MIG_FLAG, MIG_TIMESTAMP';

        vSQL := 'UPDATE ETL_SA_IA SET FIELD_LIST = ' || CHR(39) || vFldLst || CHR(39)
        || ' WHERE MIGRATION_AREA = ' || CHR(39) || 'SA_IA' || CHR(39)
        || ' and SOURCE_VIEW = ' || CHR(39) || tRec.SOURCE_VIEW || CHR(39) || ' and DEST_TABLE = ' || CHR(39) || tRec.DEST_TABLE || CHR(39);

        EXECUTE IMMEDIATE vSQL;

        FOR uRec IN (SELECT ud.NAME AS SOURCE_VIEW,
                            ud.REFERENCED_NAME AS TABLE_NAME
            FROM USER_DEPENDENCIES ud
            WHERE 1 = 1
              AND ud.REFERENCED_OWNER = v_my_schema
              AND ud.TYPE = 'VIEW'
              AND ud.REFERENCED_TYPE = 'TABLE'
              AND ud.REFERENCED_NAME LIKE 'SA_%'
              AND ud.NAME = tRec.VIEW_NAME
            ORDER BY ud.REFERENCED_NAME)
        LOOP

        << ViewTablesLoop >>
          vSQL := '  INSERT INTO ETL_VIEW_TBLS (SOURCE_VIEW, TABLE_NAME) VALUES ( '
          || CHR(39) || tRec.SOURCE_VIEW || CHR(39) || ', ' || CHR(39) || uRec.TABLE_NAME || CHR(39) || ' )';

          EXECUTE IMMEDIATE vSQL;

        END LOOP ViewTablesLoop;

      END LOOP ETL_tbl_loop;

    EXCEPTION
      WHEN OTHERS THEN

        l_LogRec.mig_batch_id:= '0-2';
        l_LogRec.migrArea      :=   'REBUILD SA IA' ;
        l_LogRec.migrStep      :=   'MIGR_IA.REBUILD_SA_IA' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=     SQLERRM || '-vsql:'  ||vSQL  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END REBUILD_SA_IA;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --  RUN_IA_SETUP();   -- for each record from ETL_SA_IA table, executes 'CREATE TABLE' statement for creation of IA_ tables.

  PROCEDURE RUN_IA_SETUP
    AS

      L_ERRMSG    SRVERRMSG;
      L_SRVERRMSG SRVERRMSG;
      PIO_ERR     SRVERR;
      vFldLst     VARCHAR2(2100);
      vSQL        VARCHAR2(2100);
     l_LogRec   MIGR_GVAR.LogRecTyp;
    BEGIN

      FOR tRec IN (SELECT STEP,
                          SOURCE_VIEW,
                          DEST_TABLE,
                          FIELD_LIST,
                          UNIQ_KEY,
                          ALLOW_DUPL
          FROM ETL_SA_IA
          WHERE 1 = 1
            AND Migration_area = 'SA_IA'
            AND IS_ACTIVE = 'TRUE'
          ORDER BY ETL_ID ASC)
      LOOP

      << ETL_tbl_loop >>
        vSQL := ' DROP TABLE ' || tRec.DEST_TABLE;

        BEGIN
          EXECUTE IMMEDIATE vSQL;
        EXCEPTION
          WHEN OTHERS THEN NULL;
        END;

        --FA.20160824 Add NOLOGGING mode to minimize redo information size.

        BEGIN
            vSQL := ' CREATE TABLE ' || tRec.DEST_TABLE || '  NOLOGGING  AS ('
            || 'SELECT' || tRec.FIELD_LIST
            || ' FROM ' || tRec.SOURCE_VIEW
            || ' WHERE 1=2 )';

            EXECUTE IMMEDIATE vSQL;

        EXCEPTION
          WHEN OTHERS THEN

              l_LogRec.mig_batch_id:= '0-2';
              l_LogRec.migrArea      :=   'RUN IA SETUP ' ;
              l_LogRec.migrStep      :=   'MIGR_IA.RUN_IA_SETUP' ;
              l_LogRec.migrRelTbl    :=    tRec.DEST_TABLE;
              l_LogRec.migrRelKey  :=   NULL;
              l_LogRec.logMsg        :=     SQLERRM || ' vSQL:'|| vSQL    ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

        END;

      END LOOP ETL_tbl_loop;

--LM - 12-02-2018 - Modify IA_DESCRIPTION in all tables with Specified Items - START
      FOR ctab IN (SELECT epo.IA_OBJ_TABLE
               FROM ETL_PRODUCT_OBJECTS epo
              WHERE epo.HAS_SPECIFIED = 'Y'
                AND epo.IS_ACTIVE = 'Y'
             )
      LOOP

        VSQL := 'ALTER table ' || ctab.IA_OBJ_TABLE || ' MODIFY ( IA_DESCRIPTION VARCHAR2(2000))' ;
        EXECUTE IMMEDIATE VSQL;

      END LOOP;
--LM - 12-02-2018 - END

    EXCEPTION
      WHEN OTHERS THEN
              l_LogRec.mig_batch_id:= '0-2';
              l_LogRec.migrArea      :=   'RUN IA SETUP ' ;
              l_LogRec.migrStep      :=   'MIGR_IA.RUN_IA_SETUP' ;
              l_LogRec.migrRelTbl    :=   NULL;
              l_LogRec.migrRelKey  :=   NULL;
              l_LogRec.logMsg        :=     SQLERRM|| ' vSQL:'|| vSQL   ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END RUN_IA_SETUP;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Clean up SA Xferred records all tables from 1 view
  PROCEDURE IA_UPD_SA(vIA_TableName IN VARCHAR2,
                      vSourceView   IN VARCHAR2,
                      vStatus       IN VARCHAR2,
                      vSQL_ID_List  IN VARCHAR2)
    AS
      l_LogRec MIGR_GVAR.LogRecTyp;
      vSQL        VARCHAR2(2100);
      L_ERRMSG    SRVERRMSG;
      L_SRVERRMSG SRVERRMSG;
      PIO_ERR     SRVERR;
      vMigFlag    PLS_INTEGER;

    BEGIN
      IF vStatus = 'Accepted'
      THEN
        vMigFlag := 1;
      ELSIF vStatus = 'Duplicate'
      THEN
        vMigFlag := 2;
      END IF;

      FOR cTbl IN (SELECT evt.TABLE_NAME AS TblNameFromView
          FROM ETL_VIEW_TBLS evt
          WHERE 1 = 1
            AND evt.SOURCE_VIEW = vSourceView)
      LOOP

      << ViewTablesLoop >>

        vSQL := 'UPDATE ' || cTbl.TblNameFromView
        || '    SET MIG_FLAG = ' || vMigFlag
        || ' WHERE ' || cTbl.TblNameFromView || '.IDPL IN ( '
        || vSQL_ID_List
        || ' )';

        EXECUTE IMMEDIATE vSQL;
      END LOOP ViewTablesLoop;

    EXCEPTION
      WHEN OTHERS THEN
              l_LogRec.mig_batch_id:= '0-2';
              l_LogRec.migrArea      :=   'IA UPDATE SA ' ;
              l_LogRec.migrStep      :=   'MIGR_IA.IA_UPD_SA' ;
              l_LogRec.migrRelTbl    :=   NULL;
              l_LogRec.migrRelKey  :=   NULL;
              l_LogRec.logMsg        :=     SQLERRM|| ' vSQL:'|| vSQL   ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END IA_UPD_SA;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE UPDATE_SA_IA(p_MigrationId IN VARCHAR2)
    AS

      L_SRVERRMSG SRVERRMSG;
      l_LogRec    MIGR_GVAR.LogRecTyp;
      p_status    VARCHAR2(20) := 'COMPLETE'; --valex.23/9/16 - status for update_ia_tables
    BEGIN


      FOR LI IN (SELECT MIG_FLAG
          FROM MIGR_IA_SA_LIST
          WHERE MIG_BATCH_ID = p_MigrationId
          GROUP BY MIG_FLAG)
      LOOP

        -- +++ anb 20151117 time each table separately
        l_LogRec.migrStep := 'Intermediate';
        l_LogRec.logMsg := 'Begin marking KF100 with IA Status ';
        l_LogRec.MIG_BATCH_ID := p_MigrationId;
        MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);

        UPDATE SA_KF100F
          SET MIG_FLAG = LI.MIG_FLAG
          WHERE MIG_FLAG = 0
          AND MIG_BATCH_ID = p_MigrationId
          AND IDPL IN (SELECT dups.IDPL
              FROM MIGR_IA_SA_LIST dups
              WHERE dups.MIG_BATCH_ID = p_MigrationId
                --FA.20161031 only master table records are inserted in table
                ---AND dups.DEST_TABLE = 'IA_POLICY'
                AND MIG_FLAG = LI.MIG_FLAG);


      END LOOP;

      -- +++ anb 20151117 time each table separately
      l_LogRec.logMsg := 'End marking KF100 with IA Status ';
      COMMIT;
      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);
      MIGR_RULES.UPDATE_SA_TABLES(p_MigrationId, 'Intermediate - Update SA', p_status);       -- times its own logging

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END UPDATE_SA_IA;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE IA_MAIN(p_migrBatchId IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                    O_STATUS      OUT VARCHAR2)
    AS

      vSQL               VARCHAR2(32000);
      vSQLIns_log        VARCHAR2(2100);
      vSQLlower          VARCHAR2(2100);
      vSQLcore           VARCHAR2(2100);
      vSQL_ID_List       VARCHAR2(2100);
      l_LogRec           MIGR_GVAR.LogRecTyp;
      vSQL_ID_ListIns    VARCHAR2(2100);
      V_MIG_FLAG         PLS_INTEGER;
      ex_IaRollback      EXCEPTION;
      l_NumRec           NUMBER;
      v_query_str        VARCHAR2(2100);

      V_ROWS_AFFECTED    PLS_INTEGER;
      v_allowed_products VARCHAR2(2100);
--    v_count1           PLS_INTEGER;               -- +++ anb 2019-02-28 debug

    BEGIN
      l_LogRec.MIG_BATCH_ID := p_migrBatchId;
      IF MIGR_PROCESS.PROCESS_STEPS(l_LogRec.MIG_BATCH_ID, 'IA', NULL) = 1
      THEN

        l_LogRec.migrArea := 'MIGR_IA.IA_MAIN';
        l_LogRec.migrStep := 'Staging Maps to Intermediate area';
        l_LogRec.logMsg := 'Running SA MAPS to IA';
        MIGR_LOG.LOG_INFO(l_LogRec);


 --valex.21/2/2017 - ETL_MIGR_MAPS_INTERMEDIATE has been joined so as to identify which temp tables refer to descounts. for these tables corresponding select and group by statements are constructed to support the grouping and correct calculation of discount value when temp tables are loaded to IA
        FOR tRec IN (SELECT a.STEP,
                            a.SOURCE_VIEW,
                            a.DEST_TABLE,
                            a.FIELD_LIST,
                            a.UNIQ_KEY,
                            a.ALLOW_DUPL,
                            a.is_master,
                            b.DISCOUNTS,
                            CASE WHEN b.DISCOUNTS='Y' THEN regexp_REPLACE(regexp_REPLACE(regexp_REPLACE(a.FIELD_LIST,'IA_DISCOUNT_VALUE[ ]{0,},',''),'IA_DISC_NFKKD[ ]{0,},',''),'IA_DISC_ORDER[ ]{0,},','') ||', round(exp(sum(ln(ia_discount_value))),4) as IA_DISCOUNT_VALUE '||', LISTAGG(to_char(IA_DISC_NFKKD), '','') WITHIN GROUP (ORDER BY (IA_DISC_NFKKD)) AS IA_DISC_NFKKD ' ||', LISTAGG(to_char(IA_DISC_ORDER), '','') WITHIN GROUP (ORDER BY (IA_DISC_ORDER)) AS IA_DISC_ORDER ' ELSE NULL end discounts_select_prc,
                            CASE WHEN b.DISCOUNTS='Y' THEN regexp_REPLACE(regexp_REPLACE(regexp_REPLACE(a.FIELD_LIST,'IA_DISCOUNT_VALUE[ ]{0,},',''),'IA_DISC_NFKKD[ ]{0,},',''),'IA_DISC_ORDER[ ]{0,},','') ||', sum(ia_discount_value) as IA_DISCOUNT_VALUE '||', LISTAGG(to_char(IA_DISC_NFKKD), '','') WITHIN GROUP (ORDER BY (IA_DISC_NFKKD)) AS IA_DISC_NFKKD ' ||', LISTAGG(to_char(IA_DISC_ORDER), '','') WITHIN GROUP (ORDER BY (IA_DISC_ORDER)) AS IA_DISC_ORDER ' ELSE NULL end discounts_select_lumps,
                            CASE WHEN b.DISCOUNTS='Y' THEN regexp_REPLACE(regexp_REPLACE(regexp_REPLACE(regexp_REPLACE(a.FIELD_LIST,'IA_DISCOUNT_VALUE[ ]{0,},',''),'IA_DISC_NFKKD[ ]{0,},',''),'IA_DISC_ORDER[ ]{0,},',''),'IA_DISCOUNT_CALC_MODE[ ]{0,},','')  ||', IA_DISCOUNT_VALUE , IA_DISC_NFKKD, IA_DISC_ORDER ' ELSE NULL end discounts_select1,
                            CASE WHEN b.DISCOUNTS='Y' THEN regexp_REPLACE(regexp_REPLACE(regexp_REPLACE(regexp_REPLACE(a.FIELD_LIST,'IA_DISCOUNT_VALUE[ ]{0,},',''),'IA_DISC_NFKKD[ ]{0,},',''),'IA_DISC_ORDER[ ]{0,},',''),'IA_DISCOUNT_CALC_MODE[ ]{0,},','') ||', (case when ia_discount_calc_mode=''PRC'' then (IA_DISCOUNT_VALUE - 1) *100  else IA_DISCOUNT_VALUE *100 end) as IA_DISCOUNT_VALUE  ,IA_DISC_NFKKD, IA_DISC_ORDER ' ELSE NULL end discounts_select2,
                            CASE WHEN b.DISCOUNTS='Y' THEN regexp_REPLACE(regexp_REPLACE(regexp_REPLACE(a.FIELD_LIST,'IA_DISCOUNT_VALUE[ ]{0,},',''),'IA_DISC_NFKKD[ ]{0,},',''),'IA_DISC_ORDER[ ]{0,},','')  ELSE NULL end  discounts_group_by
            FROM ETL_SA_IA a join ETL_MIGR_MAPS_INTERMEDIATE b on a.SOURCE_VIEW=b.TABLE_NAME
            WHERE 1 = 1
             -- AND ',' || MIGR_PROCESS.PROCESS_STEPS(l_LogRec.MIG_BATCH_ID, NULL, NULL) || ',' like '%,' || a.INSR_PRODUCT || ',%'
              AND a.Migration_area = 'SA_IA'
              AND a.IS_ACTIVE = 'TRUE'
              AND b.IS_ACTIVE = 'Y'   --EZ 2019-02-28
            ORDER BY a.ETL_ID)
        LOOP

        << ETL_tbl_loop >>
          BEGIN
            l_LogRec.migrStep := 'Intermediate';
            l_LogRec.logMsg := 'Begin IA for DEST_TABLE: ' || tRec.DEST_TABLE;
            l_LogRec.migrRelTbl := tRec.DEST_TABLE;
            MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);

            --valex.27/4/16 allowed products from process_steps
            v_allowed_products := MIGR_PROCESS.PROCESS_STEPS(l_LogRec.MIG_BATCH_ID, NULL, NULL);

            --- duplicates allowed ?
            IF tRec.ALLOW_DUPL = 'FALSE'
            THEN                 -- LOG duplicates in ERROR LOG

              vSQLIns_log := 'INSERT INTO MIG_DETAIL_ERROR_LOG '
              || '(MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY) '
              || ' SELECT   x.MIG_BATCH_ID, x.ERROR_TIMESTAMP, x.MIGRATION_AREA '
              || '    , x.ERROR_TYPE, x.ERROR_MESSAGE ,x.MIGRATION_STEP, x.RELATED_TABLE, x.RELATED_KEY  ';

              vSQLcore := 'SELECT IA_IDPL as IDPL, ' || CHR(39) || tRec.DEST_TABLE || CHR(39) || ' AS RELATED_TABLE, ' || q'['Record id: ']' || ' || ' || tRec.UNIQ_KEY || ' AS RELATED_KEY '
              || '    , MIG_BATCH_ID, SYSTIMESTAMP AS ERROR_TIMESTAMP, ' || q'['Intermediate']' || ' AS MIGRATION_AREA '
              || '    , ' || q'['Warning']' || ' AS ERROR_TYPE, ' || q'['Record has already been migrated']' || ' AS ERROR_MESSAGE '
              || '    , ' || q'['Loading Intermediate Area tables']' || ' AS MIGRATION_STEP '
              || ' FROM ' || tRec.SOURCE_VIEW
              || ' WHERE 1=1 AND MIG_FLAG=0 '
              || '   AND ' || tRec.UNIQ_KEY || ' IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')'
              || '   AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);

              vSQLlower := ' FROM ( ' || vSQLcore || ' ) x ';

              vSQL := vSQLIns_log || vSQLlower;

              EXECUTE IMMEDIATE vSQL;
              V_ROWS_AFFECTED := SQL % ROWCOUNT;

              COMMIT;
              -- mark SA_ tables of view as Duplicates
              vSQL_ID_List := 'SELECT x.IDPL ' || vSQLlower;
              --FA.20160408 iNSERT ONLY IF DUPLICATES FOUND
              ---IA_KEEP_SA_LIST(l_LogRec.mig_batch_id, tRec.DEST_TABLE, tRec.SOURCE_VIEW, vSQL_ID_List, 'Duplicate');
              --FA.20161031 insert into migr_ia_sa_list only values from master table
              IF V_ROWS_AFFECTED > 0
                AND tRec.is_master = 'Y'
              THEN
                BEGIN
                  vSQL := 'INSERT INTO MIGR_IA_SA_LIST '
                  || '  SELECT ' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39)
                  || ', ' || CHR(39) || tRec.SOURCE_VIEW || CHR(39)
                  || ', ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                  --                  || ', ' || CHR(39) || '1' || CHR(39)
                  || ', ' || CHR(39) || '2' || CHR(39)
                  || ', RELATED_KEY'
                  || '  FROM MIG_DETAIL_ERROR_LOG '
                  || ' WHERE RELATED_TABLE = ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                  || ' AND ERROR_MESSAGE = ' || q'['Record has already been migrated']'
                  || ' AND MIGRATION_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);

                  EXECUTE IMMEDIATE vSQL;
                EXCEPTION
                  WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM();
                      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                END;
              END IF;
            END IF;

            l_LogRec.migrRelTbl := tRec.DEST_TABLE;

 --valex.21/2/2017 - for dicount tables, a grouping is applied (if there are lines whichj refer to the same entity, object or policy) before loading to IA. depending on discount calculation mode (lumpsum or percent) different aggregate function is used
            IF tRec.DISCOUNTS='Y' THEN

              vsql:=' INSERT INTO ' || tRec.DEST_TABLE || ' (' || trec.discounts_select1  || ') '
                 || 'with lumps as ('
                 || 'SELECT ' || trec.discounts_select_lumps
                 || ' FROM ' || tRec.SOURCE_VIEW
                 || ' WHERE 1=1 AND MIG_FLAG=0 and ia_discount_calc_mode=''LUMPS'' '
                 || ' AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);
              if tRec.ALLOW_DUPL = 'FALSE' THEN
                  vSQL:= vsql || ' AND ' || tRec.UNIQ_KEY || ' NOT IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')';
              end IF;
              vsql:= vsql || ' group by ' || tRec.discounts_group_by ||')'
                 || ' ,prc as ('
                 || 'SELECT ' || trec.discounts_select_prc
                 || ' FROM ' || tRec.SOURCE_VIEW
                 || ' WHERE 1=1 AND MIG_FLAG=0 and ia_discount_calc_mode=''PRC'' '
                 || ' AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);
              if  tRec.ALLOW_DUPL = 'FALSE' THEN
                vSQL:=vsql || ' AND ' || tRec.UNIQ_KEY || ' NOT IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')' ;
              end IF;
              vsql:= vsql || ' group by ' || tRec.discounts_group_by ||')'
                 || 'select ' ||trec.discounts_select2
                 || ' from ('
                 || ' select * from lumps '
                 || '    union all '
                 || ' select * from prc) ';
            else
                vSQL := ' INSERT INTO ' || tRec.DEST_TABLE || ' (' || tRec.FIELD_LIST || ') '
                || 'SELECT ' || tRec.FIELD_LIST
                || ' FROM ' || tRec.SOURCE_VIEW
                || ' WHERE 1=1 AND MIG_FLAG=0 '
                || ' AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);

                IF tRec.ALLOW_DUPL = 'FALSE' THEN
                  vSQL := vSQL || ' AND ' || tRec.UNIQ_KEY || ' NOT IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')';
                END IF;
            END IF;

            BEGIN

              EXECUTE IMMEDIATE vSQL;

---- +++ anb 2019-02-28 debug
--           v_count1:= SQL % ROWCOUNT;
--           l_LogRec.logMsg := 'SA MAPS to IA' ||' -Dest Table= '|| tRec.DEST_TABLE ||' -Source View= '||tRec.SOURCE_VIEW|| ' -Records= ' ||v_count1;
--           MIGR_LOG.LOG_INFO(l_LogRec);
---- +++ END anb 2019-02-28 debug


            EXCEPTION
              WHEN OTHERS THEN l_LogRec.logMsg :='Error for Table:'|| tRec.DEST_TABLE || '-'|| SQLERRM;
                  MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                  RAISE ex_IaRollback;
            END;

            --FA.20161031 insert into migr_ia_sa_list only values from master table
            IF tRec.is_master = 'Y'
            THEN
              BEGIN
                vSQL := 'INSERT INTO MIGR_IA_SA_LIST '
                || '  SELECT ' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39)
                || ', ' || CHR(39) || tRec.SOURCE_VIEW || CHR(39)
                || ', ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                || ', ' || CHR(39) || '1' || CHR(39)
                || ', ia_IDPL'
                || '  FROM '
                || tRec.DEST_TABLE
                || ' WHERE 1=1 AND MIG_FLAG=0'
                || ' AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);


                EXECUTE IMMEDIATE vSQL;
              EXCEPTION
                WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM();
                    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
              END;
            END IF;

            COMMIT;

            IA_LOG_VOL('Intermediate', tRec.STEP, 'Accepted', tRec.DEST_TABLE, l_LogRec.MIG_BATCH_ID);
            l_LogRec.logMsg := 'End IA for DEST_TABLE: ' || tRec.DEST_TABLE;
            MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);

          EXCEPTION

            WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
                l_LogRec.migrRelTbl := vSQL;
                MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                RAISE ex_IaRollback;

          END;

        END LOOP ETL_tbl_loop;

        ---FA.20160420 Populate all covers insured values tables
        BEGIN
          FOR tRec IN (SELECT IA_COVER_VALUES_TBL,
                              IA_COVER_TBL,
                              esaa.FIELD_LIST,
                              conf.HST_COVER_TBL
              FROM ETL_IA_INSRPRD_CONFIG conf,
                   ETL_SA_IA esa,
                   ETL_SA_IA esaa
              WHERE esa.IS_ACTIVE = 'TRUE'
                AND esa.DEST_TABLE = conf.IA_COVER_TBL

                AND esaa.DEST_TABLE = conf.IA_COVER_VALUES_TBL
                AND conf.IA_COVER_VALUES_TBL IS NOT NULL)
          LOOP

            vSQL := 'DECLARE CURSOR KF is '
            || '    SELECT   ' || tRec.FIELD_LIST
            || ' FROM ' || tRec.IA_COVER_VALUES_TBL || '; '
            || ' TYPE KF_tab IS TABLE OF KF%ROWTYPE; '
            || ' KF_all_records   KF_tab:= KF_tab(); '
            || 'BEGIN '
            || 'SELECT ' || REPLACE(tRec.FIELD_LIST, 'IA_INSURED_VALUE', 'MIGR_API_COVERS.GET_COVER_INSURED_VALUE(hvc.INSURED_VAL,hvc.num_params,ct.ia_IDPL,ct.ia_IDPLPS, ct.IA_OBJECT_ID,ct.MIG_BATCH_ID)')
            || ' BULK COLLECT INTO KF_all_records '
            || ' FROM ' || tRec.IA_COVER_TBL || ' ct  LEFT JOIN ' || tRec.HST_COVER_TBL || ' hvc ON ct.IA_COVER = hvc.INSIS_COVER_ID  '
            || ' WHERE 1=1 AND MIG_FLAG=0'
            --FA.20160825 Add applicable bolags condition
            || '  and '',''||HVC.APPLICABLE_BOLAGS||'','' like ''%,''||ct.MIG_MUTUAL_ID||'',%'' '
            || ' AND MIG_BATCH_ID =' || CHR(39) || p_migrBatchId || CHR(39)
            || ';'
            || ' FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT '
            || '  INSERT INTO ' || tRec.IA_COVER_VALUES_TBL || ' VALUES KF_all_records(i); '
            || 'END; ';

            EXECUTE IMMEDIATE vSQL;
          END LOOP;

        EXCEPTION
          WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || '  ' || vSQL;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec);
        END;

        -- pl 20161110: RUN_COVER_UPDATE_RULES
        MIGR_RULES.RUN_COVER_UPDATE_RULES(p_migrBatchId);
        -- pl 20170516
        MIGR_RULES.UPDATE_COVER_ON_DEDUCT_RULES(p_migrBatchId);

        --LM - 04-12-2017 - Procedure for translating according to the language of the user.
        MIGR_RULES.RUN_TRANSLATION_RULES(p_migrBatchId);

        --LM - 17-01-2018 - procedure for unmapped outhouse labels - no mapping for BENNG values.
        MIGR_RULES.UPDATE_MAP_OUTHOUSE_LABEL(p_migrBatchId);

        --LM - 12-02-2018 - procedure for updating description of Specified Items (add description from entries with KF208F.FBLKR = 0).
        MIGR_RULES.UPDATE_SPECIFIED_DESCRIPTION(p_migrBatchId);

        UPDATE_SA_IA(l_LogRec.MIG_BATCH_ID);
        O_STATUS := 'COMPLETE';

      END IF;
      COMMIT;
    EXCEPTION
      WHEN ex_IaRollback THEN O_STATUS := 'ROLLBACK_IA';
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END IA_MAIN;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE IA_MAIN_TBL (--p_migrBatchId IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                         p_LogRec     MIGR_GVAR.LogRecTyp,
                         O_STATUS OUT VARCHAR2,
                         p_status IN  VARCHAR2)
    AS

      vSQL               VARCHAR2(2100);
      vSQLIns_log        VARCHAR2(2100);
      vSQLlower          VARCHAR2(2100);
      vSQLcore           VARCHAR2(2100);
      vSQL_ID_List       VARCHAR2(2100);
      l_LogRec           MIGR_GVAR.LogRecTyp;
      vSQL_ID_ListIns    VARCHAR2(2100);
      V_MIG_FLAG         PLS_INTEGER;
      ex_IaRollback      EXCEPTION;
      l_NumRec           NUMBER;
      v_query_str        VARCHAR2(2100);

      V_ROWS_AFFECTED    PLS_INTEGER;
      v_allowed_products VARCHAR2(2100);
    BEGIN
      l_LogRec := p_LogRec;

      IF MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id, 'IA', NULL) = 1
      THEN

        l_LogRec.migrArea := 'MIGR_IA.IA_MAIN_TBL';
        l_LogRec.migrStep := 'Staging ' || l_LogRec.migrRelTbl || ' to Intermediate area';
        l_LogRec.logMsg   := 'Running ' || l_LogRec.migrRelTbl || ' MAPS to IA';
        MIGR_LOG.LOG_INFO(l_LogRec);

        FOR tRec IN (SELECT STEP,
                            SOURCE_VIEW,
                            DEST_TABLE,
                            FIELD_LIST,
                            UNIQ_KEY,
                            ALLOW_DUPL,
                            is_master
                       FROM ETL_SA_IA
                      WHERE 1 = 1
                        AND ',' || MIGR_PROCESS.PROCESS_STEPS(l_LogRec.MIG_BATCH_ID, NULL, NULL) || ',' like '%,' || INSR_PRODUCT || ',%'
                        AND Migration_area = 'SA_IA'
                        AND IS_ACTIVE = 'TRUE'
                        AND SOURCE_VIEW = l_LogRec.migrRelTbl
                      ORDER BY ETL_ID)
        LOOP

        << ETL_tbl_loop >>
          BEGIN
            l_LogRec.migrStep   := 'Intermediate';
            l_LogRec.logMsg     := 'Begin IA for DEST_TABLE: ' || tRec.DEST_TABLE;
--------            l_LogRec.migrRelTbl := tRec.DEST_TABLE;
            MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, p_status);

            --valex.27/4/16 allowed products from process_steps
            v_allowed_products := MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id, NULL, NULL);

            --- duplicates allowed ?
            IF tRec.ALLOW_DUPL = 'FALSE'
            THEN                 -- LOG duplicates in ERROR LOG

              vSQLIns_log := 'INSERT INTO MIG_DETAIL_ERROR_LOG '
              || '(MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY) '
              || ' SELECT   x.MIG_BATCH_ID, x.ERROR_TIMESTAMP, x.MIGRATION_AREA '
              || '    , x.ERROR_TYPE, x.ERROR_MESSAGE ,x.MIGRATION_STEP, x.RELATED_TABLE, x.RELATED_KEY  ';

              vSQLcore := 'SELECT IA_IDPL as IDPL, ' || CHR(39) || tRec.DEST_TABLE || CHR(39) || ' AS RELATED_TABLE, ' || q'['Record id: ']' || ' || ' || tRec.UNIQ_KEY || ' AS RELATED_KEY '
              || '    , MIG_BATCH_ID, SYSTIMESTAMP AS ERROR_TIMESTAMP, ' || q'['Intermediate']' || ' AS MIGRATION_AREA '
              || '    , ' || q'['Warning']' || ' AS ERROR_TYPE, ' || q'['Record has already been migrated']' || ' AS ERROR_MESSAGE '
              || '    , ' || q'['Loading Intermediate Area tables']' || ' AS MIGRATION_STEP '
              || ' FROM ' || tRec.SOURCE_VIEW
              || ' WHERE 1=1 AND MIG_FLAG=0 '
              || '   AND ' || tRec.UNIQ_KEY || ' IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')'
              || '   AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);

              vSQLlower := ' FROM ( ' || vSQLcore || ' ) x ';

              vSQL := vSQLIns_log || vSQLlower;

              EXECUTE IMMEDIATE vSQL;
              V_ROWS_AFFECTED := SQL % ROWCOUNT;

              COMMIT;
              -- mark SA_ tables of view as Duplicates
              vSQL_ID_List := 'SELECT x.IDPL ' || vSQLlower;
              --FA.20160408 iNSERT ONLY IF DUPLICATES FOUND
              ---IA_KEEP_SA_LIST(l_LogRec.mig_batch_id, tRec.DEST_TABLE, tRec.SOURCE_VIEW, vSQL_ID_List, 'Duplicate');
              --FA.20161031 insert into migr_ia_sa_list only values from master table
              IF V_ROWS_AFFECTED > 0
                AND tRec.is_master = 'Y'
              THEN
                BEGIN
                  vSQL := 'INSERT INTO MIGR_IA_SA_LIST '
                  || '  SELECT ' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39)
                  || ', ' || CHR(39) || tRec.SOURCE_VIEW || CHR(39)
                  || ', ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                  --                  || ', ' || CHR(39) || '1' || CHR(39)
                  || ', ' || CHR(39) || '2' || CHR(39)
                  || ', RELATED_KEY'
                  || '  FROM MIG_DETAIL_ERROR_LOG '
                  || ' WHERE RELATED_TABLE = ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                  || ' AND ERROR_MESSAGE = ' || q'['Record has already been migrated']'
                  || ' AND MIGRATION_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);

                  EXECUTE IMMEDIATE vSQL;
                EXCEPTION
                  WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM();
                      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                END;
              END IF;
            END IF;

            l_LogRec.migrRelTbl := tRec.DEST_TABLE;
            vSQL := ' INSERT INTO ' || tRec.DEST_TABLE || ' (' || tRec.FIELD_LIST || ') '
            || 'SELECT' || tRec.FIELD_LIST
            || ' FROM ' || tRec.SOURCE_VIEW
            || ' WHERE 1=1 AND MIG_FLAG=0'
            || ' AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);
            IF tRec.ALLOW_DUPL = 'FALSE'
            THEN
              vSQL := vSQL || ' AND ' || tRec.UNIQ_KEY || ' NOT IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')';
            END IF;

            BEGIN
              EXECUTE IMMEDIATE vSQL;

            EXCEPTION
              WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || vSQL;
                  MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                  RAISE ex_IaRollback;
            END;

            --FA.20161031 insert into migr_ia_sa_list only values from master table
            IF tRec.is_master = 'Y'
            THEN
              BEGIN
                vSQL := 'INSERT INTO MIGR_IA_SA_LIST '
                || '  SELECT ' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39)
                || ', ' || CHR(39) || tRec.SOURCE_VIEW || CHR(39)
                || ', ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                || ', ' || CHR(39) || '1' || CHR(39)
                || ', ia_IDPL'
                || '  FROM '
                || tRec.DEST_TABLE
                || ' WHERE 1=1 AND MIG_FLAG=0'
                || ' AND MIG_BATCH_ID = ' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);


                EXECUTE IMMEDIATE vSQL;
              EXCEPTION
                WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM();
                    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
              END;
            END IF;

            COMMIT;

            IA_LOG_VOL('Intermediate', tRec.STEP, 'Accepted', tRec.DEST_TABLE, l_LogRec.MIG_BATCH_ID);
            l_LogRec.logMsg := 'End IA for DEST_TABLE: ' || tRec.DEST_TABLE;
            MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, p_status);

          EXCEPTION

            WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || ' - ' || vSQL;
                MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                RAISE ex_IaRollback;

          END;

        END LOOP ETL_tbl_loop;
        O_STATUS := 'COMPLETE';

      END IF;

      COMMIT;

    EXCEPTION
      WHEN ex_IaRollback THEN O_STATUS := 'ROLLBACK_IA';
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END IA_MAIN_TBL;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --valex.8/9/16 - all IA processes in one procedure
  PROCEDURE RUN_IA(p_migrBatchId IN  VARCHAR2,
                   IA_Status     OUT VARCHAR2)
    AS
      l_LogRec         MIGR_GVAR.LogRecTyp;
      vSql             VARCHAR2(2000);
      l_status         VARCHAR2(30);
      l_migrateClients ETL_SETUP_INFO.MIGRATE_CLIENTS % TYPE;
         v_mig_insis_user   ETL_BOLAG_INFO.BOLAG_USERNAME%TYPE;
    BEGIN
      IA_Status := 'COMPLETE';
      l_LogRec.migrArea := 'MIGR_IA.RUN_IA';
      l_LogRec.MIG_BATCH_ID := p_migrBatchId;
      l_LogRec.logMsg := 'Started IA processing';
      MIGR_LOG.LOG_INFO(l_LogRec);

      --FA.20161027 Add condition for client migration
      SELECT MIGRATE_CLIENTS
        INTO l_migrateClients
        FROM ETL_SETUP_INFO;

      IF MIGR_INTERMEDIATE_OBJECTS.POPULATE_INTERMEDIATE_TABLES(l_LogRec.MIG_BATCH_ID)
      THEN

           l_LogRec.logMsg := 'Populated Intermediate Objects';
            MIGR_LOG.LOG_INFO(l_LogRec);
        --FA.20161109 Run Exclusion Object Rules
        MIGR_RULES.RUN_OBJ_EXCLUSION_RULES;
              l_LogRec.logMsg := 'Run Excusion Rules';
            MIGR_LOG.LOG_INFO(l_LogRec);
        MIGR_IA.IA_MAIN(l_LogRec.MIG_BATCH_ID, l_status);


        IF l_status = 'COMPLETE'
        THEN

          --FA.20161027 Add condition for client migration
          IF l_migrateClients = 'Y'
          THEN
            l_LogRec.logMsg := 'Client Migration started';
            MIGR_LOG.LOG_INFO(l_LogRec);

            MIGR_API_COMMON.SET_DEFAULT_VALUES(SUBSTR(l_LogRec.MIG_BATCH_ID, 1, 2));
            vSql := 'ALTER SESSION SET NLS_DATE_FORMAT = ''DD-MM-RRRR''';
            EXECUTE IMMEDIATE vSql;

            --!!!!!!!!!CLEAN UP PROCESS WHEN ROLLABACK STATUS !!!!!!!!!!!!!!!!!!!!!!!!
            -----FA.20160705 API Process is triggered by api_scheduled job when a batch has finished IA step
            ----MIGR_API.RUN_API(L_DEBUG, l_LogRec.mig_batch_id);
            --The following code should be removed once desgn for customer migration will be finalized
           SELECT ebi.BOLAG_USERNAME INTO v_mig_insis_user FROM ETL_BOLAG_INFO ebi WHERE ebi.BOLAG_ID = SUBSTR(l_LogRec.MIG_BATCH_ID, 1, 2);
            INSIS_SYS_V10.INSIS_CONTEXT.Prepare_Session(Pi_App => 'GEN',
            Pi_Action => 'InsisPolicyGen',
            Pi_Username => v_mig_insis_user,
            Pi_User_Role => 'InsisStaff',
            Pi_Lang => NULL,
            Pi_Country => NULL);


            MIGR_API_CLIENTS.SETUP_CLIENT(l_LogRec.MIG_BATCH_ID);
            MIGR_API_CLIENTS.SETUP_CLIENT_ADDRESS(l_LogRec.MIG_BATCH_ID);
            l_LogRec.logMsg := 'Finished  clients';
            MIGR_LOG.LOG_INFO(l_LogRec);

          ELSE
            l_LogRec.logMsg := 'Skip Client Migration';
            MIGR_LOG.LOG_INFO(l_LogRec);
          END IF;

          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.IA_COMPLETED = 'Finished'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;

        ELSE

          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.IA_COMPLETED = 'Failed', Status = 'Failed', END_TIMESTAMP = SYSTIMESTAMP
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;
          IA_Status := 'INCOMPLETE';
        END IF;

      ELSE

        UPDATE MIG_MIGRATION_INFO mmi
          SET mmi.IA_COMPLETED = 'Failed', Status = 'Failed', END_TIMESTAMP = SYSTIMESTAMP
          WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;
        IA_Status := 'INCOMPLETE';

      END IF;

      ----Rejected policies in IA area will be inserted in MIGR_FAILED_POLICY
      FOR c IN (SELECT ip.IA_POLICY_REF, ip.IA_INSRPRD, ip.MIG_BATCH_ID, ip.IA_IDPL, ip.IA_INSR_TYPE
                  FROM IA_POLICY ip
                 WHERE ip.MIG_FLAG = 3
                   AND ip.MIG_BATCH_ID = l_LogRec.MIG_BATCH_ID
      )
      LOOP
        INSERT INTO MIGR_FAILED_POLICY ( POLICY_REF, CLIENT_ID, AGENT_ID, INSRPRD, POLICY_STEP, INS_DATE, INS_MS, MIG_BATCH_ID, POLICY_IDPL, ERROR_MESSAGE, MIG_START, MIG_END, OFFRNCODE )
        VALUES (c.IA_POLICY_REF, NULL, NULL, c.IA_INSRPRD, NULL, SYSDATE, NULL, c.MIG_BATCH_ID, c.IA_IDPL, 'Policy was rejected in IA area.', NULL, NULL, c.IA_INSR_TYPE);
      END LOOP;


      l_LogRec.logMsg := 'Finished IA processing';
      l_LogRec.migrRelTbl := '';
      l_LogRec.migrRelKey := '';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          IA_Status := 'INCOMPLETE';
          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.IA_COMPLETED = 'Failed', Status = 'Failed'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;

    END RUN_IA;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Clean up SA Xferred records

  PROCEDURE IA_CLEAN_UP_XFER(vMigrationBatchId IN VARCHAR2)
    AS
      vSQL        VARCHAR2(21000);
      L_ERRMSG    SRVERRMSG;
      L_SRVERRMSG SRVERRMSG;
      PIO_ERR     SRVERR;
       l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN

      -- +++ anb 2015-09-16 needs rework to include all SA_ tables and also to select IDPL from IA_POLICY, vMigBatchId
      --                    currently it assumes that SA_ has only BOAT policies.....
      NULL;

    ------      IA_UPD_SA_OLD('SA_KF100F', 1);
    ------      IA_UPD_SA_OLD('SA_KF108F', 1);
    ------      IA_UPD_SA_OLD('SA_KF109F', 1);
    ------      IA_UPD_SA_OLD('SA_KF125F', 1);
    ------      IA_UPD_SA_OLD('SA_KF165F', 1);
    ------      IA_UPD_SA_OLD('SA_KF210F', 1);
    ------      -- log Rejected Policies
    ------      MIGR_IA.IA_LOG_VOL('Intermediate', 'POLICY', 'Rejected', 'SA_KF100F', vMigrationBatchId);
    -----      --MIGR_IA.IA_LOG_POLICY_REJECT('POLICY', 'SA_KF100F');    -- Load rejected records (Policies) to MIG_DETAIL_ERROR_LOG
    ------      -- log Rejected Addresses
    ------      MIGR_IA.IA_LOG_VOL('Intermediate', 'ADDRESS', 'Rejected', 'SA_KF100F', vMigrationBatchId);
    -----      --MIGR_IA.IA_LOG_POLICY_REJECT('ADDRESS', 'SA_KF100F');    -- Load rejected records (Policies) to MIG_DETAIL_ERROR_LOG
    ------      -- log Rejected Clients
    ------      MIGR_IA.IA_LOG_VOL('Intermediate', 'CLIENT', 'Rejected', 'SA_KF100F', vMigrationBatchId);
    ------      --MIGR_IA.IA_LOG_POLICY_REJECT('CLIENT', 'SA_KF100F');    -- Load rejected records (Policies) to MIG_DETAIL_ERROR_LOG
    ------      -- log Rejected Agents
    ------      MIGR_IA.IA_LOG_VOL('Intermediate', 'AGENTS', 'Rejected', 'SA_KF100F', vMigrationBatchId);
    ------      --MIGR_IA.IA_LOG_POLICY_REJECT('AGENTS', 'SA_KF100F');    -- Load rejected records (Policies) to MIG_DETAIL_ERROR_LOG
    ------      -- log Rejected O_Ships
    ------      MIGR_IA.IA_LOG_VOL('Intermediate', 'O_SHIP', 'Rejected', 'SA_KF165F', vMigrationBatchId);
    ------      --MIGR_IA.IA_LOG_POLICY_REJECT('O_SHIP', 'SA_KF165F');    -- Load rejected records (Policies) to MIG_DETAIL_ERROR_LOG
    ------      --Update rest records as not migrated
    ------      UPDATE SA_KF100F
    ------        SET MIG_FLAG = 2
    ------        WHERE MIG_FLAG = 0
    ------        AND MIG_BATCH_ID = vMigrationBatchId;
    ------      UPDATE SA_KF125F
    ------        SET MIG_FLAG = 2
    ------        WHERE MIG_FLAG = 0
    ------        AND MIG_BATCH_ID = vMigrationBatchId;
    ------      UPDATE SA_KF165F
    ------        SET MIG_FLAG = 2
    ------        WHERE MIG_FLAG = 0
    ------        AND MIG_BATCH_ID = vMigrationBatchId;

    EXCEPTION
      WHEN OTHERS THEN

              l_LogRec.mig_batch_id:= '0-2';
              l_LogRec.migrArea      :=   'IA CLEAN_UP XFER' ;
              l_LogRec.migrStep      :=   'MIGR_IA.IA_CLEAN_UP_XFER' ;
              l_LogRec.migrRelTbl    :=   NULL;
              l_LogRec.migrRelKey  :=   NULL;
              l_LogRec.logMsg        :=     SQLERRM   ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END IA_CLEAN_UP_XFER;


END MIGR_IA;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_INTERMEDIATE_OBJECTS
  AS
----------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE DROP_INTERMEDIATE_OBJECTS
    AS
      l_exists NUMBER;
      VSQL     VARCHAR2(200);
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN
      FOR C IN (SELECT *
          FROM ETL_MIGR_MAPS_INTERMEDIATE
          WHERE IS_ACTIVE = 'Y'
          ORDER BY ETL_ID ASC)
      LOOP
        SELECT COUNT('*')
          INTO l_exists
          FROM USER_ALL_TABLES uat
          WHERE uat.TABLE_NAME = C.TABLE_NAME;

        IF l_exists = 1
        THEN
          VSQL := 'DROP TABLE ' || C.TABLE_NAME;
          EXECUTE IMMEDIATE VSQL;
        END IF;

        SELECT COUNT('*')
          INTO l_exists
          FROM USER_ALL_TABLES uat
          WHERE uat.TABLE_NAME = C.VIEW_NAME;

        IF l_exists = 1
        THEN
          VSQL := 'DROP TABLE ' || C.VIEW_NAME;
          EXECUTE IMMEDIATE VSQL;
        END IF;

        SELECT COUNT('*')
          INTO l_exists
          FROM USER_VIEWS uat
          WHERE uat.VIEW_NAME = C.TABLE_NAME;

        IF l_exists = 1
        THEN
          VSQL := 'DROP VIEW ' || C.TABLE_NAME;
          EXECUTE IMMEDIATE VSQL;
        END IF;

        SELECT COUNT('*')
          INTO l_exists
          FROM USER_VIEWS uat
          WHERE uat.VIEW_NAME = C.VIEW_NAME;

        IF l_exists = 1
        THEN
          VSQL := 'DROP VIEW ' || C.VIEW_NAME;
          EXECUTE IMMEDIATE VSQL;
        END IF;

      END LOOP;
    EXCEPTION

      WHEN OTHERS THEN
              l_LogRec.mig_batch_id:= '0-0';
              l_LogRec.migrArea      :=   'DROP INTERMEDIATE OBJECTS' ;
              l_LogRec.migrStep      :=   'MIGR_INTERMEDIATE_OBJECTS.DROP_INTERMEDIATE_OBJECTS' ;
              l_LogRec.migrRelTbl    :=   NULL;
              l_LogRec.migrRelKey  :=   NULL;
              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM   ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;



    END DROP_INTERMEDIATE_OBJECTS;
----------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE CREATE_INTERMEDIATE_TABLES_OLD(p_table_type IN VARCHAR2)
    AS
      v_SQLERRM       VARCHAR2(2000);
      V_SQL           VARCHAR2(4000);
      V_SQL_SEL       VARCHAR2(4000);
      L_HST_CONDITION VARCHAR2(2000);
      v_Global        VARCHAR2(50);
      v_AS            VARCHAR2(50);
    l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN
      --      FOR C IN (SELECT * FROM ETL_MIGR_MAPS_INTERMEDIATE WHERE IS_ACTIVE = 'Y' ORDER BY ETL_ID ASC) LOOP
      --
      --        SELECT DECODE(C.HST_CONDITION,NULL,'  ',' AND ' || C.HST_CONDITION)  INTO L_HST_CONDITION  FROM DUAL;
      --
      --        IF C.SELECT_STMT IS NOT NULL   THEN
      --
      --          IF p_table_type ='TEMP' THEN
      --            V_SQL := ' CREATE GLOBAL TEMPORARY TABLE ' || C.TABLE_NAME || ' ON COMMIT PRESERVE ROWS AS ' || C.SELECT_STMT || ' WHERE  1=2';
      --          ELSE
      --            V_SQL := ' CREATE TABLE  ' || C.TABLE_NAME || ' AS ' || C.SELECT_STMT || ' WHERE  1=2';
      --          END IF;
      --
      --          EXECUTE IMMEDIATE V_SQL;
      --
      --        ELSE
      --
      --          V_SQL := ' SELECT ' || C.HST_FIELD_SELECT || ' FROM ' || C.HST_TABLE || ' WHERE rownum=1 AND is_active=''Y''' || L_HST_CONDITION;
      --
      --          EXECUTE IMMEDIATE V_SQL INTO V_SQL_SEL;
      --
      --          IF C.JOIN_STMT IS NULL  THEN
      --
      --            IF p_table_type ='TEMP' THEN
      --                V_SQL := ' CREATE GLOBAL TEMPORARY TABLE  ' || C.TABLE_NAME || ' ON COMMIT PRESERVE ROWS AS ' || V_SQL_SEL || ' AND 1=2';
      --
      --            ELSE
      --               V_SQL := ' CREATE TABLE  ' || C.TABLE_NAME || ' AS ' || V_SQL_SEL || ' AND 1=2';
      --            END IF;
      --
      --            EXECUTE IMMEDIATE V_SQL;
      --          ELSE
      --
      --            IF p_table_type ='TEMP' THEN
      --              V_SQL := ' CREATE GLOBAL TEMPORARY TABLE   ' || C.TABLE_NAME || ' ON COMMIT PRESERVE ROWS AS ' || REPLACE(C.JOIN_STMT, ':1', V_SQL_SEL) || ' WHERE  1=2';
      --            ELSE
      --              V_SQL := ' CREATE TABLE  ' || C.TABLE_NAME || ' AS ' || REPLACE(C.JOIN_STMT, ':1', V_SQL_SEL) || ' WHERE  1=2';
      --            END IF;
      --
      --            EXECUTE IMMEDIATE V_SQL;
      --          END IF;
      --        END IF;
      --      END LOOP;

      v_Global := ' TABLE ';
      v_AS := ' AS ';
      IF p_table_type = 'TEMP'
      THEN
        v_Global := ' GLOBAL TEMPORARY TABLE ';
        v_AS := ' ON COMMIT PRESERVE ROWS AS ';
      END IF;

      FOR C IN (SELECT *
          FROM ETL_MIGR_MAPS_INTERMEDIATE
          WHERE IS_ACTIVE = 'Y'
          ORDER BY ETL_ID ASC)
      LOOP

        SELECT DECODE(C.HST_CONDITION, NULL, '  ', ' AND ' || C.HST_CONDITION)
          INTO L_HST_CONDITION
          FROM DUAL;

        IF C.SELECT_STMT IS NOT NULL
        THEN
          V_SQL := ' CREATE ' || v_Global || C.TABLE_NAME || v_AS || C.SELECT_STMT || ' WHERE 1=2';
        ELSE

          V_SQL := ' SELECT ' || C.HST_FIELD_SELECT || ' FROM ' || C.HST_TABLE || ' WHERE rownum=1 AND is_active=''Y''' || L_HST_CONDITION;
          EXECUTE IMMEDIATE V_SQL
            INTO V_SQL_SEL;

          IF C.JOIN_STMT IS NULL
          THEN
            V_SQL := ' CREATE ' || v_Global || C.TABLE_NAME || v_AS || V_SQL_SEL || ' AND 1=2';
          ELSE
            V_SQL := ' CREATE ' || v_Global || C.TABLE_NAME || v_AS || REPLACE(C.JOIN_STMT, ':1', V_SQL_SEL) || ' WHERE  1=2';
          END IF;

        END IF;

        EXECUTE IMMEDIATE V_SQL;

      END LOOP;
    EXCEPTION

      WHEN OTHERS THEN
              l_LogRec.mig_batch_id:= '0-0';
              l_LogRec.migrArea      :=   'CREATE INTERMEDIATE OBJECTS' ;
              l_LogRec.migrStep      :=   'MIGR_INTERMEDIATE_OBJECTS.CREATE_INTERMEDIATE_TABLES' ;
              l_LogRec.migrRelTbl    :=   NULL;
              l_LogRec.migrRelKey  :=   NULL;
              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM   ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END CREATE_INTERMEDIATE_TABLES_OLD;
----------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------

--  PROCEDURE CREATE_INTERMEDIATE_TABLES(p_table_type IN VARCHAR2)
--    AS
--      v_SQLERRM       VARCHAR2(2000);
--      V_SQL           VARCHAR2(32000);
--      V_SQL_SEL       VARCHAR2(4000);
--      L_HST_CONDITION VARCHAR2(2000);
--      v_Global        VARCHAR2(50);
--      v_AS            VARCHAR2(50);
--      TYPE sql_rec IS RECORD (
--          sql_statement VARCHAR2(4000)
--        );
--      TYPE t_sql_type_tab IS TABLE OF sql_rec;
--      v_sql_tab       t_sql_type_tab;
--      vPrd            VARCHAR2(32000) := '';
--    l_LogRec MIGR_GVAR.LogRecTyp;
--    BEGIN
--
--      v_Global := ' TABLE ';
--      v_AS := ' AS ';
--
--      IF p_table_type = 'TEMP'
--      THEN
--        v_Global := ' GLOBAL TEMPORARY TABLE ';
--        v_AS := ' ON COMMIT PRESERVE ROWS AS ';
--      END IF;
--
--      FOR C IN (SELECT *
--          FROM ETL_MIGR_MAPS_INTERMEDIATE
--          WHERE IS_ACTIVE = 'Y'
--          ORDER BY ETL_ID ASC)
--      LOOP
--
--        l_LogRec.migrRelTbl    :=   C.TABLE_NAME ;
--
--        SELECT DECODE(C.HST_CONDITION, NULL, '  ', ' AND ' || C.HST_CONDITION)
--          INTO L_HST_CONDITION
--          FROM DUAL;
--
--        IF C.SELECT_STMT IS NOT NULL
--        THEN
--          V_SQL := ' CREATE ' || v_Global || C.TABLE_NAME || v_AS || C.SELECT_STMT || ' WHERE 1=2';
--          EXECUTE IMMEDIATE V_SQL;
--        ELSE
--          V_SQL := ' SELECT ' || C.HST_FIELD_SELECT || ' FROM ' || C.HST_TABLE || ' where is_active=''Y''' || L_HST_CONDITION;
--          vPrd := NULL;
--
--          EXECUTE IMMEDIATE V_SQL
--            BULK COLLECT INTO v_sql_tab;
--
--          FOR i IN 1 .. v_sql_tab.COUNT
--          LOOP
--
--            IF vPrd IS NOT NULL
--            THEN
--              vPrd := vPrd || ' UNION  ';
--            END IF;
--
--            vPrd := vPrd || v_sql_tab(i).sql_statement;
--
--          END LOOP;
--
--          IF C.JOIN_STMT IS NULL
--          THEN
--            V_SQL := ' CREATE ' || v_Global || C.TABLE_NAME || v_AS || vPrd;
--
--            EXECUTE IMMEDIATE V_SQL;
--          ELSE
--            V_SQL := ' CREATE    ' || v_Global || C.TABLE_NAME || v_AS || REPLACE(C.JOIN_STMT, ':1', vPrd);
--
--            EXECUTE IMMEDIATE V_SQL;
--          END IF;
--        END IF;
--
--      END LOOP;
--    EXCEPTION
--
--       WHEN OTHERS THEN
--              l_LogRec.mig_batch_id:= '0-0';
--              l_LogRec.migrArea      :=   'CREATE INTERMEDIATE OBJECTS' ;
--              l_LogRec.migrStep      :=   'MIGR_INTERMEDIATE_OBJECTS.CREATE_INTERMEDIATE_TABLES' ;
--              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM   ;
--              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
--
--
--    END CREATE_INTERMEDIATE_TABLES;
----------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------

--valex.6/3/2017 - discounts tables are created by a large number of select stmnt unions, over 32K character length. A varchar variable cannot store such as string, so CLOB datatype is selected as applicable.
  PROCEDURE CREATE_INTERMEDIATE_TABLES(p_table_type IN VARCHAR2)
    AS
      v_SQLERRM       VARCHAR2(2000);
      V_SQL           VARCHAR2(32000);
      L_HST_CONDITION VARCHAR2(2000);
      v_Global        VARCHAR2(50);
      v_AS            VARCHAR2(50);
      l_join_with_policy VARCHAR2(32000);

     TYPE sql_rec IS RECORD (
          sql_statement VARCHAR2(4000)
          ,where_clause VARCHAR2(4000)
          ,where_clause2 VARCHAR2(4000)
        );
      TYPE t_sql_type_tab IS TABLE OF sql_rec;
      v_sql_tab       t_sql_type_tab;
      vPrd            VARCHAR2(32000) := '';
    l_LogRec MIGR_GVAR.LogRecTyp;
    l_clob clob;
    l_clob1 clob;
    l_clob2 clob;
    l_temp_clob clob;
    v_offset number;
    v_clob_length constant number := 2000;      -- +++ anb 2018-11-09  smaller size chunks for clob replace...
    l_CLOBLogRec       MIGR_GVAR.CLOBRecTyp;      -- +++ EZ 2019-02-26 clob logging
v_cnt number;
istart number;

   BEGIN
      l_CLOBLogRec.mig_batch_id := '000';  -- +++ EZ 2019-02-26
      l_CLOBLogRec.migrArea := 'CREATE_INTERMEDIATE_TABLES';  -- +++ EZ 2019-02-26

      v_Global := ' TABLE ';
      v_AS := ' AS ';

      IF p_table_type = 'TEMP'
      THEN
        v_Global := ' GLOBAL TEMPORARY TABLE ';
        v_AS := ' ON COMMIT PRESERVE ROWS AS ';
      END IF;

      FOR C IN (SELECT *
          FROM ETL_MIGR_MAPS_INTERMEDIATE
          WHERE IS_ACTIVE = 'Y'
            --and table_name = 'OFFER_QUESTIONS'--test
          ORDER BY ETL_ID ASC)
      LOOP
         begin

        l_clob:='  ';         --valex.6/3/2017 - lob fields should not be empty in order dbms_lob functions to work properly.

        l_LogRec.migrRelTbl    :=   C.TABLE_NAME ;

        SELECT DECODE(C.HST_CONDITION, NULL, '  ', ' AND ' || C.HST_CONDITION)
          INTO L_HST_CONDITION
          FROM DUAL;

        IF C.SELECT_STMT IS NOT NULL
        THEN
          V_SQL := ' CREATE ' || v_Global || C.TABLE_NAME || v_AS || C.SELECT_STMT || ' WHERE 1=2';
            l_CLOBLogRec.EVENT_CLOB  := V_SQL;                        -- +++ EZ 2019-02-26 debug
            MIGR_LOG.LOG_CLOB(l_CLOBLogRec);                          -- +++ EZ 2019-02-26 debug
          EXECUTE IMMEDIATE V_SQL;
        ELSE
          V_SQL := ' SELECT ' || C.HST_FIELD_SELECT || ', ' || NVL(c.HST_WHERE_CLAUSE,'null') ||', '  || NVL(c.HST_WHERE_CLAUSE2,'null')||' FROM ' || C.HST_TABLE || ' where is_active=''Y''' || L_HST_CONDITION;
          vPrd := NULL;
             l_CLOBLogRec.EVENT_CLOB  := V_SQL;                       -- +++ EZ 2019-02-26 debug
             MIGR_LOG.LOG_CLOB(l_CLOBLogRec);                         -- +++ EZ 2019-02-26 debug
          EXECUTE IMMEDIATE V_SQL
            BULK COLLECT INTO v_sql_tab;

          FOR i IN 1 .. v_sql_tab.COUNT
          LOOP

            IF l_clob <> '  '     --valex.6/3/2017 - if not in first iteration append UNION ALL
            THEN
                 dbms_lob.append(l_clob,TO_CLOB(' UNION  all '));
            END IF;


            if c.DISCOUNTS='Y' THEN
              if c.HST_WHERE_CLAUSE2 is not NULL THEN  -- object-level discounts
                  l_join_with_policy:=c.JOIN_TABLE || ' p on p.ia_idplps=kf125f.idplps ';
                  vPrd :=  REPLACE(v_sql_tab(i).sql_statement,':JOIN_POLICY',l_join_with_policy);
                  vPrd :=  REPLACE(vPrd,':PRODUCT',v_sql_tab(i).where_clause);
                  l_temp_clob := case WHEN v_sql_tab(i).where_clause2 IS NOT NULL THEN TO_CLOB(vPrd || ' and ia_object_type '||v_sql_tab(i).where_clause2) ELSE TO_CLOB(vPrd) END;
              else              -- policy-level discounts
                  vPrd := REPLACE(v_sql_tab(i).sql_statement,':PRODUCT',v_sql_tab(i).where_clause) ;
                  l_temp_clob := TO_CLOB(vPrd);
              END IF;

            else
                  l_temp_clob := TO_CLOB(v_sql_tab(i).sql_statement);
            end IF;
            dbms_lob.append(l_clob,l_temp_clob);

          END LOOP;

          IF C.JOIN_STMT IS NULL THEN
            l_clob1 :=TO_CLOB(' CREATE ' || v_Global || C.TABLE_NAME || v_AS ) ;
            dbms_lob.append(l_clob1,l_clob);
          ELSE
            l_clob1 := TO_CLOB(' CREATE    ' || v_Global || C.TABLE_NAME || v_AS);
             --l_clob2 := regexp_replace(TO_CLOB(C.JOIN_STMT), ':1', l_clob, 1, 1);   --replace first occurence of :1 with l_clob value
			      l_clob2 := TO_CLOB(C.JOIN_STMT);

            --KT 2018-10-05 we brake the clob into chunks
            for cloop in 0..ceil(dbms_lob.getlength(l_clob)/v_clob_length)-1 loop
                --offset is 1 for first loop
                v_offset := (cloop * v_clob_length)+1;
                --for the LAST loop we configure the offset giving the number of remained characters
                if cloop = ceil(dbms_lob.getlength(l_clob)/v_clob_length) then
                    v_offset := dbms_lob.getlength(l_clob)-(cloop-1)*v_clob_length;
                end if;
                --we get the CHUNK
                l_temp_clob := dbms_lob.substr(l_clob,v_clob_length,v_offset);--chunk 32k
                --if it's NOT the last loop then add the :1 symbol for the next replace
                if cloop < ceil(dbms_lob.getlength(l_clob)/v_clob_length)-1 then
                    dbms_lob.append(l_temp_clob,':1');
                end if;
                --replace
                migr_setup.lob_replace(l_clob2, ':1', l_temp_clob, 1,'cs');--KT 2018_08_09 regexp_replace doesn't work with clob having length more than 32k. migr_setup.lob_replace implements replace in large clobs.
                --
            end loop;

            dbms_lob.append(l_clob1,l_clob2);

          END IF;
             l_CLOBLogRec.EVENT_CLOB  := V_SQL;                        -- +++ EZ 2019-02-26 debug
             MIGR_LOG.LOG_CLOB(l_CLOBLogRec);                          -- +++ EZ 2019-02-26 debug
          EXECUTE IMMEDIATE l_clob1;

        END IF;
         exception
         WHEN OTHERS THEN
              l_LogRec.mig_batch_id:= '0-0';
              l_LogRec.migrArea      :=   'CREATE INTERMEDIATE OBJECTS' ;
              l_LogRec.migrStep      :=   'MIGR_INTERMEDIATE_OBJECTS.CREATE_INTERMEDIATE_TABLES' ;
              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM  || ' C.TABLE_NAME: ' || C.TABLE_NAME;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
         END;


      END LOOP;
    EXCEPTION

       WHEN OTHERS THEN
              l_LogRec.mig_batch_id:= '0-0';
              l_LogRec.migrArea      :=   'CREATE INTERMEDIATE OBJECTS' ;
              l_LogRec.migrStep      :=   'MIGR_INTERMEDIATE_OBJECTS.CREATE_INTERMEDIATE_TABLES' ;
              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM  ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END CREATE_INTERMEDIATE_TABLES;

----------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------

--  PROCEDURE CREATE_INTERMEDIATE_VIEWS
--    AS
--      v_SQLERRM       VARCHAR2(2000);
--      V_SQL           VARCHAR2(32000);
--      V_SQL_SEL       VARCHAR2(32000);
--      V_REPLACE_TABLE VARCHAR2(100);
--      L_HST_CONDITION VARCHAR2(2000);
--      TYPE sql_rec IS RECORD (
--          sql_statement VARCHAR2(4000)
--        );
--      TYPE t_sql_type_tab IS TABLE OF sql_rec;
--      v_sql_tab       t_sql_type_tab;
--      vPrd            VARCHAR2(32000) := '';
--    l_LogRec MIGR_GVAR.LogRecTyp;
--    BEGIN
--
--      FOR C IN (SELECT JOIN_STMT,
--                       UPPER(JOIN_TABLE) JOIN_TABLE,
--                       SELECT_STMT,
--                       UPPER(VIEW_NAME) VIEW_NAME,
--                       HST_FIELD_SELECT,
--                       HST_TABLE,
--                       HST_CONDITION
--          FROM ETL_MIGR_MAPS_INTERMEDIATE
--          WHERE IS_ACTIVE = 'Y'
--          ORDER BY ETL_ID ASC)
--      LOOP
--
--        SELECT DECODE(C.HST_CONDITION, NULL, '  ', ' AND ' || C.HST_CONDITION)
--          INTO L_HST_CONDITION
--          FROM DUAL;
--
--        IF C.JOIN_TABLE IS NOT NULL
--        THEN
--          SELECT UPPER(VIEW_NAME)
--            INTO V_REPLACE_TABLE
--            FROM ETL_MIGR_MAPS_INTERMEDIATE
--            WHERE IS_ACTIVE = 'Y'
--              AND UPPER(TABLE_NAME) = C.JOIN_TABLE;
--        ELSE
--          V_REPLACE_TABLE := NULL;
--        END IF;
--        IF C.SELECT_STMT IS NOT NULL
--        THEN
--
--          V_SQL := 'CREATE OR REPLACE VIEW  ' || C.VIEW_NAME || '  AS ' || C.SELECT_STMT;
--
--          IF C.JOIN_TABLE IS NOT NULL
--          THEN
--            V_SQL := REPLACE(UPPER(V_SQL), C.JOIN_TABLE, V_REPLACE_TABLE);
--          END IF;
--
--          EXECUTE IMMEDIATE V_SQL;
--        ELSE
--          V_SQL := ' SELECT ' || C.HST_FIELD_SELECT || ' FROM ' || C.HST_TABLE || ' where is_active=''Y''' || L_HST_CONDITION;
--          vPrd := NULL;
--
--          EXECUTE IMMEDIATE V_SQL
--            BULK COLLECT INTO v_sql_tab;
--
--          FOR i IN 1 .. v_sql_tab.COUNT
--          LOOP
--
--            IF vPrd IS NOT NULL
--            THEN
--              vPrd := vPrd || ' UNION  ';
--            END IF;
--
--            --IF C.JOIN_STMT IS NULL  THEN
--            vPrd := vPrd || v_sql_tab(i).sql_statement;
--          --- ELSE   vPrd := vPrd || v_sql_tab(i).sql_statement;   END IF;
--
--          END LOOP;
--
--          IF C.JOIN_STMT IS NULL
--          THEN
--
--            V_SQL := ' CREATE OR REPLACE VIEW  ' || C.VIEW_NAME || ' AS ' || vPrd;
--
--            IF C.JOIN_TABLE IS NOT NULL
--            THEN
--              V_SQL := REPLACE(UPPER(V_SQL), C.JOIN_TABLE, V_REPLACE_TABLE);
--            END IF;
--
--            EXECUTE IMMEDIATE V_SQL;
--          ELSE
--            V_SQL := ' CREATE OR REPLACE VIEW   ' || C.VIEW_NAME || '  AS ' || REPLACE(C.JOIN_STMT, ':1', vPrd);
--            IF C.JOIN_TABLE IS NOT NULL
--            THEN
--              V_SQL := REPLACE(UPPER(V_SQL), C.JOIN_TABLE, V_REPLACE_TABLE);
--            END IF;
--
--            EXECUTE IMMEDIATE V_SQL;
--          END IF;
--        END IF;
--      END LOOP;
--    EXCEPTION
--
--
--      WHEN OTHERS THEN
--
--              l_LogRec.mig_batch_id:= '0-0';
--              l_LogRec.migrArea      :=   'CREATE INTERMEDIATE VIEWS' ;
--              l_LogRec.migrStep      :=   'MIGR_INTERMEDIATE_OBJECTS.CREATE_INTERMEDIATE_VIEWS' ;
--              l_LogRec.migrRelTbl    :=   NULL;
--              l_LogRec.migrRelKey  :=   NULL;
--              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(V_SQL, 1, 1500)   ;
--              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
--
--
--
--    END CREATE_INTERMEDIATE_VIEWS;

----------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------

--  FUNCTION POPULATE_INTERMEDIATE_TABLES(p_mig_batch_id IN VARCHAR2)
--    RETURN BOOLEAN
--    AS
--      v_allowed_products VARCHAR2(2100);
--      v_has_data         NUMBER;
--      V_SQL              VARCHAR2(4000);
--      v_SQLERRM          VARCHAR2(2000);
--      TYPE sql_rec IS RECORD (
--          sql_statement VARCHAR2(4000)
--        );
--      TYPE t_sql_type_tab IS TABLE OF sql_rec;
--      v_sql_tab          t_sql_type_tab;
--      L_HST_CONDITION    VARCHAR2(2000);
--    l_LogRec MIGR_GVAR.LogRecTyp;
--    BEGIN
--      v_allowed_products := MIGR_PROCESS.PROCESS_STEPS(p_mig_batch_id, NULL, NULL);
--
--     FOR C IN (SELECT *  FROM ETL_MIGR_MAPS_INTERMEDIATE  WHERE IS_ACTIVE = 'Y'   AND ',' || v_allowed_products || ',' like '%,' || INSRPRD || ',%'   ORDER BY ETL_ID ASC)
--      LOOP
--
--
--        v_has_data := 0;
--        --FA.20160606 Check if tables with 'ALL' products were filled by previous run
--        IF C.INSRPRD = 'ALL'  THEN
--
--          V_SQL := ' SELECT COUNT(''*'')  FROM  ' || C.TABLE_NAME || ' WHERE MIG_BATCH_ID = :P_MIG_BATCH_ID';
--          EXECUTE IMMEDIATE V_SQL INTO v_has_data  USING p_mig_batch_id;
--
--        END IF;
--
--        IF v_has_data = 0  THEN
--
--          SELECT DECODE(C.HST_CONDITION, NULL, '  ', ' AND ' || C.HST_CONDITION)  INTO L_HST_CONDITION   FROM DUAL;
--
--          IF C.SELECT_STMT IS NOT NULL   THEN
--   --valex.20/9/16 - append hint addition for redo amount reduction
----            V_SQL := ' insert into  ' || C.TABLE_NAME || '  ' || C.SELECT_STMT || ' WHERE MIG_BATCH_ID = :P_MIG_BATCH_ID';
--            V_SQL := ' insert /*+ append */ into  ' || C.TABLE_NAME || '  ' || C.SELECT_STMT || ' WHERE MIG_BATCH_ID = :P_MIG_BATCH_ID';
--   --valex.20/9/16 - end
--            EXECUTE IMMEDIATE V_SQL
--            USING p_mig_batch_id;
--            COMMIT;
--
--          ELSE
--            V_SQL := ' select ' || C.HST_FIELD_SELECT || ' FROM ' || C.HST_TABLE || ' where is_active=''Y''' || L_HST_CONDITION || '  AND '','' || APPLICABLE_BOLAGS || '','' like ''%,'' || :BOLAG_ID || '',%''';
--
--            EXECUTE IMMEDIATE V_SQL   BULK COLLECT INTO v_sql_tab   USING SUBSTR(p_mig_batch_id, 1, 2);
--            COMMIT;
--
--            FOR i IN 1 .. v_sql_tab.COUNT   LOOP
--
--              IF C.JOIN_STMT IS NULL   THEN
--            --valex.20/9/16 - append hint addition for redo amount reduction
--                -- V_SQL := ' insert into  ' || C.TABLE_NAME || '  ' || ' select * from (' || v_sql_tab(i).sql_statement || ' )  where mig_batch_id=  :p_mig_batch_id AND MIG_FLAG=''0''';
--                V_SQL := ' insert /*+ append */ into  ' || C.TABLE_NAME || '  ' || ' select * from (' || v_sql_tab(i).sql_statement || ' )  where mig_batch_id=  :p_mig_batch_id AND MIG_FLAG=''0''';
--            --valex.20/9/16 - end
--                EXECUTE IMMEDIATE V_SQL  USING p_mig_batch_id;
--                COMMIT;
--              ELSE
--            --valex.20/9/16 - append hint addition for redo amount reduction
--                --V_SQL := ' insert into  ' || C.TABLE_NAME || ' ' || REPLACE(C.JOIN_STMT, ':1', v_sql_tab(i).sql_statement) || ' and mig_batch_id = :p_mig_batch_id ';
--                V_SQL := ' insert /*+ append */ into  ' || C.TABLE_NAME || ' ' || REPLACE(C.JOIN_STMT, ':1', v_sql_tab(i).sql_statement) || ' and mig_batch_id = :p_mig_batch_id ';
--            --valex.20/9/16 - end
--                EXECUTE IMMEDIATE V_SQL
--                USING p_mig_batch_id;
--                COMMIT;
--              END IF;
--            END LOOP;
--          END IF;
--        END IF;
--      END LOOP;
--      COMMIT;
--
--      RETURN TRUE;
--    EXCEPTION
--       WHEN OTHERS THEN
--
--
--              l_LogRec.mig_batch_id:=p_mig_batch_id;
--              l_LogRec.migrArea      :=   'POPULATE INTERMEDIATE  TABLES VIEWS' ;
--              l_LogRec.migrStep      :=   'MIGR_INTERMEDIATE_OBJECTS.POPULATE_INTERMEDIATE_TABLES' ;
--              l_LogRec.migrRelTbl    :=   NULL;
--              l_LogRec.migrRelKey  :=   NULL;
--              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(V_SQL, 1, 1500)   ;
--              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
--
--
--          RETURN FALSE;
--    END POPULATE_INTERMEDIATE_TABLES;
----------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION POPULATE_INTERMEDIATE_TABLES(p_mig_batch_id IN VARCHAR2)
    RETURN BOOLEAN
    AS
      v_allowed_products VARCHAR2(2100);
      v_has_data         NUMBER;
      V_SQL              clob;

      v_SQLERRM          VARCHAR2(2000);
      TYPE sql_rec IS RECORD (
          sql_statement VARCHAR2(4000)
          ,where_clause VARCHAR2(4000)
          ,where_clause2 VARCHAR2(4000)
        );
      TYPE t_sql_type_tab IS TABLE OF sql_rec;
      v_sql_tab          t_sql_type_tab;
      L_HST_CONDITION    VARCHAR2(2000);
      l_LogRec           MIGR_GVAR.LogRecTyp;
      l_join_with_policy VARCHAR2(2000);
      l_CLOBLogRec       MIGR_GVAR.CLOBRecTyp;      -- +++ anb 2018-11-11 clob logging
--      v_count1           PLS_INTEGER;               -- +++ anb 2019-02-28 debug
--      v_count2           PLS_INTEGER;               -- +++ anb 2019-02-28 debug

    BEGIN

      l_CLOBLogRec.mig_batch_id := p_mig_batch_id;

      v_allowed_products := MIGR_PROCESS.PROCESS_STEPS(p_mig_batch_id, NULL, NULL);

     FOR C IN (SELECT *  FROM ETL_MIGR_MAPS_INTERMEDIATE  WHERE IS_ACTIVE = 'Y'   AND ',' || v_allowed_products || ',' like '%,' || INSRPRD || ',%'   ORDER BY ETL_ID ASC)
      LOOP

        -- +++ anb 2018-11-09 debug
        l_LogRec.logMsg := 'P.I.O-T:'||C.TABLE_NAME||' -INSRPD:'||C.INSRPRD;
        MIGR_LOG.LOG_INFO(l_LogRec);

        l_CLOBLogRec.migrStep    := C.INSRPRD;
        l_CLOBLogRec.migrRelTbl  := C.TABLE_NAME;

        -- +++ end anb 2018-11-09 debug

        v_has_data := 0;
        --FA.20160606 Check if tables with 'ALL' products were filled by previous run
        IF C.INSRPRD = 'ALL'  THEN

          V_SQL := to_clob(' SELECT COUNT(''*'')  FROM  ' || C.TABLE_NAME || ' WHERE MIG_BATCH_ID = :P_MIG_BATCH_ID');

          l_CLOBLogRec.EVENT_CLOB  := V_SQL;                        -- +++ anb 2018-11-09 debug
          MIGR_LOG.LOG_CLOB(l_CLOBLogRec);                          -- +++ anb 2018-11-09 debug
          EXECUTE IMMEDIATE V_SQL INTO v_has_data  USING p_mig_batch_id;

        END IF;

        IF v_has_data = 0  THEN

          SELECT DECODE(C.HST_CONDITION, NULL, '  ', ' AND ' || C.HST_CONDITION)  INTO L_HST_CONDITION   FROM DUAL;

          -- +++ anb 2018-11-09 debug
          l_LogRec.logMsg := 'P.I.O-T:'||C.TABLE_NAME||' -INSRPD:'||C.INSRPRD||' -HST_COND:'||L_HST_CONDITION||' -SEL:'||C.SELECT_STMT;
          MIGR_LOG.LOG_INFO(l_LogRec);
          -- +++ end anb 2018-11-09 debug


          IF C.SELECT_STMT IS NOT NULL   THEN

--            V_SQL := ' SELECT COUNT(''*'')  FROM ( ' ||C.SELECT_STMT || ' WHERE MIG_BATCH_ID = :P_MIG_BATCH_ID)';  -- +++ anb 2019-02-28 debug
--            EXECUTE IMMEDIATE V_SQL INTO v_count1  USING p_mig_batch_id;  -- +++ anb 2019-02-28 debug

            V_SQL := to_clob(' insert /*+ append */ into  ' || C.TABLE_NAME || '  ' || C.SELECT_STMT || ' WHERE MIG_BATCH_ID = :P_MIG_BATCH_ID');

            l_CLOBLogRec.EVENT_CLOB  := V_SQL;                        -- +++ anb 2018-11-09 debug
            MIGR_LOG.LOG_CLOB(l_CLOBLogRec);                          -- +++ anb 2018-11-09 debug

            EXECUTE IMMEDIATE V_SQL
            USING p_mig_batch_id;
            COMMIT;

--            V_SQL := ' SELECT COUNT(''*'')  FROM  '  ||C.TABLE_NAME || ' WHERE MIG_BATCH_ID = :P_MIG_BATCH_ID';  -- +++ anb 2019-02-28 debug
--            EXECUTE IMMEDIATE V_SQL INTO v_count2  USING p_mig_batch_id;  -- +++ anb 2019-02-28 debug

--           l_LogRec.logMsg := 'P.I.O-T:'||C.TABLE_NAME||' -INSRPD:'||C.INSRPRD||' -count1= '||v_count1||' -count2= '||v_count2;   -- +++ anb 2019-02-28 debug
--           MIGR_LOG.LOG_INFO(l_LogRec);                                                                                           -- +++ anb 2019-02-28 debug


          ELSE
            -- +++ anb 2018-11-09 debug
            l_LogRec.logMsg := 'P.I.O-T:'||C.TABLE_NAME||' -INSRPD:'||C.INSRPRD||' -WH:'||c.HST_WHERE_CLAUSE||' -WH2:'||c.HST_WHERE_CLAUSE2;
            MIGR_LOG.LOG_INFO(l_LogRec);
            -- +++ end anb 2018-11-09 debug


            V_SQL := to_clob(' select ' || C.HST_FIELD_SELECT || ', ' || NVL(c.HST_WHERE_CLAUSE,'null')||', ' || NVL(c.HST_WHERE_CLAUSE2,'null')|| ' FROM ' || C.HST_TABLE || ' where is_active=''Y''' || L_HST_CONDITION || '  AND '','' || APPLICABLE_BOLAGS || '','' like ''%,'' || :BOLAG_ID || '',%''');

            l_CLOBLogRec.EVENT_CLOB  := V_SQL;                        -- +++ anb 2018-11-09 debug
            MIGR_LOG.LOG_CLOB(l_CLOBLogRec);                          -- +++ anb 2018-11-09 debug

            EXECUTE IMMEDIATE V_SQL   BULK COLLECT INTO v_sql_tab   USING SUBSTR(p_mig_batch_id, 1, 2);
            COMMIT;
            FOR i IN 1 .. v_sql_tab.COUNT
              LOOP

                  -- +++ anb 2018-11-09 debug
                  l_LogRec.logMsg := 'P.I.O-T:'||C.TABLE_NAME||' -INSRPD:'||C.INSRPRD||' -JOIN:'||C.JOIN_STMT||' -DIS:'||c.DISCOUNTS;
                  MIGR_LOG.LOG_INFO(l_LogRec);

                  l_CLOBLogRec.EVENT_CLOB  := ' -JSTMT:'||C.JOIN_STMT||' -JTBL:'||C.JOIN_TABLE||'-vTBL:'
                                              ||v_sql_tab(i).sql_statement ||'-vWh:'||v_sql_tab(i).where_clause
                                              || '-Wh2:'||v_sql_tab(i).where_clause2
                                              || '-sql:'||v_sql_tab(i).sql_statement
                                              ||' -DIS:'||c.DISCOUNTS
                                              ;
                  MIGR_LOG.LOG_CLOB(l_CLOBLogRec);                          -- +++ anb 2018-11-09 debug
                  -- +++ end anb 2018-11-09 debug

                  IF C.JOIN_STMT IS NULL   THEN
                    V_SQL := to_clob(' insert /*+ append */ into  ' || C.TABLE_NAME || '  ' || ' select * from (' || v_sql_tab(i).sql_statement || ' )  where mig_batch_id=  :p_mig_batch_id AND MIG_FLAG=''0''');
                    if c.DISCOUNTS='Y' THEN
                      if c.HST_WHERE_CLAUSE2 is not NULL THEN-- object-level discounts
                          l_join_with_policy:=c.JOIN_TABLE || ' p on p.ia_idplps=kf125f.idplps ';
                          V_SQL :=  REPLACE(V_SQL,':JOIN_POLICY',l_join_with_policy);
                          V_SQL :=  REPLACE(V_SQL,':PRODUCT',v_sql_tab(i).where_clause);
                          V_SQL := case WHEN v_sql_tab(i).where_clause2 IS NOT NULL THEN V_SQL || ' and ia_object_type '||v_sql_tab(i).where_clause2 ELSE V_SQL END;
--                          migr_setup.lob_replace(V_SQL, ':JOIN_POLICY', l_join_with_policy, 1,'ci');--KT using clob for big queries 2018-10-10
--                          migr_setup.lob_replace(V_SQL, ':PRODUCT', v_sql_tab(i).where_clause, 1,'ci');--KT using clob for big queries 2018-10-10
--                          if v_sql_tab(i).where_clause2 IS NOT NULL THEN
--                                dbms_lob.append(V_SQL,' and ia_object_type '||v_sql_tab(i).where_clause2);--dbms_lob.append(V_SQL,x) is much faster than V_SQL || x
--                          end if;

                      else--policy-level discounts
                          V_SQL := REPLACE(V_SQL,':PRODUCT',v_sql_tab(i).where_clause);
--                          migr_setup.lob_replace(V_SQL, ':PRODUCT', v_sql_tab(i).where_clause, 1,'ci');--KT using clob for big queries 2018-10-10
                      END IF;
                    END IF;
                  ELSE
                    V_SQL := to_clob(' insert /*+ append */ into  ' || C.TABLE_NAME || ' ' || REPLACE(C.JOIN_STMT, ':1', v_sql_tab(i).sql_statement) || ' and mig_batch_id = :p_mig_batch_id ');
                  END IF;

                  l_CLOBLogRec.EVENT_CLOB  := V_SQL;                        -- +++ anb 2018-11-09 debug
                  MIGR_LOG.LOG_CLOB(l_CLOBLogRec);                          -- +++ anb 2018-11-09 debug

                  EXECUTE IMMEDIATE V_SQL USING p_mig_batch_id;
                  COMMIT;
              END LOOP;
          END IF;
        END IF;
      END LOOP;
      COMMIT;

      RETURN TRUE;
    EXCEPTION
       WHEN OTHERS THEN


              l_LogRec.mig_batch_id:=p_mig_batch_id;
              l_LogRec.migrArea      :=   'POPULATE INTERMEDIATE  TABLES VIEWS' ;
              l_LogRec.migrStep      :=   'MIGR_INTERMEDIATE_OBJECTS.POPULATE_INTERMEDIATE_TABLES' ;
              l_LogRec.migrRelTbl    :=   NULL;
              l_LogRec.migrRelKey  :=   NULL;
              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(to_char(V_SQL), 1, 1500);
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


          RETURN FALSE;
    END POPULATE_INTERMEDIATE_TABLES;


----------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------
  FUNCTION POPULATE_INTERMEDIATE_TABLE(p_LogRec IN MIGR_GVAR.LogRecTyp)
    RETURN BOOLEAN
    AS
      v_allowed_products VARCHAR2(2100);
      v_has_data         NUMBER;
      V_SQL              clob;

      v_SQLERRM          VARCHAR2(2000);
      TYPE sql_rec IS RECORD (
          sql_statement VARCHAR2(32000)
        );
      TYPE t_sql_type_tab IS TABLE OF sql_rec;
      v_sql_tab          t_sql_type_tab;
      L_HST_CONDITION    VARCHAR2(2000);

      l_LogRec           MIGR_GVAR.LogRecTyp;
  BEGIN
      l_LogRec := p_LogRec;

      v_allowed_products := MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id, NULL, NULL);

      FOR C IN (SELECT *
                  FROM ETL_MIGR_MAPS_INTERMEDIATE
                 WHERE 1=1
                   AND TABLE_NAME = l_LogRec.migrRelTbl
                   AND IS_ACTIVE = 'Y'
                   AND ',' || v_allowed_products || ',' like '%,' || INSRPRD || ',%'
      )
      LOOP
          v_has_data := 0;
          --FA.20160606 Check if tables with 'ALL' products were filled by previous run
          IF C.INSRPRD = 'ALL' THEN

             V_SQL := to_clob(' SELECT COUNT(''*'') FROM ' || C.TABLE_NAME || ' WHERE MIG_BATCH_ID = :P_MIG_BATCH_ID');--KT 2018-10-10
             EXECUTE IMMEDIATE V_SQL INTO v_has_data USING l_LogRec.mig_batch_id;

          END IF;

        IF v_has_data = 0  THEN

          SELECT DECODE(C.HST_CONDITION, NULL, '  ', ' AND ' || C.HST_CONDITION)  INTO L_HST_CONDITION   FROM DUAL;

          IF C.SELECT_STMT IS NOT NULL   THEN
            --valex.20/9/16 - append hint addition for redo amount reduction
            -- V_SQL := ' insert into  ' || C.TABLE_NAME || '  ' || C.SELECT_STMT || ' WHERE MIG_BATCH_ID = :P_MIG_BATCH_ID';
            V_SQL := to_clob(' insert /*+ append */ into  ' || C.TABLE_NAME || '  ' || C.SELECT_STMT || ' WHERE MIG_BATCH_ID = :P_MIG_BATCH_ID');
            --valex.20/9/16 - end
            EXECUTE IMMEDIATE V_SQL
            USING l_LogRec.mig_batch_id;
            COMMIT;

          ELSE
            V_SQL := to_clob(' select ' || C.HST_FIELD_SELECT || ' FROM ' || C.HST_TABLE || ' where is_active=''Y''' || L_HST_CONDITION || '  AND '','' || APPLICABLE_BOLAGS || '','' like ''%,'' || :BOLAG_ID || '',%''');

            EXECUTE IMMEDIATE V_SQL   BULK COLLECT INTO v_sql_tab   USING SUBSTR(l_LogRec.mig_batch_id, 1, 2);
            COMMIT;

            FOR i IN 1 .. v_sql_tab.COUNT   LOOP
              IF C.JOIN_STMT IS NULL   THEN
                --valex.20/9/16 - append hint addition for redo amount reduction
                -- V_SQL := ' insert into  ' || C.TABLE_NAME || '  ' || ' select * from (' || v_sql_tab(i).sql_statement || ' )  where mig_batch_id=  :p_mig_batch_id AND MIG_FLAG=''0''';
                V_SQL := to_clob(' insert /*+ append */ into  ' || C.TABLE_NAME || '  ' || ' select * from (' || v_sql_tab(i).sql_statement || ' )  where mig_batch_id=  :p_mig_batch_id AND MIG_FLAG=''0''');
                --valex.20/9/16 - end
                EXECUTE IMMEDIATE V_SQL  USING l_LogRec.mig_batch_id;
                COMMIT;
              ELSE
                --valex.20/9/16 - append hint addition for redo amount reduction
                --V_SQL := ' insert into  ' || C.TABLE_NAME || ' ' || REPLACE(C.JOIN_STMT, ':1', v_sql_tab(i).sql_statement) || ' and mig_batch_id = :p_mig_batch_id ';
                V_SQL := to_clob(' insert /*+ append */ into  ' || C.TABLE_NAME || ' ' || REPLACE(C.JOIN_STMT, ':1', v_sql_tab(i).sql_statement) || ' and mig_batch_id = :p_mig_batch_id ');
                --valex.20/9/16 - end
                EXECUTE IMMEDIATE V_SQL
                USING l_LogRec.mig_batch_id;
                COMMIT;
              END IF;
            END LOOP;
          END IF;
        END IF;
      END LOOP;

      COMMIT;

      RETURN TRUE;

  EXCEPTION
     WHEN OTHERS THEN
        l_LogRec.mig_batch_id := p_LogRec.mig_batch_id;
        l_LogRec.migrArea     := 'POPULATE INTERMEDIATE TABLE AND/OR VIEW';
        l_LogRec.migrStep     := 'MIGR_INTERMEDIATE_OBJECTS.POPULATE_INTERMEDIATE_TABLE';
        l_LogRec.migrRelKey   := NULL;
        l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM || '-' || SUBSTR(V_SQL, 1, 1500);
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);
        RETURN FALSE;

  END POPULATE_INTERMEDIATE_TABLE;
----------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------


 procedure CREATE_INTERMEDIATE_VIEWS
  as
      v_SQLERRM       VARCHAR2(2000);
      V_SQL           VARCHAR2(32000);

      V_REPLACE_TABLE VARCHAR2(100);
      L_HST_CONDITION VARCHAR2(32000);
      TYPE sql_rec IS RECORD (
          sql_statement VARCHAR2(4000)
          ,where_clause VARCHAR2(4000)
          ,where_clause2 VARCHAR2(4000)
        );
      TYPE t_sql_type_tab IS TABLE OF sql_rec;
      v_sql_tab       t_sql_type_tab;
      vPrd            VARCHAR2(32000) := '';
    l_LogRec MIGR_GVAR.LogRecTyp;
    l_join_with_policy VARCHAR2(2000);

    v_loop number;      --KT debug  11/9/2018
    v_rem number;       --KT debug  11/9/2018
    v_clob clob := ' '; --KT debug  11/9/2018

    BEGIN

      FOR C IN (SELECT JOIN_STMT,
                       UPPER(JOIN_TABLE) JOIN_TABLE,
                       SELECT_STMT,
                       UPPER(VIEW_NAME) VIEW_NAME,
                       HST_FIELD_SELECT,
                       HST_TABLE,
                       HST_CONDITION,
                       HST_WHERE_CLAUSE,
                       HST_WHERE_CLAUSE2,
                       DISCOUNTS
          FROM ETL_MIGR_MAPS_INTERMEDIATE
          WHERE IS_ACTIVE = 'Y'
          --20180917 VG not create views with IS_VIEW_ACTIVE='N'
          AND IS_VIEW_ACTIVE='Y'
           -- and view_name = 'V_VILLAHEM_QUESTIONS' --KT debug/testing
          ORDER BY ETL_ID ASC)
      LOOP

        SELECT DECODE(C.HST_CONDITION, NULL, '  ', ' AND ' || C.HST_CONDITION)
          INTO L_HST_CONDITION
          FROM DUAL;

        IF C.JOIN_TABLE IS NOT NULL
        THEN
          SELECT UPPER(VIEW_NAME)
            INTO V_REPLACE_TABLE
            FROM ETL_MIGR_MAPS_INTERMEDIATE
            WHERE IS_ACTIVE = 'Y'
              AND UPPER(TABLE_NAME) = C.JOIN_TABLE;
        ELSE
          V_REPLACE_TABLE := NULL;
        END IF;
        IF C.SELECT_STMT IS NOT NULL
        THEN

          V_SQL := 'CREATE OR REPLACE VIEW  ' || C.VIEW_NAME || '  AS ' || C.SELECT_STMT;


          IF C.JOIN_TABLE IS NOT NULL
          THEN
            V_SQL := REPLACE(UPPER(V_SQL), C.JOIN_TABLE, V_REPLACE_TABLE);
          END IF;

        ----------------------------KT debug  11/9/2018 ----------------------------
          /*  if lower(c.view_name) like lower('%V_VILLAHEM_QUESTIONS%') then
                v_clob := to_clob(V_SQL);
                select decode(REMAINDER(dbms_lob.getlength(v_clob),1000),0,0,1) into v_rem from dual;
                v_loop := (dbms_lob.getlength(v_clob)/1000)+v_rem;
                for yo in 1..v_loop loop
                      l_LogRec.mig_batch_id:= '0-0';
                      l_LogRec.migrArea      :=   'CREATE INTERMEDIATE VIEWS' ;
                      l_LogRec.migrStep      :=   'MIGR_INTERMEDIATE_OBJECTS.CREATE_INTERMEDIATE_VIEWS - debug V_VILLAHEM_QUESTIONS'||yo ;
                      l_LogRec.migrRelTbl    :=   NULL;
                      l_LogRec.migrRelKey    :=   NULL;
                      l_LogRec.logMsg        :=   DBMS_LOB.SUBSTR (v_clob,1000,((yo-1)*1000)+1);
                      MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
                end loop;
            end if;

            v_clob := to_clob(V_SQL);
            v_rem := dbms_lob.getlength(v_clob);
            if v_rem > 31000 then
                      l_LogRec.logMsg        :=  'view name: '||c.view_name||' with length: '||v_rem;
                      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                      continue;
            end if;

        ----------------------------KT debug----------------------------
        */
          EXECUTE IMMEDIATE V_SQL;
        ELSE
          V_SQL := ' SELECT ' || C.HST_FIELD_SELECT || ', ' || NVL(c.HST_WHERE_CLAUSE,'null') ||', '  || NVL(c.HST_WHERE_CLAUSE2,'null')||' FROM ' || C.HST_TABLE || ' where is_active=''Y''' || L_HST_CONDITION;
          vPrd := NULL;

          EXECUTE IMMEDIATE V_SQL
            BULK COLLECT INTO v_sql_tab;

          FOR i IN 1 .. v_sql_tab.COUNT
          LOOP

            IF vPrd IS NOT NULL
            THEN
              vPrd := vPrd || ' UNION  ';
            END IF;

            if c.DISCOUNTS='Y' THEN
              if c.HST_WHERE_CLAUSE2 is not NULL THEN  -- object-level discounts
                  l_join_with_policy:=c.JOIN_TABLE || ' p on p.ia_idplps=kf125f.idplps ';
                  vPrd :=  REPLACE(v_sql_tab(i).sql_statement,':JOIN_POLICY',l_join_with_policy);
                  vPrd :=  REPLACE(vPrd,':PRODUCT',v_sql_tab(i).where_clause);
                 -- vPrd := vPrd || ' and ia_object_type '||v_sql_tab(i).where_clause2;
                  vPrd := case WHEN v_sql_tab(i).where_clause2 IS NOT NULL THEN vPrd || ' and ia_object_type '||v_sql_tab(i).where_clause2 ELSE vPrd END;
              else              -- policy-level discounts
                  vPrd := REPLACE(v_sql_tab(i).sql_statement,':PRODUCT',v_sql_tab(i).where_clause) ;
              END IF;
            else
              vPrd := vPrd ||   v_sql_tab(i).sql_statement ;
            end IF;

          END LOOP;

          IF C.JOIN_STMT IS NULL
          THEN

            V_SQL := ' CREATE OR REPLACE VIEW  ' || C.VIEW_NAME || ' AS ' || vPrd;

            IF C.JOIN_TABLE IS NOT NULL
            THEN
              V_SQL := REPLACE(UPPER(V_SQL), C.JOIN_TABLE, V_REPLACE_TABLE);
            END IF;

            EXECUTE IMMEDIATE V_SQL;
          ELSE
            V_SQL := ' CREATE OR REPLACE VIEW   ' || C.VIEW_NAME || '  AS ' || REPLACE(C.JOIN_STMT, ':1', vPrd);
            IF C.JOIN_TABLE IS NOT NULL
            THEN
              V_SQL := REPLACE(UPPER(V_SQL), C.JOIN_TABLE, V_REPLACE_TABLE);
            END IF;

            EXECUTE IMMEDIATE V_SQL;
          END IF;
        END IF;
      END LOOP;
    EXCEPTION


      WHEN OTHERS THEN

              l_LogRec.mig_batch_id:= '0-0';
              l_LogRec.migrArea      :=   'CREATE INTERMEDIATE VIEWS' ;
              l_LogRec.migrStep      :=   'MIGR_INTERMEDIATE_OBJECTS.CREATE_INTERMEDIATE_VIEWS' ;
              l_LogRec.migrRelTbl    :=   NULL;
              l_LogRec.migrRelKey  :=   NULL;
              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(V_SQL, 1, 1500)   ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;



    END CREATE_INTERMEDIATE_VIEWS;

----------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_INTERMEDIATE_OBJECTS;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_LA_SA
  AS
  -------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE fill_SA_B_PRSN(p_migrBatchId IN  varchar2)
  AS
  l_LogRec      MIGR_GVAR.LogRecTyp;
  vsql VARCHAR2(200);

  begin
   l_LogRec.migrStep := 'Second Phase of Staging area';
   l_LogRec.logMsg := '';
   l_LogRec.mig_batch_id:=p_migrBatchId;
   l_LogRec.migrArea := 'MIGR_LA_SA.FILL_SA_B_PRSN';

   vsql:='SELECT * from RLG_LOCK_TBL WHERE tbl=''SA_B_PRSN'' FOR UPDATE';
   execute IMMEDIATE vsql;

   MERGE INTO SA_B_PRSN t
   USING (
--        WITH union_DATA AS (
--
--                        SELECT distinct LPAD(CAST(PENRs AS NvarCHAR2(2)),2,'0') || LPAD(CAST(PENR AS NvarCHAR2(10)),10,'0') as G_EGN, LPAD(CAST(PENR AS NvarCHAR2(10)),10,'0') AS penr, LPAD(CAST(PENRs AS NvarCHAR2(2)),2,'0') AS penrs,'KF100F' as origin  --, NAMN,NAMNI
---- LM - 20170309 - JOIN SA_B_PRSN.PENR with the rest SA_KF TABLES should be replaced with the source PENR and PENRS (use PENR_SRC not the converted PENR with leading zeroes)
--                         ,PENR AS PENR_SRC, PENRS AS PENRS_SRC
--                         FROM SA_KF100F
--                         where 1=1
--                         AND MIG_BATCH_ID=p_migrBatchId
--                          and PENRS in (18,19,20)
--                          and regexp_like(penr,'^[0-9]{1,}$')
--                            UNION ALL
--                         SELECT distinct LPAD(CAST(PENRs AS NvarCHAR2(2)),2,'0') || LPAD(CAST(PENR AS NvarCHAR2(10)),10,'0') as G_EGN, LPAD(CAST(PENR AS NvarCHAR2(10)),10,'0') AS penr, LPAD(CAST(PENRs AS NvarCHAR2(2)),2,'0') AS penrs,'KF170F' as origin --,NAMN,NAMNI
--                         ,PENR AS PENR_SRC, PENRS AS PENRS_SRC
--                         FROM SA_KF170F
--                         where 1=1
--                         AND MIG_BATCH_ID=p_migrBatchId
--                          and PENRS in (18,19,20)
--                          and regexp_like(penr,'^[0-9]{1,}$')
--                            UNION ALL
--                         SELECT distinct LPAD(CAST(PENRs AS NvarCHAR2(2)),2,'0') || LPAD(CAST(PENR AS NvarCHAR2(10)),10,'0') as G_EGN, LPAD(CAST(PENR AS NvarCHAR2(10)),10,'0') AS penr, LPAD(CAST(PENRs AS NvarCHAR2(2)),2,'0') AS penrs,'KF221F' as origin --,NAMN,NAMNI
--                         ,PENR AS PENR_SRC, PENRS AS PENRS_SRC
--                         FROM SA_KF221F
--                         where 1=1
--                         AND MIG_BATCH_ID=p_migrBatchId
--                          AND PENRS in (18,19,20)
--                          and regexp_like(penr,'^[0-9]{1,}$')
--                            UNION ALL
--                         SELECT distinct LPAD(CAST(olpNs AS NvarCHAR2(2)),2,'0') || LPAD(CAST(olpnr AS NvarCHAR2(10)),10,'0') as G_EGN,LPAD(CAST(olpnr AS NvarCHAR2(10)),10,'0') AS penr, LPAD(CAST(olPNs AS NvarCHAR2(2)),2,'0') AS penrs, 'KF152F' as origin --,OLNAM AS NAMN,OLNAI as NAMNI
--                         ,OLPNR AS PENR_SRC, OLPNS AS PENRS_SRC
--                         FROM SA_KF152F
--                         where 1=1
--                           AND MIG_BATCH_ID=p_migrBatchId
--                           AND OLPNS in (18,19,20)
--                           and regexp_like(olpnr,'^[0-9]{1,}$')
----                            UNION ALL
----                         SELECT distinct CAST(mfpns AS NCHAR(2)) || CAST(mfpnr AS NCHAR(10)) as G_EGN, CAST(mfpnr AS NCHAR(10)) AS penr, CAST(mfpns AS NCHAR(2)) AS penrs,'KF110F' as origin --,MFNAM as NAMN,MFNAI as NAMNI
----                         FROM SA_KF110F
----                         where 1=1
----                          and MIG_BATCH_ID=p_migrBatchId
----                          AND mfPNS in (19,20)
--                            )
--                            ,extra_flds as (
--                                             select g_egn
--                                             , penr
--                                             , penrs
--                                             , origin
--                                            -- LM - 20170309 - use the source PENR and PENRS - start
--                                             , PENR_SRC
--                                             , PENRS_SRC
--                                            -- LM - 20170309 - end
--                                             , DECODE(LENGTH(UD.PENR),10,(CASE WHEN CAST(SUBSTR(UD.PENR , 3, 2) AS NUMBER(2, 0)) > 12 THEN 1 ELSE 0 END),10) AS IA_Company
--                                             , DECODE(LENGTH(UD.PENR),10,(CASE WHEN UD.PENRS IN ('18','19', '20') THEN 1 ELSE 0 END), 10) as Century_OK
--                                             , DECODE(LENGTH(PENR),10,(case WHEN CAST (PENRS || SUBSTR(PENR, 1, 2) AS NUMBER(4,0)) >= (SELECT EXTRACT(YEAR FROM SYSDATE) FROM DUAL) then 0 ELSE 1 END),10 )  as Year_OK
--                                             , DECODE(LENGTH(UD.PENR),10,(CASE WHEN CAST(SUBSTR(UD.PENR, 3, 2) AS number(2,0)) BETWEEN 1 AND 12 THEN 1 ELSE 0 END),10 ) AS Month_OK
--                                             , DECODE(LENGTH(UD.PENR),10,(CASE WHEN CAST(SUBSTR(UD.PENR, 5, 2) AS number(2,0)) BETWEEN 1 AND 31 THEN 1 ELSE 0 END),10 ) AS Day_ok
--                                             , DECODE(LENGTH(UD.PENR), 10,
--                                                  (CASE WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
--                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2)
--                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END)
--                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 32 AND 59) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
--                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (TO_NUMBER(SUBSTR(UD.PENR, 5, 2)) - 30)
--                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 30), 'YYYY-MM-DD') ELSE NULL END)
--                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 92 AND 99) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
--                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 90)
--                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 90), 'YYYY-MM-DD') ELSE NULL END)
--                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 61 AND 91) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
--                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 60)
--                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 60), 'YYYY-MM-DD') ELSE NULL END)
--                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS = '18')  AND  (SUBSTR(UD.PENR, 1, 2) <> 10)
--                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2)
--                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END)
--                                                        WHEN (UD.PENRS = '18')  AND  (SUBSTR(UD.PENR, 1, 2) = 10)
--                                                            THEN to_date('1810-01-01','YYYY-MM-DD')
--                                                        ELSE NULL END), to_date('9999-12-31','YYYY-MM-DD')) as IA_BIRTH_DATE
--                                             , DECODE(LENGTH(UD.PENR),10,(CASE WHEN CAST(SUBSTR(UD.PENR,3,2) AS NUMBER(2,0)) > 12 THEN 10
--                                                       ELSE (CASE WHEN SUBSTR(UD.penr,9,1) IN ('0','2','4','6','8')
--                                               THEN 2 ELSE 1 END)
--                                              -- ELSE  (CASE mod(SUBSTR(cte.penr,9,1),2)  when 0 THEN 2 ELSE 1 END)
--                                                    END),10) AS IA_SEX
--                                             ,FLOOR(MONTHS_BETWEEN(SYSDATE,(DECODE(LENGTH(UD.PENR), 10,
--                                                  (CASE WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
--                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2)
--                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END)
--                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 32 AND 59) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
--                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (TO_NUMBER(SUBSTR(UD.PENR, 5, 2)) - 30)
--                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 30), 'YYYY-MM-DD') ELSE NULL END)
--                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 92 AND 99) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
--                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 90)
--                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 90), 'YYYY-MM-DD') ELSE NULL END)
--                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 61 AND 91) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
--                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 60)
--                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 60), 'YYYY-MM-DD') ELSE NULL END)
--                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS = '18')  AND  (SUBSTR(UD.PENR, 1, 2) <> 10)
--                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2)
--                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END)
--                                                        WHEN (UD.PENRS = '18')  AND  (SUBSTR(UD.PENR, 1, 2) = 10)
--                                                            THEN to_date('1810-01-01','YYYY-MM-DD')
--                                                        ELSE NULL END), to_date('9999-12-31','YYYY-MM-DD')))) / 12) AS ia_age
--                                             , 0 AS MIG_FLAG
--                                             , MM.MIGRATION_BATCH_ID AS MIG_BATCH_ID
--                                             , SYSTIMESTAMP AS MIG_TIMESTAMP
--                                             from union_data ud,
--                                                (select MIGRATION_BATCH_ID
--                                                 from MIG_MIGRATION_INFO
--                                                   WHERE STATUS='Running'
--                                                   AND MIGRATION_BATCH_ID=p_migrBatchId
--                                                ) mm
--                                           )
    WITH union_DATA AS (

-- MB - 20181003 - Concatenate KF100F.FFR with KF100F.FFM in order to get the RENEWAL DATE
                        SELECT distinct LPAD(CAST(KF100F.PENRs AS NvarCHAR2(2)),2,'0') || LPAD(CAST(KF100F.PENR AS NvarCHAR2(10)),10,'0') as G_EGN, LPAD(CAST(KF100F.PENR AS NvarCHAR2(10)),10,'0') AS penr, LPAD(CAST(KF100F.PENRs AS NvarCHAR2(2)),2,'0') AS penrs,'KF100F' as origin  --, NAMN,NAMNI
                         ,KF100F.PENR AS PENR_SRC, KF100F.PENRS AS PENRS_SRC, KF100F.FFR || substr('00'||KF100F.FFM, -2) AS RENW_DATE                                                                                                                                                                    -- Renewal Date
                         FROM SA_KF100F KF100F
                         where 1=1
                         AND KF100F.MIG_BATCH_ID= p_migrBatchId
                          and KF100F.PENRS in (18,19,20)
                          and regexp_like(KF100F.penr,'^[0-9]{1,}$')
                            UNION ALL
                         SELECT distinct LPAD(CAST(KF170F.PENRs AS NvarCHAR2(2)),2,'0') || LPAD(CAST(KF170F.PENR AS NvarCHAR2(10)),10,'0') as G_EGN, LPAD(CAST(KF170F.PENR AS NvarCHAR2(10)),10,'0') AS penr, LPAD(CAST(KF170F.PENRs AS NvarCHAR2(2)),2,'0') AS penrs,'KF170F' as origin --,NAMN,NAMNI
                         ,KF170F.PENR AS PENR_SRC, KF170F.PENRS AS PENRS_SRC, (SELECT  KF100F.FFR ||  substr('00'||KF100F.FFM, -2) FROM SA_KF100F KF100F WHERE KF100F.IDPL = KF170F.IDPL) AS RENW_DATE                                                                                                   -- Renewal Date
                         FROM SA_KF170F KF170F
                         where 1=1
                         AND KF170F.MIG_BATCH_ID=p_migrBatchId
                          and KF170F.PENRS in (18,19,20)
                          and regexp_like(KF170F.penr,'^[0-9]{1,}$')
                            UNION ALL
                         SELECT distinct LPAD(CAST(KF221F.PENRs AS NvarCHAR2(2)),2,'0') || LPAD(CAST(KF221F.PENR AS NvarCHAR2(10)),10,'0') as G_EGN, LPAD(CAST(KF221F.PENR AS NvarCHAR2(10)),10,'0') AS penr, LPAD(CAST(KF221F.PENRs AS NvarCHAR2(2)),2,'0') AS penrs,'KF221F' as origin --,NAMN,NAMNI
                         ,KF221F.PENR AS PENR_SRC, KF221F.PENRS AS PENRS_SRC, (SELECT  KF100F.FFR || substr('00'||KF100F.FFM, -2) FROM SA_KF100F KF100F WHERE KF100F.IDPL = KF221F.IDPL) AS RENW_DATE                                                                                                    -- Renewal Date
                         FROM SA_KF221F KF221F
                         where 1=1
                         AND KF221F.MIG_BATCH_ID= p_migrBatchId
                          AND KF221F.PENRS in (18,19,20)
                          and regexp_like(KF221F.penr,'^[0-9]{1,}$')
                            UNION ALL
                         SELECT distinct LPAD(CAST(KF152F.olpNs AS NvarCHAR2(2)),2,'0') || LPAD(CAST(KF152F.olpnr AS NvarCHAR2(10)),10,'0') as G_EGN,LPAD(CAST(KF152F.olpnr AS NvarCHAR2(10)),10,'0') AS penr, LPAD(CAST(KF152F.olPNs AS NvarCHAR2(2)),2,'0') AS penrs, 'KF152F' as origin --,OLNAM AS NAMN,OLNAI as NAMNI
                         ,KF152F.OLPNR AS PENR_SRC, KF152F.OLPNS AS PENRS_SRC, (SELECT  KF100F.FFR || substr('00'||KF100F.FFM, -2) FROM SA_KF100F KF100F WHERE KF100F.IDPL = KF152F.IDPL) AS RENW_DATE                                                                                                     -- Renewal Date
                         FROM SA_KF152F KF152F
                         where 1=1
                           AND KF152F.MIG_BATCH_ID= p_migrBatchId
                           AND KF152F.OLPNS in (18,19,20)
                           and regexp_like(KF152F.olpnr,'^[0-9]{1,}$')
--                            UNION ALL
--                         SELECT distinct CAST(mfpns AS NCHAR(2)) || CAST(mfpnr AS NCHAR(10)) as G_EGN, CAST(mfpnr AS NCHAR(10)) AS penr, CAST(mfpns AS NCHAR(2)) AS penrs,'KF110F' as origin --,MFNAM as NAMN,MFNAI as NAMNI
--                         FROM SA_KF110F
--                         where 1=1
--                          and MIG_BATCH_ID=p_migrBatchId
--                          AND mfPNS in (19,20)
                            )
                            ,extra_flds as (
                                             select g_egn
                                             , penr
                                             , penrs
                                             , origin
                                            -- LM - 20170309 - use the source PENR and PENRS - start
                                             , PENR_SRC
                                             , PENRS_SRC
                                            -- LM - 20170309 - end
                                             , DECODE(LENGTH(UD.PENR),10,(CASE WHEN CAST(SUBSTR(UD.PENR , 3, 2) AS NUMBER(2, 0)) > 12 THEN 1 ELSE 0 END),10) AS IA_Company
                                             , DECODE(LENGTH(UD.PENR),10,(CASE WHEN UD.PENRS IN ('18','19', '20') THEN 1 ELSE 0 END), 10) as Century_OK
                                            -- MB - 20180103 - we use the fields KF100F.FFR and KF100F.FFM (renewal date) instead of SYSDATE in order to check if the birth year of the insured person is ok
                                             , DECODE(LENGTH(PENR),10,(case WHEN CAST (PENRS || SUBSTR(PENR, 1, 4) AS NUMBER(10,0)) > RENW_DATE  then 0 ELSE 1 END),10 )  as Year_OK
                                             , DECODE(LENGTH(UD.PENR),10,(CASE WHEN CAST(SUBSTR(UD.PENR, 3, 2) AS number(2,0)) BETWEEN 1 AND 12 THEN 1 ELSE 0 END),10 ) AS Month_OK
                                             , DECODE(LENGTH(UD.PENR),10,(CASE WHEN CAST(SUBSTR(UD.PENR, 5, 2) AS number(2,0)) BETWEEN 1 AND 31 THEN 1 ELSE 0 END),10 ) AS Day_ok
                                             , DECODE(LENGTH(UD.PENR), 10,
                                                  (CASE WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2)
                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END)
                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 32 AND 59) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (TO_NUMBER(SUBSTR(UD.PENR, 5, 2)) - 30)
                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 30), 'YYYY-MM-DD') ELSE NULL END)
                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 92 AND 99) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 90)
                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 90), 'YYYY-MM-DD') ELSE NULL END)
                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 61 AND 91) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 60)
                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 60), 'YYYY-MM-DD') ELSE NULL END)
                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS = '18')  AND  (SUBSTR(UD.PENR, 1, 2) <> 10)
                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2)
                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END)
                                                        WHEN (UD.PENRS = '18')  AND  (SUBSTR(UD.PENR, 1, 2) = 10)
                                                            THEN to_date('1810-01-01','YYYY-MM-DD')
                                                        ELSE NULL END), to_date('9999-12-31','YYYY-MM-DD')) as IA_BIRTH_DATE
                                             , DECODE(LENGTH(UD.PENR),10,(CASE WHEN CAST(SUBSTR(UD.PENR,3,2) AS NUMBER(2,0)) > 12 THEN 10
                                                       ELSE (CASE WHEN SUBSTR(UD.penr,9,1) IN ('0','2','4','6','8')
                                               THEN 2 ELSE 1 END)
                                              -- ELSE  (CASE mod(SUBSTR(cte.penr,9,1),2)  when 0 THEN 2 ELSE 1 END)
                                                    END),10) AS IA_SEX
                                             ,FLOOR(MONTHS_BETWEEN(SYSDATE,(DECODE(LENGTH(UD.PENR), 10,
                                                  (CASE WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2)
                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END)
                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 32 AND 59) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (TO_NUMBER(SUBSTR(UD.PENR, 5, 2)) - 30)
                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 30), 'YYYY-MM-DD') ELSE NULL END)
                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 92 AND 99) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 90)
                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 90), 'YYYY-MM-DD') ELSE NULL END)
                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 61 AND 91) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS IN ('19', '20'))
                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 60)
                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 60), 'YYYY-MM-DD') ELSE NULL END)
                                                        WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND (UD.PENRS = '18')  AND  (SUBSTR(UD.PENR, 1, 2) <> 10)
                                                            THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2)
                                                                      THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END)
                                                        WHEN (UD.PENRS = '18')  AND  (SUBSTR(UD.PENR, 1, 2) = 10)
                                                            THEN to_date('1810-01-01','YYYY-MM-DD')
                                                        ELSE NULL END), to_date('9999-12-31','YYYY-MM-DD')))) / 12) AS ia_age
                                             , 0 AS MIG_FLAG
                                             , MM.MIGRATION_BATCH_ID AS MIG_BATCH_ID
                                             , SYSTIMESTAMP AS MIG_TIMESTAMP
                                             from union_data ud,
                                                (select MIGRATION_BATCH_ID
                                                 from MIG_MIGRATION_INFO
                                                   WHERE STATUS='Running'
                                                   AND MIGRATION_BATCH_ID=p_migrBatchId
                                                ) mm
                                           )
                                           SELECT * FROM extra_flds
                                           PIVOT( MIN(ORIGIN) FOR ORIGIN IN('KF100F' as KF100F,'KF170F' as KF170F,'KF221F' as KF221F,'KF152F' as KF152F/*,'KF110F' as KF110F*/))
      )S
      ON (t.G_EGN = s.G_EGN)
      WHEN MATCHED THEN
      UPDATE SET t.kf100f=nvl(s.kf100f,t.kf100f)
               , t.kf170f=nvl(s.kf170f,t.kf170f)
               , t.kf221f=nvl(s.kf221f,t.kf221f)
               , t.kf152f=nvl(s.kf152f,t.kf152f)
      WHEN NOT MATCHED THEN
        insert (t.G_EGN, t.PENR, t.PENRS,/* t.IA_FNAME, t.IA_FULL_NAME, t.IA_GNAME, t.IA_SNAME,*/ t.IA_COMPANY, t.CENTURY_OK, t.YEAR_OK, t.MONTH_OK, t.DAY_OK, t.IA_BIRTH_DATE, t.IA_AGE, t.IA_SEX, t.kf100f,t.kf170f, t.kf221f,t.kf152f,/*,t.kf110f*/ t.MIG_FLAG,t.MIG_BATCH_ID, t.MIG_TIMESTAMP )
     -- LM - 20170309 - use the source PENR and PENRS - start
        --values (s.G_EGN, s.PENR, s.PENRS,/* s.IA_FNAME, s.IA_FULL_NAME, s.IA_GNAME, s.IA_SNAME, */s.IA_COMPANY, s.CENTURY_OK, s.YEAR_OK, s.MONTH_OK, s.DAY_OK, s.IA_BIRTH_DATE, s.IA_AGE, s.IA_SEX, s.kf100f,s.kf170f, s.kf221f,s.kf152f,/*s.kf110f*/ s.MIG_FLAG,s.MIG_BATCH_ID, s.MIG_TIMESTAMP );
        values (s.G_EGN, s.PENR_SRC, s.PENRS_SRC,/* s.IA_FNAME, s.IA_FULL_NAME, s.IA_GNAME, s.IA_SNAME, */s.IA_COMPANY, s.CENTURY_OK, s.YEAR_OK, s.MONTH_OK, s.DAY_OK, s.IA_BIRTH_DATE, s.IA_AGE, s.IA_SEX, s.kf100f,s.kf170f, s.kf221f,s.kf152f,/*s.kf110f*/ s.MIG_FLAG,s.MIG_BATCH_ID, s.MIG_TIMESTAMP );
     -- LM - 20170309 - end
      COMMIT;
    EXCEPTION WHEN OTHERS THEN
          l_LogRec.logMsg := SQLERRM || ' sql:' || vsql;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END fill_SA_B_PRSN;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE fill_SA_B_ADDRESS(p_migrBatchId IN  varchar2)
  AS
  l_LogRec      MIGR_GVAR.LogRecTyp;
  vsql VARCHAR2(2500);
  v_fields VARCHAR2(1000);

begin

   l_LogRec.migrStep := 'Second Phase of Staging area';
   l_LogRec.logMsg := '';
   l_LogRec.mig_batch_id:=p_migrBatchId;
   l_LogRec.migrArea := 'MIGR_LA_SA.FILL_SA_B_ADDRESS';

   v_fields:=MIGR_SETUP.fetch_attr('B_ADDRESS',TRUE,TRUE,FALSE,TRUE);

  vsql:='insert INTO SA_B_address '
      || ' with cte AS (SELECT idpl,FSTBS,FSTNR,FSTL,MIG_FLAG,MIG_BATCH_ID,MIG_TIMESTAMP '
             || '       FROM SA_KF109F '
          || '          where MIG_BATCH_ID= :BatchId) '
  || '  , transposed as ( '
   || '                        SELECT * FROM cte '
           || '                PIVOT( MIN(FSTL) FOR FSTBS IN(''F'' as FSTBS_F,''P'' as FSTBS_P,''G'' as FSTBS_G,''Q'' AS FSTBS_Q))) '
                  || ' sELECT ' || v_fields || ' FROM transposed';
  EXECUTE IMMEDIATE vsql USING p_migrBatchId;


  EXCEPTION WHEN OTHERS THEN
        l_LogRec.logMsg := SQLERRM || ' sql:' || vsql;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END fill_SA_B_ADDRESS ;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  ------------------------ STAGING AREA ROW COUNT ---------------------------------------------
  PROCEDURE LOG_MIG_ANAL_ROW_COUNT_SA(p_LogRec MIGR_GVAR.LogRecTyp)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
      vSQL         VARCHAR2(32000);
      l_dest_table ETL_ENGINE.DEST_TABLE % TYPE;
      l_LogRec     MIGR_GVAR.LogRecTyp;
    BEGIN
      l_LogRec := p_LogRec;
      l_LogRec.migrArea := 'MIGR_LA_SA.LOG_MIG_ANAL_ROW_COUNT_SA';
      SELECT ee.DEST_TABLE
        INTO l_dest_table
        FROM ETL_ENGINE ee
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(l_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = l_LogRec.migrRelTbl
          AND ee.MIGRATION_AREA = 'Staging';

      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS
          (MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME)
          SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID,
            SYSTIMESTAMP AS LOG_TIMESTAMP,'
      || CHR(39) || 'Staging' || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_dest_table || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Accepted' || CHR(39) || ' AS STATUS, '
      || 'MVA.CNT AS VOLUME
          FROM (
                SELECT  MIGRATION_BATCH_ID
                FROM MIG_MIGRATION_INFO
                WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || l_LogRec.mig_batch_id || CHR(39) || ' ) MMI,
            (SELECT COUNT(*) AS CNT
              FROM ' || l_dest_table || CHR(10)
      || ' WHERE MIG_MUTUAL_ID = ' || CHR(39) || SUBSTR(l_LogRec.mig_batch_id, 1, 2) || CHR(39) || CHR(10)
      || 'AND MIG_FLAG = 0) MVA'
      ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_MIG_ANAL_ROW_COUNT_SA;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA. 20170323 Always set record's migr_step prior to porcedure execution
  FUNCTION INSERT_RECORDS_IN_HISTORY_SA(p_LogRec MIGR_GVAR.LogRecTyp, p_Status in varchar2)
    RETURN BOOLEAN
    AS
      vSQL            VARCHAR2(32000);
      v_srcDumplCond  VARCHAR2(4000);
      l_LogRec        MIGR_GVAR.LogRecTyp;
      l_DEST_TABLE    ETL_ENGINE.DEST_TABLE % TYPE;
      l_FIELD_LIST    ETL_ENGINE.FIELD_LIST % TYPE;
      l_ADDFLDS       ETL_ENGINE.ADDFLDS % TYPE;
      l_PK_LIST       ETL_ENGINE.PK_LIST % TYPE;
      l_SOURCE_TABLE  ETL_ENGINE.SOURCE_TABLE % TYPE;
      l_srcDupl       NUMBER;
      v_avtdt         VARCHAR2(10);
    BEGIN
      l_LogRec := p_LogRec;
      l_LogRec.migrArea := 'MIGR_LA_SA.INSERT_RECORDS_IN_HISTORY_SA';
      v_srcDumplCond :='';
      -- l_LogRec.logMsg := SQLERRM || l_LogRec.migrRelTbl  ||  ' ' || l_LogRec.migrStep;
      -- MIGR_LOG.LOG_iNfo(l_LogRec);
      SELECT ee.DEST_TABLE,
             ee.FIELD_LIST,
             ee.ADDFLDS,
             ee.PK_LIST,
             ee.SOURCE_TABLE
        INTO l_DEST_TABLE,
             l_FIELD_LIST,
             l_ADDFLDS,
             l_PK_LIST,
             l_SOURCE_TABLE
        FROM ETL_ENGINE ee
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(l_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = l_LogRec.migrRelTbl
          AND ee.MIGRATION_AREA = l_LogRec.migrStep; --'Staging';

      SELECT TO_CHAR(trunc(RENEWAL_DATE) ,'YYYYMMDD'    ) INTO v_avtdt
       FROM (SELECT *   FROM ETL_MIGRATION_CONDITIONS   WHERE 1=1      and ITERATION_STATUS='Pending'   oRDER by id)
      where ROWNUM=1;

           ---Check if table contain avtdt column in pk list in order to use it to exclude duplicates
      SELECT COUNT('*') INTO l_srcDupl FROM  ETL_TBL_DEF WHERE ',' ||    (PK3||','||PK4||','|| PK5) || ',' like '%,' ||'AVTDT' || ',%' and TBLNAME =  l_LogRec.migrRelTbl   ;
       if   l_srcDupl =1 then
             v_srcDumplCond := ' AND AVTDT= '  || CHR(39) ||  v_avtdt ||  CHR(39);

       end if;

------EZ 16/4/2019 CRs related to MIG_POL-discount solution
--Legacy File KF117F must include an extra record which will provide a Date which is older than the RenewalMonthYear and a value which represents the Old Premium MIGG
--In LA_Mxx_KF117F tables, policies with older date in KF117F.AVDT field had mig flag=0. In order to continue all records into SA_xxx tables we make the following change:
--In ETL_TBL_DEF table: For field TBLNAME=KF117F we have set NUM_KEYS=2 and PK3=null
------EZ 16/4/2019 END


      ---FA. 20160331 Bulk collect change for performance improvement
      vSQL := 'DECLARE '
      || ' CURSOR KF is '
      || '    SELECT ' || l_FIELD_LIST || l_ADDFLDS    -- ,''  as POLICY_REF,'' as IDPL,'' as IDPLPS,'' as IDPLPSDT,'' as IDPLPSDTP5,'' as MIG_FLAG,systimestamp as MIG_TIMESTAMP,'' AS mig_batch_id
      || ' FROM ' || l_DEST_TABLE || '; '
      || ' TYPE KF_tab IS TABLE OF KF%ROWTYPE; '
      || ' KF_all_records   KF_tab:= KF_tab(); '
      || 'BEGIN '
      || 'SELECT DISTINCT ' || l_FIELD_LIST || l_PK_LIST || ', 0 AS MIG_FLAG, MMI.MIGRATION_BATCH_ID AS MIG_BATCH_ID,'
      || 'SYSTIMESTAMP AS MIG_TIMESTAMP, ' || CHR(39) || SUBSTR(l_LogRec.mig_batch_id, 1, 2) || CHR(39) || ' AS MIG_MUTUAL_ID '
      || ' BULK COLLECT INTO KF_all_records '
      || 'FROM '
      || '(SELECT *'
      || ' FROM ' || l_SOURCE_TABLE
      || ' WHERE MIG_FLAG = 0'
      ||  v_srcDumplCond
      || '  ) TL, '
      || '(SELECT MIGRATION_BATCH_ID '
      || ' FROM MIG_MIGRATION_INFO '
      || ' WHERE STATUS = ' || CHR(39) || p_Status || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || l_LogRec.mig_batch_id || CHR(39) || ') MMI;'

      || '  FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT '
      || '    INSERT INTO ' || l_DEST_TABLE || ' VALUES KF_all_records(i); '
      || 'END; ';

      EXECUTE IMMEDIATE vSQL;

      COMMIT;

      RETURN TRUE;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM ||' '||l_SOURCE_TABLE  ||  ' ' ||l_DEST_TABLE;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          RETURN FALSE;

  END INSERT_RECORDS_IN_HISTORY_SA;

--------------------------------------------------------------------
--------------------------------------------------------------------

function landing_extra_where(p_LogRec MIGR_GVAR.LogRecTyp)
  RETURN VARCHAR2 IS
  v_date varchar2(20);
  v_extra_where varchar2(2100);
  l_LogRec MIGR_GVAR.LogRecTyp;
  begin
      l_LogRec := p_LogRec;
      v_extra_where :=NULL;
      FOR c IN (SELECT ee.EXTRA_WHERE1, ee.EXTRA_WHERE2,TO_CHAR(rd.RENEWAL_DATE, 'DD/MM/YYYY') as renewal_dt
        FROM ETL_ENGINE ee ,  (with x AS (SELECT renewal_date
                                          FROM ETL_MIGRATION_CONDITIONS
                                          WHERE 1=1
                                            and ITERATION_STATUS='Pending'
                                          oRDER by id )
                                SELECT RENEWAL_DATE
                                FROM x
                                where ROWNUM=1) rd
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(l_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = l_LogRec.migrRelTbl
          AND ee.MIGRATION_AREA = 'Landing'
             )
      loop

            v_extra_where := c.EXTRA_WHERE1;

      end loop;

      return v_extra_where;

  EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
  end landing_extra_where;
  --------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------
  FUNCTION INSERT_RECORDS_IN_HISTORY(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2, p_renewal in date)
    RETURN BOOLEAN
    AS
      vSQL               VARCHAR2(32000);
      l_LogRec           MIGR_GVAR.LogRecTyp;
    ---     v_date DATE:=p_renewal;

    BEGIN
      l_LogRec := p_LogRec;

      l_LogRec.migrArea := 'MIGR_LA_SA.INSERT_RECORDS_IN_HISTORY';

      l_LogRec.logMsg:='Inserting Data in Landing area for batch: '|| l_LogRec.mig_batch_id  ||' and Renewal Date: ' || to_char(p_renewal,'yyyy-mm-dd' );
      MIGR_LOG.LOG_INFO(l_LogRec)  ;

       FOR cRec IN (SELECT ee.DEST_TABLE
                                ,ee.FIELD_LIST
                                ,ee.ADDFLDS
                                ,ee.PK_LIST
                                ,ee.SOURCE_TABLE
                                ,ee.JOIN_CONDITION
                                ,ee.NOMATCH1
                                ,ee.BOLAG_NAME
                                ,ee.TBLNAME
                                ,ee.iot_fields
                                ,ee.PK_LIST_with_tbl_identifier
                                ,ee.IOT_TABLE
                                ,ee.IOT_JOIN_CONDITION
                                ,ee.IOT_MATCH
                                ,ee.IOT_NULL_FIELDS
                                ,ee.EXIST_IN_LA_TBL
                                ,ee.FIELD_LIST1
                                ,etd.FILE_ROLE
                                ,ee.MASTER_LOAD_TBL
                                ,ee.master_load_join_condition
                             --   ee.ADDFLDS1
                               -- (CASE WHEN etd.file_role<>'Reconciliation' THEN 'LA_'||BOLAG_NAME||'_KF100F_IOT' ELSE '(select ''1'' as KF_TABLE from dual)' end)AS kf_IOT,
                                --(CASE WHEN  etd.tblname='KF100F' THEN 1 ELSE 0 END ) AS seq
                FROM ETL_ENGINE ee,MIG_MIGRATION_INFO mmi,etl_tbl_def etd
                WHERE 1 = 1
                  and ee.BOLAG_ID=mmi.BOLAG_ID
                  AND mmi.STATUS = p_Status --'Running'
                  AND mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id
                  AND ee.MIGRATION_AREA = l_LogRec.migrStep --'Landing'
                  and ee.tblname=etd.TBLNAME
                  AND ee.TBLNAME = l_LogRec.migrRelTbl
      )
--valex.3/11/2016 - end
      LOOP


     vSQL := 'INSERT /*+ append */ INTO ' || cRec.DEST_TABLE || '(' || cRec.FIELD_LIST || cRec.ADDFLDS || ') '
           || 'SELECT DISTINCT ' || cRec.FIELD_LIST || cRec.PK_LIST || ', 0 AS MIG_FLAG,'''||l_LogRec.mig_batch_id||''' AS MIG_BATCH_ID,'
           || 'SYSTIMESTAMP AS MIG_TIMESTAMP '
           || ' FROM '
           || '(SELECT TL.*'
           || ' FROM ' || cRec.SOURCE_TABLE || ' TL'
           || ' LEFT OUTER JOIN  ' ||CREC.exist_in_la_tbl || ' TH ' || cRec.JOIN_CONDITION
           || '   LEFT JOIN '||cRec.IOT_TABLE || ' TI ' || cRec.IOT_JOIN_CONDITION
        -- || '     JOIN ' || crec.MASTER_LOAD_tbl || ' ML ' || cRec.MASTER_LOAD_JOIN_CONDITION
      --FA.20170907 All KF files will be archived at phase 1 completion so _LOAD will be either empty or have next;s exctraction 's data. No check for MD_DISCOUNTS
           || case when CREC.tblname<>'BR161F'  AND   CREC.tblname<>'MD_DISCOUNTS'     THEN ' JOIN ' || crec.MASTER_LOAD_tbl || ' ML ' || cRec.MASTER_LOAD_JOIN_CONDITION else NULL end
       ---20171117      || case when CREC.FILE_ROLE <> 'Reconciliation' and CREC.tblname<>'BR161F'    AND CREC.tblname<>'MD_DISCOUNTS'  THEN ' = ' ||'to_date('''||p_renewal||''',''yyyy-mm-dd'')' else null END
            || case when CREC.FILE_ROLE <> 'Reconciliation' and CREC.tblname<>'BR161F'    AND CREC.tblname<>'MD_DISCOUNTS'  THEN ' = :1 '  else null END

           || '  WHERE (' || cRec.NOMATCH1 || ')and (' || CREC.IOT_MATCH||') '
           || case WHEN CREC.FILE_ROLE = 'Discounts' THEN ' and TL.policy_id is not null ' ELSE NULL END
           || ' )';


         ---FA.20171117 Fix bug caused by the  to_date an already date parameter. Oracle implicitly converted the date to varchar and this depends on session parameters
        IF   CREC.FILE_ROLE <> 'Reconciliation' and CREC.tblname<>'BR161F'  AND CREC.tblname<>'MD_DISCOUNTS'  THEN
               EXECUTE IMMEDIATE vSQL using p_renewal;
        ELSE
               EXECUTE IMMEDIATE vSQL;

        END IF;

        COMMIT;


      IF CREC.FILE_ROLE <> 'Reconciliation' then
          vSQL := 'INSERT /*+ append */ INTO ' || cRec.DEST_TABLE || '_IOT(' || cRec.IOT_FIELDS ||')'
           || 'SELECT DISTINCT ' || cRec.IOT_FIELDS
           || ' FROM ' ||cRec.DEST_TABLE
           || ' where mig_batch_id='''||l_LogRec.mig_batch_id||'''';

           EXECUTE IMMEDIATE vSQL;
           COMMIT;

      END IF;
--valex.3/11/2016 - end

      END LOOP;
      RETURN TRUE;
    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          RETURN FALSE;
    END INSERT_RECORDS_IN_HISTORY;
  --------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_NON_MATCH(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2)
    AS
      vSQL         VARCHAR2(32000);

      l_DEST_TABLE ETL_ENGINE.DEST_TABLE % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      SELECT ee.DEST_TABLE
        INTO l_DEST_TABLE
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF etd
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND etd.TBLNAME = p_LogRec.migrRelTbl
          AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = p_LogRec.migrStep --'Landing'
          AND not(ee.TBLNAME like 'NP%')  --valex.20/4/16 exclude NP427F from process
      ;

      --Log MIG_VOLUMETRIC_ANALYSIS - No matching Records (Accepted)
      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS '
      || '(MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME) '
      || ' SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID, '
      || ' SYSTIMESTAMP AS LOG_TIMESTAMP, '
      || CHR(39) || p_LogRec.migrStep || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_DEST_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Accepted' || CHR(39) || ' AS STATUS, '
      || ' MVA.CNT AS VOLUME '
      || ' FROM '
      || '     (SELECT MIGRATION_BATCH_ID '
      || '  FROM MIG_MIGRATION_INFO '
      || '  WHERE STATUS = ' || CHR(39) || p_Status || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || p_LogRec.mig_batch_id || CHR(39) || ') MMI, '
      || ' (SELECT COUNT(*) AS CNT '
      || '  FROM ' || l_DEST_TABLE || ' THIST'
      || '  WHERE MIG_FLAG = 0) MVA';

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;

    END LOG_MIG_VOL_ANAL_NON_MATCH;
  ----------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_VOL_ANAL_NON_MATCH_LA(p_LogRec MIGR_GVAR.LogRecTyp)
    AS
      vSQL         VARCHAR2(32000);


      l_DEST_TABLE ETL_ENGINE.DEST_TABLE % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      SELECT ee.DEST_TABLE
        INTO l_DEST_TABLE
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF etd
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND etd.TBLNAME = p_LogRec.migrRelTbl
          AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = 'Landing'
          AND not(ee.TBLNAME like 'NP%')  --valex.20/4/16 exclude NP427F from process
      ;


      --Log MIG_VOLUMETRIC_ANALYSIS - No matching Records (Accepted)
      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS '
      || '(MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME) '
      || ' SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID, '
      || ' SYSTIMESTAMP AS LOG_TIMESTAMP, '
      || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_DEST_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Accepted' || CHR(39) || ' AS STATUS, '
      || ' MVA.CNT AS VOLUME '
      || ' FROM '
      || '     (SELECT MIGRATION_BATCH_ID '
      || '  FROM MIG_MIGRATION_INFO '
      || '  WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || p_LogRec.mig_batch_id || CHR(39) || ') MMI, '
      || ' (SELECT COUNT(*) AS CNT '
      || '  FROM ' || l_DEST_TABLE || ' THIST'
      || '  WHERE MIG_FLAG = 0) MVA';

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;

    END LOG_MIG_VOL_ANAL_NON_MATCH_LA;
  ----------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_VOL_ANAL_MATCHING(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2)
    AS
      vSQL           VARCHAR2(32000);

      l_DEST_TABLE   ETL_ENGINE.DEST_TABLE % TYPE;
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      l_PK1          ETL_TBL_DEF.PK1 % TYPE;
      l_PK2          ETL_TBL_DEF.PK2 % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      SELECT ee.DEST_TABLE,
             ee.SOURCE_TABLE,
             td.PK1,
             td.PK2
        INTO l_DEST_TABLE,
             l_SOURCE_TABLE,
             l_PK1,
             l_PK2
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF td
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND td.TBLNAME = p_LogRec.migrRelTbl
          AND NVL(td.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = p_LogRec.migrStep --'Landing'
          AND not(ee.TBLNAME like 'NP%')  --valex.20/4/16 exclude NP427F from process
      ;

      --Log MIG_VOLUMETRIC_ANALYSIS - Matching Records
      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS '
      || '(MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME) '
      || ' SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID, '
      || ' SYSTIMESTAMP AS LOG_TIMESTAMP, '
      || CHR(39) || p_LogRec.migrStep || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_DEST_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Rejected' || CHR(39) || ' AS STATUS, '
      || ' MVA.CNT AS VOLUME '
      || '   FROM '
      || '  (SELECT MIGRATION_BATCH_ID '
      || '   FROM MIG_MIGRATION_INFO '
      || '   WHERE STATUS = ' || CHR(39) || p_Status || CHR(39) || ' AND MIGRATION_BATCH_ID = ' || CHR(39) || p_LogRec.mig_batch_id || CHR(39) || ') MMI, '
      || '  (SELECT COUNT(*) AS CNT '
      || '   FROM ' || l_SOURCE_TABLE || ' TLOAD'
      || '        INNER JOIN ' || l_DEST_TABLE || ' THIST'
      || '           ON TLOAD.' || l_PK1 || ' = THIST.' || l_PK1
      || '          AND TLOAD.' || l_PK2 || ' = THIST.' || l_PK2 || ') MVA'
      ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_MIG_VOL_ANAL_MATCHING;
  -----------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_VOL_ANAL_MATCHING_LA(p_LogRec MIGR_GVAR.LogRecTyp)
    AS
      vSQL           VARCHAR2(32000);

      l_DEST_TABLE   ETL_ENGINE.DEST_TABLE % TYPE;
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      l_PK1          ETL_TBL_DEF.PK1 % TYPE;
      l_PK2          ETL_TBL_DEF.PK2 % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      SELECT ee.DEST_TABLE,
             ee.SOURCE_TABLE,
             td.PK1,
             td.PK2
        INTO l_DEST_TABLE,
             l_SOURCE_TABLE,
             l_PK1,
             l_PK2
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF td
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND td.TBLNAME = p_LogRec.migrRelTbl
          AND NVL(td.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = 'Landing'
          AND not(ee.TBLNAME like 'NP%')  --valex.20/4/16 exclude NP427F from process
      ;


      --Log MIG_VOLUMETRIC_ANALYSIS - Matching Records
      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS '
      || '(MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME) '
      || ' SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID, '
      || ' SYSTIMESTAMP AS LOG_TIMESTAMP, '
      || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_DEST_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Rejected' || CHR(39) || ' AS STATUS, '
      || ' MVA.CNT AS VOLUME '
      || '   FROM '
      || '  (SELECT MIGRATION_BATCH_ID '
      || '   FROM MIG_MIGRATION_INFO '
      || '   WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || p_LogRec.mig_batch_id || CHR(39) || ') MMI, '
      || '  (SELECT COUNT(*) AS CNT '
      || '   FROM ' || l_SOURCE_TABLE || ' TLOAD'
      || '        INNER JOIN ' || l_DEST_TABLE || ' THIST'
      || '            ON TLOAD.' || l_PK1 || ' = THIST.' || l_PK1
      || '            AND TLOAD.' || l_PK2 || ' = THIST.' || l_PK2 || ') MVA'
      ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_MIG_VOL_ANAL_MATCHING_LA;

  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_MATCHING_RECORDS(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2)
    AS
      vSQL           VARCHAR2(32000);

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      FOR c IN (SELECT ee.SOURCE_TABLE,
                etd.PK1,
                etd.PK2,
                ee.DEST_TABLE,
                ee.EXIST_IN_LA_TBL,
                ee.JOIN_CONDITION
                FROM ETL_ENGINE ee,
                     ETL_TBL_DEF etd
                WHERE 1 = 1
                  AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
                  AND ee.TBLNAME = p_LogRec.migrRelTbl
                  AND etd.TBLNAME = p_LogRec.migrRelTbl
                  AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
                  AND ee.MIGRATION_AREA = 'Landing'
                  AND not(ee.TBLNAME like 'NP%')  --valex.20/4/16 exclude NP427F from process
      )
      loop

          --Log matching records (already loaded) to MIG_DETAIL_ERROR_LOG
          vSQL := 'INSERT INTO MIG_DETAIL_ERROR_LOG '
          || '(MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY) '
          || ' SELECT ''' || p_LogRec.mig_batch_id ||''', '
          || ' SYSTIMESTAMP AS ERROR_TIMESTAMP, '
          || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
          || CHR(39) || 'Critical Error' || CHR(39) || ' AS ERROR_TYPE, '
          || CHR(39) || 'Record has already been migrated' || CHR(39) || ' AS ERROR_MESSAGE, '
          || CHR(39) || 'Transfering from _LOAD to historical tables' || CHR(39) || ' AS MIGRATION_STEP, '
          || CHR(39) || c.SOURCE_TABLE || CHR(39) || ' AS RELATED_TABLE, '
          || CHR(39) || c.PK1 || ':' || CHR(39) || '|| TMATCH.' || c.PK1 || ' || '' '' ||'
          || CHR(39) || c.PK2 || ':' || CHR(39) || ' || TMATCH.' || c.PK2 || ' AS RELATED_KEY '
          || 'FROM (SELECT TH.' || c.PK1 || ' , ' || 'TH.' || c.PK2
          || '      FROM ' || c.SOURCE_TABLE || ' TL'
          || '        JOIN  ' ||C.exist_in_la_tbl || ' TH ' || c.JOIN_CONDITION || ') TMATCH '

          ;

          EXECUTE IMMEDIATE vSQL;

      END loop;



    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_MIG_MATCHING_RECORDS;

  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_MATCHING_RECORDS(p_LogRec MIGR_GVAR.LogRecTyp)
    AS
      vSQL           VARCHAR2(32000);
      l_DEST_TABLE   ETL_ENGINE.DEST_TABLE % TYPE;
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      l_PK1          ETL_TBL_DEF.PK1 % TYPE;
      l_PK2          ETL_TBL_DEF.PK2 % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      SELECT ee.SOURCE_TABLE,
             etd.PK1,
             etd.PK2,
             ee.DEST_TABLE
        INTO l_SOURCE_TABLE,
             l_PK1,
             l_PK2,
             l_DEST_TABLE
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF etd
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND etd.TBLNAME = p_LogRec.migrRelTbl
          AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = 'Landing'
          AND not(ee.TBLNAME like 'NP%')  --valex.20/4/16 exclude NP427F from process
      ;
      --Log matching records (already loaded) to MIG_DETAIL_ERROR_LOG
      vSQL := 'INSERT INTO MIG_DETAIL_ERROR_LOG '
      || '(MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY) '
      || ' SELECT MMI.MIGRATION_BATCH_ID, '
      || ' SYSTIMESTAMP AS ERROR_TIMESTAMP, '
      || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || 'Critical Error' || CHR(39) || ' AS ERROR_TYPE, '
      || CHR(39) || 'Record has already been migrated' || CHR(39) || ' AS ERROR_MESSAGE, '
      || CHR(39) || 'Transfering from _LOAD to historical tables' || CHR(39) || ' AS MIGRATION_STEP, '
      || CHR(39) || l_SOURCE_TABLE || CHR(39) || ' AS RELATED_TABLE, '
      || CHR(39) || l_PK1 || ':' || CHR(39) || '|| TMATCH.' || l_PK1 || ' || '
      || CHR(39) || l_PK2 || ':' || CHR(39) || ' || TMATCH.' || l_PK2 || ' AS RELATED_KEY '
      || 'FROM (SELECT THIST.' || l_PK1 || ' , ' || 'THIST.' || l_PK2
      || ' FROM ' || l_SOURCE_TABLE || ' TLOAD'
      || ' INNER JOIN ' || l_DEST_TABLE || ' THIST'
      || '  ON TLOAD.' || l_PK1 || ' = THIST.' || l_PK1
      || '  AND TLOAD.' || l_PK2 || ' = THIST.' || l_PK2 || ') TMATCH, '
      || '(SELECT MIGRATION_BATCH_ID '
      || ' FROM MIG_MIGRATION_INFO '
      || ' WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID =' || CHR(39) || p_LogRec.mig_batch_id || CHR(39) || ') MMI'
      ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_MIG_MATCHING_RECORDS;

  ---------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_ROW_COUNT(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2)
    AS
      vSQL           VARCHAR2(32000);
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;

    BEGIN

      SELECT ee.SOURCE_TABLE
        INTO l_SOURCE_TABLE
        FROM ETL_ENGINE ee
       WHERE 1 = 1
         AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
         AND ee.TBLNAME = p_LogRec.migrRelTbl
         AND ee.MIGRATION_AREA = p_LogRec.migrStep; --'Landing';

      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS'
           || ' (MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME)
               SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS LOG_TIMESTAMP,'
--           || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
           || CHR(39) || p_LogRec.migrStep || CHR(39) || ' AS MIGRATION_AREA, '
           || CHR(39) || l_SOURCE_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
           || CHR(39) || 'Accepted' || CHR(39) || ' AS STATUS, '
           || 'MVA.CNT AS VOLUME
               FROM (SELECT MIGRATION_BATCH_ID
                       FROM MIG_MIGRATION_INFO
                      WHERE STATUS = ' || CHR(39) || p_Status || CHR(39) || ' AND MIGRATION_BATCH_ID =' || CHR(39) || p_LogRec.mig_batch_id || CHR(39)
           || ' ) MMI,
              (SELECT COUNT(*) AS CNT
              FROM ' || l_SOURCE_TABLE
           || ') MVA'
           ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;

    END LOG_MIG_VOL_ANAL_ROW_COUNT;

  ---------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_ROW_COUNT_LA(p_LogRec MIGR_GVAR.LogRecTyp)
    AS
      vSQL           VARCHAR2(32000);
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;

    BEGIN

      SELECT ee.SOURCE_TABLE
        INTO l_SOURCE_TABLE
        FROM ETL_ENGINE ee
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND ee.MIGRATION_AREA = 'Landing';

      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS
          (MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME)
          SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID,
            SYSTIMESTAMP AS LOG_TIMESTAMP,'
      || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_SOURCE_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Accepted' || CHR(39) || ' AS STATUS, '
      || 'MVA.CNT AS VOLUME
          FROM (
                SELECT MIGRATION_BATCH_ID
                FROM MIG_MIGRATION_INFO
                WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID =' || CHR(39) || p_LogRec.mig_batch_id || CHR(39)
      || ' ) MMI,
            (SELECT COUNT(*) AS CNT
              FROM ' || l_SOURCE_TABLE
      || ') MVA'
      ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;

    END LOG_MIG_VOL_ANAL_ROW_COUNT_LA;

  ---------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------

  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(p_LogRec MIGR_GVAR.LogRecTyp, p_Status IN VARCHAR2)
    IS
      PRAGMA AUTONOMOUS_TRANSACTION;

  BEGIN

      INSERT INTO MIG_MIGRATION_STEPS (
        MIGRATION_BATCH_ID, STEP_TIMESTAMP, STEP_AREA, STEP_MESSAGE, TABLENAME
      )
        SELECT MMI.MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS STEP_TIMESTAMP,
               p_LogRec.migrStep AS STEP_AREA,
               p_LogRec.logMsg AS STEP_MESSAGE,
               p_LogRec.migrRelTbl AS TABLENAME
          FROM MIG_MIGRATION_INFO MMI
         WHERE STATUS = p_Status --'Running'
           AND MMI.MIGRATION_BATCH_ID = p_LogRec.mig_batch_id;

      COMMIT;

  EXCEPTION
    WHEN OTHERS THEN ROLLBACK;

  END UPDATE_LOG_MIG_MIGRATION_STEPS;

  ---------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------

  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(p_LogRec MIGR_GVAR.LogRecTyp)
    IS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      INSERT INTO MIG_MIGRATION_STEPS (
        MIGRATION_BATCH_ID, STEP_TIMESTAMP, STEP_AREA, STEP_MESSAGE, TABLENAME
      )
        SELECT MMI.MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS STEP_TIMESTAMP,
               p_LogRec.migrStep AS STEP_AREA,
               p_LogRec.logMsg AS STEP_MESSAGE,
               p_LogRec.migrRelTbl AS TABLENAME
          FROM MIG_MIGRATION_INFO MMI
          WHERE STATUS = 'Running'
            AND MMI.MIGRATION_BATCH_ID = p_LogRec.mig_batch_id;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;

    END UPDATE_LOG_MIG_MIGRATION_STEPS;
  ---------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------
  PROCEDURE TRUNCATE_ALL
    AS
      vSQL VARCHAR2(1000);
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN

      vSQL := '';

      MIGR_SETUP.TBL_OPERATION_LA('TRUNCATE');          --Truncate Landing Tables

      MIGR_SETUP.TBL_OPERATION_SA('TRUNCATE');          --Truncate Staging Tables


    --Truncate Intermediate Tables    -- runs from MIGR_IA.RUN_IA_SETUP()

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.mig_batch_id:='0-1';
        l_LogRec.migrArea      :=   'MIGR_LA_SA.TRUNCATE_ALL' ;
        l_LogRec.migrStep      :=  ' TRUNCATE_ALL' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM    ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END TRUNCATE_ALL;
  -----------------------------------------------------------------------------------------


  ------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LA_MIG_FLAG(p_LogRec MIGR_GVAR.LogRecTyp)
    AS
      vSQL           VARCHAR2(32000);

      l_LogRec       MIGR_GVAR.LogRecTyp;
      l_DEST_TABLE   ETL_ENGINE.DEST_TABLE % TYPE;
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      l_PK1          ETL_TBL_DEF.PK1 % TYPE;
      l_PK2          ETL_TBL_DEF.PK2 % TYPE;
      l_PK3          ETL_TBL_DEF.PK2 % TYPE;
      l_PK4          ETL_TBL_DEF.PK2 % TYPE;
      l_PK5          ETL_TBL_DEF.PK2 % TYPE;
    BEGIN
      l_LogRec := p_LogRec;
      l_LogRec.migrArea := 'MIGR_LA_SA.UPDATE_LA_MIG_FLAG';
      SELECT ee.SOURCE_TABLE,
             etd.PK1,
             etd.PK2,
             ee.DEST_TABLE,
             etd.PK3,
             etd.PK4,
             etd.PK5
        INTO l_SOURCE_TABLE,
             l_PK1,
             l_PK2,
             l_DEST_TABLE,
             l_PK3,
             l_PK4,
             l_PK5
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF etd
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(l_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = l_LogRec.migrRelTbl
          AND ee.TBLNAME = etd.TBLNAME
          AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = 'Staging';

      IF NOT l_PK1 IS NULL AND NOT l_PK2 IS NULL THEN
          vSQL := 'UPDATE ' || l_SOURCE_TABLE
          || ' SET MIG_FLAG = 1
          WHERE EXISTS
         (SELECT ' || l_PK1 || ', ' || l_PK2 || CHR(10)
          || ' FROM ' || l_DEST_TABLE || CHR(10)
          || ' WHERE MIG_MUTUAL_ID = ' || CHR(39) || SUBSTR(l_LogRec.mig_batch_id, 1, 2) || CHR(39) || CHR(10)
          || (CASE WHEN l_PK1 IS NOT NULL THEN ' AND ' || l_SOURCE_TABLE || '.' || l_PK1 || ' = ' || l_DEST_TABLE || '.' || l_PK1 || CHR(10) ELSE NULL END)
          || (CASE WHEN l_PK2 IS NOT NULL THEN ' AND ' || l_SOURCE_TABLE || '.' || l_PK2 || ' = ' || l_DEST_TABLE || '.' || l_PK2 || CHR(10) ELSE NULL END)
          || (CASE WHEN l_PK3 IS NOT NULL THEN ' AND ' || l_SOURCE_TABLE || '.' || l_PK3 || ' = ' || l_DEST_TABLE || '.' || l_PK3 || CHR(10) ELSE NULL END)
          || (CASE WHEN l_PK4 IS NOT NULL THEN ' AND ' || l_SOURCE_TABLE || '.' || l_PK4 || ' = ' || l_DEST_TABLE || '.' || l_PK4 || CHR(10) ELSE NULL END)
          || (CASE WHEN l_PK5 IS NOT NULL THEN ' AND ' || l_SOURCE_TABLE || '.' || l_PK5 || ' = ' || l_DEST_TABLE || '.' || l_PK5 || CHR(10) ELSE NULL END)
          || ')'
          ;
          l_LogRec.migrRelTbl := vSQL;

          EXECUTE IMMEDIATE vSQL;
          COMMIT;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN
          --        MIGR_SYSTEM.MIGR_LOG_LINE('FALSE', '0-1', 'MIGR_LA_SA.UPDATE_LA_MIG_FLAG', NULL, 'EXCEPTION',  SQLERRM, vSQL, NULL);
          l_LogRec.logMsg := SQLERRM;

          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
    END UPDATE_LA_MIG_FLAG;
  ------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(steparea          IN VARCHAR2,
                                           stepmessage       IN VARCHAR2,
                                           vMigrationBatchId IN VARCHAR2,
                                           vtablename        IN VARCHAR2)
    IS
      L_SRVERRMSG SRVERRMSG;
      PIO_ERR     SRVERR;

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      INSERT INTO MIG_MIGRATION_STEPS (
        MIGRATION_BATCH_ID, STEP_TIMESTAMP, STEP_AREA, STEP_MESSAGE, TABLENAME
      )
        SELECT MMI.MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS STEP_TIMESTAMP,
               steparea AS STEP_AREA,
               stepmessage AS STEP_MESSAGE,
               vtablename AS TABLENAME
          FROM MIG_MIGRATION_INFO MMI
          WHERE STATUS = 'Running'
            AND MMI.MIGRATION_BATCH_ID = vMigrationBatchId;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END UPDATE_LOG_MIG_MIGRATION_STEPS;


-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
--valex.1/9/2016 - RUN_LA_SA is split to RUN_LA and RUN_SA
  PROCEDURE RUN_LA(p_migrBatchId IN  VARCHAR2,
                      LA_Status  OUT VARCHAR2)
    AS


      l_LogRec      MIGR_GVAR.LogRecTyp;
      ex_LaRollback EXCEPTION;
      vSql          VARCHAR2(2000);
    --  V_COUNT       INTEGER;   --valex.27/4/16
      v_recon       VARCHAR2(30);  --valex.20/4/16  it holds _LOAD name of bolag reonciliation file

      --valex.20/4/16.start declaration of objects needed for _LOAD - ReconFile consistency check
      TYPE t_bulk_collect IS TABLE OF varchar2(30);
      l_tab     t_bulk_collect;
      l_cursor  SYS_REFCURSOR;
      --valex.20/4/16.end
      l_kf100f_recs PLS_INTEGER;
    v_renewal date;

    BEGIN

      LA_Status := 'COMPLETE';
      l_LogRec.migrArea := 'MIGR_LA_SA.RUN_LA';
      l_LogRec.mig_batch_id := p_migrBatchId;


        l_LogRec.migrStep := 'Loading to Landing area';
        l_LogRec.logMsg := 'Started Loading from LOAD to LA';
        l_LogRec.migrStep   := 'Landing';
        MIGR_LOG.LOG_INFO(l_LogRec);
        -- +++ anb 2015-11-17 time inside loop
        --        MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Landing', 'Begin loading Landing Area', vMigrationBatchID, NULL);

      SELECT trunc(RENEWAL_DATE)
        into v_renewal
      FROM (SELECT *   FROM ETL_MIGRATION_CONDITIONS   WHERE 1=1      and ITERATION_STATUS='Pending'   oRDER by id)
      where ROWNUM=1;

        l_LogRec.logMsg := 'The configured date in migration schedule is: ' ||TO_CHAR(v_renewal,'dd-mm-yyyy');
        MIGR_LOG.LOG_INFO(l_LogRec);

        FOR cBolag IN (SELECT ebi.BOLAG_ID
            FROM MIG_MIGRATION_INFO ebi
            WHERE 1 = 1
              AND ebi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id)
        LOOP


          FOR cTable IN (
--valex.3/11/2016 - KF100F file and its IOT are loaded first, as loading of NORMAL files depends on the latter
--                      SELECT etd.TBLNAME,
--                      etd.LA
--                      FROM ETL_TBL_DEF etd
--                      WHERE 1 = 1
--                        AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
--                        AND NVL(etd.LA, 'N') = 'Y'                 -- +++ anb 2016-02-03 skip reconciliation file
                        SELECT etd.TBLNAME,
                            etd.LA,
                            (CASE WHEN etd.FILE_ROLE='Master' THEN 1 ELSE 0 END) seq
                          FROM ETL_TBL_DEF etd
                          WHERE 1 = 1
                            AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
                            AND NVL(etd.LA, 'N') = 'Y'
                            AND FILE_ROLE <> 'Discounts'   --valex.3/1/2017 - do not process MD_DISCOUNTS file during first stage of migration
                        ORDER BY seq desc
--valex.3/11/2016 - end
          )
          LOOP

            l_LogRec.migrRelTbl := cTable.TBLNAME;
            l_LogRec.migrRelKey := cTable.TBLNAME || '.' || cBolag.BOLAG_ID;
            l_LogRec.migrStep := 'Landing';


            UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);

            LOG_MIG_VOL_ANAL_ROW_COUNT_LA(l_LogRec);

            LOG_MIG_MATCHING_RECORDS(l_LogRec);

            LOG_MIG_VOL_ANAL_MATCHING_LA(l_LogRec);

            IF NOT INSERT_RECORDS_IN_HISTORY(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING, v_renewal)
            THEN
              RAISE ex_LaRollback;


            END IF;
            LOG_RECORDS_NOT_IN_MASTER_FILE(l_LogRec, v_renewal);  --valex.3/11/2016 - log policies of NORMAL files not in Master file

            LOG_MIG_VOL_ANAL_NON_MATCH_LA(l_LogRec);


            UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);
          --MIGR_LOG.LOG_INFO(l_LogRec);

          END LOOP;

--valex.20/4/16.start logic for record count check among _LOAD tables and corresponding records counts in reconciliation file
          select b.source_table
            into v_recon
          from etl_tbl_def a, etl_engine b
          where 1=1
            and a.file_role='Reconciliation'
            and b.BOLAG_ID = cBolag.BOLAG_ID
            and a.tblname=b.tblname;

          OPEN l_cursor FOR  'SELECT a.tblname'
                    || ' FROM  ETL_ENGINE a inner join MIG_VOLUMETRIC_ANALYSIS b on a.source_table = b.table_name'
                    || ' inner join ' || v_recon || ' c on a.tblname = c.KF_TABLE'
                    || ' WHERE 1=1'
                    || ' AND b.MIGRATION_BATCH_ID = ''' || l_LogRec.mig_batch_id || ''''
                    || ' AND b.VOLUME <> c.REC_COUNT'
                    || ' and a.migration_area= ''Landing''';
          FETCH l_cursor
          BULK COLLECT INTO l_tab;
          CLOSE l_cursor;


          for i in 1 .. l_tab.count
           loop
              LA_Status := 'INCOMPLETE';
              l_LogRec.logMsg := 'LA - ReconFile record count inconsistency for file: ' || l_tab(i);
              MIGR_LOG.LOG_EXCEPTION(l_LogRec);
           end loop;
          if LA_Status <> 'COMPLETE' then
            RAISE ex_LaRollback;
          END IF;
--valex.20/4/16.end


--valex.6/9/16 - issue a warning status, if no data from bolag's KF100F_LOAD are inserted in LA
          FOR c in (SELECT tblname
                    from ETL_TBL_DEF etd
                    WHERE file_role='Master'
          )
          LOOP
            vSql:='SELECT VOLUME '
                  || 'FROM MIG_VOLUMETRIC_ANALYSIS '
                  || 'WHERE 1=1 '
                  || '  AND MIGRATION_BATCH_ID = ''' || l_LogRec.mig_batch_id || ''''
                  || '  and status=''Accepted'''
                  || '  and TABLE_NAME=''LA_M'' || ''' || SUBSTR(l_LogRec.mig_batch_id,1,2)|| '''|| ''_''||''' || c.TBLNAME ||'''';
            EXECUTE IMMEDIATE vSql INTO l_kf100f_recs;
            if l_kf100f_recs=0 then

              l_LogRec.logMsg := 'No policies were loaded from KF files to Landing area. Please check that the KF files contains the  expected by migration schedule renewal date and  all batch policies were not included in previous runs.';
              MIGR_LOG.LOG_ERROR(l_LogRec);
              LA_Status:='NO_DATA_MIGRATED';
            END IF;
          END LOOP;

--valex.6/9/16 - end

        END LOOP;

      --FA.20160705 Change LA status in mig_migration_info in order to fire archive job
        if LA_Status = 'COMPLETE' then
         UPDATE MIG_MIGRATION_INFO mmi SET mmi.LA_COMPLETED='Finished' WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
        elsif  LA_Status='NO_DATA_MIGRATED' then
         UPDATE MIG_MIGRATION_INFO mmi SET mmi.LA_COMPLETED='No_data_migrated' WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
        END IF;

        l_LogRec.logMsg := 'Finished Loading from LOAD to LA';
        l_LogRec.migrRelTbl  :='';
        l_LogRec.migrRelKey:='';
        MIGR_LOG.LOG_INFO(l_LogRec);
        COMMIT;


    EXCEPTION
      WHEN ex_LaRollback THEN
          LA_Status := 'ROLLBACK_LA';
          UPDATE MIG_MIGRATION_INFO mmi SET mmi.LA_COMPLETED='Failed' WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
          COMMIT;
      WHEN OTHERS THEN
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          LA_Status := 'INCOMPLETE';


    END RUN_LA;


-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------

  PROCEDURE RUN_SA(p_migrBatchId IN  VARCHAR2,
                      SA_Status  OUT VARCHAR2)
    AS

      l_LogRec      MIGR_GVAR.LogRecTyp;
      ex_SaRollback EXCEPTION;
      vSql          VARCHAR2(2000);

    BEGIN
      SA_Status := 'COMPLETE';
      l_LogRec.migrArea := 'MIGR_LA_SA.RUN_SA';
      l_LogRec.mig_batch_id := p_migrBatchId;

        l_LogRec.migrRelTbl := '';
        l_LogRec.migrRelKey := '';
        l_LogRec.migrStep := 'Landing to Staging area';
        l_LogRec.logMsg := 'Starting Loading from LA to SA';
        MIGR_LOG.LOG_INFO(l_LogRec);

        --Log MIG_MIGRATION_STEPS - Initialize loading
        UPDATE_LOG_MIG_MIGRATION_STEPS('Staging', 'Begin loading Staging Area', l_LogRec.mig_batch_id, NULL);

        --FA.20161108 get kf100f table first in order to store renewal date
        FOR cTable IN (SELECT etd.TBLNAME   ,   (CASE WHEN etd.FILE_ROLE='Master' THEN 1 ELSE 0 END) seq
            FROM ETL_TBL_DEF etd
            WHERE 1 = 1
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
              AND NVL(etd.SA, 'N') = 'Y'                         -- +++ anb 2016-02-03 NP427F
              and etd.FILE_ROLE NOT IN ( 'Derived', 'Discounts' )                    --valex.3/1/2017 add exclusion for discounts.txt
            ORDER BY seq desc
        )
        LOOP
          --Log MIG_MIGRATION_STEPS - Initialize loading
          -- +++ anb 2015-11-17 time inside loop
          --             MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging', 'Begin loading table ' || cTable.TBLNAME, vMigrationBatchID, cTable.TBLNAME);

          FOR cBolag IN (SELECT ebi.BOLAG_ID
              FROM MIG_MIGRATION_INFO ebi
              WHERE 1 = 1
                AND ebi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id)
          LOOP

            -- l_LogRec.mig_bolag_id := cBolag.BOLAG_ID;
            l_LogRec.migrRelTbl := cTable.TBLNAME;
            l_LogRec.logMsg := 'Begin loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
            MIGR_LOG.log_info(l_LogRec);
            --Log MIG_MIGRATION_STEPS - Load from landing M43_KF100F
            UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);
            --FA. 20170323 Always set migr_step prior to porcedure execution
             l_LogRec.migrStep:='Staging';
            IF NOT INSERT_RECORDS_IN_HISTORY_SA(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING)
            THEN
              RAISE ex_SaRollback;
            END IF;
            --Update MIG_FLAG in M43_KFXXXF - Rows that have been imported
            UPDATE_LA_MIG_FLAG(l_LogRec);

            LOG_MIG_ANAL_ROW_COUNT_SA(l_LogRec);

            --Log MIG_MIGRATION_STEPS - Load from landing M43_KFXXXF
            l_LogRec.logMsg := 'End loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
            UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);
          END LOOP;
        --Log MIG_MIGRATION_STEPS - Finish KFXXXF for staging area
        -- +++ anb 2015-11-17 time inside loop
        --              MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging', 'End loading table ' || cTable.TBLNAME, vMigrationBatchID, cTable.TBLNAME);
        END LOOP;
        l_LogRec.logMsg := 'End loading Staging Area';
        UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);

      --FA.20160407 Moved rules execution outside sa step
      -- RULES take care of their own logging
      --MIGR_RULES.RUN_RULES(l_LogRec.mig_batch_id);

      --valex populate SA_B_* tables
      fill_SA_B_PRSN(l_LogRec.mig_batch_id);    --valex.2/6/2016
      fill_SA_B_address(l_LogRec.mig_batch_id);    --valex.24/8/16
      --valex.end


      UPDATE MIG_MIGRATION_INFO mmi SET mmi.SA_COMPLETED='Finished' WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
      l_LogRec.logMsg := 'Finished Loading from LA to SA';
      l_LogRec.migrRelTbl := '';
      l_LogRec.migrRelKey := '';
      MIGR_LOG.LOG_INFO(l_LogRec);




    EXCEPTION
      WHEN ex_SaRollback THEN
        SA_Status := 'ROLLBACK_SA';
        UPDATE MIG_MIGRATION_INFO mmi SET mmi.SA_COMPLETED='Failed' WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
      WHEN OTHERS THEN
        l_LogRec.logMsg := SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);
        SA_Status := 'INCOMPLETE';
        UPDATE MIG_MIGRATION_INFO mmi SET mmi.SA_COMPLETED='Failed' WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;


    END RUN_SA;

  --valex.1/9/2016 - end

-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------

  PROCEDURE LOG_RECORDS_NOT_IN_MASTER_FILE(p_LogRec MIGR_GVAR.LogRecTyp, p_renewal date)
    AS
      vSQL               VARCHAR2(32000);
      l_LogRec           MIGR_GVAR.LogRecTyp;
      vfields VARCHAR2(100);
      --v_run_renewals     BOOLEAN;
      --v_date             VARCHAR2(20);
     -- l_SOURCE_TABLE_REN ETL_ENGINE.SOURCE_TABLE % TYPE;
      --vsqlRenewals       VARCHAR2(4000);
    BEGIN
      l_LogRec := p_LogRec;

      l_LogRec.migrArea := 'MIGR_LA_SA.LOG_RECORDS_NOT_IN_MASTER_FILE';
      --- +++ anb 2016-02-04 beware of string size for SELECT INTO  - cannot exceed 2100 !!!

       FOR cRec IN (SELECT ee.DEST_TABLE,
                           ee.FIELD_LIST,
                           ee.ADDFLDS,
                           ee.PK_LIST,
                           etd.pk1,
                           etd.pk2,
                           ee.SOURCE_TABLE,
                           ee.JOIN_CONDITION,
                           ee.NOMATCH1,
                           ee.BOLAG_NAME,
                           ee.TBLNAME,
                           ee.iot_fields,
                           ee.PK_LIST_with_tbl_identifier,
                           ee.IOT_TABLE,
                           ee.IOT_JOIN_CONDITION,
                           ee.IOT_MATCH,
                           ee.IOT_NULL_FIELDS,
                           ee.EXIST_IN_LA_TBL,
                           ee.FIELD_LIST1,
                           ee.IOT_NOT_MATCH,
                           ee.MASTER_LOAD_TBL,
                           ee.master_load_join_condition
                           -- ee.ADDFLDS1
                           -- (CASE WHEN etd.file_role<>'Reconciliation' THEN 'LA_'||BOLAG_NAME||'_KF100F_IOT' ELSE '(select ''1'' as KF_TABLE from dual)' end)AS kf_IOT,
                           -- (CASE WHEN  etd.tblname='KF100F' THEN 1 ELSE 0 END ) AS seq
                      FROM ETL_ENGINE ee,MIG_MIGRATION_INFO mmi,etl_tbl_def etd
                     WHERE 1 = 1
                       AND ee.BOLAG_ID=mmi.BOLAG_ID
                       AND mmi.STATUS='Running'
                       AND mmi.migration_batch_id=l_LogRec.mig_batch_id
                       AND ee.MIGRATION_AREA = 'Landing'
                       AND ee.TBLNAME = etd.TBLNAME
                       AND ee.TBLNAME = l_LogRec.migrRelTbl
                       AND FILE_ROLE = 'Normal'

                       AND ee.TBLNAME <> 'BR161F'

       )
       LOOP
           vSQL := 'DECLARE '
                || ' CURSOR KF is '
                || '    SELECT * '
                || '    FROM MIG_DETAIL_ERROR_LOG; '
                || ' TYPE KF_tab IS TABLE OF KF%ROWTYPE; '
                || ' KF_all_records   KF_tab:= KF_tab(); '
                || ' cnt pls_integer:=0;'
                || 'BEGIN '
                || ' SELECT ''' ||l_LogRec.mig_batch_id ||''','
                || ' SYSTIMESTAMP AS ERROR_TIMESTAMP, '
                || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
                || CHR(39) || 'Critical Error' || CHR(39) || ' AS ERROR_TYPE, '
                || CHR(39) || 'IDPL does not exist in Master table' || CHR(39) || ' AS ERROR_MESSAGE, '
                || CHR(39) || 'Transfering from _LOAD to historical tables' || CHR(39) || ' AS MIGRATION_STEP, '
                || CHR(39) || CREC.dest_TABLE || CHR(39) || ' AS RELATED_TABLE, '''||crec.PK1||':''||'||crec.PK1||'||'',''||'''||crec.PK2||':''||'||crec.PK2||  '  AS RELATED_KEY '   --fix it
                || ' BULK COLLECT INTO KF_all_records '
                || 'FROM '
                || '(SELECT TI.*'
                || ' FROM ' || cRec.IOT_TABLE || ' TL'
                || ' RIGHT JOIN  ' || cRec.SOURCE_TABLE || ' TI ' || cRec.IOT_JOIN_CONDITION
                ||  '  inner join ' || CREC.MASTER_LOAD_TBL || ' ML ' || CREC.master_load_join_condition ||' = ' ||'to_date('''||p_renewal||''',''yyyy-mm-dd'')'
                || ' WHERE ' || cRec.iot_not_mATCH || ') '


                || ';'
                || ' cnt:=KF_all_records.COUNT;'

               || '  FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT '
                || '    INSERT  INTO MIG_DETAIL_ERROR_LOG VALUES KF_all_records(i); '

                || 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS '
                || '(MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME) '
                || ' values ('''||l_LogRec.mig_batch_id||''','
                || ' SYSTIMESTAMP,'
                || '''Landing'','
                || ''''||CREC.DEST_TABLE ||''','
                || '''Rejected - IDPL not in Master table'','
                || ' cnt);'
                || 'END; ';



                EXECUTE IMMEDIATE vSQL;
                COMMIT;

       END LOOP;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM||' vsql:'||vsql ;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END LOG_RECORDS_NOT_IN_MASTER_FILE;

-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------








END MIGR_LA_SA;
/

CREATE OR REPLACE PACKAGE BODY                   MIGR_LOCK_UTILS
  AS

--User locks are automatically released when a session terminates
--SELECT FROM DBMS_LOCK_ALLOCATED
--grant execute on sys.dbms_lock to


--Expiration secs:Number of seconds to wait after the last ALLOCATE_UNIQUE has been performed on a given lock,
--before permitting that lock to be deleted from the DBMS_LOCK_ALLOCATED table.
--The default waiting period is 10 days. You should not delete locks from this table.
--Subsequent calls to ALLOCATE_UNIQUE may delete expired locks to recover space.

FUNCTION GET_HANDLE(p_lock_name IN VARCHAR2)  RETURN VARCHAR2
    IS
      PRAGMA AUTONOMOUS_TRANSACTION;
      lock_handle       VARCHAR2(128);
      v_expiration_secs INTEGER;
      l_LogRec MIGR_GVAR.LogRecTyp;
BEGIN

      SELECT EXPIRATION_SECS INTO v_expiration_secs FROM ETL_LOCK_CONFIGURATION A WHERE A.LOCKNAME=p_lock_name;
        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_LOCK_UTILS.GET_HANDLE' ;
        l_LogRec.migrStep      :=   'GET_HANDLE' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;


      DBMS_LOCK.ALLOCATE_UNIQUE(
                    LOCKNAME => p_lock_name,
                    LOCKHANDLE => lock_handle,
                    EXPIRATION_SECS => v_expiration_secs);

       l_LogRec.logMsg        :=  'Got lock handle'  ;
       MIGR_LOG.LOG_INFO(l_LogRec) ;

      RETURN lock_handle;

   EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.logMsg        :=  SQLERRM||    'lock_name: '||p_lock_name;
       MIGR_LOG.LOG_INFO(l_LogRec) ;


END GET_HANDLE;

-------------------------------------------------------------------
-------------------------------------------------------------------
--id or lockhandle: Returned by ALLOCATE_UNIQUE, of the lock mode you want to change.
--timeout:Number of seconds to continue trying to grant the lock.
--release_on_commit: I set to False the lock is held until it is explicitly released or until the end of the session.
--Choose False because allocate performs a commit.

FUNCTION  REQUEST_LOCK(p_lock_handle IN VARCHAR2,p_lock_name IN VARCHAR2) RETURN BOOLEAN
    IS
      lock_status NUMBER;
      v_timeout   INTEGER;
      v_sleep     INTEGER;
     l_LogRec MIGR_GVAR.LogRecTyp;
BEGIN

        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_LOCK_UTILS.REQUEST_LOCK' ;
        l_LogRec.migrStep      :=   'REQUEST_LOCK' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;


      SELECT TIMEOUT,SLEEP_TIME INTO v_timeout, v_sleep FROM ETL_LOCK_CONFIGURATION A WHERE A.LOCKNAME=p_lock_name;

      lock_status := DBMS_LOCK.REQUEST(
                      LOCKHANDLE => p_lock_handle,
                      LOCKMODE => DBMS_LOCK.x_mode, -- eXclusive
                      TIMEOUT => v_timeout, -- wait 5 secs
                      RELEASE_ON_COMMIT => FALSE);

      CASE lock_status

        WHEN 0 THEN
             l_LogRec.logMsg        := p_lock_name || ' lock sucessfully requested';
             MIGR_LOG.LOG_INFO(l_LogRec) ;

           RETURN TRUE;

        WHEN 1 THEN
              l_LogRec.logMsg        :=  'Waiting for lock:' ||p_lock_name;
             MIGR_LOG.LOG_INFO(l_LogRec) ;

              DBMS_LOCK.SLEEP(v_sleep); -- sleep x seconds before retrying

              l_LogRec.logMsg        :=   'Timeout for:' ||p_lock_name;
              MIGR_LOG.LOG_ERROR(l_LogRec) ;

            --RAISE_APPLICATION_ERROR(-20000, 'Timeout');
            RETURN FALSE;

        WHEN 2 THEN
              l_LogRec.logMsg        :=  'Deadlock detected for:'||p_lock_name;
              MIGR_LOG.LOG_ERROR(l_LogRec) ;

            --RAISE_APPLICATION_ERROR(-20000, 'Deadlock detected');
            RETURN FALSE;

        WHEN 3 THEN
              l_LogRec.logMsg        :=  'Parameter error for:'||p_lock_name;
              MIGR_LOG.LOG_ERROR(l_LogRec) ;
             RETURN FALSE;

        WHEN 4 THEN
               l_LogRec.logMsg        :=  'Lock Already obtained for:'||p_lock_name;
               MIGR_LOG.LOG_ERROR(l_LogRec) ;

              RAISE_APPLICATION_ERROR(-20000, 'Lock Already obtained');

        WHEN 5 THEN
             l_LogRec.logMsg        :=  'Illegal lock handle for:'||p_lock_name;
             MIGR_LOG.LOG_ERROR(l_LogRec) ;

            --RAISE_APPLICATION_ERROR(-20000, ' Illegal lock handle');
            RETURN FALSE;

        ELSE
             l_LogRec.logMsg        :=  'Request lock failed:'||p_lock_name;
             MIGR_LOG.LOG_ERROR(l_LogRec) ;

          --RAISE_APPLICATION_ERROR(-20000, 'Request lock failed: ' || lock_status);
          RETURN FALSE;

      END CASE;

  EXCEPTION
      WHEN OTHERS THEN
          l_LogRec.logMsg        :=  'Lock name:'||p_lock_name|| '-' ||SQLERRM;
          MIGR_LOG.LOG_ERROR(l_LogRec) ;


        RETURN FALSE;
END REQUEST_LOCK;

-------------------------------------------------------------------
-------------------------------------------------------------------

  -- wrapper to release a lock
PROCEDURE RELEASE_LOCK(p_lock_name IN VARCHAR2)
    IS
      lock_status NUMBER;
      l_LogRec MIGR_GVAR.LogRecTyp;
BEGIN


        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_LOCK_UTILS.RELEASE_LOCK' ;
        l_LogRec.migrStep      :=   'RELEASE_LOCK' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;

       lock_status := DBMS_LOCK.RELEASE(p_lock_name);

        CASE lock_status
        WHEN 0 THEN
             l_LogRec.logMsg        :=  p_lock_name || ' lock released';
             MIGR_LOG.LOG_INFO(l_LogRec) ;

        WHEN 3 THEN
             l_LogRec.logMsg        :=  'Parameter error for:'||p_lock_name;
             MIGR_LOG.LOG_ERROR(l_LogRec) ;
            RAISE_APPLICATION_ERROR(-20000, 'Parameter error');

        WHEN 4 THEN
            l_LogRec.logMsg        := 'Do not own lock specified by id or lockhandle:'||p_lock_name;
             MIGR_LOG.LOG_ERROR(l_LogRec) ;
            RAISE_APPLICATION_ERROR(-20000, 'Do not own lock specified by id or lockhandle');

        WHEN 5 THEN
              l_LogRec.logMsg        := 'Illegal lock handle for:'||p_lock_name ;
             MIGR_LOG.LOG_ERROR(l_LogRec) ;
            RAISE_APPLICATION_ERROR(-20000, 'Illegal lock handle');

        ELSE
            l_LogRec.logMsg        := 'Release lock failed for :' ||p_lock_name|| 'status:'  || lock_status;
            MIGR_LOG.LOG_ERROR(l_LogRec) ;
          RAISE_APPLICATION_ERROR(-20000, 'Release lock failed: ' || lock_status);
      END CASE;

   EXCEPTION
     WHEN OTHERS THEN
              l_LogRec.logMsg        :=  'Lock name:'||p_lock_name  ||'-'||SQLERRM;
             MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
END RELEASE_LOCK;

-------------------------------------------------------------------
-------------------------------------------------------------------

END MIGR_LOCK_UTILS;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_LOG
  AS
  /*************************************************************************
   Author: Fani.Avgerou
   Package Purpose: Autonomous porcedures to insert into log table
   Supported log Levels: Info -Werning-Error-Exception declared in spec
   Overloading concept used to support different input record datatypes
 ***************************************************************************/
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_ERROR(p_migrBatchId   IN VARCHAR2,
                      p_MigrationArea IN VARCHAR2,
                      p_MigrationStep IN VARCHAR2,
                      p_LogMsg        IN VARCHAR2,
                      p_RelatedTable  IN VARCHAR2,
                      p_RelatedKey    IN VARCHAR2)
    AS
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      INSERT INTO MIGR_API_DETAIL_LOG (
        LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
      )
      VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_migrBatchId, SYSTIMESTAMP, SUBSTR(p_MigrationArea, 1, 50), MIGR_GVAR.C_ERR_ERROR, SUBSTR(p_LogMsg, 1, 2000), SUBSTR(p_MigrationStep, 1, 256), SUBSTR(p_RelatedTable, 1, 2000), SUBSTR(p_RelatedKey, 1, 2000));

      COMMIT;

      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_MigrationArea || '.' || p_MigrationStep || ': = ' || p_LogMsg || ' ' || p_RelatedKey || ' ( ' || p_RelatedTable || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_ERROR;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_ERROR(p_LogRec MIGR_GVAR.LogRecTyp)
    AS
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      INSERT INTO MIGR_API_DETAIL_LOG (
        LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
      )
      VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_LogRec.mig_batch_id, SYSTIMESTAMP, SUBSTR(p_LogRec.migrArea, 1, 50), MIGR_GVAR.C_ERR_ERROR, SUBSTR(p_LogRec.logMsg, 1, 2000), SUBSTR(p_LogRec.migrStep, 1, 256), SUBSTR(p_LogRec.migrRelTbl, 1, 2000), SUBSTR(p_LogRec.migrRelKey, 1, 2000));

      COMMIT;
      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_LogRec.migrArea || '.' || p_LogRec.migrStep || ': = ' || p_LogRec.logMsg || ' ' || p_LogRec.migrRelKey || ' ( ' || p_LogRec.migrRelTbl || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_ERROR;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_ERROR_EVENT(p_LogRec    MIGR_GVAR.LogRecTyp,
                            PIO_ERR  IN SRVERR)
    AS
      l_policyRec MIGR_GVAR.LogRecTyp;
      v_error NUMBER;
    BEGIN

      l_policyRec := p_LogRec;
      FOR I IN PIO_ERR.FIRST .. PIO_ERR.LAST
      LOOP
        l_policyRec.logMsg := 'ERROR:' || PIO_ERR(I).ERRCODE || '' || ' TYPE:' || PIO_ERR(I).ERRTYPE || ' MESSAGE:' || PIO_ERR(I).ERRMESSAGE;
        MIGR_LOG.LOG_ERROR(l_policyRec);
        --FA.20170612 Try to ensure that no tablespace issues occured during the process. If yes, send an email and stop the process
        SELECT count('*') into v_error FROM DUAL
        WHERE  UPPER( l_policyRec.logMsg)  like '%ORA%UNABLE TO EXTEND%TABLESPACE%' ;

        IF   v_error !=0 THEN
            -- l_policyRec.logMsg := 'ERROR:' || PIO_ERR(I).ERRCODE || '' || ' TYPE:' || PIO_ERR(I).ERRTYPE || ' MESSAGE:' || PIO_ERR(I).ERRMESSAGE;
            --  MIGR_LOG.LOG_ERROR(l_policyRec);

              MIGR_API_COMMON.SUSPEND_MIGRATION (l_policyRec.logMsg || CHR(10) || CHR(13) || 'Once the issue is resolved, migration jobs should be started ', MIGR_GVAR.GV_MSG_CODE_MIGR_TBL_SPC_ERR);

        END IF;


    END LOOP;

    EXCEPTION
      WHEN OTHERS THEN NULL;
    END LOG_ERROR_EVENT;
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_ERROR_EVENT(p_LogRec IN MIGR_GVAR.PolicyRecTyp,
                            PIO_ERR  IN SRVERR)
    AS
      l_policyRec MIGR_GVAR.PolicyRecTyp;
      v_error NUMBER;
    BEGIN

      l_policyRec := p_LogRec;
      FOR I IN PIO_ERR.FIRST .. PIO_ERR.LAST
      LOOP
        l_policyRec.logMsg := 'ERROR:' || PIO_ERR(I).ERRCODE || '' || ' TYPE:' || PIO_ERR(I).ERRTYPE || ' MESSAGE:' || PIO_ERR(I).ERRMESSAGE;
        MIGR_LOG.LOG_ERROR(l_policyRec);

          --FA.20170612 Try to ensure that no tablespace issues occured during the process. If yes, send an email and stop the process
            SELECT count('*') into v_error FROM DUAL
            WHERE  UPPER( l_policyRec.logMsg)  like '%ORA%UNABLE TO EXTEND%TABLESPACE%' ;

            IF   v_error !=0 THEN
             -- l_policyRec.logMsg := 'ERROR:' || PIO_ERR(I).ERRCODE || '' || ' TYPE:' || PIO_ERR(I).ERRTYPE || ' MESSAGE:' || PIO_ERR(I).ERRMESSAGE;
             -- MIGR_LOG.LOG_ERROR(l_policyRec);

              MIGR_API_COMMON.SUSPEND_MIGRATION (l_policyRec.logMsg || CHR(10) || CHR(13) || 'Once the issue is resolved, migration jobs should be started ', MIGR_GVAR.GV_MSG_CODE_MIGR_TBL_SPC_ERR);

        END IF;

      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN NULL;
    END LOG_ERROR_EVENT;

 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_WARNING_EVENT(p_LogRec IN MIGR_GVAR.PolicyRecTyp,
                              PIO_ERR  IN SRVERR)
    AS

      l_policyRec MIGR_GVAR.PolicyRecTyp;
    BEGIN

      l_policyRec := p_LogRec;
      FOR I IN PIO_ERR.FIRST .. PIO_ERR.LAST
      LOOP
        l_policyRec.logMsg := 'WARNING:' || PIO_ERR(I).ERRCODE || '' || 'TYPE:' || PIO_ERR(I).ERRTYPE || ' MESSAGE:' || PIO_ERR(I).ERRMESSAGE;
        MIGR_LOG.LOG_WARNING(l_policyRec);

      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN NULL;
    END LOG_WARNING_EVENT;
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_WARNING_EVENT(p_LogRec    MIGR_GVAR.LogRecTyp,
                              PIO_ERR  IN SRVERR)
    AS
      l_policyRec MIGR_GVAR.LogRecTyp;
    BEGIN
      l_policyRec := p_LogRec;
      FOR I IN PIO_ERR.FIRST .. PIO_ERR.LAST
      LOOP
        l_policyRec.logMsg := 'WARNING:' || PIO_ERR(I).ERRCODE || '' || 'TYPE:' || PIO_ERR(I).ERRTYPE || ' MESSAGE:' || PIO_ERR(I).ERRMESSAGE;
        MIGR_LOG.LOG_WARNING(l_policyRec);
      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN NULL;
    END LOG_WARNING_EVENT;
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_INFO(p_migrBatchId   IN VARCHAR2,
                     p_MigrationArea IN VARCHAR2,
                     p_MigrationStep IN VARCHAR2,
                     p_LogMsg        IN VARCHAR2,
                     p_RelatedTable  IN VARCHAR2,
                     p_RelatedKey    IN VARCHAR2)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
       IF MIGR_GVAR.GV_DEBUG_INFO
       THEN

      INSERT INTO MIGR_API_DETAIL_LOG (
        LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
      )
      VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_migrBatchId, SYSTIMESTAMP, SUBSTR(p_MigrationArea, 1, 50), MIGR_GVAR.C_ERR_INFO, SUBSTR(p_LogMsg, 1, 2000), SUBSTR(p_MigrationStep, 1, 256), SUBSTR(p_RelatedTable, 1, 2000), SUBSTR(p_RelatedKey, 1, 2000));
       END IF;
      COMMIT;

      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_MigrationArea || '.' || p_MigrationStep || ': = ' || p_LogMsg || ' ' || p_RelatedKey || ' ( ' || p_RelatedTable || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_INFO;
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_INFO(p_LogRec MIGR_GVAR.LogRecTyp)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      IF MIGR_GVAR.GV_DEBUG_INFO
      THEN

        INSERT INTO MIGR_API_DETAIL_LOG (
          LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
        )
        VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_LogRec.mig_batch_id, SYSTIMESTAMP, SUBSTR(p_LogRec.migrArea, 1, 50), MIGR_GVAR.C_ERR_INFO, SUBSTR(p_LogRec.logMsg, 1, 2000), SUBSTR(p_LogRec.migrStep, 1, 256), SUBSTR(p_LogRec.migrRelTbl, 1, 2000), SUBSTR(p_LogRec.migrRelKey, 1, 2000));

      END IF;
      COMMIT;
      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_LogRec.migrArea || '.' || p_LogRec.migrStep || ': = ' || p_LogRec.logMsg || ' ' || p_LogRec.migrRelKey || ' ( ' || p_LogRec.migrRelTbl || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_INFO;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_INFO(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      IF MIGR_GVAR.GV_DEBUG_INFO
      THEN

        INSERT INTO MIGR_API_DETAIL_LOG (
          LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
        )
        VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_policyRec.mig_batch_id, SYSTIMESTAMP, p_policyRec.migrArea, MIGR_GVAR.C_ERR_INFO, p_policyRec.logMsg, p_policyRec.migrStep, p_policyRec.migrRelTbl, p_policyRec.policy_idpl);

      END IF;
      COMMIT;

      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_policyRec.migrArea || '.' || p_policyRec.migrStep || ': = ' || p_policyRec.logMsg || ' ' || p_policyRec.policy_idpl || ' ( ' || p_policyRec.migrRelTbl || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_INFO;

 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_EXCEPTION(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      INSERT INTO MIGR_API_DETAIL_LOG (
        LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
      )
      VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_policyRec.mig_batch_id, SYSTIMESTAMP, p_policyRec.migrArea, MIGR_GVAR.C_ERR_EXCEPTION, SUBSTR(p_policyRec.logMsg, 1, 2000), p_policyRec.migrStep, p_policyRec.migrRelTbl, p_policyRec.policy_idpl);

      COMMIT;
      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_policyRec.migrArea || '.' || p_policyRec.migrStep || ': = ' || p_policyRec.logMsg || ' ' || p_policyRec.policy_idpl || ' ( ' || p_policyRec.migrRelTbl || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_EXCEPTION;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_WARNING(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      IF MIGR_GVAR.GV_DEBUG_WARNING  THEN

        INSERT INTO MIGR_API_DETAIL_LOG (
          LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
        )
        VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_policyRec.mig_batch_id, SYSTIMESTAMP, p_policyRec.migrArea, MIGR_GVAR.C_ERR_WARN, SUBSTR(p_policyRec.logMsg, 1, 2000), p_policyRec.migrStep, p_policyRec.migrRelTbl, p_policyRec.policy_idpl);

      END IF;
      COMMIT;
      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_policyRec.migrArea || '.' || p_policyRec.migrStep || ': = ' || p_policyRec.logMsg || ' ' || p_policyRec.policy_idpl || ' ( ' || p_policyRec.migrRelTbl || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_WARNING;
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_ERROR(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    AS
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      INSERT INTO MIGR_API_DETAIL_LOG (
        LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
      )
      VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_policyRec.mig_batch_id, SYSTIMESTAMP, p_policyRec.migrArea, MIGR_GVAR.C_ERR_ERROR, p_policyRec.logMsg, p_policyRec.migrStep, p_policyRec.migrRelTbl, p_policyRec.policy_idpl);

      COMMIT;

      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_policyRec.migrArea || '.' || p_policyRec.migrStep || ': = ' || p_policyRec.logMsg || ' ' || p_policyRec.policy_idpl || ' ( ' || p_policyRec.migrRelTbl || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_ERROR;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_WARNING(p_migrBatchId   IN VARCHAR2,
                        p_MigrationArea IN VARCHAR2,
                        p_MigrationStep IN VARCHAR2,
                        p_LogMsg        IN VARCHAR2,
                        p_RelatedTable  IN VARCHAR2,
                        p_RelatedKey    IN VARCHAR2)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        IF MIGR_GVAR.GV_DEBUG_WARNING  THEN
          INSERT INTO MIGR_API_DETAIL_LOG (
            LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
          )
          VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_migrBatchId, SYSTIMESTAMP, SUBSTR(p_MigrationArea, 1, 50), MIGR_GVAR.C_ERR_WARN, SUBSTR(p_LogMsg, 1, 2000), SUBSTR(p_MigrationStep, 1, 256), SUBSTR(p_RelatedTable, 1, 2000), SUBSTR(p_RelatedKey, 1, 2000));


        END IF;

      COMMIT;
      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_MigrationArea || '.' || p_MigrationStep || ': = ' || p_LogMsg || ' ' || p_RelatedKey || ' ( ' || p_RelatedTable || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_WARNING;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_WARNING(p_LogRec MIGR_GVAR.LogRecTyp)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      IF MIGR_GVAR.GV_DEBUG_WARNING  THEN

        INSERT INTO MIGR_API_DETAIL_LOG (
          LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
        )
        VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_LogRec.mig_batch_id, SYSTIMESTAMP, SUBSTR(p_LogRec.migrArea, 1, 50), MIGR_GVAR.C_ERR_WARN, SUBSTR(p_LogRec.logMsg, 1, 2000), SUBSTR(p_LogRec.migrStep, 1, 256), SUBSTR(p_LogRec.migrRelTbl, 1, 2000), SUBSTR(p_LogRec.migrRelKey, 1, 2000));

      END IF;
      COMMIT;
      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_LogRec.migrArea || '.' || p_LogRec.migrStep || ': = ' || p_LogRec.logMsg || ' ' || p_LogRec.migrRelKey || ' ( ' || p_LogRec.migrRelTbl || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_WARNING;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_EXCEPTION(p_migrBatchId   IN VARCHAR2,
                          p_MigrationArea IN VARCHAR2,
                          p_MigrationStep IN VARCHAR2,
                          p_LogMsg        IN VARCHAR2,
                          p_RelatedTable  IN VARCHAR2,
                          p_RelatedKey    IN VARCHAR2)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      INSERT INTO MIGR_API_DETAIL_LOG (
        LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
      )
      VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_migrBatchId, SYSTIMESTAMP, SUBSTR(p_MigrationArea, 1, 50), MIGR_GVAR.C_ERR_EXCEPTION, SUBSTR(p_LogMsg, 1, 2000), SUBSTR(p_MigrationStep, 1, 256), SUBSTR(p_RelatedTable, 1, 2000), SUBSTR(p_RelatedKey, 1, 2000));

      COMMIT;

      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_MigrationArea || '.' || p_MigrationStep || ': = ' || p_LogMsg || ' ' || p_RelatedKey || ' ( ' || p_RelatedTable || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_EXCEPTION;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE LOG_EXCEPTION(p_LogRec MIGR_GVAR.LogRecTyp)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      INSERT INTO MIGR_API_DETAIL_LOG (
        LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
      )
      VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_LogRec.mig_batch_id, SYSTIMESTAMP, SUBSTR(p_LogRec.migrArea, 1, 50), MIGR_GVAR.C_ERR_EXCEPTION, SUBSTR(p_LogRec.logMsg, 1, 2000), SUBSTR(p_LogRec.migrStep, 1, 256), SUBSTR(p_LogRec.migrRelTbl, 1, 2000), SUBSTR(p_LogRec.migrRelKey, 1, 2000));

      COMMIT;

      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_LogRec.migrArea || '.' || p_LogRec.migrStep || ': = ' || p_LogRec.logMsg || ' ' || p_LogRec.migrRelKey || ' ( ' || p_LogRec.migrRelTbl || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_EXCEPTION;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 --FA.20161121 Procedure to log event consumed time
    PROCEDURE LOG_EVENT_TIME(p_policyRec MIGR_GVAR.PolicyRecTyp)
    AS
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

     IF MIGR_GVAR.GV_LOG_TIMER THEN
      INSERT INTO MIGR_API_DETAIL_LOG (
        LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, EVENT_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
      )
      VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_policyRec.mig_batch_id, SYSTIMESTAMP, p_policyRec.migrArea, MIGR_GVAR.C_ERR_INFO, p_policyRec.logMsg,  p_policyRec.migrStep, 'TIMER', p_policyRec.policy_idpl);


      END IF;
      COMMIT;

     IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_policyRec.migrArea || '.' || p_policyRec.migrStep || ': = ' || p_policyRec.logMsg || ' ' || p_policyRec.policy_idpl || ' ( ' || p_policyRec.migrRelTbl || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_EVENT_TIME;
   --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA.20160706 LOG all policies that were not migrated  in INSIS
  PROCEDURE LOG_FAILED_POLICY(P_POLICYREC  IN   MIGR_GVAR.PolicyRecTyp,
                              p_beginStepTimer  TIMESTAMP,
                              p_policyStep IN   VARCHAR)
    IS
    BEGIN

      INSERT INTO MIGR_FAILED_POLICY (
        POLICY_REF, POLICY_STEP, INS_DATE, INS_MS, MIG_START, MIG_END, MIG_BATCH_ID, POLICY_IDPL, CLIENT_ID, AGENT_ID, INSRPRD, ERROR_MESSAGE ,OFFRNCODE
      )
      VALUES (P_POLICYREC.POLICY_REF, p_policyStep, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, p_beginStepTimer), p_beginStepTimer, SYSTIMESTAMP, P_POLICYREC.MIG_BATCH_ID, P_POLICYREC.POLICY_IDPL, P_POLICYREC.CLIENT_ID, P_POLICYREC.AGENT_ID, P_POLICYREC.INSRPRD, SUBSTR(P_POLICYREC.logMsg, 1, 2000), P_POLICYREC.insr_type);

      MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(P_POLICYREC.POLICY_IDPL, MIGR_GVAR.GV_MIG_FLAG_FAILED, P_POLICYREC.MIG_BATCH_ID);

    END;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160706 LOG all policies that were  migrated  in INSIS -Log the step the last succesfull step
  PROCEDURE LOG_POLICY(P_POLICYREC  IN out  MIGR_GVAR.PolicyRecTyp,
                       p_beginStepTimer  TIMESTAMP,
                       p_policyStep IN   VARCHAR)
    IS
     l_flag  PLS_INTEGER;
     l_insisPrem VARCHAR2(50);

    BEGIN

     --Get premiium calculated from INSIS
    BEGIN
          SELECT cond_value INTO l_insisPrem
          FROM INSIS_GEN_V10.POLICY_CONDITIONS pc
          WHERE pc.COND_TYPE = 'POLICY_NET_PREMIUM' AND pc.POLICY_ID=p_policyrec.POLICY_ID;

    EXCEPTION WHEN OTHERS THEN
             l_insisPrem :=NULL;
     END;

     IF p_policyrec.mig_flag= MIGR_GVAR.GV_MIG_FLAG_RUNNING  THEN
        --Log time values and premiums for phase A
        --If at least one step failed then turn policy to failed status
           IF   P_POLICYREC.continue_migr THEN
              --FA.20170316 Special treatment In case that all steps run at phase 1 flag should turn into final status in order to be bale to close the bacth -Added condition p_policyrec.policy_final_step:= 'CONVERTED'
              IF  p_policyrec.policy_final_step != 'CONVERTED'  THEN
                       l_flag :=MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS ;
               ELSE
                       l_flag := MIGR_GVAR.GV_MIG_FLAG_SUCCESS;
               END IF;
           ELSE
                  l_flag:= MIGR_GVAR.GV_MIG_FLAG_FAILED;
          END IF;


        INSERT INTO MIGR_POLICY ( POLICY_REF, POLICY_ID, POLICY_STEP, INS_DATE_A, INS_MS_A, MIG_START_A, MIG_END_A, MIG_BATCH_ID, POLICY_IDPL, CLIENT_ID, AGENT_ID, INSRPRD, OFFRNCODE,INSIS_PREMIUM_A,INSIS_PREMIUM_B )
        VALUES (p_policyrec.POLICY_REF, p_policyrec.POLICY_ID, p_policyStep, SYSDATE, MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, p_beginStepTimer), p_beginStepTimer, SYSTIMESTAMP, p_policyrec.MIG_BATCH_ID, p_policyrec.POLICY_IDPL, p_policyrec.CLIENT_ID, p_policyrec.AGENT_ID, p_policyrec.INSRPRD, p_policyrec.insr_type,l_insisPrem,l_insisPrem);

      ELSE
                --Log time values and premiums for phase B
                --Fa.20170126 if at least one step failed then turn policy to failed status
              IF   P_POLICYREC.continue_migr THEN
                    l_flag := MIGR_GVAR.GV_MIG_FLAG_SUCCESS;
              ELSE
                  l_flag:= MIGR_GVAR.GV_MIG_FLAG_FAILED_DISCOUNTS;
              END IF;

              UPDATE    MIGR_POLICY
              SET       POLICY_STEP=p_policyStep, INS_DATE_B = SYSDATE,  INS_MS_B =   MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, p_beginStepTimer)  ,MIG_START_B=p_beginStepTimer, MIG_END_B =SYSTIMESTAMP , INSIS_PREMIUM_B=l_insisPrem
              WHERE   POLICY_ID =  P_POLICYREC.policy_id;

      END IF;
           MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(P_POLICYREC.POLICY_IDPL, l_flag, P_POLICYREC.MIG_BATCH_ID);

    END;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    PROCEDURE LOG_COVER_ERROR_RULES(p_idpl   NUMBER,  p_mig_batch_id IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE)
    IS
      PRAGMA AUTONOMOUS_TRANSACTION;

    BEGIN

      INSERT INTO MIG_DETAIL_ERROR_LOG (
        MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
      )
      VALUES (p_mig_batch_id, SYSTIMESTAMP, 'RULES', 'ERROR', 'Record has been excluded due to missing mandatory insured value', 'Rules before API Area', 'IA_POLICY', p_idpl);

     EXECUTE IMMEDIATE 'UPDATE IA_POLICY SET MIG_FLAG = ''3'' WHERE IA_IDPL = ' || p_idpl;

      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END;


------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- +++ anb 2018-11-11 log CLOBs
  PROCEDURE LOG_CLOB(p_CLOBLogRec MIGR_GVAR.CLOBRecTyp)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
      IF MIGR_GVAR.GV_DEBUG_INFO
      THEN

        INSERT INTO MIGR_API_CLOB_LOG (
          LOG_ID, MIGRATION_BATCH_ID, EVENT_TIMESTAMP, MIGRATION_AREA, EVENT_TYPE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY,  EVENT_CLOB
        )
        VALUES (MIGR_DETAIL_SEQ.NEXTVAL, p_CLOBLogRec.mig_batch_id, SYSTIMESTAMP, SUBSTR(p_CLOBLogRec.migrArea, 1, 50), MIGR_GVAR.C_ERR_INFO, SUBSTR(p_CLOBLogRec.migrStep, 1, 256), SUBSTR(p_CLOBLogRec.migrRelTbl, 1, 2000), SUBSTR(p_CLOBLogRec.migrRelKey, 1, 2000), p_CLOBLogRec.EVENT_CLOB);

      END IF;
      COMMIT;
      IF MIGR_GVAR.GV_DEBUG = 'TRUE'
      THEN
        DBMS_OUTPUT.PUT_LINE(p_CLOBLogRec.migrArea || '.' || p_CLOBLogRec.migrStep || ': = ' ||' CLOB '|| ' ' || p_CLOBLogRec.migrRelKey || ' ( ' || p_CLOBLogRec.migrRelTbl || ' )');
      END IF;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_CLOB;
-- +++ end anb 2018-11-11 log CLOBs
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_LOG;
/

CREATE OR REPLACE PACKAGE BODY                   MIGR_MAPS
  AS
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------
 --Get select statement from configuration table and create the view

--  PROCEDURE CREATE_MIGR_VIEWS
--    AS
--
--      vSQL VARCHAR2(6000) := '';
--    BEGIN
--
--      FOR cRec IN (SELECT VIEW_NAME, VIEW_SELECT
--          FROM ETL_MIGR_MAPS
--          WHERE NVL(IS_ACTIVE, 'FALSE') = 'TRUE'
--         --FA.20160413 Deductibles should be created after cover views
--         AND view_name NOT like '%DEDUCTIBLES%'
--          ORDER BY ETL_ID ASC)
--      LOOP
--        BEGIN
--
--          vSQL := 'CREATE OR REPLACE VIEW ' || cRec.VIEW_NAME
--          || ' AS ( '
--          || CREC.VIEW_SELECT
--          || ' ) ';
--
--          EXECUTE IMMEDIATE vSQL;
--
--        EXCEPTION
--          WHEN OTHERS THEN NULL;
--        END;
--      END LOOP;
--
--    EXCEPTION
--      WHEN OTHERS THEN NULL;
--    END CREATE_MIGR_VIEWS;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ---FA.20160517 New functionality that replaces old views with tables and create new views with v_ prefix
  PROCEDURE RUN_MAPS AS
    v_table_type ETL_SETUP_INFO.INTERMEDIATE_TABLE_TYPE%TYPE;
    l_LogRec MIGR_GVAR.LogRecTyp;
  BEGIN

    --FA.20160718 Get table type parameter from intermediate objects
  SELECT INTERMEDIATE_TABLE_TYPE
          INTO v_table_type
          FROM ETL_SETUP_INFO;

   MIGR_INTERMEDIATE_OBJECTS.DROP_INTERMEDIATE_OBJECTS();
    MIGR_INTERMEDIATE_OBJECTS.CREATE_INTERMEDIATE_TABLES(v_table_type);
    MIGR_INTERMEDIATE_OBJECTS.CREATE_INTERMEDIATE_VIEWS();


EXCEPTION WHEN OTHERS THEN
        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_MAPS.RUN_MAPS' ;
        l_LogRec.migrStep      :=   'RUN_MAPS' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=    SQLCODE || '-'||SQLERRM  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

END RUN_MAPS;

--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------

END MIGR_MAPS;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_MD_DISCOUNTS
  AS

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--Load discounts into Landing area table
--No reconciliation checks are performed between discounts file an kf100f or between waiting discounts polciy in ia_policy and discounts file
  PROCEDURE RUN_LA_DISCOUNTS(p_migrBatchId IN VARCHAR2, LA_Status OUT VARCHAR2)
    AS
      vSQL                 VARCHAR2(2000);
      l_LogRec             MIGR_GVAR.LogRecTyp;
      ex_LaRollback        EXCEPTION;
      l_md_discounts_count PLS_INTEGER;
      l_ia_count           PLS_INTEGER;
      v_renewal            DATE;

      l_bolag_id           VARCHAR2(10);
      l_tbl_name           VARCHAR2(50);
      l_tbl_row_cnt        PLS_INTEGER;
      l_file_row_cnt       PLS_INTEGER;

      v_query              VARCHAR2(1024);
      v_count              PLS_INTEGER;
    BEGIN
      LA_Status             := MIGR_GVAR.GV_MD_DISC_STATUS_INCOMPLETE; --'INCOMPLETE';
      l_LogRec.migrArea     := 'MIGR_MD_DISCOUNTS.RUN_LA_DISCOUNTS';
      l_LogRec.migrStep     := 'Loading to Landing area';
      l_LogRec.logMsg       := 'Started Loading Discounts from LOAD to LA';
      l_LogRec.mig_batch_id := p_migrBatchId;
      MIGR_LOG.LOG_INFO(l_LogRec);

      l_bolag_id := SUBSTR(p_migrBatchId, 1, 2);
      l_tbl_name := 'LA_M' || l_bolag_id || '_MD_DISCOUNTS_LOAD';

      -- Table counter
      EXECUTE IMMEDIATE 'SELECT COUNT(''X'') FROM ' || l_tbl_name || ' WHERE NOT BOLAG_ID IS NULL' INTO l_tbl_row_cnt;

      -- File counter
      l_file_row_cnt := MD_DISCOUNTS_FILE_ROW_COUNTER(p_migrBatchId);

      -- Policy IDPL validation
      v_query := 'SELECT COUNT(*)'
              || '  FROM ' || l_tbl_name -- i.e. 'LA_M27_MD_DISCOUNTS_LOAD '
              || ' WHERE 1=1'
              || '  AND MIGG_POLICY_IDPL = BOLAG_ID || LPAD(FNR, 7, ''0'') || LPAD(FVNR, 3, ''0'')';

      EXECUTE IMMEDIATE v_query INTO v_count;

      l_LogRec.logMsg := 'Load table row count: ' || l_tbl_row_cnt || ' Discount file row count: ' || l_file_row_cnt || ' IDPL Validation counter: ' || v_count;
      MIGR_LOG.LOG_INFO(l_LogRec);

      IF NOT l_file_row_cnt IS NULL AND l_file_row_cnt = l_tbl_row_cnt AND v_count = l_file_row_cnt THEN
            --Get current renewal date from migration plan schedule
            SELECT trunc(RENEWAL_DATE)
            INTO v_renewal
            FROM (SELECT * FROM ETL_MIGRATION_CONDITIONS   WHERE 1=1  AND ITERATION_STATUS='Pending' ORDER BY id)
            WHERE ROWNUM=1;

            FOR cBolag IN (SELECT ebi.BOLAG_ID
                                   FROM MIG_MIGRATION_INFO ebi
                                   WHERE 1 = 1
                                   AND ebi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id
            )
            LOOP
                FOR cTable IN (SELECT etd.TBLNAME, etd.LA
                                 FROM ETL_TBL_DEF etd
                                 WHERE 1 = 1
                                  AND etd.file_role = 'Discounts'
                                  AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
                                  AND NVL(etd.LA, 'N') = 'Y'
                )
                LOOP
                    l_LogRec.migrRelTbl := cTable.TBLNAME;
                    l_LogRec.migrRelKey := cTable.TBLNAME || '.' || cBolag.BOLAG_ID;
                    l_LogRec.migrStep   := 'Landing';
                    l_LogRec.logMsg     := 'Begin loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
                    MIGR_LOG.LOG_INFO(l_LogRec);
                    MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

                    MIGR_LA_SA.LOG_MIG_VOL_ANAL_ROW_COUNT(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

                    MIGR_LA_SA.LOG_MIG_MATCHING_RECORDS(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

                    MIGR_LA_SA.LOG_MIG_VOL_ANAL_MATCHING(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

                    --Commits for every table load
                    IF NOT MIGR_LA_SA.INSERT_RECORDS_IN_HISTORY(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC,v_renewal)
                    THEN
                      RAISE ex_LaRollback;
                    END IF;

                     l_LogRec.logMsg := 'End loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
                     MIGR_LOG.LOG_INFO(l_LogRec);
                     MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

                END LOOP;
                LA_Status := MIGR_GVAR.GV_MD_DISC_STATUS_COMPLETE; --'COMPLETE';

            END LOOP;
      ELSE
        LA_Status := MIGR_GVAR.GV_MD_DISC_STATUS_FAILED_DISC;

      END IF;

      l_LogRec.logMsg     := 'Finished Loading Discounts from LOAD to LA with status: ' || LA_Status;
      l_LogRec.migrRelTbl := '';
      l_LogRec.migrRelKey := '';
      MIGR_LOG.LOG_INFO(l_LogRec);



  EXCEPTION
    WHEN ex_LaRollback THEN
        LA_Status := 'ROLLBACK_LA';
        UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Failed' WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
        l_LogRec.logMsg := 'ex_LaRollback Exception';
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);
        COMMIT;
    WHEN OTHERS THEN
        LA_Status       := MIGR_GVAR.GV_MD_DISC_STATUS_INCOMPLETE; --'INCOMPLETE';
        l_LogRec.logMsg := SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);
        UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Failed' WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
       COMMIT;

  END RUN_LA_DISCOUNTS;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 --Load discounts into Staging area table
  PROCEDURE RUN_SA_DISCOUNTS(p_migrBatchId IN VARCHAR2, SA_Status OUT VARCHAR2)
    AS
      vSql           VARCHAR2(2000);
      l_LogRec       MIGR_GVAR.LogRecTyp;
      ex_SaRollback  EXCEPTION;

  BEGIN
      SA_Status             := 'INCOMPLETE';
      l_LogRec.migrArea     := 'MIGR_MD_DISCOUNTS.RUN_SA_DISCOUNTS';
      l_LogRec.migrStep     := 'Landing to Staging area';
      l_LogRec.logMsg       := 'Starting Loading Discounts from LA to SA';
      l_LogRec.mig_batch_id := p_migrBatchId;
      MIGR_LOG.LOG_INFO(l_LogRec);

      FOR cTable IN (SELECT etd.TBLNAME
                       FROM ETL_TBL_DEF etd
                      WHERE 1 = 1
                        AND etd.TBLNAME = 'MD_DISCOUNTS'
                        AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
                        AND NVL(etd.SA, 'N') = 'Y'
      )
      LOOP
          FOR cBolag IN (SELECT ebi.BOLAG_ID
                           FROM MIG_MIGRATION_INFO ebi
                          WHERE 1 = 1
                            AND ebi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id
          )
          LOOP
              l_LogRec.migrRelTbl := cTable.TBLNAME;
              l_LogRec.migrRelKey := cTable.TBLNAME || '.' || cBolag.BOLAG_ID;
              l_LogRec.migrStep   := 'Staging';
              l_LogRec.logMsg     := 'Begin loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
              MIGR_LOG.LOG_INFO(l_LogRec);

              MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

              IF NOT MIGR_LA_SA.INSERT_RECORDS_IN_HISTORY_SA(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC)
              THEN
                RAISE ex_SaRollback;
              ELSE
                SA_Status := 'COMPLETE';
              END IF;

              MIGR_LA_SA.UPDATE_LA_MIG_FLAG(l_LogRec);

              MIGR_LA_SA.LOG_MIG_VOL_ANAL_ROW_COUNT(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

              l_LogRec.logMsg := 'End loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
              MIGR_LOG.LOG_INFO(l_LogRec);

              MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

          END LOOP;

      END LOOP;

      l_LogRec.logMsg := 'Finished Loading Discounts from LA to SA'; l_LogRec.migrRelTbl := ''; l_LogRec.migrRelKey := '';
      MIGR_LOG.LOG_INFO(l_LogRec);

  EXCEPTION
    WHEN ex_SaRollback THEN
          l_LogRec.logMsg := 'Exception ex_SaRollback';
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          SA_Status := 'ROLLBACK_SA';
          UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Failed' WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
    WHEN OTHERS THEN
          SA_Status       := 'INCOMPLETE';
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Failed' WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;

  END RUN_SA_DISCOUNTS;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--Load Discounts in Intermediate Area
  PROCEDURE RUN_IA_DISCOUNTS(p_migrBatchId IN VARCHAR2, IA_Status OUT VARCHAR2)
    AS
      vSql           VARCHAR2(2000);
      l_LogRec       MIGR_GVAR.LogRecTyp;
      ex_SaRollback  EXCEPTION;

  BEGIN
      IA_Status             := 'INCOMPLETE';
      l_LogRec.migrArea     := 'MIGR_MD_DISCOUNTS.RUN_IA_DISCOUNTS';
      l_LogRec.migrStep     := 'Staging to Intermediate area';
      l_LogRec.logMsg       := 'Started IA Discounts processing';
      l_LogRec.mig_batch_id := p_migrBatchId;
      MIGR_LOG.LOG_INFO(l_LogRec);

      l_LogRec.migrRelTbl   := 'MD_DISCOUNTS';
      --Populate temporary table  MD_DISCOUNTS
      IF MIGR_INTERMEDIATE_OBJECTS.POPULATE_INTERMEDIATE_TABLE(l_LogRec)
      THEN
            l_LogRec.logMsg := 'Populated Intermediate Objects';
            MIGR_LOG.LOG_INFO(l_LogRec);
             --IA_Status := 'COMPLETE';
             --Populate  table  IA_MD_DISCOUNTS
             MIGR_IA.IA_MAIN_TBL(l_LogRec, IA_Status, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);
        ELSE
             UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Failed', Status = 'Failed', END_TIMESTAMP = SYSTIMESTAMP WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;

      END IF;


      l_LogRec.logMsg := 'Finished IA processing'; l_LogRec.migrRelTbl := ''; l_LogRec.migrRelKey := '';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN
          IA_Status       := 'INCOMPLETE';
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Failed', Status = 'Failed' WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;
          COMMIT;
  END RUN_IA_DISCOUNTS;
---------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Update INSIS discounts table: INSIS_GEN_V10.GEN_RISK_DISCOUNT
  --The function is called by discount flow and by  premiums adjustment flow
  FUNCTION UPDATE_MD_DISCOUNTS (p_policyRec MIGR_GVAR.PolicyRecTyp, p_discount_type IN VARCHAR2)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS
      L_IN_CONTEXT   SRVCONTEXT;
      L_OUT_CONTEXT  SRVCONTEXT;
      L_RESULT       VARCHAR2(50);
      pio_err        SRVERR;

      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

      R_DISCOUNT        INSIS_GEN_V10.P_DISCOUNT_TYPE;
      l_discount_id     NUMBER;
      l_discount_value  NUMBER;

  BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrStep   := 'Update Policy MD Discounts';
      l_policyRec.migrArea   := 'MIGR_MD_DISCOUNTS.UPDATE_MD_DISCOUNT';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

      --Find discount id in INSIS. If  INSURED_OBJ_ID is null than the discount applies to policy level
       IF l_policyRec.insured_object_id IS NULL THEN
           SELECT grd.DISCOUNT_ID
              INTO l_discount_id
              FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
             WHERE grd.POLICY_ID = l_policyRec.policy_id AND grd.DISCOUNT_TYPE = p_discount_type AND grd.INSURED_OBJ_ID IS NULL and grd.CLIENT_GROUP=0 AND NVL(grd.COVER_TYPE,'0')='0' AND grd.ANNEX_ID=MIGR_GVAR.GV_ANNEX_ID ;
       ELSE
            SELECT grd.DISCOUNT_ID
              INTO l_discount_id
              FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
             WHERE grd.POLICY_ID = l_policyRec.policy_id AND grd.DISCOUNT_TYPE = p_discount_type AND grd.INSURED_OBJ_ID =l_policyRec.insured_object_id and grd.CLIENT_GROUP=0 AND NVL(grd.COVER_TYPE,'0')='0' AND grd.ANNEX_ID=MIGR_GVAR.GV_ANNEX_ID ;
       END IF;

      ---Get discount value from IA_MD_DISCOUNTS
        SELECT imd.IA_DISCOUNT
            INTO l_discount_value
            FROM IA_MD_DISCOUNTS imd
           WHERE imd.IA_POLICY_ID = l_policyRec.policy_id;

        IF  MIGR_GVAR.GV_MIGRATION_METHOD='EVENT' THEN

           L_IN_CONTEXT    := NULL;
           L_OUT_CONTEXT := NULL;
           L_RESULT           := NULL;
           pio_err                 := NULL;

           SRV_CONTEXT.SETCONTEXTATTRNUMBER (L_IN_CONTEXT, 'DISCOUNT_ID', SRV_CONTEXT.INTEGERS_FORMAT, l_discount_id);
           SRV_CONTEXT.SETCONTEXTATTRNUMBER (L_IN_CONTEXT, 'DISCOUNT_VALUE', SRV_CONTEXT.REAL_NUMBER_FORMAT ,l_discount_value)  ;

           v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('UPD_DISCOUNT');

           v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
           EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_IN_CONTEXT, IN 'FALSE', OUT L_OUT_CONTEXT, IN OUT pio_err;

           SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

           l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, L_RESULT);

           IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS   THEN
                l_policyRec.logMsg := 'Updated Discounts succesfully for policy :' ||  l_policyRec.policy_id  ||  ' and  Insured Object for object_id: ' || l_policyRec.object_id || '-RESULT:' || L_RESULT;
                MIGR_LOG.LOG_INFO(l_policyRec);

          ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                l_policyRec.logMsg := 'Update Discounts returned with warning -RESULT:' || L_RESULT;
                MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);

          ELSE
                l_policyRec.logMsg := 'Failed to Update Discounts-RESULT ' || L_RESULT;
                MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);

                l_policyRec.logMsg := 'ERROR';
                l_policyRec.continue_migr := FALSE;
          END IF;

        --------------------------------------------------------


      ELSE



          R_DISCOUNT := NEW INSIS_GEN_V10.P_DISCOUNT_TYPE(l_discount_id);
--          R_DISCOUNT.INSURED_OBJ_ID    :=
--          R_DISCOUNT.COVER_TYPE        :=
--          R_DISCOUNT.POLICY_ID         := l_policyRec.policy_id;
--          R_DISCOUNT.ANNEX_ID          := MIGR_GVAR.GV_ANNEX_ID; -- ?
--          R_DISCOUNT.CLIENT_GROUP      :=
--          R_DISCOUNT.DISCOUNT_TYPE     :=
          R_DISCOUNT.DISCOUNT_VALUE    := l_discount_value;
--          R_DISCOUNT.ACCUMULATIVE_FLAG :=
--          R_DISCOUNT.APPLIED           :=
--          R_DISCOUNT.TARIFF_DISCOUNT   :=
--          R_DISCOUNT.DISCOUNT_ORDER    :=
--          R_DISCOUNT.LUMP_SUM_DISCOUNT :=
--          R_DISCOUNT.DISCOUNT_ID       :=
--          R_DISCOUNT.SEPARATE_ACCOUNT  :=
--          R_DISCOUNT.CORRECTION_AMOUNT :=
--          R_DISCOUNT.CALCULATION_MODE  :=
--          R_DISCOUNT.EFFECTIVE_FROM    :=
--          R_DISCOUNT.EFFECTIVE_TO      :=

           IF NOT R_DISCOUNT.UpdateDiscount(PIO_ERR) THEN
               MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
               l_policyRec.logMsg := 'ERROR';
           END IF;

      END IF;

      IF l_policyRec.logMsg = 'ERROR' THEN
          -- UPDATE IA_POLICY -> MIG_FLAG FAILED DISCOUNTS!
          MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(l_policyRec.policy_idpl, MIGR_GVAR.GV_MIG_FLAG_FAILED_DISCOUNTS, l_policyRec.MIG_BATCH_ID);

      END IF;

      RETURN l_policyRec;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      l_policyRec.logMsg := 'No discount found in GEN_RISK_DISCOUNT for discount type: ' || p_discount_type || ' ERR: ' || SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
       l_policyRec.continue_migr := FALSE;
      RETURN l_policyRec;
    WHEN OTHERS THEN
      l_policyRec.logMsg := 'ERR: ' || SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
      l_policyRec.continue_migr := FALSE;
      RETURN l_policyRec;

  END UPDATE_MD_DISCOUNTS;
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
--  PROCEDURE LOAD_MD_DISCOUNTS(p_migrBatchId IN VARCHAR2, LOAD_Status OUT VARCHAR2)
--    AS
--      vSql             VARCHAR2(2000);
--      l_LogRec         MIGR_GVAR.LogRecTyp;
--      ex_SaRollback    EXCEPTION;
--      l_policyRec      MIGR_GVAR.PolicyRecTyp;
--      l_discount_type  VARCHAR2(10);
--
--  BEGIN
--      LOAD_Status           := 'COMPLETE';
--      l_LogRec.migrArea     := 'MIGR_MD_DISCOUNTS.LOAD_MD_DISCOUNTS';
--      l_LogRec.migrStep     := 'Loading MD Discounts to INSIS area';
--      l_LogRec.logMsg       := 'Started MD Discounts loading';
--      l_LogRec.mig_batch_id := p_migrBatchId;
--      l_LogRec.migrRelTbl   := 'IA_MD_DISCOUNTS';
--      MIGR_LOG.LOG_INFO(l_LogRec);
--
--      SELECT DISCOUNT_TYPE INTO l_discount_type FROM ETL_SETUP_INFO;
--
--      FOR cRec IN (SELECT * FROM IA_MD_DISCOUNTS imd WHERE imd.MIG_BATCH_ID = p_migrBatchId AND NVL(imd.IA_DISCOUNT, '0') <> 0)
--      LOOP
--        l_policyRec.mig_batch_id := cRec.MIG_BATCH_ID;
--        l_policyRec.policy_id    := cRec.IA_POLICY_ID;
--        l_policyRec.policy_idpl  := cRec.IA_IDPL;
--
--        l_policyRec := UPDATE_MD_DISCOUNTS(l_policyRec, l_discount_type);
--
----        IF l_policyRec.logMsg = 'ERROR' THEN
----          RAISE ex_SaRollback;
----        END IF;
--
--      END LOOP;
--
--      UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Finished', DISCOUNTS_END_TIMESTAMP=SYSTIMESTAMP ----FA.20170127 Only API should be able to turn status to Finished ,status ='Finished'
--        WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
--
--      COMMIT;
--      l_LogRec.logMsg       := 'Finished MD Discounts loading';
--      MIGR_LOG.LOG_INFO(l_LogRec);
--
--
--    EXCEPTION
----    WHEN ex_SaRollback THEN
----      LOAD_Status := 'ROLLBACK_LOAD';
----      UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Failed' WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
--    WHEN OTHERS THEN
--      LOAD_Status := 'INCOMPLETE';
--      l_LogRec.logMsg := SQLERRM;
--      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
--      UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Failed', DISCOUNTS_END_TIMESTAMP=SYSTIMESTAMP WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
--
--  END LOAD_MD_DISCOUNTS;
---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

--   procedure retrieve_discounts_not(p_policyRec  MIGR_GVAR.PolicyRecTyp, p_discount_type in varchar2)
--
--  IS
--
--    l_discount_id NUMBER;
--    l_discount_value NUMBER;
--    vsql varchar2(3000);
--    TYPE sql_rec IS RECORD (
--            ia_discount_type VARCHAR2(50)
--            ,ia_discount_value number
--            ,is_valid_to date
--            ,ins_object_id  number
--    );
--    TYPE t_sql_type_tab IS TABLE OF sql_rec;
--    v_sql_tab       t_sql_type_tab;
--    i PLS_INTEGER;
--    l_policyRec    MIGR_GVAR.PolicyRecTyp;
--
--
--
--  BEGIN
--      l_policyRec := p_policyRec;
--      l_policyRec.migrStep   := 'Get Discount_ID from INSIS';
--      l_policyRec.migrArea   := 'MIGR_MD_DISCOUNTS.get_insis_discount_id';
--      l_policyRec.migrRelTbl := '';
--
--      IF p_discount_type is NOT NULL THEN     -- MD_DISCOUNTS.txt discounts
--          SELECT grd.DISCOUNT_ID
--                INTO l_discount_id
--               FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
--               WHERE grd.POLICY_ID = l_policyRec.policy_id AND grd.DISCOUNT_TYPE = p_discount_type AND grd.INSURED_OBJ_ID IS NULL and grd.CLIENT_GROUP=0 /*AND NVL(grd.COVER_TYPE,'0')='0'*/ AND grd.ANNEX_ID=MIGR_GVAR.GV_ANNEX_ID ;
--
--          SELECT imd.IA_DISCOUNT
--            INTO l_discount_value
--            FROM IA_MD_DISCOUNTS imd
--           WHERE imd.IA_POLICY_ID = l_policyRec.policy_id;
--
--          --use upload_discounts here
--
--       else
--          vsql:= 'select a.ia_discount_type, a.ia_discount_value, a.is_valid_to, b.ins_object_id '
--              || 'from ' || l_policyRec.ia_discountsTbl || ' a join ' ||l_policyRec.migrTbl ||' b on a.ia_idpl=b.policy_idpl '
--              || ' where a.ia_idpl=' ||l_policyRec.policy_idpl
--              || '   union all  '--policy_level
--              || ' select a.ia_discount_type, a.ia_discount_value, a.is_valid_to, null '
--              || ' from ia_gen_discounts_pol a '
--              || ' where ia_idpl='|| l_policyRec.policy_idpl  ;
--          EXECUTE IMMEDIATE vsql bulk COLLECT INTO  v_sql_tab;
--
--          FOR i IN 1 .. v_sql_tab.COUNT
--          LOOP
--
--                IF v_sql_tab(i).ins_object_id IS NULL THEN
--                       SELECT grd.DISCOUNT_ID
--                          INTO l_discount_id
--                          FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
--                         WHERE grd.POLICY_ID = l_policyRec.policy_id AND grd.DISCOUNT_TYPE = v_sql_tab(i).IA_DISCOUNT_TYPE AND grd.INSURED_OBJ_ID IS NULL and grd.CLIENT_GROUP=0 /*AND NVL(grd.COVER_TYPE,'0')='0'*/ AND grd.ANNEX_ID=MIGR_GVAR.GV_ANNEX_ID ;
--                ELSE
--                        SELECT grd.DISCOUNT_ID
--                          INTO l_discount_id
--                          FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
--                         WHERE grd.POLICY_ID = l_policyRec.policy_id AND grd.DISCOUNT_TYPE = v_sql_tab(i).IA_DISCOUNT_TYPE AND grd.INSURED_OBJ_ID =v_sql_tab(i).ins_object_id and grd.CLIENT_GROUP=0 /*AND NVL(grd.COVER_TYPE,'0')='0'*/ AND grd.ANNEX_ID=MIGR_GVAR.GV_ANNEX_ID ;
--                END IF;
--
--                --use upload_discounts here
--          END LOOP;
--       END IF;
--
--
--
--  EXCEPTION
--    WHEN OTHERS THEN
--      l_policyRec.logMsg := 'ERR: ' || SQLERRM;
--      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
--
--  END retrieve_discounts_not;
--
--
--
-----------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
FUNCTION GET_INSIS_DISCOUNT_ID(p_policyRec MIGR_GVAR.PolicyRecTyp, p_discount_type IN VARCHAR2, p_ins_object_id IN VARCHAR2)
RETURN NUMBER
IS
  l_policyRec    MIGR_GVAR.PolicyRecTyp;
  l_discount_id  number;
---  l_LogRec         MIGR_GVAR.LogRecTyp;

BEGIN
      l_policyRec:= p_policyRec;
      l_policyRec.migrArea     := 'MIGR_MD_DISCOUNTS.GET_INSIS_DISCOUNT_ID';
      l_policyRec.migrStep     := 'Fetch Discount_id from INSIS';
      l_policyRec.logMsg       := '';
      l_policyRec.migrRelTbl   := '';

     IF p_ins_object_id IS NULL THEN --policy_level
            SELECT grd.DISCOUNT_ID
               INTO l_discount_id
               FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
              WHERE grd.POLICY_ID = l_policyRec.policy_id AND grd.DISCOUNT_TYPE = p_discount_type AND grd.INSURED_OBJ_ID IS NULL and grd.CLIENT_GROUP=0 /*AND NVL(grd.COVER_TYPE,'0')='0'*/ AND grd.ANNEX_ID=MIGR_GVAR.GV_ANNEX_ID ;
     ELSE                            --object-level
             SELECT grd.DISCOUNT_ID
               INTO l_discount_id
               FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
              WHERE grd.POLICY_ID = l_policyRec.policy_id AND grd.DISCOUNT_TYPE = p_discount_type AND grd.INSURED_OBJ_ID =p_ins_object_id and grd.CLIENT_GROUP=0 /*AND NVL(grd.COVER_TYPE,'0')='0'*/ AND grd.ANNEX_ID=MIGR_GVAR.GV_ANNEX_ID ;
     END IF;

     RETURN l_discount_id;

  EXCEPTION
      when no_data_found then
        l_policyRec.logMsg := 'Cannot find discount_id for policy: ' || l_policyRec.policy_id || ' and object_id: '||p_ins_object_id;
        MIGR_LOG.LOG_EXCEPTION(l_policyRec);
        RETURN NULL;
      WHEN OTHERS THEN
        l_policyRec.logMsg := 'ERR: ' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_policyRec);
        RETURN NULL;
END GET_INSIS_DISCOUNT_ID;


---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
-- MD DISCOUNTS FILE ROW COUNTER
FUNCTION MD_DISCOUNTS_FILE_ROW_COUNTER (p_migrBatchId IN VARCHAR2)
RETURN NUMBER
IS
  l_LogRec    MIGR_GVAR.LogRecTyp;

  l_infile    utl_file.file_type;
  l_buffer    VARCHAR2(1024);
  l_cnt_rows  PLS_INTEGER := 0;
  l_dir       VARCHAR2(100);
  l_bolag_id  VARCHAR2(10);
  l_file_name VARCHAR2(30);
BEGIN
  l_LogRec.migrArea     := 'MIGR_MD_DISCOUNTS.MD_DISCOUNTS_FILE_ROW_COUNTER';
  l_LogRec.migrStep     := 'MIGR_MD_DISCOUNTS.MD_DISCOUNTS_FILE_ROW_COUNTER';
  l_LogRec.mig_batch_id := p_migrBatchId;
  l_LogRec.logMsg       := '';
  l_LogRec.migrRelTbl   := '';

  l_bolag_id      := SUBSTR(p_migrBatchId, 1, 2);
  l_dir           := 'READ_DIR_M' || l_bolag_id;
  l_file_name     := 'M' || l_bolag_id || '_MD_DISCOUNTS.txt';
  l_LogRec.logMsg := 'MIG_BATCH_ID: ' || p_migrBatchId || ', BOLAG_ID: ' || l_bolag_id || ', DIR: ' || l_dir || ', FILE_NAME: ' || l_file_name;

  -- open a file to read
  l_infile := utl_file.fopen(l_dir, l_file_name, 'r');

  -- check file is opened
  IF utl_file.is_open(l_infile) THEN

    -- loop lines in the file
    LOOP
      BEGIN
        utl_file.get_line(l_infile, l_buffer);
        IF SUBSTR(TRIM(l_buffer), 1, 5) <> 'BOLAG' AND LENGTHC(TRIM(l_buffer)) <> 0 THEN
          l_cnt_rows := l_cnt_rows + 1;
        END IF;
      EXCEPTION
        WHEN no_data_found THEN
          EXIT;
      END;

    END LOOP;

  ELSE
    l_cnt_rows := NULL;

  END IF;

  utl_file.fclose(l_infile);

--  DBMS_OUTPUT.PUT_LINE(l_cnt_rows);
  RETURN l_cnt_rows;

EXCEPTION
  WHEN OTHERS THEN
    l_LogRec.logMsg := 'ERR: ' || SQLERRM || ' - ' || l_LogRec.logMsg;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
    RETURN NULL;
END;

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
  function upload_discount(p_policyRec MIGR_GVAR.PolicyRecTyp, p_discount_id IN number, p_discount_value in NUMBER, p_valid_to IN date)
  return MIGR_GVAR.PolicyRecTyp
  IS
      l_policyRec    MIGR_GVAR.PolicyRecTyp;
      R_DISCOUNT        INSIS_GEN_V10.P_DISCOUNT_TYPE;
          L_IN_CONTEXT   SRVCONTEXT;
      L_OUT_CONTEXT  SRVCONTEXT;
      L_RESULT       VARCHAR2(50);
      pio_err        SRVERR;
          l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    --  l_LogRec         MIGR_GVAR.LogRecTyp;

  BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrStep   := 'Upload discount to INSIS';
      l_policyRec.migrArea   := 'MIGR_MD_DISCOUNTS.UPLOAD_DISCOUNT';
      l_policyRec.migrRelTbl := '';
      l_policyRec.logMsg := '';

      IF p_discount_id is NOT NULL then

          IF  MIGR_GVAR.GV_MIGRATION_METHOD='EVENT' THEN

             L_IN_CONTEXT    := NULL;
             L_OUT_CONTEXT := NULL;
             L_RESULT           := NULL;
             pio_err                 := NULL;

             SRV_CONTEXT.SETCONTEXTATTRNUMBER (L_IN_CONTEXT, 'DISCOUNT_ID', SRV_CONTEXT.INTEGERS_FORMAT, p_discount_id);
             SRV_CONTEXT.SETCONTEXTATTRNUMBER (L_IN_CONTEXT, 'DISCOUNT_VALUE', SRV_CONTEXT.REAL_NUMBER_FORMAT ,p_discount_value)  ;
             if p_valid_to IS NOT NULL THEN
                SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'EFFECTIVE_TO', SRV_CONTEXT.Date_Format, p_valid_to);
             end IF;

             v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('UPD_DISCOUNT');

             v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
             EXECUTE IMMEDIATE v_stmst   USING IN v_event, IN L_IN_CONTEXT, IN 'FALSE', OUT L_OUT_CONTEXT, IN OUT pio_err;

             SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);

             l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, L_RESULT);

             IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS   THEN
                  l_policyRec.logMsg := 'Updated Discount succesfully for policy :' ||  l_policyRec.policy_id  ||  ' and  discount_id: ' || p_discount_id || '-RESULT:' || L_RESULT;
                  MIGR_LOG.LOG_INFO(l_policyRec);

             ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING  THEN
                  l_policyRec.logMsg := 'Update Discounts returned with warning -RESULT:' || L_RESULT;
                  MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);

             ELSE
                  l_policyRec.logMsg := 'Failed to Update Discounts-RESULT ' || L_RESULT;
                  MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);

                  l_policyRec.logMsg := 'ERROR';
                  l_policyRec.continue_migr := FALSE;
             END IF;
          ELSE



              R_DISCOUNT := NEW INSIS_GEN_V10.P_DISCOUNT_TYPE(p_discount_id);
    --          R_DISCOUNT.INSURED_OBJ_ID    :=
    --          R_DISCOUNT.COVER_TYPE        :=
    --          R_DISCOUNT.POLICY_ID         := l_policyRec.policy_id;
    --          R_DISCOUNT.ANNEX_ID          := MIGR_GVAR.GV_ANNEX_ID; -- ?
    --          R_DISCOUNT.CLIENT_GROUP      :=
    --          R_DISCOUNT.DISCOUNT_TYPE     :=
              R_DISCOUNT.DISCOUNT_VALUE    := p_discount_value;
    --          R_DISCOUNT.ACCUMULATIVE_FLAG :=
    --          R_DISCOUNT.APPLIED           :=
    --          R_DISCOUNT.TARIFF_DISCOUNT   :=
    --          R_DISCOUNT.DISCOUNT_ORDER    :=
    --          R_DISCOUNT.LUMP_SUM_DISCOUNT :=
    --          R_DISCOUNT.DISCOUNT_ID       :=
    --          R_DISCOUNT.SEPARATE_ACCOUNT  :=
    --          R_DISCOUNT.CORRECTION_AMOUNT :=
    --          R_DISCOUNT.CALCULATION_MODE  :=
    --          R_DISCOUNT.EFFECTIVE_FROM    :=
              if p_valid_to IS NOT NULL THEN
                R_DISCOUNT.EFFECTIVE_TO      := p_valid_to;
              end if;

               IF NOT R_DISCOUNT.UpdateDiscount(PIO_ERR) THEN
                   MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
                   l_policyRec.logMsg := 'ERROR';
               END IF;

          END IF;
      else
          l_policyRec.logMsg := 'ERROR';
      END IF;

      if l_policyRec.logMsg = 'ERROR' THEN
        l_policyRec.logMsg := 'Failed to apply discount for policy: ' || l_policyRec.policy_id || ' with discount_id: '||p_discount_id;
        MIGR_LOG.LOG_EXCEPTION(l_policyRec);
      END IF;


      RETURN l_policyRec;



  EXCEPTION


    WHEN OTHERS THEN
      l_policyRec.logMsg := 'ERR: ' || SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
      --FA.20170301 Set migration flag to false
      l_policyRec.continue_migr := FALSE;
      RETURN l_policyRec;

  END upload_discount;

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_DISCOUNTS(p_policyRec  IN OUT MIGR_GVAR.PolicyRecTyp)
  IS
    l_discount_id NUMBER;
    l_discount_value NUMBER;
    vsql varchar2(3000);

    TYPE sql_rec IS RECORD (
            ia_discount_type VARCHAR2(50)
            ,ia_discount_value number
            ,is_valid_to date
            ,ins_object_id  number
            ,discount_id number
    );

   TYPE t_sql_type_tab IS TABLE OF sql_rec;
    v_sql_tab       t_sql_type_tab;
    i PLS_INTEGER;

  BEGIN

      p_policyRec.migrStep   := 'Gather policy-level and object-level Discounts';
      p_policyRec.migrArea   := 'MIGR_MD_DISCOUNTS.RUN_DISCOUNTS';
      p_policyRec.migrRelTbl := '';

      vsql:= 'select a.ia_discount_type, a.ia_discount_value, a.ia_valid_to, b.ins_object_id, null '
          || 'from ' || p_policyRec.ia_discountsTbl || ' a join ' ||p_policyRec.migrTbl ||' b on a.ia_idpl=b.policy_idpl '
          || ' where a.ia_idpl=' ||p_policyRec.policy_idpl || ' and a.IA_OBJECT_ID=b.IA_OBJECT_ID'
          || '   union all  '--policy_level
          || ' select a.ia_discount_type, a.ia_discount_value, a.ia_valid_to, null, null '
          || ' from ia_gen_discounts_pol a '
          || ' where ia_idpl='|| p_policyRec.policy_idpl  ;
      EXECUTE IMMEDIATE vsql bulk COLLECT INTO  v_sql_tab;

      FOR i IN 1 .. v_sql_tab.COUNT
      LOOP

        BEGIN
            v_sql_tab(i).discount_id := GET_INSIS_DISCOUNT_ID(p_policyRec, v_sql_tab(i).IA_DISCOUNT_TYPE , v_sql_tab(i).ins_object_id);
            --FA.20170301  : Check if discount id was returned prior to upload discounts
            IF  v_sql_tab(i).discount_id IS NOT NULL THEN
                  p_policyRec:= UPLOAD_DISCOUNT(p_policyRec, v_sql_tab(i).discount_id,v_sql_tab(i).ia_discount_value, v_sql_tab(i).is_valid_to);

            ELSE
                  p_policyRec.logMsg := 'INSIS Discount Id was not found for object: ' || v_sql_tab(i).ins_object_id || '  and discount type: '|| v_sql_tab(i).IA_DISCOUNT_TYPE  ;
                  MIGR_LOG.LOG_ERROR(p_policyRec);
                  p_policyRec.continue_migr := FALSE;
            END IF;

        EXCEPTION WHEN OTHERS THEN
            p_policyRec.continue_migr := FALSE;
            p_policyRec.logMsg := 'Exception: ' || SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(p_policyRec);
        END;

        --FA.commented 20170301-should be execuet only if have INSIS discount id  p_policyRec:= UPLOAD_DISCOUNt(l_policyRec, v_sql_tab(i).discount_id,v_sql_tab(i).ia_discount_value, v_sql_tab(i).is_valid_to);
      END LOOP;

  EXCEPTION
    WHEN OTHERS THEN
      p_policyRec.logMsg := 'ERR: ' || SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(p_policyRec);
      p_policyRec.continue_migr := FALSE;

  END RUN_DISCOUNTS;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- +++ anb 2015-05-22 Eliminate MIG_POL Discounts from Phase B

    PROCEDURE LOAD_MD_DISCOUNTS(p_migrBatchId IN VARCHAR2, LOAD_Status OUT VARCHAR2)
    AS
      vSql             VARCHAR2(2000);
      l_LogRec         MIGR_GVAR.LogRecTyp;
      ex_SaRollback    EXCEPTION;
      l_policyRec      MIGR_GVAR.PolicyRecTyp;
      l_discount_type  VARCHAR2(10);
      l_discount_id    number;
      l_insured_obj    VARCHAR2(50);
      l_P2_discount    VARCHAR2(30); -- +++ anb 2015-05-22 Eliminate MIG_POL Discounts from Phase B

  BEGIN
      LOAD_Status           := 'COMPLETE';
      l_LogRec.migrArea     := 'MIGR_MD_DISCOUNTS.LOAD_MD_DISCOUNTS';
      l_LogRec.migrStep     := 'Loading MD Discounts to INSIS area';
      l_LogRec.logMsg       := 'Started MD Discounts loading';
      l_LogRec.mig_batch_id := p_migrBatchId;
      l_LogRec.migrRelTbl   := 'IA_MD_DISCOUNTS';
      MIGR_LOG.LOG_INFO(l_LogRec);

--- +++ anb 2015-05-22 Eliminate MIG_POL Discounts from Phase B
--      SELECT DISCOUNT_TYPE INTO l_discount_type FROM ETL_SETUP_INFO;
      SELECT DISCOUNT_TYPE, nvl(P2_DISCOUNT, 'MIG_POL')
        INTO l_discount_type, l_P2_discount
      FROM ETL_SETUP_INFO;
--- +++ end anb 2015-05-22 Eliminate MIG_POL Discounts from Phase B

      FOR cRec IN (SELECT *
                     FROM IA_MD_DISCOUNTS imd
                    WHERE imd.MIG_BATCH_ID = p_migrBatchId
                      AND NVL(imd.IA_DISCOUNT, '0') <> 0
      )
      LOOP
        l_policyRec.mig_batch_id := cRec.MIG_BATCH_ID;
        ---FA.20170411 Instead of using file's policy_id which is candidate for format transformatiom errors, use the MIGG policy idpl and retrieve the mapped INSIS policy id from migr_policy

        l_policyRec.policy_idpl  := cRec.IA_IDPL;

        BEGIN

            SELECT POLICY_ID INTO l_policyRec.policy_id
              FROM MIGR_POLICY
              WHERE POLICY_IDPL= cRec.IA_IDPL;

                  BEGIN

--- +++ anb 2015-05-22 Eliminate MIG_POL Discounts from Phase B
--                      l_discount_id := GET_INSIS_DISCOUNT_ID(l_policyRec, l_discount_type , null);
--
--                     --FA.20170301  : Check if discount id was returned prior to upload discounts
--                      IF l_discount_id IS NOT NULL THEN
--                             l_policyRec:= UPLOAD_DISCOUNT(l_policyRec, l_discount_id, cRec.ia_discount, null);
--                      ELSE
--                            l_policyRec.logMsg := 'ERROR';
--                      END IF;

                      IF l_P2_discount = 'MIG_POL' THEN

--                          l_LogRec.logMsg       := 'Update MIG_POL'; --EZ 30.5.2019
--                          MIGR_LOG.LOG_INFO(l_LogRec);

                          l_discount_id := GET_INSIS_DISCOUNT_ID(l_policyRec, l_discount_type , null);

                         --FA.20170301  : Check if discount id was returned prior to upload discounts
                          IF l_discount_id IS NOT NULL THEN
                                 l_policyRec:= UPLOAD_DISCOUNT(l_policyRec, l_discount_id, cRec.ia_discount, null);
                          ELSE
                                l_policyRec.logMsg := 'ERROR';
                          END IF;

                      ELSE      --- Update PREM_INST_INTERIM

--                          l_LogRec.logMsg       := 'Before Updating PREM_INST_INTERIM'; --EZ 30.5.2019
--                          MIGR_LOG.LOG_INFO(l_LogRec);

                          l_policyRec.migrStep   := 'Upload discount to INSIS';
                          l_policyRec.migrArea   := 'MIGR_MD_DISCOUNTS.UPLOAD_DISCOUNT';
                          l_policyRec.migrRelTbl := 'PREM_INST_INTERIM';
                          l_policyRec.logMsg     := 'Updating 1$RENCAP';

                          UPDATE INSIS_GEN_V10.PREM_INST_INTERIM pii
                              SET PREM = 1- (cRec.IA_DISCOUNT/100)
                          WHERE 1=1
                              AND pii.POLICY_ID = l_policyRec.policy_id
                              AND pii.PREM_TYPE = '1$RENCAP';
                           -- AND pii.INSURED_OBJ_ID = l_policyRec.insured_object_id; --EZ 29.5.2019

                       --EZ 30.5.2019
                          COMMIT;

--                          l_LogRec.logMsg       := 'After Updating PREM_INST_INTERIM '||cRec.IA_DISCOUNT ;
--                          MIGR_LOG.LOG_INFO(l_LogRec);

                          l_policyRec.logMsg := 'Updated Discount succesfully for policy :' ||  l_policyRec.policy_id || ' and Discount='||cRec.IA_DISCOUNT ;
                          MIGR_LOG.LOG_INFO(l_policyRec);
                       --EZ end 30.5.2019

                      END IF;
 --- +++ end anb 2015-05-22 Eliminate MIG_POL Discounts from Phase B

                    EXCEPTION WHEN OTHERS THEN
                      --fa 20170301
                        l_policyRec.logMsg := 'Exception: ' || SQLERRM;
                        MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                        l_policyRec.logMsg := 'ERROR';

                  END;

                  --FA.20170301 Commented   l_policyRec:= UPLOAD_DISCOUNT(l_policyRec, l_discount_id, cRec.ia_discount, null);
                  -- UPDATE IA_POLICY -> MIG_FLAG FAILED DISCOUNTS!
                  IF l_policyRec.logMsg = 'ERROR' THEN

                    MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(l_policyRec.policy_idpl, MIGR_GVAR.GV_MIG_FLAG_FAILED_DISCOUNTS, l_policyRec.MIG_BATCH_ID);

                  END IF;

        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                      l_policyRec.logMsg := 'Invalid MIGG policy number was found in the loaded file. Row is skipped. ' || SQLERRM;
                      MIGR_LOG.LOG_EXCEPTION(l_policyRec);

           WHEN OTHERS THEN
                       l_policyRec.logMsg := 'Error occured while searching for the MIGG policy number:'  ||  l_policyRec.policy_idpl  ||'. Row is skipped. ' || SQLERRM;
                      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
        END;

      END LOOP;

      UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Finished', DISCOUNTS_END_TIMESTAMP=SYSTIMESTAMP ----FA.20170127 Only API should be able to turn status to Finished ,status ='Finished'
        WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;

      COMMIT;
      l_LogRec.logMsg       := 'Finished MD Discounts loading';
      MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION
        WHEN OTHERS THEN
          LOAD_Status := 'INCOMPLETE';
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Failed', DISCOUNTS_END_TIMESTAMP=SYSTIMESTAMP WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;

  END LOAD_MD_DISCOUNTS;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--valex.2/3/17 - exports discounts view (V_MIGR_PREMIUMS) without INSIS_PREM_FINAL to a flat file
procedure dump_table_to_csv( p_migrBatchId IN VARCHAR2, p_tname in varchar2,   p_dir in varchar2,   p_filename in varchar2 )
as
 l_output utl_file.file_type;
 l_theCursor integer default dbms_sql.open_cursor;
 l_columnValue varchar2(4000);
 l_status integer;
 l_query varchar2(1000);
--  default 'select * from ' || p_tname || ' where MIG_BATCH_ID=''' ||p_migrBatchId || '''';
  l_colCnt number := 0;
  l_separator varchar2(1);
  l_descTbl dbms_sql.desc_tab;
  l_LogRec      MIGR_GVAR.LogRecTyp;
  vsql VARCHAR2(2000);

  begin
   l_LogRec.migrStep := 'Create Discounts file';
   l_LogRec.mig_batch_id:=p_migrBatchId;
   l_LogRec.migrArea := 'MIGR_MD_DISCOUNTS.DUMP_TABLE_TO_CSV';

  --valex.16/3/2017 - dynamic fetch of V_MIGR_PREMIUMS column list without INSIS_PREM_FINAL

   for c in( SELECT COLUMN_NAME,column_id
              from USER_TAB_COLS
              WHERE TABLE_NAME=p_tname
              and column_name <> 'INSIS_PREM'
              ORDER BY column_id
   )
   loop
       vsql:=vsql ||case WHEN  c.COLUMN_ID=1 THEN NULL ELSE ',' END || '"'||c.COLUMN_NAME||'"';

   end loop;
--valex.16/3/2017 - end
   l_query := 'select ' || vsql || ' from ' || p_tname || ' where MIG_BATCH_ID=''' ||p_migrBatchId || '''';

   l_output := utl_file.fopen( p_dir, p_filename, 'w' );


  dbms_sql.parse( l_theCursor, l_query, dbms_sql.native );
  dbms_sql.describe_columns( l_theCursor, l_colCnt, l_descTbl );

  for i in 1 .. l_colCnt
  loop
      utl_file.put( l_output, l_separator ||  l_descTbl(i).col_name  );
      dbms_sql.define_column( l_theCursor, i, l_columnValue, 4000 );
      l_separator := '|';
  end loop;
  utl_file.new_line( l_output );

  l_status := dbms_sql.execute(l_theCursor);

  while ( dbms_sql.fetch_rows(l_theCursor) > 0 )
  loop
      l_separator := '';
      for i in 1 .. l_colCnt
      loop
          dbms_sql.column_value( l_theCursor, i, l_columnValue );
          utl_file.put( l_output, l_separator || l_columnValue );
          l_separator := '|';
      end loop;
      utl_file.new_line( l_output );
  end loop;
  dbms_sql.close_cursor(l_theCursor);
  utl_file.fclose( l_output );

  l_LogRec.logMsg := p_tname || ' data for batch: '||p_migrBatchId || ' is loaded to ' || p_filename || ' in '||p_dir;
  MIGR_LOG.LOG_INFO(l_LogRec);

  exception when others then
       l_LogRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  end dump_table_to_csv;
 ---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
--valex.3/3/17 - Create discounts file for applicable bolags and add email with relative attachment to the email queue
PROCEDURE SEND_MD_DISCOUNTS_FILE
  AS
    l_dir     VARCHAR2(30);
    l_file    VARCHAR2(100);
    l_batch   VARCHAR2(50);
    l_LogRec  MIGR_GVAR.LogRecTyp;
    v_time    VARCHAR2(50);

BEGIN
    l_LogRec.migrArea := 'MIGR_MD_DISCOUNTS.SEND_MD_DISCOUNTS_FILE';
    l_LogRec.migrStep := 'Create discounts file and add email with relative attachment to the email queue';

    FOR c IN (SELECT a.migration_batch_id, b.discounts_report_view, c.bolag_name, a.STATUS
                FROM MIG_MIGRATION_INFO a, etl_setup_info b, etl_bolag_info c
               WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC, MIGR_GVAR.GV_BATCH_STATUS_FINISHED)
                 AND a.DISCOUNTS_FILE_CREATED = MIGR_GVAR.GV_STATUS_PENDING
                 AND a.BOLAG_ID = c.BOLAG_ID
    )
    LOOP
        l_LogRec.mig_batch_id := c.MIGRATION_BATCH_ID;

        v_time := TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD@HH24-MI-SS');
        l_dir  := 'READ_DIR_' || c.BOLAG_NAME || '_ARCHIVE'; -- valex.20/3/17 - discounts file will be created in ARCHIVE folder, in order phase 2 not to be triggered.
        l_file := c.BOLAG_NAME || '_MD_DISCOUNTS_' || v_time || '.txt';
        MIGR_MD_DISCOUNTS.DUMP_TABLE_TO_CSV(c.MIGRATION_BATCH_ID, c.DISCOUNTS_REPORT_VIEW, l_dir, l_file);

        IF c.STATUS = MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC THEN
            -- email with attachment here
            MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION(c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_MIGR_DISC_REPORT, l_file, l_dir);
        ELSE
            MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION(c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_MIGR_FINAL_REPORT, l_file, l_dir);
        END IF;

        UPDATE MIG_MIGRATION_INFO
           SET DISCOUNTS_FILE_CREATED = MIGR_GVAR.GV_STATUS_FINISHED
         WHERE MIGRATION_BATCH_ID = c.MIGRATION_BATCH_ID;

    END LOOP;

EXCEPTION
  WHEN OTHERS THEN
    l_LogRec.logMsg := SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END SEND_MD_DISCOUNTS_FILE;

---------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
-- pl 20170612
PROCEDURE DEFAULT_MD_DISCOUNTS_FILE(vBatchID IN VARCHAR2)
AS
  l_dir_obj        NVARCHAR2(100);
  l_dir_arch_obj   NVARCHAR2(100);
  l_source_file    NVARCHAR2(100);
  l_dest_file      NVARCHAR2(100);

  l_LogRec         MIGR_GVAR.LogRecTyp;
      l_count NUMBER;
BEGIN
  l_LogRec.mig_batch_id := vBatchID;
  l_LogRec.migrArea     := 'MIGR_MD_DISCOUNTS.DEFAULT_MD_DISCOUNTS_FILE';
  l_LogRec.migrStep     := 'MIGR_MD_DISCOUNTS.DEFAULT_MD_DISCOUNTS_FILE';
  l_LogRec.migrRelTbl   := NULL;
  l_LogRec.migrRelKey   := NULL;

  FOR c IN (SELECT *
              FROM (
                SELECT DISTINCT menl.MSG_REGISTRATION_TIMESTAMP, menl.MSG_ATT_NAME, menl.MSG_ATT_DIR--, SUBSTR(MSG_ATT_NAME, 1, LENGTH(MSG_ATT_NAME)-24), SUBSTR(MSG_ATT_DIR, 1, LENGTH(MSG_ATT_DIR)-8)
                  FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl
                 WHERE 1=1
                   AND menl.MSG_ATT_NAME IS NOT NULL
                   AND menl.MIGRATION_BATCH_ID = vBatchID
                 ORDER BY menl.MSG_REGISTRATION_TIMESTAMP DESC) A
             WHERE ROWNUM = 1
  )
  LOOP
    l_dir_obj      := SUBSTR(c.MSG_ATT_DIR, 1, LENGTH(c.MSG_ATT_DIR)-8);
    l_dir_arch_obj := c.MSG_ATT_DIR;

    l_source_file := c.MSG_ATT_NAME;
    l_dest_file   := SUBSTR(c.MSG_ATT_NAME, 1, LENGTH(c.MSG_ATT_NAME)-24) || '.txt';

    -- Copy MD_DISCOUNTS.txt from archive directory
    UTL_FILE.FCOPY(
        src_location  => l_dir_arch_obj,
        src_filename  => l_source_file,
        dest_location => l_dir_obj,
        dest_filename => l_dest_file
    );

    l_LogRec.logMsg := ' - ' || l_dir_arch_obj || '-' || l_source_file || '-' || l_dir_obj || '-' || l_dest_file;

  END LOOP;

  l_LogRec.logMsg := 'MD_DISCOUNTS.txt retrieved.' || l_LogRec.logMsg;
  MIGR_LOG.LOG_INFO(l_LogRec);

EXCEPTION
  WHEN OTHERS THEN
    l_LogRec.logMsg := 'Could not retrieve MD_DISCOUNTS file - ' || SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
    SELECT COUNT(1) into l_count from MIGR_EMAIL_NOTIFICATIONS_LOG WHERE MIGRATION_BATCH_ID= vBatchID and  MSG_CODE= MIGR_GVAR.GV_MSG_CODE_FAIL_GET_DEF_DISC;
    IF l_count =0 THEN
    MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION (vBatchID, MIGR_GVAR.GV_MSG_CODE_FAIL_GET_DEF_DISC );
    END IF;
END DEFAULT_MD_DISCOUNTS_FILE;

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

END MIGR_MD_DISCOUNTS;
/

CREATE OR REPLACE PACKAGE BODY                   MIGR_PROCESS
  IS
  -------------------------------------------------------------------------------------------------------
  --  ALTER SESSION SET NLS_LANGUAGE = 'ENGLISH';

  -----------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------
  --
  -- MIGR_MAIN
  --      Main procedure for migrating data by MigrationBatchId
  --
  -- Purpose: Invokes procedures for migrating  into INSIS
  --          Reads all info from LA_xxxxx_LOAD tables, saves them in LA_Myy_KFxxxx, combines them in SA_KFxxx, transforms them with SA_IA MAPS
  --                and finally it attempts to post Policy Applications in INSIS
  --
  -- MODIFICATION HISTORY
  -- Person               Date         Comments
  -- ---------            ------       ------------------------------------------
  -- Andreas Boyatzoglou  15.06.2015   Initial version
  -- Andreas Boyatzoglou  24.09.2015   Full version
  -- Ploutarchos Liosis   30.12.2015   Run_LA_SA returns status for proceeding or aborting Migration Process
  -- Avgerou Fani         10.02.2016   Rewrite Package remove debug input - call function RUN_LA_SA -Change Log
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------

  ---------------------------------------------------------------------------------------------------------------------------------------------
  --valex.27/4/16 check step or products that are planned to run for bolag
  FUNCTION PROCESS_STEPS(pmig_batch IN VARCHAR2,
                         pstep      IN VARCHAR2,
                         pproduct   IN VARCHAR2)
    RETURN VARCHAR2
    IS
      vRet_val VARCHAR2(2100);
    BEGIN
      vRet_val := '0';

      IF NVL(pstep, ' ') = ' '   AND NVL(pproduct, ' ') = ' '     THEN

       FOR c IN (
            SELECT INSRPRD
            FROM MIG_PROCESS_STEPS
            WHERE IS_ACTIVE = 'Y'
      --valex.21/11/2016 - replacement of regexp_like function with like sql operator for performance improvement
      --        AND REGEXP_LIKE(',' || MIG_MUTUAL_ID || ',', ',' || SUBSTR(pmig_batch, 1, 2) || ','))
              AND ',' || MIG_MUTUAL_ID || ',' like '%,'||SUBSTR(pmig_batch, 1, 2) || ',%')
      --valex.21/11/2016 - end
        LOOP
          vRet_val := c.INSRPRD;
        END LOOP;

      ELSIF NVL(pproduct, ' ') = ' '
      THEN
--valex.21/11/2016 - replacement of regexp_like function with like sql operator and use of native SQL instead of dynamic, for performance improvement
--        EXECUTE IMMEDIATE 'SELECT COUNT(''x'')  from MIG_PROCESS_STEPS where  REGEXP_LIKE('','' || MIG_MUTUAL_ID ||'','', '','' || SUBSTR(:A, 1, 2) || '','')
--                  AND  REGEXP_LIKE('','' || STEP_CODE || '','', '','' || :B || '','') AND IS_ACTIVE=''Y'''
--          INTO vRet_val
--        USING pmig_batch, pstep;
--      ELSE
--        EXECUTE IMMEDIATE 'SELECT COUNT(''x'') from MIG_PROCESS_STEPS where  REGEXP_LIKE('','' || MIG_MUTUAL_ID ||'','', '','' || SUBSTR(:A, 1, 2) || '','')'
--        || ' AND  REGEXP_LIKE('','' || STEP_CODE || '','', '','' || :B || '','')'
--        || ' AND  REGEXP_LIKE('','' || insrprd ||'','', '','' || :C || '','')  AND IS_ACTIVE=''Y'''
--          INTO vRet_val
--        USING pmig_batch, pstep, pproduct;
        SELECT COUNT('x')
          INTO vRet_val
        from MIG_PROCESS_STEPS
        where 1=1
          and ',' || MIG_MUTUAL_ID ||',' like '%,' || SUBSTR(pmig_batch, 1, 2) || ',%'
          AND  ',' || STEP_CODE || ',' like '%,' || pstep || ',%' AND IS_ACTIVE='Y';


     -----FA.20170102 check if specific product should be migrated or skipped: 1:migrate 0 skip
          ELSIF NVL(pstep, ' ') = ' '   AND NVL(pproduct, ' ') <> ' '    THEN

              SELECT COUNT('x')
              INTO vRet_val
              FROM MIG_PROCESS_STEPS
              WHERE 1=1
              AND ',' || MIG_MUTUAL_ID ||',' like '%,' || SUBSTR(pmig_batch, 1, 2) || ',%'
              AND  ',' || insrprd ||',' like '%,' || pproduct || ',%'  AND IS_ACTIVE='Y';


      ELSE
        SELECT COUNT('x')
          INTO vRet_val
        from MIG_PROCESS_STEPS
        where 1=1
         AND ',' || MIG_MUTUAL_ID ||',' like '%,' || SUBSTR(pmig_batch, 1, 2) || ',%'
         AND  ',' || STEP_CODE || ',' like '%,' || pstep || ',%'
         AND  ',' || insrprd ||',' like '%,' || pproduct || ',%'  AND IS_ACTIVE='Y';
--valex.21/11/2016 - end

      END IF;
      RETURN vRet_val;
    EXCEPTION
      WHEN OTHERS THEN vRet_val := '0';
    END;
  ---------------------------------------------------------------------------------------------------------------------------------------------
-- LM 20170119 - START
-- Check if specific product should be migrated or skipped: 1 = migrate, 0 = skip
FUNCTION SKIP_INSIS_REG(pmig_batch IN VARCHAR2,
                        pflag      IN VARCHAR2,
                        pproduct   IN VARCHAR2)
    RETURN VARCHAR2
    IS
      vRet_val VARCHAR2(2100);
      api_step VARCHAR2(50);

    BEGIN

      vRet_val := '0';
      api_step := '0';

      FOR c1 IN (
           SELECT STEP_ALIAS
           FROM ETL_API_STEPS
           )
      LOOP
        api_step := c1.STEP_ALIAS;


         SELECT COUNT('x')
           INTO vRet_val
           FROM MIG_PROCESS_STEPS
          WHERE 1=1
            AND ',' || MIG_MUTUAL_ID ||',' like '%,' || SUBSTR(pmig_batch, 1, 2) || ',%'
            AND  ',' || insrprd ||',' like '%,' || pproduct || ',%'
            AND IS_ACTIVE='Y'
            AND (( ',' || STEP_CODE || ',' like '%,' || api_step || ',%' AND pflag = MIGR_GVAR.GV_MIG_FLAG_RUNNING)
             OR (',' || API_RESUME_STEPS || ',' like '%,' || api_step || ',%' AND pflag = MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS));

        IF vRet_val = '1' THEN
          EXIT;
        END IF;

     END LOOP;
      RETURN vRet_val;

    EXCEPTION
      WHEN OTHERS THEN vRet_val := '0' ;
      RETURN vRet_val;
   END;

-- LM 20170119 - END

  --------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20161220 Retrieve valid steps for policy depending on policy state
  FUNCTION GET_API_PROCESS_PLAN(pmig_batch IN VARCHAR2, pproduct   IN VARCHAR2,p_migr_flag IN VARCHAR2)   RETURN MIGR_GVAR.steps_tab_t
    IS
      vRet_val VARCHAR2(2100);
      steps_tab  MIGR_GVAR.steps_tab_t;

   BEGIN

      IF p_migr_flag= MIGR_GVAR.GV_MIG_FLAG_RUNNING  THEN
        FOR c IN (
                 WITH DATA AS
                    ( SELECT STEP_CODE str FROM mig_process_steps
                      WHERE 1=1
                           AND ',' || MIG_MUTUAL_ID ||',' like '%,' || SUBSTR(pmig_batch, 1, 2) || ',%'
                           AND  ',' || insrprd ||',' like '%,' || pproduct || ',%'  AND IS_ACTIVE='Y'  )
                   SELECT trim(regexp_substr(str, '[^,]+', 1, LEVEL)) str       FROM DATA       CONNECT BY instr(str, ',', 1, LEVEL - 1) > 0    )
        LOOP
                 steps_tab(c.str) :=TRUE;
        END LOOP;

    ELSE
         FOR c IN (
              WITH DATA AS
               (   SELECT API_RESUME_STEPS str   FROM MIG_PROCESS_STEPS
                    WHERE 1=1
                        AND ',' || MIG_MUTUAL_ID ||',' like '%,' || SUBSTR(pmig_batch, 1, 2) || ',%'
                        AND  ',' || insrprd ||',' like '%,' || pproduct || ',%'  AND IS_ACTIVE='Y'  )
                 SELECT trim(regexp_substr(str, '[^,]+', 1, LEVEL)) str       FROM DATA       CONNECT BY instr(str, ',', 1, LEVEL - 1) > 0    )
        LOOP
             steps_tab(c.str) :=TRUE;
        END LOOP;

    END if;

    RETURN steps_tab;

    EXCEPTION
        WHEN OTHERS THEN return steps_tab;
    END GET_API_PROCESS_PLAN;



  ---------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20161221 Retrieve api steps and api steps ordering
  FUNCTION GET_API_STEPS_ORDER   RETURN MIGR_GVAR.api_steps_orde_tab_t
    IS

      api_order_tab  MIGR_GVAR.api_steps_orde_tab_t;

   BEGIN

     FOR C IN (      SELECT step_order, STEP  from ETL_API_STEPS where IS_ACTIVE='Y' )

      LOOP
             api_order_tab(C.step) := C.step_order;

      END LOOP;

    RETURN api_order_tab;

    EXCEPTION
        WHEN OTHERS THEN return api_order_tab;
    END GET_API_STEPS_ORDER;
--------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE ROLLBACK_BATCH_DATA(p_mig_batch_id IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                                p_RollbackArea IN VARCHAR2)
    IS
      l_logRec MIGR_GVAR.LogRecTyp;
      vSQL     VARCHAR2(32000);
    BEGIN
      l_logRec.mig_batch_id := p_mig_batch_id;
      l_logRec.migrArea := 'MIGR_PROCESS.ROLLBACK_BATCH_DATA';
      l_logRec.migrStep := 'Rollback area:' || p_RollbackArea;
      l_logRec.logMsg := 'Failed to complete LA-SA Steps';
      MIGR_LOG.LOG_INFO(l_logRec);

      IF p_RollbackArea = 'ROLLBACK_LA'
      THEN

        FOR cRec IN (SELECT ee.DEST_TABLE
            FROM ETL_ENGINE ee
            WHERE 1 = 1
              AND ee.BOLAG_ID = SUBSTR(l_logRec.mig_batch_id, 1, 2)
              AND ee.MIGRATION_AREA = 'Landing')
        LOOP
          vSQL := 'DELETE FROM ' || cRec.DEST_TABLE
          || ' WHERE MIG_BATCH_ID = '
          || CHR(39) || p_mig_batch_id || CHR(39);

        END LOOP;


      ELSIF p_RollbackArea = 'ROLLBACK_SA'
      THEN

        FOR cRec IN (SELECT ee.DEST_TABLE
            FROM ETL_ENGINE ee
            WHERE 1 = 1
              AND ee.BOLAG_ID = SUBSTR(l_logRec.mig_batch_id, 1, 2)
              AND ee.MIGRATION_AREA = 'Staging')
        LOOP
          vSQL := 'DELETE FROM ' || cRec.DEST_TABLE
          || ' WHERE MIG_BATCH_ID = '
          || CHR(39) || p_mig_batch_id || CHR(39);

          EXECUTE IMMEDIATE vSQL;

        END LOOP;

      ELSIF p_RollbackArea = 'ROLLBACK_IA'
      THEN


        FOR tRec IN (SELECT DEST_TABLE

            FROM ETL_SA_IA
            WHERE MIGRATION_AREA = 'SA_IA'
              AND IS_ACTIVE = 'TRUE')
        LOOP

          vSQL := ' DELETE FROM ' || tRec.DEST_TABLE
          || ' WHERE MIG_BATCH_ID =' || CHR(39) || p_mig_batch_id || CHR(39);

          EXECUTE IMMEDIATE vSQL;

        END LOOP;

      ELSE
        l_logRec.logMsg := 'Unknown Rollback Area';
        MIGR_LOG.LOG_ERROR(l_logRec);
      END IF;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN l_logRec.migrRelTbl := vSQL;

          l_logRec.logMsg := SQLERRM();
          MIGR_LOG.LOG_EXCEPTION(l_logRec);
    END;
  ------------------------------------------------------------------------------------------------------------_
  ------------------------------------------------------------------------------------------------------------_

--  PROCEDURE MIGR_MAIN(P_DEBUG IN VARCHAR2)
--    IS
--
--      vTruncateAll      BOOLEAN;
--      vSQL              VARCHAR2(2100);
--      l_Status          VARCHAR2(50);
--      l_LogRec          MIGR_API_COMMON.LogRecTyp;
--      L_CONTINUE        BOOLEAN;
--    BEGIN
--
--      vSQL := 'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
--      EXECUTE IMMEDIATE vSQL;
--
--      vSQL := NULL;
--      --- get next Queued Batch that has no 'Running' status for same Bolag
--      l_LogRec.mig_batch_id := MIGR_SIGNAL.GET_NEXT_QUEUED();
--      l_LogRec.migrArea := 'MIGR_PROCESS.MIGR_MAIN';
--
--
--      IF NVL(l_LogRec.mig_batch_id, ' ') <> ' '   THEN
--        -- run LOAD, LA, SA, Rules
--        MIGR_LA_SA.RUN_LA_SA(l_LogRec.mig_batch_id, l_Status);
--
--        /* IF l_Status IN ('ROLLBACK_LA', 'ROLLBACK_SA')    THEN    ROLLBACK_BATCH_DATA(l_LogRec.mig_batch_id, l_Status);   ELSE     */
--
--        --FA.20160510 Populate all intermediate tables
--        IF MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id, 'LA', NULL) = 1
--        THEN
--          IF MIGR_INTERMEDIATE_OBJECTS.POPULATE_INTERMEDIATE_TABLES(l_LogRec.mig_batch_id)
--          THEN
--            L_CONTINUE := TRUE;
--          END IF;
--        END IF;
--        IF L_CONTINUE
--        THEN
--          IF l_Status = 'COMPLETE'
--          THEN
--
--            MIGR_IA.IA_MAIN(l_LogRec.mig_batch_id, l_Status);
--
--            --FA.20160705 Change status to trigger api job
--            IF l_Status = 'COMPLETE' THEN
--
--                 l_LogRec.logMsg:='About to call clients';
--
--
--                MIGR_API_COMMON.SET_DEFAULT_VALUES(SUBSTR(l_LogRec.mig_batch_id, 1, 2));
--                  vSQL := 'ALTER SESSION SET NLS_DATE_FORMAT = ''DD-MM-RRRR''';
--            EXECUTE IMMEDIATE vSQL;
--             --!!!!!!!!!CLEAN UP PROCESS WHEN ROLLABACK STATUS !!!!!!!!!!!!!!!!!!!!!!!!
--             -----FA.20160705 API Process is triggered by api_scheduled job when a batch has finished IA step
--             ----MIGR_API.RUN_API(L_DEBUG, l_LogRec.mig_batch_id);
--            --The following code should be removed once desgn for customer migration will be finalized
--               INSIS_SYS_V10.INSIS_CONTEXT.Prepare_Session(Pi_App       => 'GEN',
--                                                    Pi_Action    => 'InsisPolicyGen',
--                                                    -- FA. 20160405 Change user to migration user
--                                                    Pi_Username  => MIGR_API_COMMON.GV_DEFAULT_MIGR_USER, -- FA. 20160419 Get user from ETL_SETUP_INFO 'insis_gen_v10', ----'insis_gen_v10', --'insis_mig_user'
--                                                    Pi_User_Role => 'InsisStaff',
--                                                    Pi_Lang      => NULL,
--                                                    Pi_Country   => NULL);
--
--                MIGR_LOG.LOG_INFO(l_LogRec);
--                 MIGR_API_CLIENTS.SETUP_CLIENT( l_LogRec.mig_batch_id);
--              MIGR_API_CLIENTS.SETUP_CLIENT_ADDRESS( l_LogRec.mig_batch_id);
--
--                 l_LogRec.logMsg:='Finished  clients';
--                MIGR_LOG.LOG_INFO(l_LogRec);
--
--
--
--
--                  UPDATE MIG_MIGRATION_INFO mmi SET mmi.IA_COMPLETED ='Finished' WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
--            ELSE
--                 UPDATE MIG_MIGRATION_INFO mmi SET mmi.IA_COMPLETED ='Failed' WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
--             END IF;
--            COMMIT;
--
--            ---FA.20160418 SET Default values
--
--
--
--
--
--
--          END IF;
--     ELSE
--
--              UPDATE MIG_MIGRATION_INFO mmi SET mmi.IA_COMPLETED ='Failed' WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
--
--        END IF;
--
--        -----FA.20160705 Archived process is triggered when LA step is completed
--        --The above actions: close batch and truncate ia tables  will be executed when all policies will be migrated
--        /*    IF (MIGR_ARCHIVE.ARCHIVE_MUTUAL_DATA(l_LogRec.mig_batch_id))
--        THEN
--          ---FA.20160409 Truncate migr_sa_ia_list data
--          MIGR_IA.TRUNCATE_IA_TABLES();
--          MIGR_SIGNAL.CLOSE_BATCH(l_LogRec.mig_batch_id, 'Finished');
--
--
--        ELSE     --valex.20/4/16 abort batch
--          MIGR_ARCHIVE.ARCHIVE_COMPLETED_FILE(l_LogRec.mig_batch_id, 'Remove');
--          MIGR_SIGNAL.CLOSE_BATCH(l_LogRec.mig_batch_id, 'Aborted');
--          MIGR_SYSTEM.MIGR_LOG_LINE('FALSE', l_LogRec.mig_batch_id, 'MIGR_MAIN', 'Migration Main Area', 'ERROR', 'Batch was aborted', NULL, NULL);
--
--        END IF;-- l_Status
--              */
--      END IF;
--
--    EXCEPTION
--      WHEN OTHERS THEN l_LogRec.logMsg := 'MIGR_MAIN' || SQLERRM;
--          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
--
--
--    END MIGR_MAIN;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------

  ------------------------------------------------------------------------------------------------------------_
  ------------------------------------------------------------------------------------------------------------_

--valex.8/9/16 - MIGR_MAIN is updated so as to use RUN_LA, RUN_SA and RUN_IA separate procedures
  /*FA. 20180207 Commented because is never called
  PROCEDURE MIGR_MAIN(P_DEBUG IN VARCHAR2)
    IS

      vTruncateAll      BOOLEAN;
      vSQL              VARCHAR2(2100);
      l_Status          VARCHAR2(50);
      l_LogRec          MIGR_GVAR.LogRecTyp;
      L_CONTINUE        BOOLEAN ;
    BEGIN

      vSQL := 'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
      EXECUTE IMMEDIATE vSQL;

        --FA. 20160824 ALTER SESSION param to minmize indirect redo log size of global temporary table undo
       vSQL := 'ALTER SESSION SET TEMP_UNDO_ENABLED = TRUE';
       EXECUTE IMMEDIATE vSQL;

--      vSQL := NULL;
--      --- get next Queued Batch that has no 'Running' status for same Bolag
--      l_LogRec.mig_batch_id := MIGR_SIGNAL.GET_NEXT_QUEUED();
--      l_LogRec.migrArea := 'MIGR_PROCESS.MIGR_MAIN';
--
--
--      IF NVL(l_LogRec.mig_batch_id, ' ') <> ' '   THEN
--
--        IF  MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id,'LA',null)=1 THEN
--            MIGR_LA_SA.RUN_LA(l_LogRec.mig_batch_id, l_Status);
--        ELSE
--            l_Status:='INCOMPLETE';
--        END IF;
--
--        IF MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id, 'SA', NULL) = 1 and l_Status='COMPLETE' then
--            MIGR_LA_SA.RUN_SA(l_LogRec.mig_batch_id, l_Status);
--        ELSE
--            l_Status:='INCOMPLETE';
--        END IF;
--
--        IF MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id,'RULES',null)=1 and l_Status='COMPLETE' THEN
--            MIGR_RULES.RUN_RULES(l_LogRec.mig_batch_id, l_Status);
--        ELSE
--            l_Status:='INCOMPLETE';
--        END IF;
--        COMMIT;
--
--        IF MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id,'IA',null)=1 and l_Status='COMPLETE' THEN
--           MIGR_IA.RUN_IA(l_LogRec.mig_batch_id, l_Status);
--        else
--           UPDATE MIG_MIGRATION_INFO mmi SET STATUS='Failed', END_TIMESTAMP = SYSTIMESTAMP WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
--        END IF;
--
--
--      else
--        UPDATE MIG_MIGRATION_INFO mmi SET STATUS='Failed', END_TIMESTAMP = SYSTIMESTAMP WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
--      end IF;


    MIGR_PROCESS_RESUME.RESUME_MAIN;





    EXCEPTION WHEN OTHERS THEN
        l_LogRec.logMsg := 'MIGR_MAIN ' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);


    END MIGR_MAIN;
*/
  --valex.8/9/16

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------

----valex.1/9/16 - MIGR_MAIN is updated so as to use RUN_LA and RUN_SA separate procedures
--  PROCEDURE MIGR_MAIN(P_DEBUG IN VARCHAR2)
--    IS
--
--      vTruncateAll      BOOLEAN;
--      vSQL              VARCHAR2(2100);
--      l_Status          VARCHAR2(50);
--      l_LogRec          MIGR_API_COMMON.LogRecTyp;
--      L_CONTINUE        BOOLEAN ;
--    BEGIN
--
--      vSQL := 'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
--      EXECUTE IMMEDIATE vSQL;
--
--        --FA. 20160824 ALTER SESSION param to minmize indirect redo log size of global temporary table undo
--       vSQL := 'ALTER SESSION SET TEMP_UNDO_ENABLED = TRUE';
--       EXECUTE IMMEDIATE vSQL;
--
--      vSQL := NULL;
--      --- get next Queued Batch that has no 'Running' status for same Bolag
--      l_LogRec.mig_batch_id := MIGR_SIGNAL.GET_NEXT_QUEUED();
--      l_LogRec.migrArea := 'MIGR_PROCESS.MIGR_MAIN';
--
--
--      IF NVL(l_LogRec.mig_batch_id, ' ') <> ' '   THEN
--
--        IF  MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id,'LA',null)=1 THEN
--            MIGR_LA_SA.RUN_LA(l_LogRec.mig_batch_id, l_Status);
--        ELSE
--            l_Status:='INCOMPLETE';
--        END IF;
--
--        IF MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id, 'SA', NULL) = 1 and l_Status='COMPLETE' then
--            MIGR_LA_SA.RUN_SA(l_LogRec.mig_batch_id, l_Status);
--        ELSE
--            l_Status:='INCOMPLETE';
--        END IF;
--
--        IF MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id,'RULES',null)=1 and l_Status='COMPLETE' THEN
--            MIGR_RULES.RUN_RULES(l_LogRec.mig_batch_id, l_Status);
--        ELSE
--            l_Status:='INCOMPLETE';
--        END IF;
--        COMMIT;
--
--        IF MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id,'IA',null)=1 and l_Status='COMPLETE' THEN
--          IF MIGR_INTERMEDIATE_OBJECTS.POPULATE_INTERMEDIATE_TABLES(l_LogRec.mig_batch_id)
--          THEN
--            L_CONTINUE := TRUE;
--          END IF;
--        ELSE
--            L_CONTINUE:=FALSE;
--        END IF;
--
--        IF L_CONTINUE=TRUE THEN
--
--          MIGR_IA.IA_MAIN(l_LogRec.mig_batch_id, l_Status);
--
--          IF l_Status = 'COMPLETE' THEN
--
--                l_LogRec.logMsg:='About to call clients';
--
--
--                MIGR_API_COMMON.SET_DEFAULT_VALUES(SUBSTR(l_LogRec.mig_batch_id, 1, 2));
--                vSQL := 'ALTER SESSION SET NLS_DATE_FORMAT = ''DD-MM-RRRR''';
--                EXECUTE IMMEDIATE vSQL;
--                 --!!!!!!!!!CLEAN UP PROCESS WHEN ROLLABACK STATUS !!!!!!!!!!!!!!!!!!!!!!!!
--                 -----FA.20160705 API Process is triggered by api_scheduled job when a batch has finished IA step
--                 ----MIGR_API.RUN_API(L_DEBUG, l_LogRec.mig_batch_id);
--                --The following code should be removed once desgn for customer migration will be finalized
--                INSIS_SYS_V10.INSIS_CONTEXT.Prepare_Session(Pi_App       => 'GEN',
--                                                    Pi_Action    => 'InsisPolicyGen',
--                                                    -- FA. 20160405 Change user to migration user
--                                                    Pi_Username  => MIGR_API_COMMON.GV_DEFAULT_MIGR_USER, -- FA. 20160419 Get user from ETL_SETUP_INFO 'insis_gen_v10', ----'insis_gen_v10', --'insis_mig_user'
--                                                    Pi_User_Role => 'InsisStaff',
--                                                    Pi_Lang      => NULL,
--                                                    Pi_Country   => NULL);
--
--                MIGR_LOG.LOG_INFO(l_LogRec);
--                MIGR_API_CLIENTS.SETUP_CLIENT( l_LogRec.mig_batch_id);
--                MIGR_API_CLIENTS.SETUP_CLIENT_ADDRESS( l_LogRec.mig_batch_id);
--                l_LogRec.logMsg:='Finished  clients';
--                MIGR_LOG.LOG_INFO(l_LogRec);
--
--
--
--                UPDATE MIG_MIGRATION_INFO mmi SET mmi.IA_COMPLETED ='Finished' WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
--          ELSE
--                UPDATE MIG_MIGRATION_INFO mmi SET mmi.IA_COMPLETED ='Failed',STATUS='Failed', END_TIMESTAMP = SYSTIMESTAMP WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
--          END IF;
--          COMMIT;
--
--        else
--          UPDATE MIG_MIGRATION_INFO mmi SET mmi.IA_COMPLETED ='Failed',STATUS='Failed', END_TIMESTAMP = SYSTIMESTAMP WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
--        end if;
--
--      else
--        UPDATE MIG_MIGRATION_INFO mmi SET STATUS='Failed', END_TIMESTAMP = SYSTIMESTAMP WHERE  mmi.MIGRATION_BATCH_ID=l_LogRec.mig_batch_id;
--      end IF;
--
--
--
--
--    EXCEPTION WHEN OTHERS THEN
--        l_LogRec.logMsg := 'MIGR_MAIN ' || SQLERRM;
--        MIGR_LOG.LOG_EXCEPTION(l_LogRec);
--
--
--    END MIGR_MAIN;
--  --valex.1/9/16 - end
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------


--  PROCEDURE MIGR_MAIN_RUN_IA(P_BATCH_ID IN VARCHAR2)
--    IS
--
--      L_DEBUG           VARCHAR2(10);
--      vTruncateAll      BOOLEAN;
--
--      vMigrationBatchId MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE;   -- +++ anb 20160203
--      vSQL              VARCHAR2(2100);
--      l_Status          VARCHAR2(50);
--      l_LogRec          MIGR_GVAR.LogRecTyp;
--      L_CONTINUE        BOOLEAN;
--    BEGIN
--
--        l_LogRec.mig_batch_id:=  P_BATCH_ID;
--        l_LogRec.migrArea      :=   'MIGR_PROCESS.MIGR_MAIN_RUN_IA' ;
--        l_LogRec.migrStep      :=   'MIGR_MAIN_RUN_IA' ;
--        l_LogRec.migrRelTbl    :=   NULL;
--        l_LogRec.migrRelKey  :=   NULL;
--
--
--      L_DEBUG := 'FALSE';
--
--      vSQL := 'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
--      EXECUTE IMMEDIATE vSQL;
--      vSQL := NULL;
--
--      IF MIGR_INTERMEDIATE_OBJECTS.POPULATE_INTERMEDIATE_TABLES(l_LogRec.mig_batch_id)
--      THEN
--        L_CONTINUE := TRUE;
--      END IF;
--
--      IF L_CONTINUE
--      THEN
--
--        MIGR_IA.IA_MAIN(l_LogRec.mig_batch_id, l_Status);
--
--        vSQL := 'ALTER SESSION SET NLS_DATE_FORMAT = ''DD-MM-RRRR''';
--        EXECUTE IMMEDIATE vSQL;
--
--        MIGR_API_COMMON.SET_DEFAULT_VALUES(SUBSTR(l_LogRec.mig_batch_id, 1, 2));
--      -- MIGR_API.RUN_API(L_DEBUG, l_LogRec.mig_batch_id);
--
--      END IF;
--
--
--      IF (MIGR_ARCHIVE.ARCHIVE_MUTUAL_DATA(l_LogRec.mig_batch_id))
--      THEN
--
--        MIGR_IA.TRUNCATE_IA_TABLES();
--        MIGR_SIGNAL.CLOSE_BATCH(l_LogRec.mig_batch_id, 'Finished');
--      ELSE
--       -- MIGR_ARCHIVE.ARCHIVE_COMPLETED_FILE(l_LogRec.mig_batch_id, 'Remove');
--         MIGR_ARCHIVE.ARCHIVE_COMPLETED_FILE(l_LogRec.mig_batch_id);
--        MIGR_SIGNAL.CLOSE_BATCH(l_LogRec.mig_batch_id, 'Aborted');
--
--        l_LogRec.logMsg        :=    'Batch was aborted'  ;
--        MIGR_LOG.LOG_ERROR(l_LogRec) ;
--
--
--      END IF;
--    EXCEPTION
--      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
--          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
--
--
--    END MIGR_MAIN_RUN_IA;


END MIGR_PROCESS;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_PROCESS_RESUME
  IS
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- 1.delete batch and step specific rows from MIG_VOLUMETRIC_ANALYSIS
  -- 2.delete batch specific rows from SA_* tables

  PROCEDURE DELETE_SA(p_migration_batch_id IN VARCHAR2, SA_status OUT varchar2)
    AS
      l_file_name     NVARCHAR2(50);
      l_addtnl_fields VARCHAR2(10);
      l_Status          VARCHAR2(50);
      vsql VARCHAR(1000);
      l_LogRec      MIGR_GVAR.LogRecTyp;

      CURSOR fetch_file_names IS
          SELECT DISTINCT (etd.TBLNAME),
                          NVL(etd.ADDTNL, 'N') AS ADDTNL
            FROM ETL_TBL_DEF etd
            WHERE NVL(etd.SA, 'N') = 'Y'
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y';

    BEGIN

      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME.DELETE_SA';
      l_LogRec.mig_batch_id := p_migration_batch_id;

  --initialise LA MIG_FLAG
      for c in (     SELECT DEST_TABLE
                    FROM ETL_ENGINE a,MIG_MIGRATION_INFO b
                    WHERE 1=1
                     AND MIGRATION_AREA='Landing'
                     and a.BOLAG_ID=b.BOLAG_ID
                     and b.MIGRATION_BATCH_ID=p_migration_batch_id
      )
      loop
          vsql:='update '||  c.DEST_TABLE  || ' set mig_flag=0 where mig_flag=1 AND MIG_BATCH_ID = :p_migr_batch';

          EXECUTE immediate vsql using p_migration_batch_id;
      end loop;

      DELETE FROM MIG_VOLUMETRIC_ANALYSIS WHERE MIGRATION_BATCH_ID=p_migration_batch_id AND MIGRATION_AREA='Staging';

  --delete batch data from SA
      OPEN fetch_file_names;
      LOOP
        FETCH fetch_file_names INTO l_file_name, l_addtnl_fields;
        EXIT WHEN fetch_file_names % NOTFOUND;

        vsql := 'DELETE FROM  ' || ' SA_' || l_file_name || ' WHERE MIG_BATCH_ID = :p_migr_batch ';

        EXECUTE IMMEDIATE vsql
        USING p_migration_batch_id;
      END LOOP;
      CLOSE fetch_file_names;

  -- remove from SA_B area
        vsql:='TRUNCATE  table SA_B_PRSN';
        EXECUTE IMMEDIATE vsql;

        delete from  SA_B_ADDRESS where MIG_BATCH_ID=p_migration_batch_id;
        SA_Status:='COMPLETE';
        l_LogRec.logMsg :='DELETE_SA ran successfully';
        MIGR_LOG.LOG_INFO(l_LogRec);
        COMMIT;

    EXCEPTION
      WHEN OTHERS THEN
      --DBMS_OUTPUT.PUT_LINE('DELETE_SA:' || SQLERRM());
         SA_Status:='INCOMPLETE';
         l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
         MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END DELETE_SA;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- 1.delete batch and step specific rows from MIG_VOLUMETRIC_ANALYSIS, MIGR_IA_SA_LIST
  -- 2.delete batch specific rows from IA_* tables
  PROCEDURE DELETE_IA(p_migration_batch_id IN VARCHAR2, IA_status OUT varchar2)
    AS
      vSQL VARCHAR2(2000);
      l_LogRec      MIGR_GVAR.LogRecTyp;

    BEGIN
      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME.DELETE_IA';
      l_LogRec.mig_batch_id := p_migration_batch_id;

    --initialise SA tables MIG_FLAG, with respect to IA step
      for c in (    select dest_table
                    FROM ETL_ENGINE a,MIG_MIGRATION_INFO b
                  WHERE 1=1
                   AND a.MIGRATION_AREA='Staging'
                   and a.BOLAG_ID=b.BOLAG_ID
                   and b.MIGRATION_BATCH_ID=p_migration_batch_id
      )
      loop
          vsql:='update '|| c.dest_table  || '  set mig_flag=0 where mig_flag in (1,2) AND MIG_BATCH_ID = :p_migr_batch';
          EXECUTE immediate vSQL using p_migration_batch_id;
      end loop;

      DELETE FROM MIG_VOLUMETRIC_ANALYSIS WHERE MIGRATION_BATCH_ID=p_migration_batch_id AND MIGRATION_AREA='Intermediate';

      vSQL:='DELETE FROM MIGR_IA_SA_LIST WHERE MIG_BATCH_ID= :batch' ;
      EXECUTE IMMEDIATE vSQL using p_migration_batch_id;

  --delete batch data from IA
      FOR tRec IN (SELECT DEST_TABLE

          FROM ETL_SA_IA
          WHERE MIGRATION_AREA = 'SA_IA'
            AND IS_ACTIVE = 'TRUE')
      LOOP

        vSQL := ' DELETE FROM ' || tRec.DEST_TABLE   || ' WHERE MIG_BATCH_ID =:batch' ;

        EXECUTE IMMEDIATE vSQL using p_migration_batch_id;

      END LOOP;
      IA_Status:='COMPLETE';
      l_LogRec.logMsg :='DELETE_IA ran successfully';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN
     --DBMS_OUTPUT.PUT_LINE('DELETE_IA:' || SQLERRM());
        IA_Status:='INCOMPLETE';
        l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END DELETE_IA;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- 1.delete batch and step specific rows from MIG_DETAIL_ERROR_LOG, MIG_VOLUMETRIC_ANALYSIS
  -- 2.delete batch specific rows from LA_* tables
  PROCEDURE DELETE_LA(p_migration_batch_id IN VARCHAR2, LA_Status  OUT VARCHAR2)
    AS
      vsql      VARCHAR(2100);
      l_file_name   NVARCHAR2(50);
      l_bolag_name  NVARCHAR2(50);
      l_tbl_cnt     PLS_INTEGER;
      l_addtnl_flds VARCHAR2(10);
      l_Status          VARCHAR2(50);
      l_LogRec      MIGR_GVAR.LogRecTyp;
      v_my_schema VARCHAR2(50);
    BEGIN
      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME.DELETE_LA';
      l_LogRec.mig_batch_id := p_migration_batch_id;

      select sys_context('userenv','current_schema') INTO v_my_schema
      from dual;

      DELETE FROM MIG_DETAIL_ERROR_LOG WHERE MIGRATION_BATCH_ID=p_migration_batch_id AND MIGRATION_AREA='Landing';
      DELETE FROM MIG_VOLUMETRIC_ANALYSIS WHERE MIGRATION_BATCH_ID=p_migration_batch_id AND MIGRATION_AREA='Landing';

  --delete batch data from LA
      FOR c in (  SELECT  TO_CHAR(DEST_TABLE) AS DEST_TABLE
                  FROM ETL_ENGINE a,MIG_MIGRATION_INFO b
                  WHERE 1=1
                   AND MIGRATION_AREA='Landing'
                   and a.BOLAG_ID=b.BOLAG_ID
                   and b.MIGRATION_BATCH_ID=p_migration_batch_id
                    union ALL
                  SELECT table_name AS DEST_TABLE
                  FROM ALL_ALL_TABLES
                  WHERE 1=1
                    AND owner= v_my_schema
                    and REGEXP_LIKE(table_name,'^LA_M'||SUBSTR(p_migration_batch_id,1,2)||'(.*)_IOT$')
      )
      LOOP
        vsql := 'delete from ' || c.DEST_TABLE || ' where mig_batch_id =:p_mig_batch';
        EXECUTE IMMEDIATE vsql
        USING p_migration_batch_id;
      END LOOP;

      LA_Status:='COMPLETE';
      l_LogRec.logMsg :='DELETE_LA ran successfully';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;

    EXCEPTION

      WHEN OTHERS THEN
      --DBMS_OUTPUT.PUT_LINE('DELETE_LA:' || SQLERRM());
        l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);
        LA_Status:='INCOMPLETE';

    END DELETE_LA;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20180207 Overloaded this is called by process
  PROCEDURE RESUME_MAIN (P_BOLAG_ID IN NUMBER)
      as
      l_step VARCHAR2(100);
      l_status VARCHAR2(30):='INCOMPLETE';
      l_LogRec      MIGR_GVAR.LogRecTyp;
      resume_step_failed EXCEPTION;
      vsql VARCHAR2(200);
      v_queued_batch VARCHAR2(50);
      v_resume_batch PLS_INTEGER:=0;

    begin
     l_LogRec.migrArea := 'MIGR_PROCESS_RESUME.RESUME_MAIN';
     l_LogRec.logMsg := 'RESUME started';
     MIGR_LOG.LOG_INFO(l_LogRec);

      vSQL := 'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
      EXECUTE IMMEDIATE vSQL;

        --FA. 20160824 ALTER SESSION param to minmize indirect redo log size of global temporary table undo
       vSQL := 'ALTER SESSION SET TEMP_UNDO_ENABLED = TRUE';
       EXECUTE IMMEDIATE vSQL;

     v_queued_batch := MIGR_SIGNAL.GET_NEXT_QUEUED(P_BOLAG_ID);

      --find the step where migration stopped
      CHECK_PROCESS_STATUS(v_queued_batch, l_step);
      l_LogRec.logMsg := 'Step : ' || l_step ||  ' for batch:' ||v_queued_batch;
      MIGR_LOG.LOG_INFO(l_LogRec);

      IF NVL(l_step, ' ') <> ' ' THEN
         IF l_step <> 'FULL' THEN
           v_resume_batch:=1;
         END IF;

         IF l_Step <> 'Steps Completed' THEN
           --loop which executes all necessary steps till IA
             FOR c1 IN (SELECT *
                          FROM ETL_PROCESS_RESUME_CONFIG
                         WHERE ',' || EXECUTE_WHEN_STOPPED_IN || ',' LIKE '%,' || l_step || ',%'
                         ORDER BY ID
             )
             LOOP
                  l_LogRec.logMsg := 'ETL_PROCESS_RESUME_CONFIG : ' || c1.PROCESS ||  ' for batch:' ||v_queued_batch;
      MIGR_LOG.LOG_INFO(l_LogRec);
                 EXECUTE IMMEDIATE c1.PROCESS
                   USING IN v_queued_batch, OUT l_status;
        l_LogRec.logMsg := 'ETL_PROCESS_RESUME_CONFIG  l_status: ' || l_status ||  ' for batch:' ||v_queued_batch;
      MIGR_LOG.LOG_INFO(l_LogRec);
                 IF l_status<>'COMPLETE' THEN
                    IF l_status=MIGR_GVAR.GV_MD_DISC_STATUS_FAILED_DISC THEN
                        -- Archive MD_DISCOUNTS file and UPDATE MIG_MIGRATION_INFO status as 'Wait_Discounts'
                        MIGR_ARCHIVE.ARCHIVE_MD_DISCOUNTS_FILE(v_queued_batch);

                        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( v_queued_batch, MIGR_GVAR.GV_MSG_CODE_MIGR_FAILED_DISC );

                        UPDATE MIG_MIGRATION_INFO mmi SET STATUS=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC, END_TIMESTAMP = SYSTIMESTAMP, DISCOUNTS_TXT_ARCHIVED = MIGR_GVAR.GV_STATUS_PENDING  WHERE  mmi.MIGRATION_BATCH_ID=v_queued_batch;

                        EXIT;
                    ELSE
                        UPDATE MIG_MIGRATION_INFO mmi SET STATUS=MIGR_GVAR.GV_BATCH_STATUS_FAILED, END_TIMESTAMP = SYSTIMESTAMP WHERE  mmi.MIGRATION_BATCH_ID=v_queued_batch;

                        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( v_queued_batch, MIGR_GVAR.GV_MSG_CODE_MIGR_FAILED );
                        EXIT;
                    END IF;
                 END IF;

             END LOOP;
         ELSE
            l_status := 'COMPLETE';
         END IF;

      ELSE
          l_LogRec.logMsg := 'ERROR: Step is null';
          MIGR_LOG.LOG_INFO(l_LogRec);
      END IF;


      if l_status='COMPLETE' and v_resume_batch=1 then


           vsql:='UPDATE MIG_MIGRATION_INFO mmi SET mmi.resume_process='''' WHERE  mmi.resume_process=''In Progress'' AND mmi.MIGRATION_BATCH_ID=:batch';
           EXECUTE IMMEDIATE vsql USING v_queued_batch;
--           vsql:='delete from  ETL_RESUME_BATCHES where  MIGRATION_BATCH_ID=:batch';
--           EXECUTE IMMEDIATE vsql USING v_queued_batch;
           COMMIT;
  --         l_LogRec.logMsg := 'RESUME finished';
  --         MIGR_LOG.LOG_INFO(l_LogRec);
      END IF;

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END RESUME_MAIN;


    --FA.20180207 Remains for not changing the deployment script -Dummy programm created
  PROCEDURE RESUME_MAIN
      as
      l_step VARCHAR2(100);
      l_status VARCHAR2(30):='INCOMPLETE';
      l_LogRec      MIGR_GVAR.LogRecTyp;
      resume_step_failed EXCEPTION;
      vsql VARCHAR2(200);
      v_queued_batch VARCHAR2(50);
      v_resume_batch PLS_INTEGER:=0;

    begin

     l_LogRec.migrArea := 'MIGR_PROCESS_RESUME.RESUME_MAIN';
     l_LogRec.logMsg := 'RESUME started';
     MIGR_LOG.LOG_INFO(l_LogRec);


      vSQL := 'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
      EXECUTE IMMEDIATE vSQL;

        --FA. 20160824 ALTER SESSION param to minmize indirect redo log size of global temporary table undo
       vSQL := 'ALTER SESSION SET TEMP_UNDO_ENABLED = TRUE';
       EXECUTE IMMEDIATE vSQL;


     v_queued_batch := MIGR_SIGNAL.GET_NEXT_QUEUED();


--     for c in (with cte AS (SELECT MIGRATION_BATCH_ID
--                          from ETL_RESUME_BATCHES
--                           union ALL
--                          SELECT  v_queued_batch as MIGRATION_BATCH_ID
--                          FROM DUAL)
--               SELECT MIGRATION_BATCH_ID
--               FROM cte
--               WHERE 1=1
--                and (MIGRATION_BATCH_ID IS NOT NULL) and (MIGRATION_BATCH_ID <> ' ')
--
--     )
--     loop
      --find the step where migration stopped
      CHECK_PROCESS_STATUS(v_queued_batch, l_step);
      l_LogRec.logMsg := 'Step : ' || l_step ||  ' for batch:' ||v_queued_batch;
      MIGR_LOG.LOG_INFO(l_LogRec);


      IF NVL(l_step, ' ') <> ' ' THEN

         IF l_step <> 'FULL' THEN
           v_resume_batch:=1;
         END IF;

         IF l_Step <> 'Steps Completed' THEN
           --loop which executes all necessary steps till IA
             FOR c1 IN (SELECT *
                          FROM ETL_PROCESS_RESUME_CONFIG
                         WHERE ',' || EXECUTE_WHEN_STOPPED_IN || ',' LIKE '%,' || l_step || ',%'
                         ORDER BY ID
             )
             LOOP

                 --l_LogRec.logMsg := 'c1.PROCESS : '|| c1.PROCESS || v_queued_batch;
                 --MIGR_LOG.LOG_ERROR(l_LogRec);

                 EXECUTE IMMEDIATE c1.PROCESS
                   USING IN v_queued_batch, OUT l_status;

                 IF l_status<>'COMPLETE' THEN
                    IF l_status=MIGR_GVAR.GV_MD_DISC_STATUS_FAILED_DISC THEN
                        -- Archive MD_DISCOUNTS file and UPDATE MIG_MIGRATION_INFO status as 'Wait_Discounts'
                        MIGR_ARCHIVE.ARCHIVE_MD_DISCOUNTS_FILE(v_queued_batch);

                     --   l_LogRec.logMsg := 'Failed step: ' || c1.PROCESS || ' ' || SQLERRM;
                     ---   MIGR_LOG.LOG_ERROR(l_LogRec);
                        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( v_queued_batch, MIGR_GVAR.GV_MSG_CODE_MIGR_FAILED_DISC );

                        UPDATE MIG_MIGRATION_INFO mmi SET STATUS=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC, END_TIMESTAMP = SYSTIMESTAMP WHERE  mmi.MIGRATION_BATCH_ID=v_queued_batch;

                        EXIT;
                    ELSE
                        UPDATE MIG_MIGRATION_INFO mmi SET STATUS=MIGR_GVAR.GV_BATCH_STATUS_FAILED, END_TIMESTAMP = SYSTIMESTAMP WHERE  mmi.MIGRATION_BATCH_ID=v_queued_batch;
                     --   l_LogRec.logMsg := 'Failed step: ' || c1.PROCESS || ' ' || SQLERRM;
                    ---    MIGR_LOG.LOG_ERROR(l_LogRec);
                        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( v_queued_batch, MIGR_GVAR.GV_MSG_CODE_MIGR_FAILED );
                        EXIT;
                    END IF;
                 END IF;

             END LOOP;

         ELSE
            l_status := 'COMPLETE';
         END IF;

      ELSE
          l_LogRec.logMsg := 'ERROR: Step is null';
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
      END IF;
 --    end loop;



      if l_status='COMPLETE' and v_resume_batch=1 then


           vsql:='UPDATE MIG_MIGRATION_INFO mmi SET mmi.resume_process='''' WHERE  mmi.resume_process=''In Progress'' AND mmi.MIGRATION_BATCH_ID=:batch';
           EXECUTE IMMEDIATE vsql USING v_queued_batch;
--           vsql:='delete from  ETL_RESUME_BATCHES where  MIGRATION_BATCH_ID=:batch';
--           EXECUTE IMMEDIATE vsql USING v_queued_batch;
           COMMIT;
  --         l_LogRec.logMsg := 'RESUME finished';
  --         MIGR_LOG.LOG_INFO(l_LogRec);
      END IF;

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END RESUME_MAIN;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 --FA.20180125 Check if subsequently to RAC node crash there jobs running in the node that did not crash and let them complete prior to any remediation action
 PROCEDURE CHECK_RAC_RUNNING_POLICIES
  IS
       v_jobsRunning NUMBER;
       l_LogRec      MIGR_GVAR.LogRecTyp;
 BEGIN
       l_LogRec.migrArea := 'MIGR_PROCESS_RESUME.CHECK_RAC_RUNNING_POLICIES';
       l_LogRec.logMsg := 'Check if there are jobs running in the node that did not crash prior to any remediation action';
       MIGR_LOG.LOG_INFO(l_LogRec);
      v_jobsRunning:=1;

      WHILE   v_jobsRunning >0
        LOOP
           SELECT COUNT(1) into v_jobsRunning
            FROM IA_POLICY a
           JOIN USER_SCHEDULER_JOBS JOB ON   A.IA_IDPL =    SUBSTR(REGEXP_SUBSTR(job_action, '[^,]+', 1, 2),3,12)
           WHERE 1=1
           AND a.MIG_FLAG in (MIGR_GVAR.GV_MIG_FLAG_RUNNING  ,MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS);

            l_LogRec.logMsg := 'Jobs Running in the node that didn''t crash:'|| v_jobsRunning;
            MIGR_LOG.LOG_INFO(l_LogRec);
            DBMS_LOCK.SLEEP(15);
        END LOOP;


  EXCEPTION
    WHEN OTHERS THEN
           l_LogRec.logMsg  := SQLERRM ;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
 END;
   ----------------------------------------------------------------------------------------------------------------------------------------

 -- first action of MIGR_RUN_API. identifies RUNNING and RUNNING_DISCOUNTS policies right after a system resumption and re-initialises them. exception: Confirmed policies resumed in Phase 2 are manually converted

  PROCEDURE initialize_Running_policies
    AS
       vsql VARCHAR2(500);
       l_LogRec      MIGR_GVAR.LogRecTyp;
       v_running_found PLS_INTEGER:=0;
       v_running_disc_found PLS_INTEGER:=0;
       l_policyRec     MIGR_GVAR.PolicyRecTyp ;
       l_eventTimer TIMESTAMP;
       l_beginTimer       TIMESTAMP WITH TIME ZONE;
       l_runPhase2 PLS_INTEGER;
     v_pp NUMBER;

v_p  NUMBER;
    begin
       l_LogRec.migrArea := 'MIGR_PROCESS_RESUME.initialize_Running_policies';
       l_LogRec.logMsg := 'initialize_Running_policies started';
       MIGR_LOG.LOG_INFO(l_LogRec);
       l_beginTimer:=NULL;

       ---- FA. 20180125 RAC addition: Pol Jobs are running in node A and node B->Node b jobs should be completed prior to initialize  the node A crashed jobs
       CHECK_RAC_RUNNING_POLICIES;
       -- for running idpls delete data in INSIS and relative MIGR_O tables (if exist)



       FOR c1 IN (SELECT a.IA_IDPL, e.POLICY_ID, c.MIGR_TBL, a.MIG_BATCH_ID AS MIGRATION_BATCH_ID , a.mig_mutual_id
                    FROM IA_POLICY a
                   ---- LEFT JOIN MIGR_POLICY b on a.IA_idpl=b.POLICY_idpl
                    LEFT JOIN ETL_IA_INSRPRD_CONFIG c ON a.IA_PARENT_INSR_TYPE=c.INSR_TYPE
                    LEFT JOIN INSIS_GEN_V10.POLICY e ON TO_CHAR(a.IA_POLICY_REF)=E.POLICY_REF AND a.IA_OFFICE_ID=E.OFFICE_ID
                    WHERE 1=1
                     AND a.mig_flag=MIGR_GVAR.GV_MIG_FLAG_RUNNING

       )
       LOOP
          v_running_found:= 1;
          l_LogRec.migrRelKey:= c1.IA_IDPL;
          l_LogRec.logMsg := 'About to delete MIGR data for IA_IDPL:''' ||c1.IA_IDPL||''' of batch:'''||c1.MIGRATION_BATCH_ID||'''';
          MIGR_LOG.LOG_INFO(l_LogRec);
          l_LogRec.mig_batch_id := c1.migration_batch_id;

          if NVL(c1.policy_id,0 )<>0 THEN

       --delete in MIGR_O
            vsql:= 'DELETE FROM ' || c1.MIGR_TBL || ' where policy_idpl=:idpl'  ;
               l_LogRec.logMsg := 'About to delete MIGR vsql:' ||vsql;
          MIGR_LOG.LOG_INFO(l_LogRec);


            EXECUTE IMMEDIATE vsql USING c1.IA_IDPL;

       -- delete in MIGR_POLICY
            vsql:= 'DELETE FROM MIGR_POLICY where policy_idpl=:idpl'  ;
            EXECUTE IMMEDIATE vsql  USING c1.IA_IDPL;

       --cancel policy in INSIS
            MIGR_SYSTEM.CANCEL_INSIS_POLICY(c1.POLICY_ID,c1.mig_mutual_id);
          end IF;

       -- initialise mig_flag
          MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(c1.IA_IDPL, MIGR_GVAR.GV_MIG_FLAG_PENDING,c1.MIGRATION_BATCH_ID);
          l_LogRec.logMsg := 'IA_IDPL:''' ||c1.IA_IDPL||''' of batch:'''||c1.MIGRATION_BATCH_ID||''' is reinitialised';
          MIGR_LOG.LOG_INFO(l_LogRec);

       END loop;

       IF v_running_found=0 THEN
          l_LogRec.logMsg := 'No RUNNING policies were found';
          MIGR_LOG.LOG_INFO(l_LogRec);
            --FA.20170808 If API Phase 1 will run normal and  not from resume phase store INSIS log level values
             SELECT COUNT(*) INTO l_runPhase2 FROM MIG_MIGRATION_INFO mmi WHERE mmi.STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC,MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC);

             IF l_runPhase2>0 THEN
                  MIGR_API_COMMON.STORE_INSIS_LOG_LEVEL;
             END IF;

       END IF;

   --PHASE 2

       for c in (select a.IA_IDPL,E.POLICY_ID,E.POLICY_STATE,a.MIG_BATCH_ID,a.MIG_FLAG,E.POLICY_REF, E.CLIENT_ID, E.AGENT_ID, a.IA_INSRPRD, E.INSR_TYPE
                  from IA_POLICY a
                       LEFT JOIN INSIS_GEN_V10.POLICY E ON TO_CHAR(a.IA_POLICY_REF)=E.POLICY_REF     AND a.IA_OFFICE_ID=E.OFFICE_ID
                  where 1=1
                    AND a.mig_flag=MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS
       )
       LOOP
          v_running_disc_found:= 1;
          l_policyRec.policy_id:=c.POLICY_ID;
          l_policyRec.mig_flag:=c.MIG_FLAG;
          l_policyRec.continue_migr:=TRUE;
          l_policyRec.policy_ref:=c.POLICY_REF;
          l_policyRec.client_id:=c.CLIENT_ID;
          l_policyRec.agent_id:=c.AGENT_ID;
          l_policyRec.insrprd:=c.IA_INSRPRD;
          l_policyRec.insr_type:=c.INSR_TYPE;
          l_policyRec.policy_idpl:=c.IA_IDPL;
          l_policyRec.policy_final_step:='CONFIRMED';
          l_policyRec.mig_batch_id:= C.MIG_BATCH_ID;
  --if policy is in status CONFIRMED, run only CONVERT_POLICY and LOG policy in MIGR_POLICY
          if c.POLICY_STATE = '-2' THEN
            l_eventTimer := SYSTIMESTAMP;
            MIGR_API_POLICY.CONVERT_APPLICATION(l_policyrec);
            l_policyrec.logMsg := 'CONVERTED: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
            MIGR_LOG.LOG_EVENT_TIME(l_policyrec);

            MIGR_LOG.LOG_POLICY(l_policyRec, l_beginTimer, l_policyRec.policy_final_step);   --l_beginTimer is not meaningful here because is the policy is not fully migrated in one stream. value here is null
  --if policy is in status other than CONFIRMED, policy should rerun the whole phase 2
          ELSE
            MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(c.IA_IDPL, MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS,c.MIG_BATCH_ID);
          end IF;

       END loop;
       IF v_running_disc_found=0 THEN
          l_LogRec.logMsg := 'No RUNNING_DISCOUNTS policies were found';
          MIGR_LOG.LOG_INFO(l_LogRec);
          --FA.20170808 If API Phase 2 will run normal and  not from resume phase store INSIS log level values
             SELECT COUNT(*) INTO l_runPhase2 FROM MIG_MIGRATION_INFO mmi WHERE mmi.STATUS =MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC;
             IF l_runPhase2>0 THEN
                  MIGR_API_COMMON.STORE_INSIS_LOG_LEVEL;
             END IF;
       END IF;
      COMMIT;
    exception when others then
          l_LogRec.logMsg := SQLERRM || ' ' || vsql  ;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    end initialize_Running_policies;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- identify the migration step where the batch has stopped

   PROCEDURE CHECK_PROCESS_STATUS(p_migration_batch_id IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,  resume_step OUT VARCHAR2)
    AS
       l_status VARCHAR2(20);
       l_LogRec      MIGR_GVAR.LogRecTyp;

    BEGIN
       l_LogRec.migrArea := 'MIGR_PROCESS_RESUME.CHECK_PROCESS_STATUS';
       l_LogRec.mig_batch_id := p_migration_batch_id;

       --Check running batches
      FOR cor IN (SELECT *
                  FROM MIG_MIGRATION_INFO
                  WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC )
                    and MIGRATION_BATCH_ID=p_migration_batch_id)
      LOOP

        --found running batches
        --step 1 :identify last successful step   - delete all problematic data
          IF NVL(cor.RESUME_PROCESS,' ') =' ' AND cor.STATUS=MIGR_GVAR.GV_BATCH_STATUS_RUNNING THEN
            resume_step := 'FULL';

          ELSIF NVL(cor.RESUME_PROCESS,' ') =' ' AND cor.STATUS=MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC THEN
            resume_step := 'FULL_DISCOUNTS';

          ELSIF cor.RESUME_PROCESS ='In Progress' AND cor.STATUS=MIGR_GVAR.GV_BATCH_STATUS_RUNNING THEN

              IF cor.LA_COMPLETED ='Pending' THEN
                   resume_step := 'LA';
              ELSIF cor.SA_COMPLETED ='Pending' THEN
                   resume_step := 'SA';
              ELSIF cor.RULES_COMPLETED ='Pending' THEN
                  resume_step := 'RULES';
              ELSIF cor.IA_COMPLETED  ='Pending' THEN
                  resume_step := 'IA';
              END IF;

            --FA.20170404 Added check status for discounts completed step-if finished do not resume discounts steps
           ELSIF cor.RESUME_PROCESS ='In Progress' AND cor.STATUS=MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC AND COR.DISCOUNT_COMPLETED ='Pending'  THEN
                resume_step := 'RESUME_DISCOUNTS';

             -- FA.20170404 If aboev cases are not valid assume that all step has been completed
            ELSE
                resume_step := 'Steps Completed';

            END IF;

      END LOOP;
          l_LogRec.logMsg := 'Migration for batch: '''|| p_migration_batch_id|| ''' will be resumed from '||resume_step || ' step' ;
          MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION WHEN OTHERS THEN
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END CHECK_PROCESS_STATUS;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE DELETE_LA_to_IA_DISCOUNTS(p_migration_batch_id IN VARCHAR2, Status  OUT VARCHAR2)
    AS
      vsql      VARCHAR(2100);
      l_file_name   NVARCHAR2(50);
      l_bolag_name  NVARCHAR2(50);
      l_tbl_cnt     PLS_INTEGER;
      l_addtnl_flds VARCHAR2(10);
      l_Status          VARCHAR2(50);
      l_LogRec      MIGR_GVAR.LogRecTyp;
      v_my_schema VARCHAR2(50);

    BEGIN
      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME.DELETE_LA_to_IA_DISCOUNTS';
      l_LogRec.mig_batch_id := p_migration_batch_id;

      select sys_context('userenv','current_schema') INTO v_my_schema
      from dual;

      DELETE FROM MIG_DETAIL_ERROR_LOG WHERE MIGRATION_BATCH_ID=p_migration_batch_id AND RELATED_TABLE='MD_DISCOUNTS';
      DELETE FROM MIG_VOLUMETRIC_ANALYSIS WHERE MIGRATION_BATCH_ID=p_migration_batch_id AND TABLE_NAME='MD_DISCOUNTS';

  --delete batch data from LA, SA
      FOR c in (  SELECT  TO_CHAR(DEST_TABLE) AS DEST_TABLE
                  FROM ETL_ENGINE a,MIG_MIGRATION_INFO b
                  WHERE 1=1
                   AND MIGRATION_AREA IN ('Landing','Staging')
                   and a.BOLAG_ID=b.BOLAG_ID
                   and b.MIGRATION_BATCH_ID=p_migration_batch_id
                   AND TBLNAME='MD_DISCOUNTS'
                    union ALL
                  SELECT table_name AS DEST_TABLE
                  FROM ALL_ALL_TABLES
                  WHERE 1=1
                    AND owner= v_my_schema
                    and REGEXP_LIKE(table_name,'^LA_M'||SUBSTR(p_migration_batch_id,1,2)||'(.*)DISCOUNTS_IOT$')
                    UNION ALL
                  SELECT TO_CHAR(DEST_TABLE) AS DEST_TABLE
                  FROM ETL_SA_IA
                  WHERE MIGRATION_AREA = 'SA_IA'
                    AND IS_ACTIVE = 'TRUE'
                    and STEP='MD_DISCOUNTS'

      )
      LOOP
        vsql := 'delete from ' || c.DEST_TABLE || ' where mig_batch_id =:p_mig_batch';
        EXECUTE IMMEDIATE vsql
        USING p_migration_batch_id;
      END LOOP;
      Status:='COMPLETE';
      l_LogRec.logMsg :='DELETE_LA_to_IA_DISCOUNTS ran successfully';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;

    EXCEPTION

      WHEN OTHERS THEN
      --DBMS_OUTPUT.PUT_LINE('DELETE_LA:' || SQLERRM());
        l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);
        Status:='INCOMPLETE';

    END DELETE_LA_to_IA_DISCOUNTS;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_PROCESS_RESUME;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_REPORTING AS

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--- +++ anb 2019-02-28 -- V_MIGR_FACT and V_MIGR_PREMIUMS are build by MIGR_REPORTING procedure
/*
  PROCEDURE MIGR_FACT
    AS
  END;

   ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGR_PREMIUMS
    AS
  END;
--- end +++ anb 2019-02-28 -- V_MIGR_FACT and V_MIGR_PREMIUMS are build by MIGR_REPORTING procedure
*/
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- PL 20170411 new etl reports definition table and flow
  -- exec MIGR_REPORTING.REPORTING();
  PROCEDURE REPORTING
    AS

    l_LogRec    MIGR_GVAR.LogRecTyp;
    v_view_clob CLOB;
    v_view_name VARCHAR2(200);
  BEGIN

    l_LogRec.migrArea   := 'MIGR_REPORTING.REPORTING';
    l_LogRec.migrStep   := 'MIGR_REPORTING.REPORTING';
    l_LogRec.migrRelTbl := '';
    l_LogRec.logMsg     := '';

    v_view_name         := ' ';

    FOR c IN ( SELECT VIEW_NAME, VIEW_BODY
                 FROM ETL_REPORTS_DEF
                WHERE IS_ACTIVE = 'Y'
                ORDER BY ROW_ID ASC
    )
    LOOP
      v_view_name := c.VIEW_NAME;           -- +++ anb for error handling
      v_view_clob := 'CREATE OR REPLACE VIEW ' || c.VIEW_NAME || ' AS ' || c.VIEW_BODY;
         l_LogRec.logMsg     := 'v_view_name' ||v_view_name;

      EXECUTE IMMEDIATE(v_view_clob);

    END LOOP;


  EXCEPTION
    WHEN OTHERS THEN
      l_LogRec.logMsg := SQLCODE || ' - ' || SQLERRM|| ' - View: ' || v_view_name;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
  END REPORTING;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 --FA.20171212 Changed report design as the previous had  issues
  PROCEDURE DAILY_PROGRESS ( pRenewalDate IN DATE )
    IS
       vDailyProgress         VARCHAR2(32000);
       vBatchDailyProgress    VARCHAR2(4000);
       vBatchDailyProgressAll VARCHAR2(4000);
       l_runningDisc_cnt      PLS_INTEGER := 0;
       l_running_cnt          PLS_INTEGER := 0;
       l_runningbatch_list    VARCHAR2(4000);
       l_runningDiscbatch_list VARCHAR2(4000);
       l_counter              PLS_INTEGER := 0;
       l_last24hh             PLS_INTEGER;
       l_count_all_Phase1     PLS_INTEGER := 0;
       l_count_all_Phase2     PLS_INTEGER := 0;
       l_pending              PLS_INTEGER := 0;
       l_success              PLS_INTEGER := 0;
       l_duplicate            PLS_INTEGER := 0;
       l_rules_exclusion      PLS_INTEGER := 0;
       l_und_prd              PLS_INTEGER := 0;
       l_failed               PLS_INTEGER := 0;
       l_running              PLS_INTEGER := 0;
       l_skipped              PLS_INTEGER := 0;
       l_wait_disc_Phase1     PLS_INTEGER := 0;
       l_wait_disc            PLS_INTEGER := 0;
       l_wait_disc_Phase2     PLS_INTEGER := 0;
       l_running_disc         PLS_INTEGER := 0;
       l_failed_disc          PLS_INTEGER := 0;
       l_error                PLS_INTEGER := 0;
       l_count_all            PLS_INTEGER := 0;
       l_countA               PLS_INTEGER := 0;
       l_countB               PLS_INTEGER := 0;
       l_LogRec             MIGR_GVAR.LogRecTyp;
       l_daily_check          VARCHAR2(8);
       l_start_date_a         VARCHAR2(10);
       l_start_date_b         VARCHAR2(10);
       v_msA                  PLS_INTEGER := 0;
       v_msB                  PLS_INTEGER := 0;
       v_PRL_LEVEL            PLS_INTEGER := 0;
       v_ID                   PLS_INTEGER := 0;
       total_pend             PLS_INTEGER := 0;
       pol_sec                PLS_INTEGER := 0;
       h_count                PLS_INTEGER := 0;
       v_first_hr             PLS_INTEGER := 0;

BEGIN
   l_LogRec.migrArea := 'MIGR_REPORTING.DAILY_PROGRESS';
   l_LogRec.migrStep := 'MIGR_REPORTING.DAILY_PROGRESS';

-- LM - 01/02/2018 - FIX DAILY PROGRESS
 SELECT DAILY_PROG_CHECK INTO l_daily_check FROM ETL_SETUP_INFO esi;

 SELECT COUNT(*)
   INTO l_countA
   FROM MIG_MIGRATION_INFO mmi
  WHERE 1=1
    AND mmi.RENEWAL_DATE = pRenewalDate
    AND mmi.STATUS = 'Running' ;

  SELECT COUNT(*)
   INTO l_countB
   FROM MIG_MIGRATION_INFO mmi
  WHERE 1=1
    AND mmi.RENEWAL_DATE = pRenewalDate
    AND mmi.STATUS = 'Running_Discounts' ;

 IF l_countA > 0 THEN
   SELECT TO_CHAR((mmi.START_TIMESTAMP+1), 'DD-MM-YYYY')
     INTO l_start_date_a
     FROM MIG_MIGRATION_INFO mmi
    WHERE 1=1
      AND mmi.RENEWAL_DATE = pRenewalDate
      AND mmi.STATUS = 'Running'
    ORDER BY mmi.START_TIMESTAMP
    FETCH FIRST ROW ONLY;
 END IF;

 IF l_countB > 0 THEN
     SELECT TO_CHAR((mmi.DISCOUNTS_START_TIMESTAMP+1), 'DD-MM-YYYY')
     INTO l_start_date_b
     FROM MIG_MIGRATION_INFO mmi
    WHERE 1=1
      AND mmi.RENEWAL_DATE = pRenewalDate
      AND mmi.STATUS = 'Running_Discounts'
    ORDER BY mmi.DISCOUNTS_START_TIMESTAMP
    FETCH FIRST ROW ONLY;
 END IF;

   IF TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS') >= l_daily_check AND
    ((l_countA > 0 AND SYSDATE >= TO_DATE(l_start_date_a,'DD-MM-YYYY')) OR (l_countB > 0 AND SYSDATE >= TO_DATE(l_start_date_b,'DD-MM-YYYY'))) THEN
-- LM - 01/02/2018 - FIX DAILY PROGRESS

      --Check if the email has already been sent
        SELECT COUNT(*)  INTO l_counter
        FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl
        WHERE 1=1
        AND TO_CHAR(SYSDATE, 'DD-MM-YYYY') = TO_CHAR(menl.MSG_REGISTRATION_TIMESTAMP, 'DD-MM-YYYY')
        AND menl.MSG_CODE = MIGR_GVAR.GV_MSG_CODE_MIGR_DAILY_PROGRSS
        -- LM - 10/01/2018 - FIX DAILY PROGRESS
        AND menl.MSG_STATUS = 'Sent'
        ;

        IF  l_counter= 0 THEN

            SELECT COUNT (1), LISTAGG(mmi.MIGRATION_BATCH_ID, ',')
            WITHIN GROUP (ORDER BY mmi.MIGRATION_BATCH_ID ASC) BATCH_LIST
            INTO l_running_cnt,l_runningbatch_list
            FROM MIG_MIGRATION_INFO mmi
            WHERE 1=1
            AND mmi.RENEWAL_DATE = pRenewalDate
            AND mmi.STATUS IN ('Running') ;

            SELECT COUNT (1), LISTAGG(mmi.MIGRATION_BATCH_ID, ',')
            WITHIN GROUP (ORDER BY mmi.MIGRATION_BATCH_ID ASC) BATCH_LIST
            INTO l_runningDisc_cnt,l_runningDiscbatch_list
            FROM MIG_MIGRATION_INFO mmi
            WHERE 1=1
            AND mmi.RENEWAL_DATE = pRenewalDate
            AND mmi.STATUS IN ('Running_Discounts') ;

            IF l_running_cnt>0 or l_runningDisc_cnt>0  then

                  --- All batches
                 SELECT COUNT(*)
                 INTO l_count_all_Phase1
                 FROM IA_POLICY ip
                 WHERE  (  ',' || l_runningbatch_list   || ',' LIKE '%,' || ip.MIG_BATCH_ID || ',%' ) ;

                 SELECT COUNT(*)
                 INTO l_count_all_Phase2
                 FROM IA_POLICY ip
                 WHERE   (    ',' || l_runningDiscbatch_list || ',' LIKE '%,' || ip.MIG_BATCH_ID || ',%'    )  ;

                 ---get policies migrated the last 24 hours
                 WITH
                  DETAIL_LOG AS (
                 SELECT TRUNC(madl.EVENT_TIMESTAMP, 'HH24')AS TIMESTMP,  madl.EVENT_TIMESTAMP, madl.RELATED_KEY
                 FROM MIGR_API_DETAIL_LOG madl
                 WHERE madl.RELATED_TABLE = 'POLICY JOB'
                 AND madl.EVENT_MESSAGE LIKE 'About to REMOVE%'
                 and   madl.EVENT_TIMESTAMP >= SYSTIMESTAMP-1
                  ),
                  POL_PER_HOUR AS (
                  SELECT TO_CHAR(TIMESTMP, 'DD/MM/YYYY HH24:MI:SS') AS TIMESTAMP, COUNT(TIMESTMP) AS POLICIES_PER_MIGRATION_HOUR
                  FROM DETAIL_LOG
                  GROUP BY TIMESTMP
                  ORDER BY TIMESTMP ASC
                  )
                  SELECT sum(POLICIES_PER_MIGRATION_HOUR)/count(1) INTO l_last24hh
                  FROM POL_PER_HOUR
                  ;

                 FOR c IN
                         (SELECT ip.MIG_FLAG, COUNT(*) AS counter
                           FROM IA_POLICY ip
                           WHERE 1=1
                           AND ',' || l_runningbatch_list || ',' LIKE '%,' || ip.MIG_BATCH_ID || ',%'
                           GROUP BY ip.MIG_FLAG
                           )
                 LOOP

                          IF    c.MIG_FLAG =  0 THEN l_pending := c.counter;
                          ELSIF c.MIG_FLAG =  2 THEN l_duplicate := c.counter;
                          ELSIF c.MIG_FLAG =  3 THEN l_rules_exclusion := c.counter;
                          ELSIF c.MIG_FLAG =  4 THEN l_und_prd := c.counter;
                          ELSIF c.MIG_FLAG =  5 THEN l_failed := c.counter;
                          ELSIF c.MIG_FLAG =  6 THEN l_running := c.counter;
                          ELSIF c.MIG_FLAG =  7 THEN l_skipped := c.counter;
                          ELSIF c.MIG_FLAG =  8 THEN l_wait_disc_Phase1 := c.counter;
                          ELSE  l_error := 1;
                          END IF;

                  END LOOP;

                  --check for all running Discounnts batches the status
                  FOR c IN
                           (SELECT ip.MIG_FLAG, COUNT(*) AS counter
                             FROM IA_POLICY ip
                             WHERE 1=1
                             AND ',' || l_runningDiscbatch_list || ',' LIKE '%,' || ip.MIG_BATCH_ID || ',%'
                             GROUP BY ip.MIG_FLAG
                             )
                  LOOP

                          IF c.MIG_FLAG =  1 THEN l_success := c.counter;
                          ELSIF c.MIG_FLAG =  5 THEN l_failed := c.counter;
                          ELSIF c.MIG_FLAG =  7 THEN l_skipped := c.counter;
                          ELSIF c.MIG_FLAG =  8 THEN l_wait_disc_Phase2 := c.counter;
                          ELSIF c.MIG_FLAG =  9 THEN l_running_disc := c.counter;
                          ELSIF c.MIG_FLAG = 10 THEN l_failed_disc := c.counter;
                          ELSE  l_error := 1;
                          END IF;

                  END LOOP;

-- LM - 2018-03-07 - Calculate 'Estimated time of completion' according to parallel level configuration - START
                    SELECT SUM(NVL(mp.INS_MS_A, 0))/COUNT(*)
                      INTO v_msA
                      FROM MIGR_POLICY mp
                     WHERE 1=1
                       AND ',' || l_runningbatch_list || ',' LIKE '%,' || mp.MIG_BATCH_ID || ',%';

                    SELECT SUM(NVL(mp.INS_MS_B,0))/COUNT(*)
                      INTO v_msB
                      FROM MIGR_POLICY mp
                     WHERE 1=1
                       AND mp.INS_MS_B IS NOT null
                       AND ',' || l_runningDiscbatch_list || ',' LIKE '%,' || mp.MIG_BATCH_ID || ',%';

                    IF v_msB > 0 THEN
                      pol_sec := ROUND(v_msB/1000);
                    ELSE
                      pol_sec := ROUND(v_msA/1000);
                    END IF;

                    SELECT
                      CASE (SELECT PLAN FROM ETL_PARALLEL_LEVEL_PER_TIME eplpt
                                 WHERE TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) >=eplpt.TIME_FROM
                                   AND TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) <= eplpt.TIME_TO)
                      WHEN 'HIGH' THEN NVL(PARALLEL_LEVEL, 1)
                      WHEN 'MID'  THEN NVL(MID_PARALLEL_LEVEL, 1)
                      WHEN 'MIN'  THEN NVL(MIN_PARALLEL_LEVEL, 1)
                      ELSE 1
                     END as NEW_PRL_LEVEL,
                    (SELECT eplpt.ID
                       FROM ETL_PARALLEL_LEVEL_PER_TIME eplpt
                      WHERE TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) >=eplpt.TIME_FROM
                        AND TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) <= eplpt.TIME_TO),
                    (SELECT MIGR_SYSTEM.fn_ELAPSEDms (TO_TIMESTAMP( TO_CHAR(TRUNC(sysdate),'dd-mm-yyyy')||' ' ||eplpt.time_to , 'dd-mm-yyyy hh24:mi:ss') , SYSTIMESTAMP)/1000 AS first_hr
                       FROM ETL_PARALLEL_LEVEL_PER_TIME eplpt
                      WHERE TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) >=eplpt.TIME_FROM
                        AND TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) <= eplpt.TIME_TO)
                    INTO v_PRL_LEVEL, v_ID, v_first_hr
                    FROM ETL_SETUP_INFO;

                    total_pend := l_pending+l_wait_disc_Phase2;

                    total_pend := total_pend - ROUND((v_first_hr/pol_sec) * v_PRL_LEVEL);
                    h_count :=  h_count + 1;

                    WHILE total_pend > 0
                      LOOP

                      SELECT a.ID ,
                        CASE a.PLAN
                        WHEN 'HIGH' THEN NVL(b.PARALLEL_LEVEL, 1)
                        WHEN 'MID'  THEN NVL(b.MID_PARALLEL_LEVEL, 1)
                        WHEN 'MIN'  THEN NVL(b.MIN_PARALLEL_LEVEL, 1)
                        ELSE 1
                       END
                      INTO v_ID, v_PRL_LEVEL
                      FROM ETL_PARALLEL_LEVEL_PER_TIME a, ETL_SETUP_INFO b
                      WHERE a.ID = v_ID + 1 ;

                      total_pend := total_pend - ROUND((3600/pol_sec) * v_PRL_LEVEL);
                      h_count :=  h_count + 1;

                    END LOOP;
-- LM - 2018-03-07 - Calculate 'Estimated time of completion' according to parallel level configuration - END

                   vDailyProgress := 'EY Migration Process - Daily Progress'      || CHR(10)
                                               || '----------------------------------------'   || CHR(10)
                                               || 'Renewal Date : '              || TO_CHAR(pRenewalDate,'yyyy/mm/dd')                    || CHR(10)
                                               || 'AVG Speed (per hour) : '      || l_last24hh  || ' policies/hour       '                || CHR(10)
                                              -- || 'Estimated time of completion : ' || RTRIM(TO_CHAR(ROUND(((l_pending+l_wait_disc_Phase2) / l_last24hh),2),'FM999999990D99'),',') || ' hours  ' || CHR(10)
                                               || 'Estimated time of completion : ' || h_count || ' hours  ' || CHR(10)
                                               || '----------------------------------------'           || CHR(10)
                                               || 'Total Policies : '            ||TO_CHAR( l_count_all_Phase1+l_count_all_Phase2  )      || CHR(10)
                                               || 'Policies Processed by API : '                  ||TO_CHAR( l_wait_disc_Phase1 + l_success )       || CHR(10)
                                               || '  Pending Policies : '        || TO_CHAR(l_pending + l_wait_disc_Phase2 + l_running + l_running_disc)         || CHR(10)
                                               || '  Duplicate : '               || l_duplicate        || CHR(10)
                                               || '  Rules Exclusion : '         || l_rules_exclusion  || CHR(10)
                                               || '  Undefined Product : '       || l_und_prd          || CHR(10)
                                               || '  Failed on Phase A : '       || l_failed           || CHR(10)
                                               || '  Wait Discounts : '          || TO_CHAR(l_wait_disc_Phase2+l_wait_disc_Phase1)        || CHR(10)
                                               || '  Skipped : '                 || l_skipped          || CHR(10)
                                               || '  Failed on Discount : '      || l_failed_disc      || CHR(10)
                                               || '----------------------------------------'           || CHR(10)     ----- end
                                              ;

                      -- Per Batch
                   FOR cur IN (SELECT *
                                        FROM MIG_MIGRATION_INFO mmi
                                        WHERE 1=1
                                        AND mmi.RENEWAL_DATE = pRenewalDate
                                        AND mmi.STATUS IN ('Running', 'Running_Discounts')
                                       )
                   LOOP
                          l_count_all_Phase1 := 0;
                          l_count_all_Phase2 :=0;
                          l_rules_exclusion := 0;
                          l_pending := 0;
                          l_success := 0;
                          l_duplicate := 0;
                          l_und_prd  := 0;
                          l_failed := 0;
                          l_running := 0;
                          l_skipped := 0;
                          l_wait_disc := 0;
                          l_error := 0;
                          l_running_disc := 0;
                          l_failed_disc  := 0;

                          SELECT COUNT(*) INTO l_count_all
                          FROM IA_POLICY ip
                          WHERE 1=1
                          AND ip.MIG_BATCH_ID = cur.MIGRATION_BATCH_ID;

                          FOR c IN
                                    (SELECT ip.MIG_FLAG, COUNT(*) AS counter
                                     FROM IA_POLICY ip
                                     WHERE 1=1
                                      AND ip.MIG_BATCH_ID = cur.MIGRATION_BATCH_ID
                                     GROUP BY ip.MIG_FLAG
                                     )
                          LOOP

                              IF    c.MIG_FLAG =  0 THEN l_pending := c.counter;
                              ELSIF c.MIG_FLAG =  1 THEN l_success := c.counter;
                              ELSIF c.MIG_FLAG =  2 THEN l_duplicate := c.counter;
                              ELSIF c.MIG_FLAG =  3 THEN l_rules_exclusion := c.counter;
                              ELSIF c.MIG_FLAG =  4 THEN l_und_prd := c.counter;
                              ELSIF c.MIG_FLAG =  5 THEN l_failed := c.counter;
                              ELSIF c.MIG_FLAG =  6 THEN l_running := c.counter;
                              ELSIF c.MIG_FLAG =  7 THEN l_skipped := c.counter;
                              ELSIF c.MIG_FLAG =  8 THEN l_wait_disc := c.counter;
                              ELSIF c.MIG_FLAG =  9 THEN l_running_disc := c.counter;
                              ELSIF c.MIG_FLAG = 10 THEN l_failed_disc := c.counter;
                              ELSE l_error := 1;
                              END IF;

                          END LOOP;

                          vBatchDailyProgress := 'Migration Batch ID : '       || cur.MIGRATION_BATCH_ID          || CHR(10)
                                                                || 'Renewal Date : '             || cur.RENEWAL_DATE                || CHR(10)
                                                                || '----------------------------------------'                       || CHR(10)
                                                                || 'Total Policies : '            || l_count_all        || CHR(10) ;

                          IF  cur.STATUS ='Running' THEN
                                vBatchDailyProgress :=vBatchDailyProgress || 'Policies Processed by API :    '                  || l_wait_disc         || CHR(10)
                                                                      || ' Phase A '                                          || CHR(10)
                                                                      || '  Pending Policies : '        || TO_CHAR(l_pending + l_running)         || CHR(10)
                                                                      || '  Duplicate : '               || l_duplicate        || CHR(10)
                                                                      || '  Rules Exclusion : '         || l_rules_exclusion  || CHR(10)
                                                                      || '  Undefined Product : '       || l_und_prd          || CHR(10)
                                                                      || '  Failed on Phase A : '       || l_failed           || CHR(10)
                                                                      || '----------------------------------------'           || CHR(10);
                          ELSE
                                vBatchDailyProgress :=vBatchDailyProgress || 'Policies Processed by API :    '                  || l_success           || CHR(10)
                                                                      || ' Phase B '                                          || CHR(10)
                                                                      || '  Wait Discounts : '          || TO_CHAR(l_wait_disc + l_running_disc)       || CHR(10)
                                                                      || '  Skipped : '                 || l_skipped          || CHR(10)
                                                                      || '  Failed on Discount : '      || l_failed_disc      || CHR(10)
                                                                      || '----------------------------------------'           || CHR(10)   ;
                          END IF;
                -- LM - 10/01/2018 - FIX DAILY PROGRESS - 1 email for all batches
                          vBatchDailyProgressAll := vBatchDailyProgressAll || CHR(10) || CHR(13) || vBatchDailyProgress ;

                         -- MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_WITH_DYNAMIC_MSG(cur.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_MIGR_DAILY_PROGRSS, vDailyProgress || CHR(10) || CHR(13) || vBatchDailyProgress);

                   END LOOP;

                   MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_WITH_DYNAMIC_MSG('0-0', MIGR_GVAR.GV_MSG_CODE_MIGR_DAILY_PROGRSS, vDailyProgress || CHR(10) || CHR(13) || vBatchDailyProgressAll);
                -- LM - 10/01/2018 - FIX DAILY PROGRESS - 1 email for all batches
            END IF;
        END IF;
   END IF;

  EXCEPTION
      WHEN OTHERS THEN
          l_LogRec.logMsg := SQLCODE || ' - ' || SQLERRM || ' - ' || l_LogRec.logMsg;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END DAILY_PROGRESS;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_REPORTING;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_RULES
  AS

  ---------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------
  -- +++ anb 2015-10-20 mark SA_KF100F records with appropriate Product definition
  PROCEDURE MARK_PRODUCTS(VMigrationBatchId IN VARCHAR2, p_status OUT varchar2)
    AS

      vSQL             VARCHAR2(32000);
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN
      p_status:='COMPLETE';

      l_LogRec.mig_batch_id:=  vMigrationBatchID;
      l_LogRec.migrArea      :=   'MIGR_PRODUCTS' ;
      l_LogRec.migrStep      :=  'MARK_PRODUCTS' ;
      l_LogRec.migrRelTbl    :=    'ETL_PRODUCT_DEF';
      l_LogRec.migrRelKey  :=   NULL;

      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging Insr Products', 'Begin Marking Products ', vMigrationBatchID, 'ETL_PRODUCT_DEF');

       l_LogRec.logMsg        :=     'Mark Product field for all records';
       MIGR_LOG.LOG_INFO(l_LogRec) ;


      --FA. 20160209 Add bolag condition
      --+++ anb 20160210 Get bolag_ID from MIG_MIGRATION_INFO
--      FOR cRec IN (SELECT epd.NAME_PRODUCT,
--                          epd.WHERE_CLAUSE2,
--                          epd.APPLICABLE_BOLAGS
--          FROM ETL_PRODUCT_DEF epd
--          WHERE epd.IS_ACTIVE = 'Y'
--            -- AND (not epd.APPLICABLE_BOLAGS IS NULL)
--            AND SUBSTR(VMigrationBatchId, 1, INSTR(VMigrationBatchId, '-') - 1) IN (SELECT REGEXP_SUBSTR(NVL(epd.APPLICABLE_BOLAGS, '0'), '[^,]+', 1, LEVEL)
--                FROM dual
--              CONNECT BY REGEXP_SUBSTR(NVL(epd.APPLICABLE_BOLAGS, '0'), '[^,]+', 1, LEVEL) IS NOT NULL)
--          ORDER BY epd.Row_ID)
--      LOOP
--        vSQL := 'UPDATE SA_KF100F SET INSRPRD = ' || CHR(39) || cRec.NAME_PRODUCT || CHR(39)
--        || ' WHERE MIG_FLAG = 0 '
--        || ' AND IDPL IN ('
--        || cRec.WHERE_CLAUSE2 || ' ) '
--        || ' AND MIG_MUTUAL_ID IN (' || cRec.APPLICABLE_BOLAGS || ')'
--        || ' AND MIG_BATCH_ID = '
--        || CHR(39) || vMigrationBatchId || CHR(39);

      FOR cRec IN (
          SELECT epd.NAME_PRODUCT, epd.WHERE_CLAUSE2, epd.APPLICABLE_BOLAGS
          FROM ETL_PRODUCT_DEF epd
                  , (SELECT BOLAG_ID from MIG_MIGRATION_INFO mmi WHERE mmi.MIGRATION_BATCH_ID= VMigrationBatchId)  bg
          WHERE epd.IS_ACTIVE = 'Y'
            AND (not epd.APPLICABLE_BOLAGS IS NULL)
            and ','||epd.APPLICABLE_BOLAGS||',' like '%,'||substr(VMigrationBatchId,1,2)||',%'
--valex.7/10/2016 - mark policies in KF100F only for products included in MIG_PROCESS_STEPS plan
            AND ',' || MIGR_PROCESS.PROCESS_STEPS(VMigrationBatchId,null,null) || ',' LIKE  '%,' || epd.NAME_PRODUCT || ',%'
--valex.7/10/2016 - end
          ORDER BY epd.Row_ID
      )



      LOOP


       --FA.20160410 Rewrite product definition query with bulk insert
      vSQL := 'DECLARE '
      || ' CURSOR KF is '
      || '    SELECT IDPL'
      || ' FROM SA_KF100F ;'
      || ' TYPE KF_tab IS TABLE OF KF%ROWTYPE; '
      || ' KF_all_records   KF_tab:= KF_tab(); '
      || 'BEGIN '

      || 'SELECT IDPL BULK COLLECT INTO KF_all_records '

      || 'FROM ( '
      ||  cRec.WHERE_CLAUSE2
      || '  ); '

--      || '  FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT '
--      || '    insert into MIG_DETAIL_ERROR_LOG '
--      || '      SELECT MIG_BATCH_ID as MIGRATION_BATCH_ID, '
--      || '        SYSTIMESTAMP AS ERROR_TIMESTAMP, '
--      || '        ''Rules'' AS MIGRATION_AREA, '
--      || '        ''Critical Error'' AS ERROR_TYPE, '
--      || '        ''IDPL identified under multiple products: '' || insrprd || '', '' || :insrprd  AS ERROR_MESSAGE, '
--      || '        ''MARK_PRODUCTS''  AS MIGRATION_STEP, '
--      || '        null AS RELATED_TABLE, idpl   AS RELATED_KEY '
--      || '      from sa_kf100f'
--      || '      where  insrprd<>'' '''
--      || '        and idpl=KF_all_records(i).idpl ;'

      || '  FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT '
      || '    UPDATE  SA_KF100F SET  INSRPRD= :insrprd  WHERE  MIG_BATCH_ID=:mig_batch_id and MIG_FLAG = 0 and idpl = KF_all_records(i).idpl; '
      || 'END; ';


        /*vSQL :=  'UPDATE SA_KF100F SET INSRPRD = ' || CHR(39) || cRec.NAME_PRODUCT || CHR(39)
              || ' WHERE MIG_FLAG = 0 '
              || ' AND IDPL IN ('
              ||   cRec.WHERE_CLAUSE2 || ' ) '
              || ' AND REGEXP_LIKE('||''',''||'''||cRec.APPLICABLE_BOLAGS||'''||'','', '',''||MIG_MUTUAL_ID||'','') '
              || ' AND MIG_BATCH_ID = '
              || CHR(39) || vMigrationBatchId || CHR(39);*/
        --          DBMS_OUTPUT.PUT_LINE(vSQL);

  --valex.20/9/16 - addition of cRec.APPLICABLE_BOLAGS bind variable in WHERE_CLAUSE2 of ETL_TBL_DEF for retrieval of only bolag-specific policies
        --EXECUTE IMMEDIATE vSQL USING cRec.NAME_PRODUCT, vMigrationBatchId;
        EXECUTE IMMEDIATE vSQL USING cRec.APPLICABLE_BOLAGS, cRec.NAME_PRODUCT, vMigrationBatchId;
--valex.20/9/16 - end

      END LOOP;
      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging Insr Products', 'End Marking Products ', vMigrationBatchID, 'ETL_PRODUCT_DEF');

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.logMsg        :=    SQLERRM || ' ' ||  vSQL;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
        p_status:='INCOMPLETE';

    END MARK_PRODUCTS;
  -------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------


  ---------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------
  -- pl 20161031 mark SA_KF100F records with appropriate Offering definition
  PROCEDURE MARK_OFFERINGS(VMigrationBatchId IN VARCHAR2, p_status OUT VARCHAR2)
    AS

      vSQL             VARCHAR2(2100);
       l_LogRec MIGR_GVAR.LogRecTyp;


    BEGIN
      p_status := 'COMPLETE';


        l_LogRec.mig_batch_id:=  vMigrationBatchID;
        l_LogRec.migrArea      :=   'MIGR_OFFERINGS' ;
        l_LogRec.migrStep      :=  'MARK_OFFERINGS' ;
        l_LogRec.migrRelTbl    :=    'ETL_OFF_DEF';
        l_LogRec.migrRelKey  :=   NULL;


      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging Insr Offerings', 'Begin Marking Offerings ', vMigrationBatchID, 'ETL_OFF_DEF');

       l_LogRec.logMsg        :=     'Mark Offering field for all records';
       MIGR_LOG.LOG_INFO(l_LogRec) ;


      FOR cRec IN (
          SELECT eod.NAME_PRODUCT, eod.WHERE_CLAUSE, eod.APPLICABLE_BOLAGS, eod.INSIS_PRODUCT2
            FROM ETL_OFF_DEF eod
               , (SELECT BOLAG_ID from MIG_MIGRATION_INFO mmi WHERE mmi.MIGRATION_BATCH_ID = VMigrationBatchId) bg
           WHERE eod.IS_ACTIVE = 'Y'
             AND (NOT eod.APPLICABLE_BOLAGS IS NULL)
             AND ',' || eod.APPLICABLE_BOLAGS || ',' like '%,' || SUBSTR(VMigrationBatchId,1,2) || ',%'
             -- valex.7/10/2016 - mark policies in KF100F only for products included in MIG_PROCESS_STEPS plan
             AND ',' || MIGR_PROCESS.PROCESS_STEPS(VMigrationBatchId, null, null) || ',' like '%,' || eod.NAME_PRODUCT || ',%'
             -- valex.7/10/2016 - end
           ORDER BY eod.Row_ID
      )
      LOOP
          -- FA.20160410 Rewrite product definition query with bulk insert
          vSQL := 'DECLARE '
          || ' CURSOR KF is '
          || '    SELECT IDPL'
          || ' FROM SA_KF100F ;'
          || ' TYPE KF_tab IS TABLE OF KF%ROWTYPE; '
          || ' KF_all_records   KF_tab:= KF_tab(); '
          || 'BEGIN '

          || 'SELECT IDPL BULK COLLECT INTO KF_all_records '

          || 'FROM ( '
          ||  cRec.WHERE_CLAUSE
          || '  ); '

          || '  FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT '
          || '    UPDATE SA_KF100F SET OFFRNCODE = :offrncode WHERE MIG_BATCH_ID = :mig_batch_id AND MIG_FLAG = 0 and idpl = KF_all_records(i).idpl; '
          || 'END; ';


          -- addition of cRec.APPLICABLE_BOLAGS bind variable in WHERE_CLAUSE of ETL_OFF_DEF for retrieval of only bolag-specific policies
          -- EXECUTE IMMEDIATE vSQL USING cRec.NAME_PRODUCT, vMigrationBatchId;
          EXECUTE IMMEDIATE vSQL USING cRec.APPLICABLE_BOLAGS, cRec.INSIS_PRODUCT2, vMigrationBatchId;

      END LOOP;

      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging Insr Offerings', 'End Marking Offerings', vMigrationBatchID, 'ETL_OFF_DEF');

    EXCEPTION
      WHEN OTHERS THEN
         l_LogRec.logMsg        :=    SQLERRM || ' ' ||  vSQL;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
        p_status:='INCOMPLETE';

    END MARK_OFFERINGS;

  -------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------

  -------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------
  PROCEDURE RUN_EXCLUDE_PRODUCTS(VMigrationBatchId IN VARCHAR2, p_status OUT varchar2)
    AS


      vPrd             VARCHAR2(2100);
      vSQL             VARCHAR2(2100);
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN
      p_status:='COMPLETE';

        l_LogRec.mig_batch_id:=  vMigrationBatchID;
        l_LogRec.migrArea      :=   'MIGR_PRODUCTS' ;
        l_LogRec.migrStep      :=  'EXCLUDE_PRODUCTS' ;
        l_LogRec.migrRelTbl    :=    'ETL_OFF_DEF';
        l_LogRec.migrRelKey  :=   NULL;


      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging Insr Products', 'Begin Excluding Products ', vMigrationBatchID, 'Exclude ETL_PRODUCT_DEF');

       l_LogRec.logMsg        :=     'Exclude non-active Products';
       MIGR_LOG.LOG_INFO(l_LogRec) ;


      --      vPrd  := NULL;
      --      FOR cRec IN ( SELECT epd.WHERE_CLAUSE2, epd.APPLICABLE_BOLAGS
      --                    FROM ETL_PRODUCT_DEF epd
      --                    WHERE epd.IS_ACTIVE = 'Y'
      --                  )
      --      LOOP
      --          IF NOT vPrd IS NULL THEN
      --              vPrd := vPrd || ' UNION ALL ';
      --          END IF;
      --          vPrd := vPrd || cRec.WHERE_CLAUSE2 ||;
      --      END LOOP;
      --
      --      vSQL  := 'UPDATE SA_KF100F SET MIG_FLAG =4 '
      --             ||'WHERE MIG_FLAG = 0 '
      --             ||' AND IDPL NOT IN ('
      --             || vPrd    ||' ) '
      --             ||' AND MIG_BATCH_ID = '
      --             || CHR(39) || vMigrationBatchId || CHR(39);
      ----      DBMS_OUTPUT.PUT_LINE(vSQL);
      --      EXECUTE IMMEDIATE vSQL;

      vSQL := 'UPDATE SA_KF100F SET MIG_FLAG =4 '
      || 'WHERE MIG_FLAG = 0 '
      || ' AND NVL(TRIM(BOTH ' || CHR(39) || ' ' || CHR(39) || ' FROM INSRPRD),' || CHR(39) || ' ' || CHR(39) || ')=' || CHR(39) || ' ' || CHR(39)
      || ' AND MIG_BATCH_ID = '
      || CHR(39) || vMigrationBatchId || CHR(39);
      --      DBMS_OUTPUT.PUT_LINE(vSQL);
      EXECUTE IMMEDIATE vSQL;

      --- need to also set MIG_FLAG=4 to other KFxxxF files related to KF100F.

      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging Insr Products', 'End Excluding Products ', vMigrationBatchID, 'Exclude ETL_PRODUCT_DEF');

    EXCEPTION
      WHEN OTHERS THEN
           l_LogRec.logMsg        :=    SQLERRM || ' ' ||  vSQL;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
          p_status:='INCOMPLETE';

    END RUN_EXCLUDE_PRODUCTS;
  -------------------------------------------------------------------------------------------------------------

  ---- new procedure 20150914 AM - combines: unpackaged procedure TEST_DYN_MIGR_RULES_TST with RUN_EXCLUSION_RULES_TST
  -- Includes Volumetrics from RUN_EXCLUSION_RULES_TST
  -- This procedure has been renamed after successful testing into RUN_EXCLLUSION_RULES --------------------
  -- PROCEDURE DYNAMIC_RULES_EXEC_TST(vMigrationBatchID IN VARCHAR2) AS
  -------------------------------------------------------------------------------------------------------------
  PROCEDURE RUN_EXCLUSION_RULES(VMigrationBatchId IN VARCHAR2, p_status OUT varchar2)
    AS
      vSQL             VARCHAR2(4000);
      vSQLRowCount     NUMBER  := -1;
      vDebug           BOOLEAN := FALSE;
      V_ROWS_AFFECTED  PLS_INTEGER;
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN
      p_status:='COMPLETE';

        l_LogRec.mig_batch_id:=  vMigrationBatchID;
        l_LogRec.migrArea      :=   'MIGR_RULES' ;
        l_LogRec.migrStep      :=  'RUN_EXCLUSION_RULES' ;
        l_LogRec.migrRelTbl    :=   'ETL_MIGRATION_RULES';
        l_LogRec.migrRelKey  :=   NULL;

       l_LogRec.logMsg        :=     'Running Rules';
       MIGR_LOG.LOG_INFO(l_LogRec) ;

      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging - DATA RULES', 'BEGIN OF DATA RULES ', VMigrationBatchId, NULL);

      FOR cRule IN (SELECT MRT.RULE_NO,
                           (MRT.SQL_STATEMENT || CHR(39) || vMigrationBatchId || CHR(39) ||
                           ' AND ' || X.BOLAG_ID || ' IN (' || MRT.APPLICABLE_BOLAGS || ')') AS vSQL,
                           MRT.RULE_ENABLED
          FROM ETL_MIGRATION_RULES MRT,
               (SELECT BOLAG_ID
                   FROM MIG_MIGRATION_INFO MMI
                   WHERE MMI.MIGRATION_BATCH_ID = vMigrationBatchId) X
          WHERE 1 = 1
            AND MRT.SQL_STATEMENT <> 'NULL' -- Necessary for ON_HOLD rules
          --AND MRT.RULE_ENABLED = 'Y'
          ORDER BY MRT.RULE_NO ASC)
      LOOP

      << rule_loop >>

        --FA. 20160125 Fix Bug- Exception inside rule loop :if a rule fails to run continue with the rules
        -- Reset vSQLRowCount
        BEGIN
          vSQLRowCount := 0;
          vSQL := cRule.vSQL;          --- for proper Error Logging

          IF cRule.RULE_ENABLED = 'Y'
          THEN
            -- +++ anb 2015-11-11 log excluded records

           --FA.20160411 Rewrite statement without in  - Rule should  run only once and collect idpls with bulk insert -START

             vSQL := 'DECLARE  vSQLRowCount  PLS_INTEGER; CURSOR KF is   SELECT IDPL  FROM SA_KF100F ;'
                      || ' TYPE KF_tab IS TABLE OF KF%ROWTYPE; '
                      || ' KF_all_records   KF_tab:= KF_tab(); '
                      || 'BEGIN '
                      || 'SELECT IDPL BULK COLLECT INTO KF_all_records '
                      || 'FROM ( '
                      ||  cRule.vSQL
                      || '  ); '
                      || ' vSQLRowCount :=KF_all_records.COUNT;'
                      || '  FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT '
                      ||'INSERT INTO MIG_DETAIL_ERROR_LOG (MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY) '
                      || ' SELECT KF100F.MIG_BATCH_ID, SYSTIMESTAMP AS ERROR_TIMESTAMP, ''RULES'' AS MIGRATION_AREA, ''Warning'' AS ERROR_TYPE '
                      || '  , ''Record has been excluded by rule no:'' ||' || CHR(39) || cRule.RULE_NO || CHR(39) || ' AS ERROR_MESSAGE '
                      || '  , ''Rules before Intermediate Area'' AS MIGRATION_STEP '
                      || '  , ''SA_KF100F'' AS RELATED_TABLE, KF100F.IDPL  AS RELATED_KEY '
                      || ' FROM SA_KF100F KF100F '
                      || ' WHERE 1=1 AND KF100F.MIG_FLAG=0 AND KF100F.MIG_BATCH_ID =:vMigrationBatchId '
                      || '        AND KF100F.IDPL = KF_all_records(i).idpl ;'
                      || '  FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT '
                      || '    UPDATE  SA_KF100F set  MIG_FLAG = 3  WHERE idpl = KF_all_records(i).idpl AND MIG_FLAG= 0 ; '
                      || 'END; ';

                     EXECUTE IMMEDIATE vSQL USING  vMigrationBatchId;



          /*  vSQL := 'INSERT INTO MIG_DETAIL_ERROR_LOG '
            || '(MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY) '
            || ' SELECT KF100F.MIG_BATCH_ID, SYSTIMESTAMP AS ERROR_TIMESTAMP, ''RULES'' AS MIGRATION_AREA, ''Warning'' AS ERROR_TYPE '
            || '  , ''Record has been excluded by rule no:'' ||' || CHR(39) || cRule.RULE_NO || CHR(39) || ' AS ERROR_MESSAGE '
            || '  , ''Rules before Intermediate Area'' AS MIGRATION_STEP '
            || '  , ''SA_KF100F'' AS RELATED_TABLE, KF100F.IDPL  AS RELATED_KEY '
            || ' FROM SA_KF100F KF100F '
            || ' WHERE 1=1 AND KF100F.MIG_FLAG=0 AND KF100F.MIG_BATCH_ID = ' || CHR(39) || vMigrationBatchId || CHR(39)
            || '        AND KF100F.IDPL IN ( ' || cRule.vSQL || ' ) ';


            EXECUTE IMMEDIATE vSQL;       -- LOG excluded records in ERROR LOG

            -- mark records as excluded from rule
           --FA.20160411 Instead of re-execute query use rowcount
           V_ROWS_AFFECTED:=SQL%ROWCOUNT;

           --vSQL := 'select count(''c'') from (' || cRule.vSQL || ')';
           -- EXECUTE IMMEDIATE vSQL INTO v_upd;

            IF V_ROWS_AFFECTED > 0
            THEN

              vSQL := ' merge into SA_KF100F sa  using (' || cRule.vSQL || ') kf on (sa.IDPL = kf.IDPL) ' ||
              ' when matched then  update set  MIG_FLAG = 3  WHERE sa.MIG_FLAG= 0 ';

            END IF;


            L_RELATED_KEY := 'Rule No:' || cRule.RULE_NO; --- +++ anb 2015-10-01 for exception handling

            EXECUTE IMMEDIATE vSQL;

            vSQLRowCount := SQL % ROWCOUNT;
            */
            --FA.20160411 Rewrite statement without in  - Rule should  run only once and collect idpls with bulk insert -END
            -- Log the rule
            MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging - DATA RULES',
            'Rule No: ' || cRule.RULE_NO || ', Enabled: ' || cRule.RULE_ENABLED || ', Records excluded: ' || vSQLRowCount
            , VMigrationBatchId, NULL);
          END IF;
        EXCEPTION
          WHEN OTHERS THEN
               l_LogRec.logMsg        :=    SQLERRM || ' ' ||  SUBSTR(vSQL,1,1000);
               MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
               p_status:='INCOMPLETE';
        END;

      END LOOP rule_loop;
      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging - DATA RULES', 'END OF DATA RULES ', VMigrationBatchId, NULL);

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.logMsg        :=    SQLERRM || ' ' ||  vSQL;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
        p_status:='INCOMPLETE';

    END RUN_EXCLUSION_RULES;


  -------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------



/* rules applied to persons --> 1.each row of a specific KF table per migration area (e.g. CLIENT, ACC_POL_INS_PERSON, POLICY_PARTICIPANT)
                                  is scanned once, against all activated rules of the relative area (info found in ETL_MIGR_FLD_RULES).
                                2.MIG_DETAIL_ERROR_LOG is populated with violations (i.e. persons whose data have violated at least one rule and information on potential violations)
                                3.SA_KF100F.MIG_FLAG is updated to '3' for persons who have violated any of the rules  */



PROCEDURE RUN_EXCLUSION_RULES_FLD(VMigrationBatchId IN VARCHAR2, p_status OUT varchar2)
AS
 TYPE rec IS RECORD(
  idpl SA_KF100F.IDPL%TYPE,
  g_egn SA_B_PRSN.G_EGN%type,
  rules_violated VARCHAR2(2000));
 TYPE recs IS TABLE OF rec;
 all_recs recs;
 vsql VARCHAR2(3000);
 vsql1 VARCHAR2(3000);
 kf_Key VARCHAR2(200);

l_LogRec MIGR_GVAR.LogRecTyp;
begin
  p_status:='COMPLETE';

    l_LogRec.mig_batch_id:=  vMigrationBatchID;
    l_LogRec.migrArea      :=   'MIGR_RULES' ;
    l_LogRec.migrStep      :=  'RUN_EXCLUSION_RULES_FLD' ;
    l_LogRec.migrRelTbl    :=   'ETL_MIGR_FLD_RULES';
    l_LogRec.migrRelKey  :=   NULL;

     l_LogRec.logMsg        :=     'Running FLD Rules';
     MIGR_LOG.LOG_INFO(l_LogRec) ;


  MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging - DATA RULES', 'BEGIN OF DATA FLD RULES ', VMigrationBatchId, NULL);
  for c IN (select distinct migr_area
            from ETL_MIGR_FLD_RULES
            WHERE is_active='Y'
  )
  loop
     vsql:='''||''';
     FOR c1 IN (select *
               from ETL_MIGR_FLD_RULES
               WHERE 1=1
                  AND MIGR_AREA=c.migr_area
                  AND  is_active='Y'
     )
     LOOp
         vsql:= vsql || '||(case when ' || c1.sql_stmt || ' then ''' || c1.RULE_NAME || '''||''||'' else null end)';

     END LOOP;

     for c2 in (SELECT DISTINCT migr_area,rule_table,related_key
                FROM ETL_MIGR_FLD_RULES
                WHERE 1=1
                  and MIGR_AREA=c.MIGR_AREA
                  AND  is_active='Y')
     loop
         kf_Key:=c2.RELATED_KEY;

         vsql1:= ' with cte as (select kf.idpl, prsn.g_egn,(case when prsn.g_egn is null then ''person not in sa_b_prsn'' else (' || vsql || ') end) as rules_violated '
                     || ' from sa_b_prsn prsn right join ' || c2.RULE_TABLE || ' kf on prsn.g_egn= ' || kf_Key
                     || ' where 1=1'
                   --  || '   and prsn.mig_batch_id=  :1'
                     || '   and kf.mig_batch_id = :1 )'
              || ' select distinct cte.idpl,cte.g_egn,cte.rules_violated'
              || ' from cte where 1=1'
              || '   and (g_egn is null or (g_egn is not null and cte.rules_violated<>''||''))';  --valex.13/3/17 if a policy does not violate any rule, then rules_violated='||'
         --  dbms_output.PUT_LINE(v1);
         EXECUTE immediate vsql1
           bulk COLLECT INTO all_recs using VMigrationBatchId;
      --  dbms_output.PUT_LINE(all_recs(1).idpl ||' ' || all_recs(1).g_egn || ' ' || all_recs(1).rules_violated);
       --dbms_output.PUT_LINE(all_recs.COUNT);


         FORALL i IN all_recs.FIRST..all_recs.COUNT
         INSERT INTO MIG_DETAIL_ERROR_LOG (MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY)
         SELECT  VMigrationBatchId , SYSTIMESTAMP AS ERROR_TIMESTAMP, 'RULES' AS MIGRATION_AREA, 'Warning' AS ERROR_TYPE
         ,'Record has been excluded by rules: ' || all_recs(i).rules_violated  AS ERROR_MESSAGE
         ,'Rules before Intermediate Area' AS MIGRATION_STEP
         , c2.rule_table  AS RELATED_TABLE, all_recs(i).idpl  AS RELATED_KEY
         FROM dual;

         FORALL i in all_recs.FIRST .. all_recs.COUNT
         EXECUTE IMMEDIATE 'UPDATE  SA_KF100F set  MIG_FLAG = 3  WHERE idpl = :1 AND MIG_FLAG= 0'
         USING all_recs(i).idpl;
     END LOOP;

   END LOOP;



EXCEPTION
    WHEN OTHERS THEN
         l_LogRec.logMsg        :=    SQLERRM || ' ' ||  vSQL1;
         MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
         p_status:='INCOMPLETE';

end RUN_EXCLUSION_RULES_FLD;
  -------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------

--20161101 - LM - Use sa_b_prsn table instead
 ---- new procedure 20160318 FA - Covert mig source data
 -------------------------------------------------------------------------------------------------------------
/*  PROCEDURE CONVERT_MIG_SRC_DATA(VMigrationBatchId IN VARCHAR2, p_status OUT varchar2)
    AS
      vSQL             VARCHAR2(4000);
      vSQLRowCount     NUMBER  := -1;
      vDebug           BOOLEAN := FALSE;
      L_ERRMSG         SRVERRMSG;
      L_SRVERRMSG      SRVERRMSG;
      PIO_ERR          SRVERR;
      v_upd            PLS_INTEGER;
      L_MIGRATION_AREA VARCHAR2(50);
      L_MIGRATION_STEP VARCHAR2(256);
      L_ERROR_TYPE     VARCHAR2(50);
      L_ERROR_MESSAGE  VARCHAR2(256);
      L_RELATED_TABLE  MIGR_API_DETAIL_LOG.RELATED_TABLE % TYPE;     --VARCHAR2(2000);
      L_RELATED_KEY    MIGR_API_DETAIL_LOG.RELATED_KEY % TYPE;        --;VARCHAR2(2000);

    BEGIN
      p_status:='COMPLETE';
      L_MIGRATION_AREA := 'MIGR_RULES';

      L_ERROR_TYPE := 'Information';
      L_ERROR_MESSAGE := NULL;
      L_RELATED_KEY := NULL;
      L_RELATED_TABLE := NULL;




      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging - CONVERT DATA RULES', 'BEGIN OF CONVERT SOURCE DATA RULES ', VMigrationBatchId, NULL);

      FOR cRule IN (SELECT MRT.RULE_NO,
                           (MRT.SQL_STATEMENT || CHR(39) || vMigrationBatchId || CHR(39) ||
                           ' AND ' || X.BOLAG_ID || ' IN (' || MRT.APPLICABLE_BOLAGS || ')') AS vSQL,
                           MRT.RULE_ENABLED
          FROM ETL_CONVERSION_RULES MRT,
               (SELECT BOLAG_ID
                   FROM MIG_MIGRATION_INFO MMI
                   WHERE MMI.MIGRATION_BATCH_ID = vMigrationBatchId) X
          WHERE 1 = 1
            AND MRT.SQL_STATEMENT <> 'NULL' -- Necessary for ON_HOLD rules
          --AND MRT.RULE_ENABLED = 'Y'
          ORDER BY MRT.RULE_NO ASC)
      LOOP

      << rule_loop >>


        -- Reset vSQLRowCount
        BEGIN
          vSQLRowCount := 0;
          vSQL := cRule.vSQL;          --- for proper Error Logging

          IF cRule.RULE_ENABLED = 'Y'
          THEN

            -- convert data as described  from rule

            EXECUTE IMMEDIATE vSQL ;

            L_RELATED_KEY := 'Convert Rule No:' || cRule.RULE_NO; --- +++ anb 2015-10-01 for exception handling



            vSQLRowCount := SQL % ROWCOUNT;

            -- Log the rule
            MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging - Data Convertion RULES',
            'Rule No: ' || cRule.RULE_NO || ', Enabled: ' || cRule.RULE_ENABLED || ', Records converted: ' || vSQLRowCount
            , VMigrationBatchId, NULL);
          END IF;
        EXCEPTION
          WHEN OTHERS THEN

            p_status:='INCOMPLETE';
        END;

      END LOOP rule_loop;
      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging - CONVERT DATA RULES', 'END OF CONVERT DATA RULES ', VMigrationBatchId, NULL);

    EXCEPTION
      WHEN OTHERS THEN

        p_status:='INCOMPLETE';

    END CONVERT_MIG_SRC_DATA;

*/
--20161101 - LM - Use sa_b_prsn table instead



  -----------------------------------------------------------------------------------------------------------------


  --FA. 20151109  update all sa_ tables

  PROCEDURE UPDATE_SA_TABLES(p_MigrationId IN VARCHAR2,
                             vSTEP_AREA    IN VARCHAR2,
                              p_status OUT varchar2)
    AS
      l_LogRec MIGR_GVAR.LogRecTyp;
      L_SRVERRMSG SRVERRMSG;
      l_file_name VARCHAR2(50);
      vSQL        VARCHAR(2100);
      l_STEP_AREA VARCHAR2(150);

      CURSOR fetch_file_names IS
          SELECT DISTINCT (etd.TBLNAME)
            FROM ETL_TBL_DEF etd
            WHERE NVL(etd.IS_ACTIVE, 'N') = 'Y'
             AND sa='Y'
--            AND FILE_ROLE<>'Derived'  ;   --valex 2/6/16. skip SA_B_PRSN
             AND FILE_ROLE NOT IN ('Derived' , 'Discounts') ;   --valex.3/1/2017 - skip also discounts.txt


    BEGIN
      p_status:='COMPLETE';

      l_STEP_AREA := vSTEP_AREA || '-UPDATE_SA_TABLES';

      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_STEP_AREA, 'Begin Update_SA_Tables ', p_MigrationId, NULL);

      OPEN fetch_file_names;
      LOOP
        FETCH fetch_file_names INTO l_file_name;
        EXIT WHEN fetch_file_names % NOTFOUND;
        ---FA. 20151118 Must be improved slow performance - Use merge instead
        /*   vSQL :=  'UPDATE  SA_'||  l_file_name || ' t1 SET MIG_FLAG = '
                                 || '(SELECT t2.MIG_FLAG FROM SA_KF100F t2 '
                                 || ' WHERE t1.idPL = t2.IDPL  and MIG_BATCH_ID=' || CHR(39) || p_MigrationId ||CHR(39)|| ') '
                 || ' WHERE EXISTS ( SELECT 1  FROM SA_KF100F t2 WHERE t1.idPL = t2.idPL AND MIG_BATCH_ID=' ||CHR(39)|| p_MigrationId|| CHR(39)
                 ||             ') and  NVL(t1.MIG_FLAG,0)= 0 ';*/


        vSQL := 'MERGE INTO  SA_' || l_file_name || ' t '
        || '   USING (SELECT MIG_FLAG ,IDPL ,MIG_BATCH_ID from SA_KF100F ) ext
                ON (ext.IDPL=t.idPL AND ext.MIG_BATCH_ID=  ' || CHR(39) || p_MigrationId || CHR(39) || ') '

        || ' WHEN MATCHED THEN UPDATE set t.MIG_FLAG=ext.MIG_FLAG '
        || ' WHERE NVL(t.MIG_FLAG,0)= 0 ';


        EXECUTE IMMEDIATE vSQL;

      END LOOP;
      CLOSE fetch_file_names;

      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_STEP_AREA, 'End Update_SA_Tables ', p_MigrationId, NULL);

    EXCEPTION
      WHEN OTHERS THEN
         l_LogRec.logMsg        :=    SQLERRM || ' ' ||  vSQL;
         MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
         p_status:='INCOMPLETE';

    END UPDATE_SA_TABLES;


  -------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------


--  PROCEDURE RUN_RULES(vMigrationBatchId IN VARCHAR2)
--    AS
--      vRunRules BOOLEAN;
--    BEGIN
--      -- +++ anb 2015-10-20   mark SA_KF100F records with appropriate Insurance Product code
--      MIGR_RULES.MARK_PRODUCTS(vMigrationBatchId);
--
--      vRunRules := TRUE;
--      --- apply rules and exclude non-compliant records
--      IF vRunRules = TRUE
--      THEN
--
--        --FA. 20160318 Added new step to transform source data e.g. length penr between 7 and 1- left padded with zeros
--        CONVERT_MIG_SRC_DATA(vMigrationBatchId);
--
--        MIGR_RULES.RUN_EXCLUDE_PRODUCTS(vMigrationBatchId);       --- +++ anb 2015-10-08
--        MIGR_RULES.RUN_EXCLUSION_RULES(vMigrationBatchId);
--        MIGR_RULES.RUN_EXCLUSION_RULES_FLD(vMigrationBatchId);    ---valex.30/6/2016 penr-related field rules
--
--
--      END IF;
--
--      UPDATE_SA_TABLES(vMigrationBatchId, 'Staging - DATA RULES');
--
--    END RUN_RULES;

--- legacy end of procedure
-----END DYNAMIC_RULES_EXEC_TST;
-------------------------------------------------------------------------------------------------------------


  -------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------


  PROCEDURE RUN_RULES(vMigrationBatchId IN VARCHAR2, Rules_Status  OUT VARCHAR2)
    AS
      vRunRules BOOLEAN;
    BEGIN
      Rules_Status := 'COMPLETE';

      -- +++ anb 2015-10-20   mark SA_KF100F records with appropriate Insurance Product code
      MIGR_RULES.MARK_PRODUCTS(vMigrationBatchId, Rules_Status);

      -- pl 20161031 mark SA_KF100F records with appropriate Insurance Offering code
      MIGR_RULES.MARK_OFFERINGS(vMigrationBatchId, Rules_Status);

      vRunRules := TRUE;
      --- apply rules and exclude non-compliant records
      IF vRunRules = TRUE
      THEN
      --20161101 - LM - Use sa_b_prsn table instead
        --FA. 20160318 Added new step to transform source data e.g. length penr between 7 and 1- left padded with zeros
--        if Rules_Status = 'COMPLETE' then
--          CONVERT_MIG_SRC_DATA(vMigrationBatchId, Rules_Status);
--        END IF;
      --20161101 - LM - Use sa_b_prsn table instead
        if Rules_Status = 'COMPLETE' then
          MIGR_RULES.RUN_EXCLUDE_PRODUCTS(vMigrationBatchId, Rules_Status);       --- +++ anb 2015-10-08
        END IF;
        if Rules_Status = 'COMPLETE' then
          MIGR_RULES.RUN_EXCLUSION_RULES(vMigrationBatchId, Rules_Status);
        END IF;
        if Rules_Status = 'COMPLETE' then
          MIGR_RULES.RUN_EXCLUSION_RULES_FLD(vMigrationBatchId, Rules_Status);    ---valex.30/6/2016 penr-related field rules
        END IF;

       --valex.14/3/2017 - Rejected policies will be inserted in MIGR_FAILED_POLICY
        FOR c IN (select POLICY_REF,  MIG_BATCH_ID, IDPL, INSRPRD,OFFRNCODE
                  FROM SA_KF100F
                  WHERE MIG_FLAG = 3
                   and MIG_BATCH_ID=VMigrationBatchId)
        LOOP
           INSERT INTO MIGR_FAILED_POLICY (
             POLICY_REF, POLICY_STEP, INS_DATE, INS_MS, MIG_START, MIG_END, MIG_BATCH_ID, POLICY_IDPL, CLIENT_ID, AGENT_ID, INSRPRD, ERROR_MESSAGE ,OFFRNCODE
           )
           VALUES (c.POLICY_REF, null, SYSDATE, null, null, null, c.MIG_BATCH_ID, c.IDPL, null, null, C.INSRPRD, 'Policy was rejected in MIGR_RULES area ', c.OFFRNCODE);

        END LOOP;


      END IF;

      if Rules_Status = 'COMPLETE' then
        UPDATE_SA_TABLES(vMigrationBatchId, 'Staging - DATA RULES', Rules_Status);
      END IF;

      IF Rules_Status = 'COMPLETE' THEN
        UPDATE MIG_MIGRATION_INFO mmi SET mmi.RULES_COMPLETED='Finished' WHERE  mmi.MIGRATION_BATCH_ID=vMigrationBatchId;
      ELSE
        UPDATE MIG_MIGRATION_INFO mmi SET mmi.RULES_COMPLETED='Failed' WHERE  mmi.MIGRATION_BATCH_ID=vMigrationBatchId;
      END IF;

    EXCEPTION
      WHEN others THEN
        Rules_Status := 'INCOMPLETE';
        UPDATE MIG_MIGRATION_INFO mmi SET mmi.RULES_COMPLETED='Failed' WHERE  mmi.MIGRATION_BATCH_ID=vMigrationBatchId;

    END RUN_RULES;

--- legacy end of procedure
-----END DYNAMIC_RULES_EXEC_TST;
-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
--FA. Exclude objects  from intermediate area by updating temp mig_flag to 3  according to ETL_OBJ_EXCLUSION_RULES
PROCEDURE RUN_OBJ_EXCLUSION_RULES
AS
        v_sql     VARCHAR2(2000);
       TYPE sql_rec IS RECORD (
         OBJECT_ID NVARCHAR2(294) ,
        idpl VARCHAR2(200),
        mig_batch_id VARCHAR2(200) );

        TYPE t_sql_type_tab IS TABLE OF sql_rec;
        v_sql_tab          t_sql_type_tab;

BEGIN

      FOR c IN (SELECT eoer.APPLICABLE_BOLAGS,
                       eoer.OFFRNCODE,
                       eoer.UPD_TABLE,
                       eoer.OBJECT_TYPE,
                       eoer.RULE_NO
          FROM ETL_OBJ_EXCLUSION_RULES eoer
          WHERE 1 = 1
            AND IS_ACTIVE = 'Y')
      LOOP

      v_sql := ' SELECT  t1.ia_object_id , t2.idpl, t1.mig_batch_id  FROM     ' ||  c.UPD_TABLE || '  t1  JOIN    SA_KF100F  t2  ON      t1.ia_idpl  = t2.idpl
                     WHERE     '',''|| '''|| c.OFFRNCODE ||   '''||  '','' like ''%,'' ||  t2.OFFRNCODE || '',%''  and     '','' ||''' || c.OBJECT_TYPE|| '''||  '','' like ''%,'' ||  t1.IA_OBJECT_TYPE || '',%'' ';

      EXECUTE IMMEDIATE V_SQL   BULK COLLECT INTO v_sql_tab ;

      FORALL i IN v_sql_tab.FIRST .. v_sql_tab.COUNT
          INSERT INTO MIG_DETAIL_ERROR_LOG (MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY  )
            SELECT    v_sql_tab(i).mig_batch_id,SYSTIMESTAMP AS ERROR_TIMESTAMP,  'OBJECT EXCLUSION RULES' AS MIGRATION_AREA,  'Information' AS ERROR_TYPE,
                   'Object has been excluded by rules: ' || c.RULE_NO AS ERROR_MESSAGE,  'Object Exclusion Rules before Intermediate Area' AS MIGRATION_STEP,  c.UPD_TABLE AS RELATED_TABLE,
                v_sql_tab(i).object_id  AS RELATED_KEY
              FROM DUAL;

      FORALL i IN v_sql_tab.FIRST .. v_sql_tab.COUNT
          EXECUTE IMMEDIATE 'UPDATE ' ||  c.UPD_TABLE   || ' set  MIG_FLAG = 3  WHERE ia_object_id = :2  AND MIG_FLAG= 0'
          USING   v_sql_tab(i).object_id;
      END LOOP;

    END;
 -------------------------------------------------------------------------------------------------------------------------------------
 -------------------------------------------------------------------------------------------------------------------------------------
 -- pl 20161110: RUN_COVER_UPDATE_RULES
  PROCEDURE RUN_COVER_UPDATE_RULES (p_migrBatchId IN VARCHAR2)
    AS
      l_log_rec  MIGR_GVAR.LogRecTyp;
      vSQL       VARCHAR2(4000);

  BEGIN
      l_log_rec.mig_batch_id := p_migrBatchId;
      l_log_rec.migrArea     := 'MIGR_RULES.RUN_COVER_UPDATE_RULES';
      l_log_rec.migrRelTbl   := '';


      l_Log_Rec.logMsg := 'Start: Update covers and insured values step';
      MIGR_LOG.LOG_INFO(l_Log_Rec);

      FOR cREC IN ( SELECT *
                      FROM ETL_COVER_UPDATE_RULES RL
                      JOIN ETL_IA_INSRPRD_CONFIG CF
                        ON RL.INSIS_PRODUCT1=CF.INSR_TYPE
                     WHERE 1=1
                       AND NVL(RL.IS_ACTIVE, 'N') = 'Y'
                       AND REGEXP_LIKE(',' || RL.APPLICABLE_BOLAGS || ',', ',' || SUBSTR(p_migrBatchId, 1, 2) || ',')
      )
      LOOP

            FOR tREC IN ( SELECT *
                            FROM IA_POLICY IA
                           WHERE 1=1
                             AND IA.MIG_BATCH_ID = p_migrBatchId
                             AND REGEXP_LIKE(',' || cREC.OFFRNCODE || ',', ',' || IA.IA_INSR_TYPE || ',')
            )
            LOOP

                  -- If new cover id is not null
                  IF NOT cREC.COVER_ID_NEW IS NULL THEN

                        BEGIN
                            vSQL := 'UPDATE ' || cREC.IA_COVER_TBL || ' dest SET dest.IA_COVER = ''' || cREC.COVER_ID_NEW || ''' WHERE dest.IA_COVER = ''' || cREC.COVER_ID_OLD || ''' AND dest.IA_IDPL = ' || tREC.IA_IDPL;
                            EXECUTE IMMEDIATE vSQL;

                            -- If new insured value is null
                            IF cREC.INS_VAL_NEW IS NULL THEN
                                vSQL := 'UPDATE ' || cREC.IA_COVER_VALUES_TBL || ' dest SET dest.IA_INSURED_VALUE = NULL, dest.IA_COVER = ''' || cREC.COVER_ID_NEW || ''' WHERE dest.IA_COVER = ''' || cREC.COVER_ID_OLD || ''' AND dest.IA_IDPL = ' || tREC.IA_IDPL;
                                EXECUTE IMMEDIATE vSQL;

                            -- If new insured value is not null
                            ELSE
                                vSQL := 'UPDATE ' || cREC.IA_COVER_VALUES_TBL || ' dest SET dest.IA_INSURED_VALUE = ' || cREC.INS_VAL_NEW || ', dest.IA_COVER = ''' || cREC.COVER_ID_NEW || ''' WHERE dest.IA_COVER = ''' || cREC.COVER_ID_OLD || ''' AND dest.IA_IDPL = ' || tREC.IA_IDPL;
                                EXECUTE IMMEDIATE vSQL;

                            END IF;

                        EXCEPTION
                            WHEN OTHERS THEN
                                l_Log_Rec.logMsg := SQLERRM; l_log_rec.migrRelTbl := vSQL; MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);
                        END;

                  -- If new cover id is null
                  ELSE

                        BEGIN
                            -- If new insured value is null
                            IF cREC.INS_VAL_NEW IS NULL THEN
                                vSQL := 'UPDATE ' || cREC.IA_COVER_VALUES_TBL || ' dest SET dest.IA_INSURED_VALUE = NULL WHERE dest.IA_COVER = ''' || cREC.COVER_ID_OLD || ''' AND dest.IA_IDPL = ' || tREC.IA_IDPL;
                                EXECUTE IMMEDIATE vSQL;

                            -- If new insured value is not null
                            ELSE
                                vSQL := 'UPDATE ' || cREC.IA_COVER_VALUES_TBL || ' dest SET dest.IA_INSURED_VALUE = ' || cREC.INS_VAL_NEW || ' WHERE dest.IA_COVER = ''' || cREC.COVER_ID_OLD || ''' AND dest.IA_IDPL = ' || tREC.IA_IDPL;
                                EXECUTE IMMEDIATE vSQL;

                            END IF;

                        EXCEPTION
                            WHEN OTHERS THEN
                                l_Log_Rec.logMsg := SQLERRM; l_log_rec.migrRelTbl := vSQL; MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);
                        END;

                  END IF;

            END LOOP;

      END LOOP;

      COMMIT;

      l_Log_Rec.logMsg := 'End: Update covers and insured values step';
      MIGR_LOG.LOG_INFO(l_Log_Rec);


  EXCEPTION
      WHEN OTHERS THEN
            l_Log_Rec.logMsg := SQLERRM; l_log_rec.migrRelTbl := vSQL; MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);

  END RUN_COVER_UPDATE_RULES;

 -------------------------------------------------------------------------------------------------------------------------------------
 -------------------------------------------------------------------------------------------------------------------------------------

 -------------------------------------------------------------------------------------------------------------------------------------
 -------------------------------------------------------------------------------------------------------------------------------------
 -- pl 20170516: UPDATE_COVER_ON_DEDUCT_RULES
  PROCEDURE UPDATE_COVER_ON_DEDUCT_RULES (p_migrBatchId IN VARCHAR2)
    AS
      l_log_rec  MIGR_GVAR.LogRecTyp;
      vSQL       VARCHAR2(4000);

  BEGIN
      l_log_rec.mig_batch_id := p_migrBatchId;
      l_log_rec.migrArea     := 'MIGR_RULES.UPDATE_COVER_ON_DEDUCT_RULES';
      l_log_rec.migrRelTbl   := '';

--      l_Log_Rec.logMsg := 'Start: Update ia_cover on deductible tables';
--      MIGR_LOG.LOG_INFO(l_Log_Rec);

      FOR cREC IN ( SELECT *
                      FROM ETL_COVER_UPDATE_RULES RL
                      JOIN ETL_IA_INSRPRD_CONFIG CF
                        ON RL.INSIS_PRODUCT1=CF.INSR_TYPE
                     WHERE 1=1
                       AND NVL(RL.IS_ACTIVE, 'N') = 'Y'
                       AND REGEXP_LIKE(',' || RL.APPLICABLE_BOLAGS || ',', ',' || SUBSTR(p_migrBatchId, 1, 2) || ',')
      )
      LOOP
            FOR tREC IN ( SELECT *
                            FROM IA_POLICY IA
                           WHERE 1=1
                             AND IA.MIG_BATCH_ID = p_migrBatchId
                             AND REGEXP_LIKE(',' || cREC.OFFRNCODE || ',', ',' || IA.IA_INSR_TYPE || ',')
            )
            LOOP
                  -- If new cover id is not null
                  IF NOT cREC.COVER_ID_NEW IS NULL THEN
                        BEGIN
                            vSQL := 'UPDATE ' || cREC.IA_DEDUCTIBLES_TBL || ' dest SET dest.IA_COVER = ''' || cREC.COVER_ID_NEW ||
                                    ''' WHERE dest.IA_COVER = ''' || cREC.COVER_ID_OLD || ''' AND dest.IA_IDPL = ' || tREC.IA_IDPL;

                            EXECUTE IMMEDIATE vSQL;

                        EXCEPTION
                            WHEN OTHERS THEN
                                l_Log_Rec.logMsg := SQLERRM || '-' || vSQL; l_log_rec.migrRelTbl := vSQL; MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);
                        END;

                  END IF;

            END LOOP;

      END LOOP;

      COMMIT;

--      l_Log_Rec.logMsg := 'End: Update ia_cover on deductable tables';
--      MIGR_LOG.LOG_INFO(l_Log_Rec);


  EXCEPTION
      WHEN OTHERS THEN
            l_Log_Rec.logMsg := SQLERRM || '-' || vSQL; l_log_rec.migrRelTbl := vSQL; MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);

  END UPDATE_COVER_ON_DEDUCT_RULES;

 -------------------------------------------------------------------------------------------------------------------------------------
 -------------------------------------------------------------------------------------------------------------------------------------

-- LM - 04-12-2017 - Procedure for translating according to the language of the user.
-- Update IA_NAME field in each IA object table with the value retrieved from INSIS_GEN_CFG_V10.SYSCFG_TRANSLATIONS table.

  PROCEDURE RUN_TRANSLATION_RULES (p_migrBatchId IN VARCHAR2)
  AS
      l_log_rec  MIGR_GVAR.LogRecTyp;
      vSQL       VARCHAR2(32000);
      v_count    NUMBER;
      v_language VARCHAR2(50);

  BEGIN

    l_log_rec.mig_batch_id := p_migrBatchId;
    l_log_rec.migrArea     := 'MIGR_RULES.RUN_TRANSLATION_RULES';
    l_log_rec.migrRelTbl   := '';


    l_Log_Rec.logMsg := 'Start: Update translation values step';
    MIGR_LOG.LOG_INFO(l_Log_Rec);

    SELECT COUNT(DISTINCT pua.LANGUAGE)
      INTO v_count
      FROM INSIS_PEOPLE_V10.P_USER_ACCOUNTS pua
     WHERE 1 = 1
       AND pua.USER_NAME IN (SELECT ebi.BOLAG_USERNAME FROM ETL_BOLAG_INFO ebi);

    IF v_count = 1 THEN
      SELECT DISTINCT pua.LANGUAGE
        INTO v_language
        FROM INSIS_PEOPLE_V10.P_USER_ACCOUNTS pua
       WHERE 1 = 1
         AND pua.USER_NAME IN (SELECT ebi.BOLAG_USERNAME FROM ETL_BOLAG_INFO ebi);


      FOR c IN (SELECT * FROM ETL_PRODUCT_OBJECTS tpo
                 WHERE tpo.IS_ACTIVE = 'Y'
                 ORDER BY tpo.PRODUCT_CODE, tpo.OBJECT_TYPE
      )
      LOOP

        vSQL := 'UPDATE ' || c.IA_OBJ_TABLE || ' dest ' ||
                ' SET dest.IA_NAME = (SELECT  st.DESCRIPTION || ''(' || c.object_type || '.1.1)''' ||
                     ' FROM INSIS_GEN_CFG_V10.SYSCFG_TRANSLATIONS st ' ||
                     ' JOIN INSIS_GEN_CFG_V10.CPRS_OBJECT_SUBT a ON TO_CHAR(a.OBJECT_TYPE_CPR_ID) = st.ID ' ||
                     ' WHERE st.language = ''' || v_language || ''' AND a.OBJECT_SUB_TYPE = ''' || c.object_type || '.1.1''' ||
                     ' AND st.TABLE_NAME = ''CPRS_OBJECT_SUBT'')' ||
                ' WHERE 1 = 1 AND dest.IA_NAME like ''%(' || c.object_type || '.1.1)''' ;

       EXECUTE IMMEDIATE vSQL;

      END LOOP;

    ELSE
      FOR c1 IN (SELECT DISTINCT pua.LANGUAGE, ebi.BOLAG_ID
                   FROM INSIS_PEOPLE_V10.P_USER_ACCOUNTS pua
                   JOIN ETL_BOLAG_INFO ebi ON pua.USER_NAME = ebi.BOLAG_USERNAME
                 )
      LOOP

        FOR c IN (SELECT * FROM ETL_PRODUCT_OBJECTS tpo
                   WHERE tpo.IS_ACTIVE = 'Y'
                   ORDER BY tpo.PRODUCT_CODE, tpo.OBJECT_TYPE
        )
        LOOP

        vSQL := 'UPDATE ' || c.IA_OBJ_TABLE || ' dest ' ||
                ' SET dest.IA_NAME = (SELECT  st.DESCRIPTION || ''(' || c.object_type || '.1.1)''' ||
                     ' FROM INSIS_GEN_CFG_V10.SYSCFG_TRANSLATIONS st ' ||
                     ' JOIN INSIS_GEN_CFG_V10.CPRS_OBJECT_SUBT a ON TO_CHAR(a.OBJECT_TYPE_CPR_ID) = st.ID ' ||
                     ' WHERE st.language = ''' || c1.LANGUAGE || ''' AND a.OBJECT_SUB_TYPE = ''' || c.object_type || '.1.1''' ||
                     ' AND st.TABLE_NAME = ''CPRS_OBJECT_SUBT'')' ||
                ' WHERE 1 = 1 AND dest.IA_NAME like ''%(' || c.object_type || '.1.1)''' ||
                ' AND dest.MIG_MUTUAL_ID = ''' || TO_CHAR(c1.BOLAG_ID) || '''' ;

          EXECUTE IMMEDIATE vSQL;

        END LOOP;
      END LOOP;
    END IF;

    COMMIT;

    l_Log_Rec.logMsg := 'End: Update translation values step';
    MIGR_LOG.LOG_INFO(l_Log_Rec);

    EXCEPTION
       WHEN OTHERS THEN
         l_Log_Rec.logMsg := SQLERRM; l_log_rec.migrRelTbl := vSQL; MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);

  END RUN_TRANSLATION_RULES;
-- LM - 04-12-2017 - end
 -------------------------------------------------------------------------------------------------------------------------------------

-- LM - 17-01-2018 - Apply rules from HST_OUTHOUSE_LABELS in case unmapped outhouse labels are found - START
  PROCEDURE UPDATE_MAP_OUTHOUSE_LABEL (p_migrBatchId IN VARCHAR2)
  AS
      l_log_rec   MIGR_GVAR.LogRecTyp;
      v_key       VARCHAR(1);
      v_count     NUMBER;
      l_cur_sql   VARCHAR2(2000);
      VSQL        VARCHAR2(2000);
      VSQL1       VARCHAR2(2000);
      VSQL2       VARCHAR2(2000);
      VSQL3       VARCHAR2(2000);
      VSQL4       VARCHAR2(2000);
      l_INSIS_KEY VARCHAR2(50);
      TYPE  t_bulk_collect IS TABLE OF varchar2(30);
      l_label    t_bulk_collect;
      l_INSIS_CODE NUMBER;

  BEGIN

    l_log_rec.mig_batch_id := p_migrBatchId;
    l_log_rec.migrArea     := 'MIGR_RULES.UPDATE_MAP_OUTHOUSE_LABEL';
    l_log_rec.migrRelTbl   := '';
    l_Log_Rec.logMsg := 'Start: Update null outhouse labels step';
    MIGR_LOG.LOG_INFO(l_Log_Rec);

    FOR ctab IN (SELECT IA_OBJ_TABLE , INSRPRD
                   FROM ETL_PRODUCT_OBJECTS
                  WHERE HAS_OUTHOUSE_LABEL = 'Y'
                 )
    LOOP

      l_cur_sql := 'SELECT DISTINCT IA_BENNG FROM ' || ctab.IA_OBJ_TABLE || ' a WHERE a.IA_OUTHOUSE_LABEL IS NULL AND MIG_BATCH_ID = ''' || p_migrBatchId || '''';

      EXECUTE IMMEDIATE l_cur_sql
        BULK COLLECT INTO l_label;

      FOR i in 1 .. l_label.count
      LOOP

        << KEY_LOOP >>
        FOR c1 IN (SELECT MIG_KEY,
                         REGULAR_EXP,
                         PRIORITY,
                         INSIS_CODE,
                         INSIS_KEY
            FROM HST_OUTHOUSE_LABELS
            WHERE PRIORITY <> 0
            AND INSRPRD = '' || ctab.INSRPRD || ''
            ORDER BY PRIORITY ASC)
        LOOP

          VSQL := ' SELECT case WHEN  REGEXP_LIKE(' || q'[']' ||REGEXP_REPLACE(l_label(i),'''','') || q'[']' || ',' || c1.REGULAR_EXP || ') THEN ' || q'[']' || 'Y' || q'[']' || ' ELSE ' || q'[']' || 'N' || q'[']' || ' end   from DUAL';
          EXECUTE IMMEDIATE VSQL
          INTO v_key;

          l_INSIS_KEY := c1.INSIS_KEY;

          IF v_key = 'Y'
          THEN
            VSQL1 := 'SELECT H.INSIS_CODE FROM HST_OUTHOUSE_LABELS H WHERE H.INSIS_KEY = ''' || c1.INSIS_KEY || ''' AND H.INSRPRD = ''' || ctab.INSRPRD || '''' ;
            EXECUTE IMMEDIATE VSQL1 INTO l_INSIS_CODE;
            EXIT KEY_LOOP;
          END IF;
        END LOOP;

        IF v_key = 'N' THEN
          l_INSIS_KEY := 'Other';
          VSQL2 := 'SELECT H.INSIS_CODE FROM HST_OUTHOUSE_LABELS H WHERE H.INSIS_KEY = ''' || l_INSIS_KEY || ''' AND H.INSRPRD = ''' || ctab.INSRPRD || '''' ;
          EXECUTE IMMEDIATE VSQL2 INTO l_INSIS_CODE;
        END IF;

        VSQL3 := 'UPDATE ' || ctab.IA_OBJ_TABLE ||
                 ' SET IA_OUTHOUSE_LABEL = ' || l_INSIS_CODE ||
                 ', IA_OUTHOUSE_LABEL_OTHER = (CASE WHEN ''' || l_INSIS_KEY || ''' = ''Other'' THEN ''' || l_label(i) || ''' ELSE NULL END ) ' ||
                 ' WHERE IA_BENNG = ''' || l_label(i) || ''' AND IA_OUTHOUSE_LABEL IS NULL' ;
        EXECUTE IMMEDIATE VSQL3;

        SELECT COUNT(1) INTO v_count FROM ETL_OUTHOUSE_LABELS_MAP WHERE UPPER(LABEL) = l_label(i);

        IF v_count = 0 THEN
          VSQL4 := 'INSERT INTO ETL_OUTHOUSE_LABELS_MAP VALUES (''' || l_label(i) || ''',''' || l_INSIS_KEY || ''')' ;
          EXECUTE IMMEDIATE VSQL4;
        END IF;

      END LOOP;
    END LOOP;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN MIGR_LOG.LOG_EXCEPTION('0-0', 'UPDATE_MAP_OUTHOUSE_LABEL', 'UPDATE_MAP_OUTHOUSE_LABEL', SQLERRM, '', '');

  END UPDATE_MAP_OUTHOUSE_LABEL;
-- LM - 17-01-2018 - END

-------------------------------------------------------------------------------------------------------------------------------------

-- LM - 12-02-2018 - Update IA_DESCRIPTION for Specified Items when there are additional records with KF208F.FBLKR = 0.
-- Skip entries where there are more than one objects created and cannot identify with which one to link the description - START
  PROCEDURE UPDATE_SPECIFIED_DESCRIPTION (p_migrBatchId IN VARCHAR2)
  AS
      l_log_rec   MIGR_GVAR.LogRecTyp;
      v_count     NUMBER;
      l_err        NUMBER;
      l_cur_sql   VARCHAR2(32000);
      VSQL        VARCHAR2(32000);
      VSQL1       VARCHAR2(32000);
      l_obj_id    VARCHAR2(300);
      l_ia_descr  VARCHAR2(2000);
      l_descr     VARCHAR2(2000);
      TYPE  t_bulk_collect IS TABLE OF number;
      l_idplps    t_bulk_collect;
      l_idpl      t_bulk_collect;
      l_psonr     t_bulk_collect;

  BEGIN

    l_log_rec.mig_batch_id := p_migrBatchId;
    l_log_rec.migrArea     := 'MIGR_RULES.UPDATE_SPECIFIED_DESCRIPTION';
    l_log_rec.migrRelTbl   := '';
    l_Log_Rec.logMsg := 'Start: Update description  step';
    MIGR_LOG.LOG_INFO(l_Log_Rec);

    FOR ctab IN (SELECT epo.IA_OBJ_TABLE
                   FROM ETL_PRODUCT_OBJECTS epo
                  WHERE epo.HAS_SPECIFIED = 'Y'
                    AND epo.IS_ACTIVE = 'Y'
                 )
    LOOP

      l_cur_sql := 'SELECT DISTINCT KF208F.IDPLPS, KF208F.IDPL, KF208F.PSONR FROM ' || ctab.IA_OBJ_TABLE || ' ivso '
                || 'JOIN SA_KF208F KF208F ON KF208F.IDPLPS = REGEXP_SUBSTR(IA_OBJECT_ID, ''\w+'', 1, 1)||REGEXP_SUBSTR(IA_OBJECT_ID, ''\w+'', 1, 5)  '
                || ' WHERE KF208F.FBLKR = 0 AND KF208F.MIG_BATCH_ID = ''' || p_migrBatchId || '''';

      EXECUTE IMMEDIATE l_cur_sql
        BULK COLLECT INTO l_idplps,l_idpl,l_psonr;

      IF l_idplps.count <> 0 THEN

        FOR i in 1 .. l_idplps.count
        LOOP

          BEGIN
            l_err := 0;

            VSQL := 'SELECT IA_OBJECT_ID, IA_DESCRIPTION, LISTAGG(cast(trim(ALRTX) as varchar2(2000)), '' '' ) within group (ORDER BY IA_OBJECT_ID, RADNR, ALRTX) FROM ( ' ||
                     'SELECT ivso.IA_IDPL, ivso.IA_OBJECT_ID, TO_NUMBER(REGEXP_SUBSTR(ivso.IA_OBJECT_ID, ''\w+'', 1, 6)) AS obj_radnr, a.radnr, a.FBLKR, ivso.IA_DESCRIPTION, a.ALRTX, ' ||
                     '(select COUNT(DISTINCT b.RADNR) FROM SA_KF208F b WHERE b.IDPLPS = a.IDPLPS and b.FBLKR = 0) as radnr_cnt ' ||
                     'FROM SA_KF208F a JOIN ' || ctab.IA_OBJ_TABLE || ' ivso ON ivso.IA_IDPL = a.IDPL AND a.PSONR = REGEXP_SUBSTR(ivso.IA_OBJECT_ID, ''\w+'', 1, 5) ' ||
                     'WHERE a.FBLKR = 0 AND a.IDPLPS = ' || l_idplps(i) ||
                     ' ORDER BY a.IDPLPS, obj_radnr ) ' ||
                    'WHERE (obj_radnr = radnr+1 OR obj_radnr = radnr-1) OR (radnr = obj_radnr+2 AND radnr_cnt > 1) ' ||
                    'GROUP BY IA_OBJECT_ID, IA_DESCRIPTION ';

            EXECUTE IMMEDIATE VSQL INTO l_obj_id, l_ia_descr, l_descr;

            EXCEPTION
              WHEN TOO_MANY_ROWS THEN
                 l_err := 1;
                 l_Log_Rec.logMsg := 'Additional description for idplps ' || l_idplps(i) || ' is skipped due to more than one object exists for the same position type.';
                 MIGR_LOG.LOG_INFO(l_Log_Rec);
              WHEN OTHERS THEN
                 l_Log_Rec.logMsg := 'UPDATE_SPECIFIED_DESCRIPTION - SELECT ' || SQLERRM ;
                 MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);
            END;

            IF l_err = 0 AND l_obj_id IS NOT NULL THEN
              VSQL1 := 'UPDATE ' || ctab.IA_OBJ_TABLE ||
                       ' SET IA_DESCRIPTION = ''' || l_ia_descr || ' ' || l_descr || '''' ||
                       ' WHERE IA_IDPL = ' || l_idpl(i) || ' AND REGEXP_SUBSTR(IA_OBJECT_ID, ''\w+'', 1, 5) = ' || l_psonr(i) ||
                       ' AND IA_DESCRIPTION =  ''' || l_ia_descr || '''';

              EXECUTE IMMEDIATE VSQL1;
            END IF;

        END LOOP;
      END IF;
    END LOOP;

    COMMIT;
    EXCEPTION
      WHEN OTHERS THEN l_Log_Rec.logMsg := 'UPDATE_SPECIFIED_DESCR ' || SQLERRM ;
                       MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);
  END UPDATE_SPECIFIED_DESCRIPTION;
-- LM - 12-02-2018 - END
-------------------------------------------------------------------------------------------------------------------------------------

END MIGR_RULES;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_SCHEDULED_JOBS
  AS

  --You must have the CREATE JOB privilege to create a job in your own schema
  --As soon as you enable a job, it is automatically run by the Scheduler at its next scheduled date and time.
  --By default, jobs are disabled when created and must be enabled with DBMS_SCHEDULER.ENABLE to run.
  --Jobs are set to be automatically dropped by default after they complete.
  --Setting the auto_drop attribute to FALSE causes the job to persist.
  --Note that repeating jobs are not auto-dropped unless the job end date passes, the maximum number of runs (max_runs) is reached, or the maximum number of failures is reached (max_failures).
  --After a job is created, it can be queried using the *_SCHEDULER_JOBS views.


  ---------------------------------------------------------------------------------------------------
  PROCEDURE CREATE_MIGR_JOBS(p_job_name        IN VARCHAR2,
                             p_job_action      IN VARCHAR2,
                             p_repeat_interval IN VARCHAR2,
                             p_start_date      IN TIMESTAMP,
                             p_end_date        IN TIMESTAMP)
    AS
    BEGIN

      DBMS_SCHEDULER.CREATE_JOB(
      JOB_NAME => p_job_name,
      JOB_TYPE => 'PLSQL_BLOCK',
      JOB_ACTION => p_job_action,
      START_DATE => p_start_date,
      REPEAT_INTERVAL => p_repeat_interval,
      END_DATE => p_end_date,
      AUTO_DROP => FALSE);


    END CREATE_MIGR_JOBS;

  -------------------------------------------------------------------
  -------------------------------------------------------------------

  PROCEDURE ENABLE_MIGR_JOB(p_job_name IN VARCHAR2)
    AS
    l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN
      DBMS_SCHEDULER.ENABLE(NAME => p_job_name);

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_SCHEDULED_JOBS.ENABLE_MIGR_JOB' ;
        l_LogRec.migrStep      :=   'MIGR_SCHEDULED_JOBS.ENABLE_MIGR_JOB' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=    SQLERRM  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END ENABLE_MIGR_JOB;

  -------------------------------------------------------------------
  -------------------------------------------------------------------
  --If the job is running when the disable procedure is called, you get an error.
  --You can stop the running job as shown in the last example, or you can add force => true to the disable statement

  PROCEDURE DISABLE_MIGR_JOB(p_job_name IN VARCHAR2)
    AS
    l_logRec MIGR_GVAR.LogRecTyp;
    BEGIN
      DBMS_SCHEDULER.DISABLE(NAME => p_job_name);
    EXCEPTION
      WHEN OTHERS THEN

        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_SCHEDULED_JOBS.DISABLE_MIGR_JOB' ;
        l_LogRec.migrStep      :=   'MIGR_SCHEDULED_JOBS.DISABLE_MIGR_JOB' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=    SQLERRM  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END DISABLE_MIGR_JOB;
  -------------------------------------------------------------------
  -------------------------------------------------------------------

  PROCEDURE STOP_MIGR_RUNNING_JOB(p_job_name IN VARCHAR2)
    IS
    l_logRec MIGR_GVAR.LogRecTyp;
    BEGIN
      DBMS_SCHEDULER.STOP_JOB(JOB_NAME => p_job_name);

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_SCHEDULED_JOBS.STOP_MIGR_RUNNING_JOB' ;
        l_LogRec.migrStep      :=   'MIGR_SCHEDULED_JOBS.STOP_MIGR_RUNNING_JOB' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=    SQLERRM  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END STOP_MIGR_RUNNING_JOB;

  -------------------------------------------------------------------
  -------------------------------------------------------------------

  --if a job is running when you try to drop it, you get an error.
  --You can stop the job, then drop it or set the force parameter to true.
  --Setting force to true causes the running job to be stopped, and then the job is dropped from the scheduler.
  PROCEDURE DROP_MIGR_JOB(p_job_name IN VARCHAR2)
    AS
    l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN
      DBMS_SCHEDULER.DROP_JOB(JOB_NAME => p_job_name);

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_SCHEDULED_JOBS.DROP_MIGR_JOB' ;
        l_LogRec.migrStep      :=   'MIGR_SCHEDULED_JOBS.DROP_MIGR_JOB' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=    SQLERRM  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END DROP_MIGR_JOB;
  -------------------------------------------------------------------
  -------------------------------------------------------------------

--  PROCEDURE START_JOBS
--    AS
--    BEGIN
--
--      FOR j IN (SELECT JOB_NAME,
--                       JOB_ACTION,
--                       JOB_INTERVAL,
--                       START_DATE,
--                       END_DATE,
--                       ROLE
--          FROM ETL_JOB_CONFIGURATION)
--      LOOP
--        CREATE_MIGR_JOBS(j.JOB_NAME, j.JOB_ACTION, j.JOB_INTERVAL, j.START_DATE, j.END_DATE);
--     -- valex.9/9/16 - start only SIGNAL job, which is the job manager
--     --   ENABLE_MIGR_JOB(j.JOB_NAME);
--        if j.ROLE='Master' then
--          ENABLE_MIGR_JOB(j.JOB_NAME);
--        END IF;
--     -- valex.9/9/16 - end
--
--
--      END LOOP;
--    EXCEPTION
--      WHEN OTHERS THEN MIGR_SYSTEM.MIGR_LOG_LINE('FALSE', '0-0', 'MIGR_SCHEDULED_JOBS.START_JOBS', NULL, 'EXCEPTION', SQLERRM, NULL, NULL);
--    END START_JOBS;
  -------------------------------------------------------------------
  -------------------------------------------------------------------

    PROCEDURE START_JOBS
    AS
         l_logRec MIGR_GVAR.LogRecTyp;
    BEGIN

      FOR j IN (SELECT JOB_NAME,
                       JOB_ACTION,
                       JOB_INTERVAL,
                       START_DATE,
                       END_DATE,
                       ROLE,
                        (SELECT COUNT(*) FROM USER_SCHEDULER_JOBS WHERE job_name=a.job_name) as exist,
                         (SELECT COUNT(*) FROM USER_SCHEDULER_JOBS WHERE job_name=a.JOB_NAME AND STATE='RUNNING') as runs
                FROM ETL_JOB_CONFIGURATION a
      )
      LOOP
        if j.exist=0 THEN
            CREATE_MIGR_JOBS(j.JOB_NAME, j.JOB_ACTION, j.JOB_INTERVAL, j.START_DATE, j.END_DATE);
        END IF;
     -- valex.9/9/16 - start only SIGNAL job, which is the job manager
     --   ENABLE_MIGR_JOB(j.JOB_NAME);
        if j.ROLE='Master' and j.runs=0 then
          ENABLE_MIGR_JOB(j.JOB_NAME);
        END IF;
     -- valex.9/9/16 - end


      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_SCHEDULED_JOBS.START_JOBS' ;
        l_LogRec.migrStep      :=   'MIGR_SCHEDULED_JOBS.START_JOBS' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=    SQLERRM  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END START_JOBS;
  -------------------------------------------------------------------
  -------------------------------------------------------------------

  --If you must create many jobs,you may be able to reduce transaction overhead and experience a performance gain if you use the CREATE_JOBS procedure
  --FA.20180207 FIX Bug : Process spawned Migrate_Bolag_27 and picked randomly the next queued bolag.So MIGRATE_BOLAG_27 run fro bolag 50. Impact on resume.
  --Rewrite run parallel to spawn each migrate bolag job for specific bolag. As transactional jobs cannot support dynamic arguments the jobs are created as once off regular jobs
--  PROCEDURE RUN_PARALLEL
--    IS
--      l_jobno         PLS_INTEGER;
--      v_job_count     INTEGER;
--      v_count         INTEGER;
--      v_Transactional CHAR(1);
--      newjob          sys.job;
--      newjobarr       sys.job_array;
--      v_job_name      VARCHAR2(100);
--      vjob            INTEGER;
--      v_interval      INTEGER;
--      v_start_date    TIMESTAMP WITH TIME ZONE;
--      v_running   NUMBER;
--      v_available_jobs     NUMBER;
--      v_max_available NUMBER;
--      l_logRec MIGR_GVAR.LogRecTyp;
--    BEGIN
--        v_job_name := 'MIGRATE_BOLAG';
--       SELECT MIGG_JOB_TRANSACTIONAL,BATCH_PARALLEL_JOBS  INTO v_Transactional  ,v_max_available  FROM ETL_SETUP_INFO;
--      vjob := 0;
--
--      SELECT COUNT('X')
--        INTO v_job_count
--        FROM MIG_MIGRATION_INFO A
--        WHERE A.STATUS = 'Queued';
--
--
--      --FA.20160706 Always keep max 10 running batches
--      SELECT COUNT('x') INTO v_running from MIG_MIGRATION_INFO where status ='Running'  AND IA_COMPLETED <>'Finished';
--
--      IF  v_max_available - v_running >0 THEN
--        v_available_jobs:= v_max_available - v_running;
--         IF   v_available_jobs >= v_job_count THEN
--                      v_available_jobs :=v_job_count;
--          END IF;
--
--            IF v_Transactional = 'Y'   THEN
--
--                newjobarr := sys.job_array();
--
--                -- Allocate sufficient space in the array
--                --newjobarr.EXTEND(v_job_count);
--                 newjobarr.EXTEND(v_available_jobs);
--
--                -- Add definitions for x jobs
--                -- FOR I IN (SELECT BOLAG_ID   FROM MIG_MIGRATION_INFO A  WHERE A.STATUS = 'Queued') LOOP
--               FOR I IN (SELECT BOLAG_ID   FROM MIG_MIGRATION_INFO A  WHERE A.STATUS = 'Queued' ) LOOP
--                   vjob := vjob + 1;
--                  if v_available_jobs >=  vjob THEN
--
--
--                 --FA.20151112 First check if job has already been created
--                  SELECT COUNT('X')
--                    INTO v_count
--                    FROM USER_SCHEDULER_JOBS usj
--                    WHERE JOB_NAME = (v_job_name || TO_CHAR(i.BOLAG_ID));
--
--                  IF v_count = 0   THEN
--
--                    -- Create a JOB object type
--                    newjob := sys.job(job_name => v_job_name || TO_CHAR(i.BOLAG_ID),
--                    job_style => 'REGULAR',
--                    job_template => 'Run_Transactional',
--                    repeat_interval => 'FREQ=MINUTELY',
--                    start_date => systimestamp + INTERVAL '10' SECOND,
--                    max_runs => 1,
--                    auto_drop => TRUE,
--                    enabled => TRUE
--                    );
--
--                    -- Add it to the array
--                    newjobarr(vjob) := newjob;
--                END IF;
--                 end if;
--             END LOOP;
--
--
--        -- Call CREATE_JOBS to create jobs in one transaction
--        DBMS_SCHEDULER.CREATE_JOBS(newjobarr, 'TRANSACTIONAL');
--
--      ELSE
--
--         l_LogRec.mig_batch_id:=   '0-0';
--        l_LogRec.migrArea      :=   'MIGR_SCHEDULED_JOBS.RUN_PARALLEL' ;
--        l_LogRec.migrStep      :=   'MIGR_SCHEDULED_JOBS.RUN_PARALLEL' ;
--        l_LogRec.migrRelTbl    :=   NULL;
--        l_LogRec.migrRelKey  :=   NULL;
--        l_LogRec.logMsg        :=     'About to create: ' || v_job_count || ' jobs.'   ;
--        MIGR_LOG.LOG_INFO(l_LogRec) ;
--
--
--
--        -- Add definitions for v_job_count jobs
--       --- FOR i IN 1 .. v_job_count
--        FOR i IN 1 .. v_available_jobs
--        LOOP
--          DBMS_JOB.SUBMIT(l_jobno, 'begin MIGR_PROCESS.MIGR_MAIN(''FALSE''); end;');
--        END LOOP;
--
--      END IF;
--
--      END IF;
--    EXCEPTION
--      WHEN OTHERS THEN
--
--        l_LogRec.mig_batch_id:=   '0-0';
--        l_LogRec.migrArea      :=   'MIGR_SCHEDULED_JOBS.RUN_PARALLEL' ;
--        l_LogRec.migrStep      :=   'MIGR_SCHEDULED_JOBS.RUN_PARALLEL' ;
--        l_LogRec.migrRelTbl    :=   NULL;
--        l_LogRec.migrRelKey  :=   NULL;
--        l_LogRec.logMsg        :=    SQLERRM  ;
--        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
--
--
--    END RUN_PARALLEL;
  -------------------------------------------------------------------
  -------------------------------------------------------------------

  PROCEDURE RUN_PARALLEL
    IS
      l_jobno         PLS_INTEGER;
      v_job_count     INTEGER;
      v_Transactional CHAR(1);
      v_job_name      VARCHAR2(100);
      vjob            INTEGER;
      v_interval      INTEGER;
      v_start_date    TIMESTAMP WITH TIME ZONE;
      v_running   NUMBER;
      v_available_jobs     NUMBER;
      v_max_available NUMBER;
      l_logRec MIGR_GVAR.LogRecTyp;
    BEGIN
      sELECT MIGG_JOB_TRANSACTIONAL,BATCH_PARALLEL_JOBS  INTO v_Transactional  ,v_max_available  FROM ETL_SETUP_INFO;
      vjob := 0;

      SELECT COUNT('X')  INTO v_job_count  FROM MIG_MIGRATION_INFO A  WHERE A.STATUS in ( 'Queued','Queued_Discounts');

       --FA.20160706 Always keep max xx running batches
      SELECT COUNT(*)  INTO v_running  FROM USER_SCHEDULER_JOBS   where JOB_NAME LIKE 'MIGRATE%';

      IF  v_max_available - v_running >0 THEN
         v_available_jobs:= v_max_available - v_running;

         IF   v_available_jobs >= v_job_count THEN
            v_available_jobs :=v_job_count;
         END IF;

         FOR I IN (SELECT BOLAG_ID, status
                      FROM MIG_MIGRATION_INFO
                      WHERE STATUS in ( 'Queued' ,'Queued_Discounts')
            )
            LOOP

               vjob := vjob + 1;

               IF v_available_jobs >=  vjob THEN
                   IF i.status='Queued' THEN v_job_name := 'MIGRATE_BOLAG_';
                   ELSE v_job_name := 'MIGRATE_BOLAG_DISC_';
                   END  IF;

                   --FA.20151112 First check if job has already been created
                   FOR c IN (SELECT 'X'
                                     FROM DUAL
                                    WHERE 0=(SELECT COUNT(*)
                                      FROM USER_SCHEDULER_JOBS usj
                                      WHERE JOB_NAME = v_job_name || TO_CHAR(i.BOLAG_ID))
                   )
                   LOOP

                     DBMS_SCHEDULER.CREATE_JOB(job_name => v_job_name || TO_CHAR(i.BOLAG_ID),
                        JOB_TYPE=>'PLSQL_BLOCK' ,
                        JOB_ACTION=>  'declare '
                                                   || '  l_LogRec MIGR_GVAR.LogRecTyp; '
                                                   || 'BEGIN '
                                                   || '  l_LogRec.logMsg := ''Error in job action of Migration Job'';'
                                                   || ' MIGR_PROCESS_RESUME.RESUME_MAIN('||i.BOLAG_ID||'); '
                                                   || ' exception when others then   '
                                                   || ' MIGR_LOG.LOG_EXCEPTION(l_LogRec); '
                                                   || 'END; ' ,
                        START_DATE => systimestamp + INTERVAL '10' SECOND,
                        AUTO_DROP => TRUE,
                        ENABLED => TRUE
                      )   ;

                   END LOOP;
               END IF;

         END LOOP;

      END IF;
    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_SCHEDULED_JOBS.RUN_PARALLEL' ;
        l_LogRec.migrStep      :=   'MIGR_SCHEDULED_JOBS.RUN_PARALLEL' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=    SQLERRM  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
    END RUN_PARALLEL;

  -------------------------------------------------------------------
  -------------------------------------------------------------------
  -- +++ anb 206-04-28  - check if Program is already created and skip it.
  ----SELECT * FROM USER_SCHEDULER_PROGRAMS usp;
  --PROCEDURE CREATE_PROGRAM
  --  AS
  --BEGIN
  --    DBMS_SCHEDULER.create_program(
  --        program_name => 'Run_Transactional',
  --        program_action =>
  --              'begin MIGR_PROCESS.MIGR_MAIN(''FALSE''); end;',
  --        program_type => 'plsql_block',
  --        enabled   => true);
  --END;
  --Always drop program if exists and create
  PROCEDURE CREATE_PROGRAM
    AS
    ---  vSQL VARCHAR2(2100);
      l_logRec MIGR_GVAR.LogRecTyp;
    BEGIN
     --- vSQL := 'NOT STARTED';
      FOR cRec IN (SELECT usp.PROGRAM_NAME,
                          usp.ENABLED
          FROM USER_SCHEDULER_PROGRAMS usp
          WHERE 1 = 1
            AND usp.PROGRAM_NAME = 'RUN_TRANSACTIONAL')
      LOOP
       -- IF CREC.ENABLED = 'TRUE'  THEN  vSQL := 'RUNNING';   ELSE   vSQL := 'DISABLED';    END IF;
           DBMS_SCHEDULER.DROP_PROGRAM('Run_Transactional');
      END LOOP;

   ---   IF vSQL = 'NOT STARTED'    THEN

        DBMS_SCHEDULER.create_program(
        program_name => 'Run_Transactional',
        program_action =>
          'declare '
       || '  l_LogRec      MIGR_GVAR.LogRecTyp; '
       || 'BEGIN '
       || '  l_LogRec.logMsg := ''Error in job action of Migration Job'';'
       || ' MIGR_PROCESS_RESUME.RESUME_MAIN; '
       || ' exception when others then   '
       || ' MIGR_LOG.LOG_EXCEPTION(l_LogRec); '
       || 'END; ' ,
        program_type => 'plsql_block',
         number_of_arguments=>1,
        enabled => FALSE);




     /* ELSIF vSQL = 'DISABLED'    THEN   DBMS_SCHEDULER.ENABLE('RUN_TRANSACTIONAL');
      ELSIF vSQL = 'RUNNING'     THEN     NULL;
      END IF;*/


    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_SCHEDULED_JOBS.CREATE_PROGRAM' ;
        l_LogRec.migrStep      :=   'MIGR_SCHEDULED_JOBS.CREATE_PROGRAM' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=    SQLERRM  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END CREATE_PROGRAM;
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
 /* PROCEDURE RUN_PARALLEL_DISCOUNTS
    IS
      v_job_name      VARCHAR2(100);
      l_logRec MIGR_GVAR.LogRecTyp;
  BEGIN
      v_job_name := 'DISCOUNTS_BOLAG';


      for c IN (SELECT bolag_id
                FROM MIG_MIGRATION_INFO A
                WHERE A.STATUS = 'Queued_Discounts'
                  and 0=(SELECT COUNT(*) FROM USER_SCHEDULER_JOBS WHERE JOB_NAME=v_job_name||bolag_id)
      )
      LOOP
         DBMS_SCHEDULER.CREATE_JOB(
             JOB_NAME        => v_job_name||c.bolag_id,
             JOB_TYPE        => 'PLSQL_BLOCK',
             JOB_ACTION      => 'declare '
                             || ' l_LogRec      MIGR_GVAR.LogRecTyp; '
                             || 'begin '
                             || ' l_LogRec.logMsg := ''Error in Discounts Migration job calling procedure''; '
                             || ' MIGR_PROCESS.MIGR_MAIN(''FALSE'');'
                             || 'exception when others then '
                             || ' MIGR_LOG.LOG_EXCEPTION(l_LogRec);'
                             || 'end;',
             START_DATE      => NULL,        -- Schedule job will run as soon as it is enabled
             REPEAT_INTERVAL => NULL,        -- Schedule job will run only once
             ENABLED         => TRUE,
             AUTO_DROP       => TRUE
         );
      END LOOP;


  EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.mig_batch_id:=   '0-0';
        l_LogRec.migrArea      :=   'MIGR_SCHEDULED_JOBS.RUN_PARALLEL_DISCOUNTS' ;
        l_LogRec.migrStep      :=   'MIGR_SCHEDULED_JOBS.RUN_PARALLEL_DISCOUNTS' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=    SQLERRM  ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END RUN_PARALLEL_DISCOUNTS;     */

-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
END MIGR_SCHEDULED_JOBS;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_SETUP
  AS

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --PROCEDURE THAT Truncates statistics tables
  PROCEDURE TRUNCATE_STATS
    AS
      vSQL  VARCHAR2(2100);
      l_LogRec  MIGR_GVAR.LogRecTyp;
    BEGIN

      vSQL := 'TRUNCATE TABLE MIG_MIGRATION_INFO';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIG_MIGRATION_STEPS';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIG_DETAIL_ERROR_LOG';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIG_VOLUMETRIC_ANALYSIS';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_EMAIL_NOTIFICATIONS_LOG';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_PARALLEL_PROCESS_LOG';
      EXECUTE IMMEDIATE vSQL;
      -- vSQL := 'TRUNCATE TABLE ETL_RESUME_BATCHES'; -- valex.2/11/2016 - for resume process purpose

    EXCEPTION
      WHEN OTHERS THEN
          l_LogRec.mig_batch_id := '0-0';
          l_LogRec.migrArea     := 'TRUNCATE  STATS' ;
          l_LogRec.migrStep     := 'MIGR_SETUP.TRUNCATE_STATS' ;
          l_LogRec.migrRelTbl   := NULL;
          l_LogRec.migrRelKey   := NULL;
          l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM || '-' || SUBSTR(vSQL, 1, 1500)   ;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END TRUNCATE_STATS;
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  PROCEDURE TBL_OPERATION_SA(OPERATION IN VARCHAR2)
    AS

      l_create_st          VARCHAR(2100);
      l_file_name          NVARCHAR2(50);
      l_addtnl_fields      VARCHAR2(10);
      l_tbl_cnt            PLS_INTEGER;
      l_file_role          VARCHAR2(50);
      l_LogRec      MIGR_GVAR.LogRecTyp;
      L_PK1                VARCHAR2(30);
      l_pk2                VARCHAR2(30);
      l_pk3                VARCHAR2(30);
      l_pk4                VARCHAR2(30);
      l_pk5                VARCHAR2(30);


      CURSOR fetch_file_names IS
          SELECT DISTINCT (etd.TBLNAME)
                          ,pk1
                          ,pk2
                          ,pk3
                          ,pk4
                          ,PK5
                          ,NVL(etd.ADDTNL, 'N') AS ADDTNL
                          ,etd.FILE_ROLE                            --valex.2/6/2016 different create for B_PRSN (Derived)
            FROM ETL_TBL_DEF etd
            WHERE NVL(etd.SA, 'N') = 'Y'
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y'                 --- +++ anb 2016-02-03 skip reconciliation file
      ;
      v_indexIDPLSql       VARCHAR2(32000);
      v_indexIDPLPSSql     VARCHAR2(32000);
      v_indexIDPLPSDTSql   VARCHAR2(32000);
      v_indexIDPLPSDTP5Sql VARCHAR2(32000);
      v_composite          VARCHAR2(1000);
    BEGIN

      OPEN fetch_file_names;
      LOOP
        FETCH fetch_file_names INTO l_file_name,L_PK1,l_pk2,l_pk3,l_pk4,l_pk5, l_addtnl_fields, l_file_role;
        EXIT WHEN fetch_file_names % NOTFOUND;
        --valex.2/6/16 different create stmnt for derived tables
        CASE
          WHEN OPERATION = 'CREATE' AND
            l_file_role <> 'Derived' /*AND l_file_role <> 'Discounts'*/ THEN l_create_st := 'CREATE TABLE' || ' SA_' || l_file_name || '( ' || FETCH_ATTR(l_file_name, FALSE, TRUE, TRUE, TRUE) || ' ) NOLOGGING';
          WHEN OPERATION = 'CREATE' AND
            l_file_role = 'Derived' /*OR l_file_role = 'Discounts')*/ THEN l_create_st := 'CREATE TABLE' || ' SA_' || l_file_name || '( ' || FETCH_ATTR(l_file_name, FALSE, FALSE, TRUE, FALSE) || ' ) NOLOGGING';

          WHEN OPERATION = 'DROP' THEN
              --FA. 20151106 Check if table exists before dropping

              SELECT COUNT(*)
                INTO l_tbl_cnt
                FROM USER_TABLES
                WHERE table_name = UPPER('SA_' || l_file_name);

              IF l_tbl_cnt = 1   THEN
                -- +++ anb 2016-04-18 added CASCADE CONSTRAINTS PURGE
                   l_create_st := 'DROP TABLE ' || ' SA_' || l_file_name || ' CASCADE CONSTRAINTS PURGE';
              ELSE
                l_create_st := 'select 1 from dual';
              END IF;

          WHEN OPERATION = 'TRUNCATE' THEN l_create_st := 'TRUNCATE TABLE ' || ' SA_' || l_file_name;
          ELSE

            l_create_st := 'SELECT ' || CHR(39) || 'ERROR-Wrong Operation' || CHR(39) || ' FROM DUAL';
        END CASE;

        EXECUTE IMMEDIATE l_create_st;

        --valex.2/6/16 skip index creation for derived tables
        --          IF OPERATION = 'CREATE' THEN
        IF OPERATION = 'CREATE'
          AND l_file_role <> 'Derived' /*AND l_file_role <> 'Discounts'*/
        THEN

          v_indexIDPLSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPL ' || ' ON SA_' || l_file_name || ' (IDPL) NOLOGGING';
          v_indexIDPLPSSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPS' || ' ON SA_' || l_file_name || ' (IDPLPS) NOLOGGING';
          v_indexIDPLPSDTSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPSDT ' || ' ON SA_' || l_file_name || ' (IDPLPSDT) NOLOGGING';
          v_indexIDPLPSDTP5Sql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPSDTP5 ' || ' ON SA_' || l_file_name || ' (IDPLPSDTP5) NOLOGGING';

          EXECUTE IMMEDIATE (v_indexIDPLSql);
          EXECUTE IMMEDIATE (v_indexIDPLPSSql);
          EXECUTE IMMEDIATE (v_indexIDPLPSDTSql);
          EXECUTE IMMEDIATE (v_indexIDPLPSDTP5Sql);

        END IF;

      END LOOP;
      CLOSE fetch_file_names;
--valex.14/9/15 - Add composite indexes creation
--        --logic fo KF* tables
--        IF OPERATION = 'CREATE'  AND l_file_role <> 'Derived'
--         THEN
--
--          IF NVL(l_pk3,' ')<>' ' THEN
--            l_pk3:=','||l_pk3;
--          END IF;
--          IF NVL(l_pk4,' ')<>' ' THEN
--            l_pk4:=','||l_pk4;
--          END IF;
--          IF NVL(l_pk5,' ')<>' ' THEN
--            l_pk5:=','||l_pk5;
--          END IF;
--
--          v_indexIDPLSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPL ' || ' ON SA_' || l_file_name || ' (IDPL) NOLOGGING';
--          v_indexIDPLPSSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPS' || ' ON SA_' || l_file_name || ' (IDPLPS) NOLOGGING';
--          v_indexIDPLPSDTSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPSDT ' || ' ON SA_' || l_file_name || ' (IDPLPSDT) NOLOGGING';
--          v_indexIDPLPSDTP5Sql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPSDTP5 ' || ' ON SA_' || l_file_name || ' (IDPLPSDTP5) NOLOGGING';
--
--          --create composite index only when at least one of pk3, pk4, pk5 is filled in etl_tbl_def
--          if instr(l_pk3||l_pk4||l_pk5,',')<> 0 then
--             v_composite := 'create index sa_' || l_file_name || '_composite  ON SA_' || l_file_name || '(idpl' ||l_pk3 ||l_pk4 || l_pk5 ||')';
--             EXECUTE IMMEDIATE v_composite;
--          end if;
--
--          --create indexes
--          EXECUTE IMMEDIATE (v_indexIDPLSql);
--          EXECUTE IMMEDIATE (v_indexIDPLPSSql);
--          EXECUTE IMMEDIATE (v_indexIDPLPSDTSql);
--          EXECUTE IMMEDIATE (v_indexIDPLPSDTP5Sql);
--
--        END IF;
--
--       --logic for sa_b_* tables (idpl is not mandatory to ne part of composite index)
--        IF OPERATION = 'CREATE'  AND l_file_role = 'Derived'
--         THEN
--
--
--          IF NVL(l_pk2,' ')<>' ' THEN
--            l_pk2:=','||l_pk2;
--          END IF;
--          IF NVL(l_pk3,' ')<>' ' THEN
--            l_pk3:=','||l_pk3;
--          END IF;
--          IF NVL(l_pk4,' ')<>' ' THEN
--            l_pk4:=','||l_pk4;
--          END IF;
--          IF NVL(l_pk5,' ')<>' ' THEN
--            l_pk5:=','||l_pk5;
--          END IF;
--
--          if instr(l_pk2||l_pk3||l_pk4||l_pk5,',')<> 0 then
--             v_composite := 'create index sa_' || l_file_name || '_composite  ON SA_' || l_file_name || ' ('||l_pk1 ||l_pk2 ||l_pk3 || l_pk4 ||l_pk5 ||')';
--             EXECUTE IMMEDIATE v_composite;
--          end if;
--        END IF;
--
--
--      END LOOP;
--      CLOSE fetch_file_names;
--valex.14/9/15 - end

    EXCEPTION
      WHEN OTHERS THEN
              l_LogRec.mig_batch_id:='0-0';
              l_LogRec.migrArea      :=   'TBL OPERATION SA' ;
              l_LogRec.migrStep      :=   'MIGR_SETUP.TBL_OPERATION_SA' ;
              l_LogRec.migrRelTbl    :=   NULL;
              l_LogRec.migrRelKey  :=   NULL;
              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(l_create_st, 1, 2000)   ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END TBL_OPERATION_SA;
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --PROCEDURE THAT CREATES,DROP AND TRUNCATES SA TABLES
  PROCEDURE TBL_OPERATION_SA_clustering(OPERATION IN VARCHAR2)
    AS

      l_create_st          VARCHAR(2100);
      l_file_name          NVARCHAR2(50);
      l_addtnl_fields      VARCHAR2(10);
      l_tbl_cnt            PLS_INTEGER;
      l_file_role          VARCHAR2(50);
      l_clustered          VARCHAR2(1);
      l_LogRec migr_gvar.LogRecTyp;
      L_PK1                VARCHAR2(30);
      l_pk2                VARCHAR2(30);
      l_pk3                VARCHAR2(30);
      l_pk4                VARCHAR2(30);
      l_pk5                VARCHAR2(30);


      CURSOR fetch_file_names IS
          SELECT DISTINCT (etd.TBLNAME)
                          ,pk1
                          ,pk2
                          ,pk3
                          ,pk4
                          ,PK5
                          ,NVL(etd.ADDTNL, 'N') AS ADDTNL
                          ,etd.FILE_ROLE                            --valex.2/6/2016 different create for B_PRSN (Derived)
                          ,etd.clustered
            FROM ETL_TBL_DEF etd
            WHERE NVL(etd.SA, 'N') = 'Y'
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y'                 --- +++ anb 2016-02-03 skip reconciliation file
      ;
      v_indexIDPLSql       VARCHAR2(32000);
      v_indexIDPLPSSql     VARCHAR2(32000);
      v_indexIDPLPSDTSql   VARCHAR2(32000);
      v_indexIDPLPSDTP5Sql VARCHAR2(32000);
      v_composite          VARCHAR2(1000);
    BEGIN

  --valex
      IF OPERATION = 'DROP' THEN
          for c in (SELECT *
              FROM USER_CLUSTERS
              WHERE cluster_name='BATCH_CLUSTER'
          )
          loop
              l_create_st:='drop CLUSTER BATCH_CLUSTER including tables';
              EXECUTE IMMEDIATE l_create_st;
          end loop;
      END IF;
      IF OPERATION = 'CREATE' THEN
          l_create_st:=' CREATE CLUSTER BATCH_CLUSTER(MIG_BATCH_ID VARCHAR2(50)) SIZE 300 ';  --SIZE 300
          EXECUTE IMMEDIATE l_create_st;

          l_create_st:=' CREATE INDEX BATCH_CLUSTER_IDX  on cluster BATCH_CLUSTER';
          EXECUTE IMMEDIATE l_create_st;
      end if;
  --valex.end

      OPEN fetch_file_names;
      LOOP
        FETCH fetch_file_names INTO l_file_name,L_PK1,l_pk2,l_pk3,l_pk4,l_pk5, l_addtnl_fields, l_file_role, l_clustered;
        EXIT WHEN fetch_file_names % NOTFOUND;
        --valex.2/6/16 different create stmnt for derived tables
        CASE
          WHEN OPERATION = 'CREATE' AND l_file_role <> 'Derived' and l_clustered ='Y' THEN
--             l_create_st := 'CREATE TABLE' || ' SA_' || l_file_name || '( ' || FETCH_ATTR(l_file_name, FALSE, TRUE, TRUE, TRUE) || ' ) NOLOGGING';
              l_create_st := 'CREATE TABLE' || ' SA_' || l_file_name || '( ' || FETCH_ATTR(l_file_name, FALSE, TRUE, TRUE, TRUE) || ' ) cluster BATCH_CLUSTER(MIG_BATCH_ID)  ';
          WHEN OPERATION = 'CREATE' AND l_file_role <> 'Derived' and l_clustered <> 'Y' THEN
              l_create_st := 'CREATE TABLE' || ' SA_' || l_file_name || '( ' || FETCH_ATTR(l_file_name, FALSE, TRUE, TRUE, TRUE) || ' ) NOLOGGING';
          WHEN OPERATION = 'CREATE' AND l_file_role = 'Derived' THEN
              l_create_st := 'CREATE TABLE' || ' SA_' || l_file_name || '( ' || FETCH_ATTR(l_file_name, FALSE, FALSE, TRUE, FALSE) || ' ) NOLOGGING';

          WHEN OPERATION = 'DROP' THEN
              --FA. 20151106 Check if table exists before dropping

              SELECT COUNT(*)
                INTO l_tbl_cnt
                FROM USER_TABLES
                WHERE table_name = UPPER('SA_' || l_file_name);

              IF l_tbl_cnt = 1   THEN
                -- +++ anb 2016-04-18 added CASCADE CONSTRAINTS PURGE
                   l_create_st := 'DROP TABLE ' || ' SA_' || l_file_name || ' CASCADE CONSTRAINTS PURGE';
              ELSE
                l_create_st := 'select 1 from dual';
              END IF;

          WHEN OPERATION = 'TRUNCATE' THEN l_create_st := 'TRUNCATE TABLE ' || ' SA_' || l_file_name;
          ELSE

            l_create_st := 'SELECT ' || CHR(39) || 'ERROR-Wrong Operation' || CHR(39) || ' FROM DUAL';
        END CASE;

        EXECUTE IMMEDIATE l_create_st;

        --valex.2/6/16 skip index creation for derived tables
        --          IF OPERATION = 'CREATE' THEN
        IF OPERATION = 'CREATE'
          AND l_file_role <> 'Derived'
        THEN

          v_indexIDPLSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPL ' || ' ON SA_' || l_file_name || ' (IDPL) NOLOGGING';
          v_indexIDPLPSSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPS' || ' ON SA_' || l_file_name || ' (IDPLPS) NOLOGGING';
          v_indexIDPLPSDTSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPSDT ' || ' ON SA_' || l_file_name || ' (IDPLPSDT) NOLOGGING';
          v_indexIDPLPSDTP5Sql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPSDTP5 ' || ' ON SA_' || l_file_name || ' (IDPLPSDTP5) NOLOGGING';

          EXECUTE IMMEDIATE (v_indexIDPLSql);
          EXECUTE IMMEDIATE (v_indexIDPLPSSql);
          EXECUTE IMMEDIATE (v_indexIDPLPSDTSql);
          EXECUTE IMMEDIATE (v_indexIDPLPSDTP5Sql);

        END IF;

      END LOOP;
      CLOSE fetch_file_names;
--valex.14/9/15 - Add composite indexes creation
--        --logic fo KF* tables
--        IF OPERATION = 'CREATE'  AND l_file_role <> 'Derived'
--         THEN
--
--          IF NVL(l_pk3,' ')<>' ' THEN
--            l_pk3:=','||l_pk3;
--          END IF;
--          IF NVL(l_pk4,' ')<>' ' THEN
--            l_pk4:=','||l_pk4;
--          END IF;
--          IF NVL(l_pk5,' ')<>' ' THEN
--            l_pk5:=','||l_pk5;
--          END IF;
--
--          v_indexIDPLSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPL ' || ' ON SA_' || l_file_name || ' (IDPL) NOLOGGING';
--          v_indexIDPLPSSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPS' || ' ON SA_' || l_file_name || ' (IDPLPS) NOLOGGING';
--          v_indexIDPLPSDTSql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPSDT ' || ' ON SA_' || l_file_name || ' (IDPLPSDT) NOLOGGING';
--          v_indexIDPLPSDTP5Sql := ' CREATE INDEX ' || 'SA_' || l_file_name || '_IDPLPSDTP5 ' || ' ON SA_' || l_file_name || ' (IDPLPSDTP5) NOLOGGING';
--
--          --create composite index only when at least one of pk3, pk4, pk5 is filled in etl_tbl_def
--          if instr(l_pk3||l_pk4||l_pk5,',')<> 0 then
--             v_composite := 'create index sa_' || l_file_name || '_composite  ON SA_' || l_file_name || '(idpl' ||l_pk3 ||l_pk4 || l_pk5 ||')';
--             EXECUTE IMMEDIATE v_composite;
--          end if;
--
--          --create indexes
--          EXECUTE IMMEDIATE (v_indexIDPLSql);
--          EXECUTE IMMEDIATE (v_indexIDPLPSSql);
--          EXECUTE IMMEDIATE (v_indexIDPLPSDTSql);
--          EXECUTE IMMEDIATE (v_indexIDPLPSDTP5Sql);
--
--        END IF;
--
--       --logic for sa_b_* tables (idpl is not mandatory to ne part of composite index)
--        IF OPERATION = 'CREATE'  AND l_file_role = 'Derived'
--         THEN
--
--
--          IF NVL(l_pk2,' ')<>' ' THEN
--            l_pk2:=','||l_pk2;
--          END IF;
--          IF NVL(l_pk3,' ')<>' ' THEN
--            l_pk3:=','||l_pk3;
--          END IF;
--          IF NVL(l_pk4,' ')<>' ' THEN
--            l_pk4:=','||l_pk4;
--          END IF;
--          IF NVL(l_pk5,' ')<>' ' THEN
--            l_pk5:=','||l_pk5;
--          END IF;
--
--          if instr(l_pk2||l_pk3||l_pk4||l_pk5,',')<> 0 then
--             v_composite := 'create index sa_' || l_file_name || '_composite  ON SA_' || l_file_name || ' ('||l_pk1 ||l_pk2 ||l_pk3 || l_pk4 ||l_pk5 ||')';
--             EXECUTE IMMEDIATE v_composite;
--          end if;
--        END IF;
--
--
--      END LOOP;
--      CLOSE fetch_file_names;
--valex.14/9/15 - end

    EXCEPTION
      WHEN OTHERS THEN
              l_LogRec.mig_batch_id:='0-0';
              l_LogRec.migrArea      :=   'TBL OPERATION SA' ;
              l_LogRec.migrStep      :=   'MIGR_SETUP.TBL_OPERATION_SA_clustering' ;
              l_LogRec.migrRelTbl    :=   NULL;
              l_LogRec.migrRelKey  :=   NULL;
              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(l_create_st, 1, 2000)   ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END TBL_OPERATION_SA_clustering;
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE THAT CREATES,DROP AND TRUNCATES LA TABLES
    PROCEDURE TBL_OPERATION_LA(OPERATION IN VARCHAR2)
    AS
      l_create_st          VARCHAR(2100);
      l_file_name          NVARCHAR2(50);
      l_bolag_name         NVARCHAR2(50);
      l_tbl_cnt            PLS_INTEGER;
      l_addtnl_flds        VARCHAR2(10);
      l_LogRec MIGR_GVAR.LogRecTyp;
      l_la_tbl_cnt            PLS_INTEGER;
      l_iot_tbl_cnt            PLS_INTEGER;

      CURSOR fetch_file_names IS
          SELECT DISTINCT (etd.TBLNAME),
                          NVL(etd.ADDTNL, 'N') AS ADDTNL
                         ,IOT
            FROM ETL_TBL_DEF etd
            WHERE NVL(etd.LA, 'N') = 'Y'
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y'              --- +++ anb 2016-02-03 skip reconciliation file
      ;
      CURSOR fetch_bolag_names IS
          SELECT BOLAG_NAME
            FROM ETL_BOLAG_INFO;



      v_indexIDPLSql       VARCHAR2(32000);
      v_indexIDPLPSSql     VARCHAR2(32000);
      v_indexIDPLPSDTSql   VARCHAR2(32000);
      v_indexIDPLPSDTP5Sql VARCHAR2(32000);

      v_fields             VARCHAR2(100);
      v_index              VARCHAR2(32000);
      v_iot_fields         VARCHAR2(100);
      v_iot_attributes     VARCHAR2(200);
      l_IOT                VARCHAR2(10);


    BEGIN

      OPEN fetch_bolag_names;
      LOOP
        FETCH fetch_bolag_names INTO l_bolag_name;
        EXIT WHEN fetch_bolag_names % NOTFOUND;

        OPEN fetch_file_names;
        LOOP
          FETCH fetch_file_names INTO l_file_name, l_addtnl_flds,l_IOT;
          EXIT WHEN fetch_file_names % NOTFOUND;

--valex.3/11/2016 - IOT design
          v_iot_attributes:='';
          v_iot_fields:='';

          for c1 IN (SELECT a.field_name,a.data_type,a.data_size
              FROM ETL_MIGG_SOURCES a,ETL_TBL_DEF b
              WHERE 1=1
                and a.FILE_NAME=l_file_name
                and a.FIle_NAME=b.TBLNAME
                and a.FIELD_NAME IN(b.PK1,b.PK2,b.pk3)
            ORDER BY a.ROW_NR
          )
          loop
              v_iot_attributes:=v_iot_attributes||c1.FIELD_NAME||' '||c1.DATA_TYPE||'('||c1.data_size||'),';
          end LOOP;
          v_iot_attributes:=v_iot_attributes||'MIG_BATCH_ID varchar2(50)';

          for c2 IN(SELECT (case when PK1 IS NOT NULL THEN PK1||',' ELSE NULL END)||(case when PK2 IS NOT NULL THEN PK2||',' ELSE NULL END)||(case when PK3 IS NOT NULL THEN PK3||',' ELSE NULL END) AS iot_fields
                    FROM ETL_TBL_DEF
                    WHERE TBLNAME=l_file_name)
          LOOP
              v_iot_fields:=c2.iot_fields||'MIG_BATCH_ID';
          END LOOP;

          SELECT COUNT(*)
                  INTO l_la_tbl_cnt
          FROM user_tables
          WHERE table_name = UPPER('LA_' || l_bolag_name || '_' || l_file_name);

          SELECT COUNT(*)
                  INTO l_iot_tbl_cnt
          FROM user_tables
          WHERE table_name = UPPER('LA_' || l_bolag_name || '_' || l_file_name||'_IOT');
--valex.3/11/2016 - end


--valex.3/11/1016 - added logic for IOT creation and rewrite of case block
--          CASE OPERATION
--            WHEN 'CREATE' THEN l_create_st := 'CREATE TABLE' || ' LA_' || l_bolag_name || '_' || l_file_name || '( '
--                || FETCH_ATTR(l_file_name, FALSE, FALSE, TRUE, (CASE
--                  WHEN l_addtnl_flds = 'Y' THEN TRUE
--                  ELSE FALSE END))
--                --                                    || ' )';
--                || ' ) NOLOGGING';
--
--
--            WHEN 'DROP' THEN
--                  SELECT COUNT(*)
--                  INTO l_tbl_cnt
--                  FROM user_tables
--                  WHERE table_name = UPPER('LA_' || l_bolag_name || '_' || l_file_name);
--                IF l_tbl_cnt = 1
--                THEN
--                  -- +++ anb 2016-04-18 added CASCADE CONSTRAINTS PURGE
--
--                  l_create_st := 'DROP TABLE ' || ' LA_' || l_bolag_name || '_' || l_file_name || ' CASCADE CONSTRAINTS PURGE'; -- +++ anb 2016-04-18
--                ELSE
--                  l_create_st := 'select 1 from dual';
--                END IF;
--            WHEN 'TRUNCATE' THEN l_create_st := 'TRUNCATE TABLE ' || ' LA_' || l_bolag_name || '_' || l_file_name;
--            ELSE
--
--              l_create_st := 'SELECT ' || CHR(39) || 'ERROR-Wrong Operation' || CHR(39) || ' FROM DUAL';
--          END CASE;
          CASE
            WHEN OPERATION='CREATE' THEN
                 l_create_st := 'CREATE TABLE' || ' LA_' || l_bolag_name || '_' || l_file_name || '( '
                  || FETCH_ATTR(l_file_name, FALSE, FALSE, TRUE, (CASE
                    WHEN l_addtnl_flds = 'Y' THEN TRUE
                    ELSE FALSE END))
                  --                                    || ' )';
                  || ' ) NOLOGGING';
                 EXECUTE IMMEDIATE l_create_st;

                 l_create_st := 'CREATE TABLE' || ' LA_' || l_bolag_name || '_' || l_file_name || '_IOT( ' || v_iot_attributes
                    || ',constraint pk_LA_' || l_bolag_name || '_' || l_file_name || '_IX primary key (' || v_iot_fields||')) organization index NOLOGGING';

                --execute only for files identified as IOT in ETL_TBL_DEF
                 IF l_IOT='Y' then
                  EXECUTE IMMEDIATE l_create_st;
                 end if;

            WHEN OPERATION='DROP' THEN
                  if l_la_tbl_cnt=1 then
                    -- +++ anb 2016-04-18 added CASCADE CONSTRAINTS PURGE
                      l_create_st := 'DROP TABLE ' || ' LA_' || l_bolag_name || '_' || l_file_name || ' CASCADE CONSTRAINTS PURGE'; -- +++ anb 2016-04-18
                      EXECUTE IMMEDIATE l_create_st;
                  END IF;
                  if l_iot_tbl_cnt=1 then
                    -- +++ anb 2016-04-18 added CASCADE CONSTRAINTS PURGE
                      l_create_st := 'DROP TABLE ' || ' LA_' || l_bolag_name || '_' || l_file_name || '_IOT CASCADE CONSTRAINTS PURGE'; -- +++ anb 2016-04-18
                      EXECUTE IMMEDIATE l_create_st;
                  END IF;

            WHEN OPERATION='TRUNCATE' THEN
                 if l_la_tbl_cnt=1 then
                     l_create_st := 'TRUNCATE TABLE ' || ' LA_' || l_bolag_name || '_' || l_file_name;
                     EXECUTE IMMEDIATE l_create_st;
                 end if;
                 if l_iot_tbl_cnt=1 then
                    l_create_st := 'TRUNCATE TABLE ' || ' LA_' || l_bolag_name || '_' || l_file_name||'_IOT';
                    EXECUTE IMMEDIATE l_create_st;
                 end if;
            END CASE;
--valex.3/11/1016 - end


--valex.3/11/1016 - rewrite of index creation
--          BEGIN
--
--                  ---+++anb 2016-02-09 skip if NO ADDTNL fields for table
--            IF l_addtnl_flds = 'Y'
--            THEN
--              CASE OPERATION
--                WHEN 'CREATE' THEN BEGIN
--
--
--                      v_indexIDPLSql := ' CREATE INDEX ' || 'LA_' || l_bolag_name || '_' || l_file_name || '_IDPL ' || ' ON LA_' || l_bolag_name || '_' || l_file_name || ' (IDPL) NOLOGGING';
--                      v_indexIDPLPSSql := ' CREATE INDEX ' || 'LA_' || l_bolag_name || '_' || l_file_name || '_IDPLPS' || ' ON LA_' || l_bolag_name || '_' || l_file_name || '(IDPLPS) NOLOGGING';
--                      v_indexIDPLPSDTSql := ' CREATE INDEX ' || 'LA_' || l_bolag_name || '_' || l_file_name || '_IDPLPSDT ' || ' ON LA_' || l_bolag_name || '_' || l_file_name || ' (IDPLPSDT) NOLOGGING';
--                      v_indexIDPLPSDTP5Sql := ' CREATE INDEX ' || 'LA_' || l_bolag_name || '_' || l_file_name || '_IDPLPSDTP5 ' || ' ON LA_' || l_bolag_name || '_' || l_file_name || '(IDPLPSDTP5) NOLOGGING';
--
--
--                      EXECUTE IMMEDIATE (v_indexIDPLSql);
--                      EXECUTE IMMEDIATE (v_indexIDPLPSSql);
--                      EXECUTE IMMEDIATE (v_indexIDPLPSDTSql);
--                      EXECUTE IMMEDIATE (v_indexIDPLPSDTP5Sql);
--
--                    EXCEPTION
--                      WHEN OTHERS THEN
--
--                          EvLog.MIGRATION_BATCH_ID := '0-0';
--                          EvLog.MIGRATION_AREA := 'MIGR_SETUP.TBL_OPERATION_LA';
--                          EvLog.MIGRATION_STEP := NULL;
--                          EvLog.EVENT_TYPE := 'TEST';
--                          EvLog.EVENT_MESSAGE := SQLERRM;
--                          EvLog.RELATED_TABLE := v_indexIDPLSql;
--                          EvLog.RELATED_KEY := NULL;
--                          MIGR_SYSTEM.MIGR_LOG_LINE_R('FALSE', EvLog);
--                    END;
--
--              END CASE;
--            END IF;
--
--
--
--          EXCEPTION
--            WHEN OTHERS THEN NULL;
--          END;


            IF l_addtnl_flds = 'Y' and OPERATION='CREATE' then
              BEGIN
                      v_index := ' CREATE INDEX ' || 'LA_' || l_bolag_name || '_' || l_file_name || '_IDPL ' || ' ON LA_' || l_bolag_name || '_' || l_file_name || ' (IDPL) NOLOGGING';
                      EXECUTE IMMEDIATE v_index;
                      v_index := ' CREATE INDEX ' || 'LA_' || l_bolag_name || '_' || l_file_name || '_IDPLPS' || ' ON LA_' || l_bolag_name || '_' || l_file_name || '(IDPLPS) NOLOGGING';
                      EXECUTE IMMEDIATE v_index;
--                      v_index := ' CREATE INDEX ' || 'LA_' || l_bolag_name || '_' || l_file_name || '_IDPLPSDT ' || ' ON LA_' || l_bolag_name || '_' || l_file_name || ' (IDPLPSDT) NOLOGGING';
--                      EXECUTE IMMEDIATE v_index;
--                      v_index := ' CREATE INDEX ' || 'LA_' || l_bolag_name || '_' || l_file_name || '_IDPLPSDTP5 ' || ' ON LA_' || l_bolag_name || '_' || l_file_name || '(IDPLPSDTP5) NOLOGGING';
--                      EXECUTE IMMEDIATE v_index;

              EXCEPTION
               WHEN OTHERS THEN

                       l_LogRec.mig_batch_id:='0-0';
                      l_LogRec.migrArea      :=   'TBL OPERATION LA' ;
                      l_LogRec.migrStep      :=   'MIGR_SETUP.TBL_OPERATION_LA' ;
                      l_LogRec.migrRelTbl    :=   NULL;
                      l_LogRec.migrRelKey  :=   NULL;
                      l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(v_index, 1, 2000)   ;
                      MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

              END;

            END if;
--valex.3/11/1016 - end

        END LOOP;
        CLOSE fetch_file_names;
      END LOOP;
      CLOSE fetch_bolag_names;

    EXCEPTION
      WHEN OTHERS THEN

            l_LogRec.mig_batch_id:='0-0';
            l_LogRec.migrArea      :=   'TBL OPERATION LA' ;
            l_LogRec.migrStep      :=   'MIGR_SETUP.TBL_OPERATION_LA' ;
            l_LogRec.migrRelTbl    :=   NULL;
            l_LogRec.migrRelKey  :=   NULL;
            l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(l_create_st, 1, 2000)   ;
            MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END TBL_OPERATION_LA;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

   --PROCEDURE THAT CREATES,DROP  EXT TABLES
  PROCEDURE TBL_OPERATION_EXT(OPERATION IN VARCHAR2)
    AS
      l_create_st   VARCHAR2(2100);
      l_file_name   NVARCHAR2(200);
      l_bolag_name  NVARCHAR2(50);
      l_dir_obj     NVARCHAR2(100);
      l_prefix      NVARCHAR2(100);
      l_delimiter   VARCHAR2(10);
      l_file_prefix VARCHAR2(20);
      l_tfile_etx   VARCHAR2(10);
      l_tbl_cnt     PLS_INTEGER;
      l_recon_file  ETL_SETUP_INFO.MIGG_RECON_FILE_NAME % TYPE;
      l_LogRec MIGR_GVAR.LogRecTyp;

      CURSOR fetch_fextn IS
          SELECT FILE_EXTN,
                 MIGG_DELIMITER,
                 MIGG_RECON_FILE_NAME
            FROM ETL_SETUP_INFO
            WHERE 1 = 1
              AND ROWNUM = 1;

      CURSOR fetch_file_names IS
          SELECT DISTINCT (etd.TBLNAME)
            FROM ETL_TBL_DEF etd
            WHERE 1 = 1
              AND etd.FILE_ROLE <> 'Derived'
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y'                 --- +++ anb 2016-02-03 skip reconciliation file
            ORDER BY etd.TBLNAME;
      CURSOR fetch_bolag_names IS
          SELECT BOLAG_NAME
            FROM ETL_BOLAG_INFO
            WHERE 1 = 1
            ORDER BY BOLAG_ID
      ;

    BEGIN

      --Fetch file etxension, delimiter, reconciliation filename from ETL_SETUP_INFO (FILE_EXTN)
      OPEN fetch_fextn;
      FETCH fetch_fextn INTO l_tfile_etx, l_delimiter, l_recon_file;
      CLOSE fetch_fextn;
      l_delimiter := CHR(39) || l_delimiter || CHR(39);

      l_file_prefix := 'LA_';
      OPEN fetch_bolag_names;
      LOOP

      << bolag_names_loop >>
        FETCH fetch_bolag_names INTO l_bolag_name;

        EXIT WHEN fetch_bolag_names % NOTFOUND;

        OPEN fetch_file_names;
        LOOP

        << file_name_loop >>
          FETCH fetch_file_names INTO l_file_name;

          EXIT WHEN fetch_file_names % NOTFOUND;

          l_prefix := l_file_prefix || l_bolag_name || '_' || l_file_name || '_LOAD';
          CASE OPERATION
            WHEN 'CREATE' THEN l_dir_obj := 'READ_DIR_' || l_bolag_name;
                --  conserve space !!!
          --valex.15/9/16 - FETCH_ATTR_ext fetches fields as they are ordered in external files so as to be consistent. FETCH_ATTR has been updated to retreive first those who are used as PKs (as of TBL_DEF) and is used in LA,SA
           --     l_create_st := 'CREATE TABLE ' || l_prefix || '(' || FETCH_ATTR(l_file_name, FALSE, FALSE, FALSE, FALSE) || ')'
                l_create_st := 'CREATE TABLE ' || l_prefix || '(' || FETCH_ATTR_ext(l_file_name, FALSE, FALSE, FALSE, FALSE) || ')'
            --valex.15/9/16 - end
                || 'ORGANIZATION EXTERNAL ( TYPE oracle_loader DEFAULT DIRECTORY ' || l_dir_obj
                || ' ACCESS PARAMETERS (RECORDS DELIMITED BY X' || q'['0D0A']' || ' CHARACTERSET WE8ISO8859P1 badfile '
                || l_dir_obj || ':' || CHR(39) || l_prefix || '.bad' || CHR(39) || ' logfile '
                || l_dir_obj || ':' || CHR(39) || l_prefix || '.log' || CHR(39) || ' FIELDS TERMINATED BY ' || l_delimiter
                || ' LRTRIM MISSING FIELD VALUES ARE NULL) LOCATION (' || CHR(39) || l_bolag_name || '_' || l_file_name || '.' || l_tfile_etx || CHR(39)
                || ' ))REJECT LIMIT UNLIMITED';
            WHEN 'DROP' THEN

                SELECT COUNT(*)
                  INTO l_tbl_cnt
                  FROM USER_TABLES
                  WHERE table_name = UPPER(l_prefix);
                IF l_tbl_cnt = 1
                THEN
                  -- +++ anb 2016-04-17 added CASCADE CONSTRAINTS PURGE

                  l_create_st := 'DROP TABLE ' || l_prefix || ' CASCADE CONSTRAINTS PURGE';
                ELSE
                  l_create_st := 'select 1 from dual';
                END IF;
            ELSE

              l_create_st := 'SELECT ' || CHR(39) || 'ERROR-Wrong Operation' || CHR(39) || ' FROM DUAL';

          END CASE;

          BEGIN

            EXECUTE IMMEDIATE l_create_st;
          EXCEPTION
            WHEN OTHERS THEN

                  l_LogRec.mig_batch_id:='0-0';
                  l_LogRec.migrArea      :=   'MIGR_SETUP.TBL_OPERATION_EXT' ;
                  l_LogRec.migrStep      :=  OPERATION ;
                  l_LogRec.migrRelTbl    :=   NULL;
                  l_LogRec.migrRelKey  :=   NULL;
                  l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(l_create_st, 1, 2000)   ;
                  MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

          END;

        END LOOP file_name_loop;
        CLOSE fetch_file_names;
      END LOOP bolag_names_loop;
      CLOSE fetch_bolag_names;

    EXCEPTION
      WHEN OTHERS THEN
            l_LogRec.mig_batch_id:='0-0';
            l_LogRec.migrArea      :=   'MIGR_SETUP.TBL_OPERATION_EXT' ;
            l_LogRec.migrStep      :=  'TBL OPERATION EXT' ;
            l_LogRec.migrRelTbl    :=   NULL;
            l_LogRec.migrRelKey  :=   NULL;
            l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(l_create_st, 1, 2000)   ;
            MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END TBL_OPERATION_EXT;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20160510 PROCEDURE THAT CREATES,DROP   TABLES THAT WILL HOLD POLICY OBJECTS
  PROCEDURE TBL_POLICY_OBJ(OPERATION IN VARCHAR2)
    AS
      l_create_st VARCHAR2(2100);
      l_tbl_cnt   NUMBER;
      l_LogRec       MIGR_GVAR.LogRecTyp;

    BEGIN
      CASE OPERATION
        WHEN 'CREATE' THEN l_create_st :=
            ' CREATE TABLE VILLAHEM_POLICY (IDPL  NUMBER, IDPLPS NUMBER,IA_IDPL NUMBER, IA_IDPLPS  NUMBER,
              IA_POLICY_REF  NUMBER(10, 0),IA_LFINSA  NUMBER(3, 0),IA_LFINSB NVARCHAR2(2),IA_PSTP  NVARCHAR2(2), IA_VILLAHEM NVARCHAR2(207),
              IA_OBJECT_ID NVARCHAR2(294),IA_OBJECT_TYPE NVARCHAR2(50),IA_HOME_TYPE NVARCHAR2(50), IA_HOME_SUBTYPE NVARCHAR2(50),  MIG_MUTUAL_ID VARCHAR2(2 BYTE),MIG_BATCH_ID  VARCHAR2(50 BYTE),
              MIG_FLAG NUMBER(*, 0), MIG_TIMESTAMP TIMESTAMP(6))';
        WHEN 'DROP' THEN SELECT COUNT(*)
              INTO l_tbl_cnt
              FROM USER_TABLES
              WHERE TABLE_NAME = 'VILLAHEM_POLICY';
            IF l_tbl_cnt = 1
            THEN

              l_create_st := 'DROP TABLE ' || 'VILLAHEM_POLICY' || ' CASCADE CONSTRAINTS PURGE';
            ELSE
              l_create_st := 'select 1 from dual';
            END IF;
        ELSE l_create_st := 'SELECT ' || CHR(39) || 'ERROR-Wrong Operation' || CHR(39) || ' FROM DUAL';

      END CASE;

      BEGIN
        EXECUTE IMMEDIATE l_create_st;
      EXCEPTION
        WHEN OTHERS THEN

                  l_LogRec.mig_batch_id:='0';
                  l_LogRec.migrArea      :=   'MIGR_SETUP.TBL_POLICY_OBJ' ;
                  l_LogRec.migrStep      :=  OPERATION ;
                  l_LogRec.migrRelTbl    :=   NULL;
                  l_LogRec.migrRelKey  :=   NULL;
                  l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(l_create_st, 1, 2000)   ;
                  MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
      END;


    EXCEPTION
      WHEN OTHERS THEN
                  l_LogRec.mig_batch_id:='0-0';
                  l_LogRec.migrArea      :=   'MIGR_SETUP.TBL_POLICY_OBJ' ;
                  l_LogRec.migrStep      :=  ' TBL POLICY OBJ' ;
                  l_LogRec.migrRelTbl    :=   NULL;
                  l_LogRec.migrRelKey  :=   NULL;
                  l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(l_create_st, 1, 2000)   ;
                  MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END TBL_POLICY_OBJ;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --function that returns the attribute fields based on file name
  -- valex.15/9/16 - fields that are used as PK (as of ETL_TBL_DEF) are retreived first in LA, SA tables creation
  -- +++ anb 2016-02-09 added ADDTNL fields flag for NP427F
  -- +++ valex 2/6/2016 process DATE fields  also

  FUNCTION FETCH_ATTR(FILE_NAME    IN VARCHAR2,
                      NO_TYPES     IN BOOLEAN,
                      IS_SA        IN BOOLEAN,
                      W_ADD_FIELDS IN BOOLEAN,
                      ADDTNL       IN BOOLEAN)
    RETURN VARCHAR2
    IS
      l_attrs         VARCHAR2(2100);
      l_file_name_in  NVARCHAR2(50);
      l_field_name_in NVARCHAR2(50);
      l_data_type_in  NVARCHAR2(50);
      l_data_size_in  NVARCHAR2(50);
      l_addtnl_fields NVARCHAR2(500);
      l_row_nr        PLS_INTEGER;
      l_FILE_ROLE     NVARCHAR2(50);
      l_LogRec  MIGR_GVAR.LogRecTyp;


      --cursor that fetches the actual data per row
      CURSOR fetch_row_data (l_file_name_in IN VARCHAR2) IS

-- valex.15/9/16 - fields that are used as PK (as of ETL_TBL_DEF) are retreived first in LA, SA tables creation
--          SELECT *
--            FROM ETL_MIGG_SOURCES
--            WHERE FILE_NAME = l_file_name_in
--            ORDER BY ROW_NR;
         with cte as (SELECT *
                      FROM ETL_MIGG_SOURCES a,ETL_TBL_DEF b
                      WHERE FILE_NAME=l_file_name_in  and a.FILE_NAME=b.TBLNAME
                          )
                          ,x AS (
                                  SELECT file_name,field_name,data_type,data_size,ROW_NR,FILE_ROLE
                                  ,((case WHEN FIELD_NAME=PK1 THEN 5 ELSE 0 END)+
                                  (case WHEN FIELD_NAME=PK2 THEN 4 ELSE 0 END)+
                                  (case WHEN FIELD_NAME=PK3 THEN 3 ELSE 0 END)+
                                  (case WHEN FIELD_NAME=PK4 THEN 2 ELSE 0 END)+
                                  (case WHEN FIELD_NAME=PK5 THEN 1 ELSE 0 END)) AS pk
                                  FROM cte)

                                ,y  AS (select file_name,field_name,data_type,data_size,FILE_ROLE,ROW_NR FROM x where pk >0 ORDER BY pk desc)
                                ,y1 AS (select file_name,field_name,data_type,data_size,FILE_ROLE,ROW_NR FROM x where pk =0 ORDER BY ROW_NR )
     SELECT * FROM y union ALL SELECT * FROM y1;
-- valex.15/9/16 - end

    BEGIN
      l_attrs := NULL;
      OPEN fetch_row_data (FILE_NAME);
      LOOP
        FETCH fetch_row_data INTO l_file_name_in, l_field_name_in, l_data_type_in, l_data_size_in, l_FILE_ROLE, l_row_nr;
        EXIT WHEN fetch_row_data % NOTFOUND;
        IF (NO_TYPES)
        THEN
          l_attrs := l_attrs || ' ' || l_field_name_in || ',';
        ELSIF (NOT NO_TYPES)
        --valex 2/6/2016 process DATE fields  also
        THEN
          IF l_data_type_in = 'DATE'
          THEN
            l_attrs := l_attrs || ' ' || l_field_name_in || ' ' || l_data_type_in || ',';
          ELSE
            l_attrs := l_attrs || ' ' || l_field_name_in || ' ' || l_data_type_in || '(' || l_data_size_in || ')' || ',';
          END IF;
        --valex 2/6/2016 end
        END IF;
      END LOOP;
      CLOSE fetch_row_data;

      -- +++ anb 2015-10-20 added INSRPRD field
      -- +++ anb 2016-02-09 added NO_IDPL controls
      --check if additional fields are required

      IF (W_ADD_FIELDS)
      THEN

         --FA.20160406 Change field list attr order so to be as declared in etl_engine - Problem with bulk insert operations
        IF (IS_SA)
        THEN
          IF (NO_TYPES)
          THEN

            -- pl 20161027 new offering code field
            -- l_attrs := l_attrs || 'POLICY_REF, INSRPRD, IDPL, IDPLPS, IDPLPSDT, IDPLPSDTP5, MIG_FLAG, MIG_BATCH_ID, MIG_TIMESTAMP, MIG_MUTUAL_ID';
            l_attrs := l_attrs || 'POLICY_REF, INSRPRD, OFFRNCODE, IDPL, IDPLPS, IDPLPSDT, IDPLPSDTP5, MIG_FLAG, MIG_BATCH_ID, MIG_TIMESTAMP, MIG_MUTUAL_ID';
          ELSE

            -- valex.14/9/16 - change the type of IDPLPSDT and IDPLPSDTP5 fields to varchar  in case of varchar vPK4 and/or vPK5 (vPK1 to vPK3 are always number)
            -- pl 20161027 new offering code field
            -- l_attrs := l_attrs || 'POLICY_REF NUMBER(10,0),INSRPRD NVARCHAR2(20), IDPL  NUMBER, IDPLPS  NUMBER, IDPLPSDT  NUMBER, IDPLPSDTP5   NUMBER, MIG_FLAG   NUMBER(*, 0), MIG_BATCH_ID  VARCHAR2(50), MIG_TIMESTAMP TIMESTAMP(6), MIG_MUTUAL_ID VARCHAR2(2 BYTE)';
            -- l_attrs := l_attrs || 'POLICY_REF NUMBER(10,0), INSRPRD NVARCHAR2(20), IDPL  NUMBER, IDPLPS  NUMBER, IDPLPSDT  NVARCHAR2(200), IDPLPSDTP5   NVARCHAR2(200), MIG_FLAG   NUMBER(*, 0), MIG_BATCH_ID  VARCHAR2(50), MIG_TIMESTAMP TIMESTAMP(6), MIG_MUTUAL_ID VARCHAR2(2 BYTE)';
            l_attrs := l_attrs || 'POLICY_REF NUMBER(10,0), INSRPRD NVARCHAR2(20), OFFRNCODE NVARCHAR2(20), IDPL  NUMBER, IDPLPS  NUMBER, IDPLPSDT  NVARCHAR2(200), IDPLPSDTP5   NVARCHAR2(200), MIG_FLAG   NUMBER(*, 0), MIG_BATCH_ID  VARCHAR2(50), MIG_TIMESTAMP TIMESTAMP(6), MIG_MUTUAL_ID VARCHAR2(2 BYTE)';
            --valex.14/9/16 - end
          END IF;
        ELSE
          IF (NO_TYPES)
          THEN

            l_addtnl_fields := ' MIG_FLAG, MIG_BATCH_ID, MIG_TIMESTAMP';
            IF (ADDTNL)
            THEN
              l_addtnl_fields := 'POLICY_REF, IDPL, IDPLPS, IDPLPSDT, IDPLPSDTP5,' || l_addtnl_fields;
            END IF;
            l_attrs := l_attrs || l_addtnl_fields;
          ELSE

            l_addtnl_fields := ' MIG_FLAG NUMBER(*, 0), MIG_BATCH_ID VARCHAR2(50), MIG_TIMESTAMP TIMESTAMP(6)';
            IF (ADDTNL)
            THEN

            --valex.14/9/16 - change the type of IDPLPSDT and IDPLPSDTP5 fields to varchar  in case of varchar vPK4 and/or vPK5 (vPK1 to vPK3 are always number)
            --  l_addtnl_fields := 'POLICY_REF NUMBER(10,0), IDPL NUMBER, IDPLPS NUMBER, IDPLPSDT NUMBER, IDPLPSDTP5  NUMBER,' || l_addtnl_fields;
              l_addtnl_fields := 'POLICY_REF NUMBER(10,0), IDPL NUMBER, IDPLPS NUMBER, IDPLPSDT NVARCHAR2(200), IDPLPSDTP5  NVARCHAR2(200),' || l_addtnl_fields;
            --valex.14/9/16 -
            END IF;
            l_attrs := l_attrs || l_addtnl_fields;
          END IF;
        END IF;


      ELSE
-- valex.28/9/2016 - brings SA_B_* tables spec with additional fields
--        l_attrs := SUBSTR(l_attrs, 1, INSTR(l_attrs, ',', -1) - 1);
--        if l_FILE_ROLE<>'Derived' THEN
        if l_FILE_ROLE<>'Derived'/* AND l_FILE_ROLE<>'Discounts'*/ THEN -- pl 20161219 add discounts role
          l_attrs := SUBSTR(l_attrs, 1, INSTR(l_attrs, ',', -1) - 1);
        else
          l_attrs := l_attrs || ' MIG_FLAG, MIG_BATCH_ID, MIG_TIMESTAMP';
        END IF;
-- valex.28/9/2016 - end
      END IF;
      RETURN l_attrs;

    EXCEPTION
      WHEN OTHERS THEN
              l_LogRec.mig_batch_id:='0-0';
              l_LogRec.migrArea      :=   'MIGR_SETUP.FETCH_ATTR' ;
              l_LogRec.migrStep      :=  ' FETCH ATTR' ;
              l_LogRec.migrRelTbl    :=   NULL;
              l_LogRec.migrRelKey  :=   NULL;
              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(l_attrs, 1, 2000)   ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END FETCH_ATTR;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 --valex.15/9/16 - function that returns the attribute fields based on file name, without reordering them. Is is used only in creation of external tables
  FUNCTION FETCH_ATTR_ext(FILE_NAME    IN VARCHAR2,
                      NO_TYPES     IN BOOLEAN,
                      IS_SA        IN BOOLEAN,
                      W_ADD_FIELDS IN BOOLEAN,
                      ADDTNL       IN BOOLEAN)
    RETURN VARCHAR2
    IS
      l_attrs         VARCHAR2(2100);
      l_file_name_in  NVARCHAR2(50);
      l_field_name_in NVARCHAR2(50);
      l_data_type_in  NVARCHAR2(50);
      l_data_size_in  NVARCHAR2(50);
      l_addtnl_fields NVARCHAR2(500);
      l_row_nr        PLS_INTEGER;
      l_LogRec  MIGR_GVAR.LogRecTyp;

      --cursor that fetches the actual data per row
      CURSOR fetch_row_data (l_file_name_in IN VARCHAR2) IS
          SELECT *
            FROM ETL_MIGG_SOURCES
            WHERE FILE_NAME = l_file_name_in
            ORDER BY ROW_NR;


    BEGIN
      l_attrs := NULL;
      OPEN fetch_row_data (FILE_NAME);
      LOOP
        FETCH fetch_row_data INTO l_file_name_in, l_field_name_in, l_data_type_in, l_data_size_in, l_row_nr;
        EXIT WHEN fetch_row_data % NOTFOUND;
        IF (NO_TYPES)
        THEN
          l_attrs := l_attrs || ' ' || l_field_name_in || ',';
        ELSIF (NOT NO_TYPES)
        --valex 2/6/2016 process DATE fields  also
        THEN
          IF l_data_type_in = 'DATE'
          THEN
            l_attrs := l_attrs || ' ' || l_field_name_in || ' ' || l_data_type_in || ',';
          ELSE
            l_attrs := l_attrs || ' ' || l_field_name_in || ' ' || l_data_type_in || '(' || l_data_size_in || ')' || ',';
          END IF;
        --valex 2/6/2016 end
        END IF;
      END LOOP;
      CLOSE fetch_row_data;

      -- +++ anb 2015-10-20 added INSRPRD field
      -- +++ anb 2016-02-09 added NO_IDPL controls
      --check if additional fields are required

      IF (W_ADD_FIELDS)
      THEN

         --FA.20160406 Change field list attr order so to be as declared in etl_engine - Problem with bulk insert operations
        IF (IS_SA)
        THEN
          IF (NO_TYPES)
          THEN

            l_attrs := l_attrs || 'POLICY_REF,INSRPRD, IDPL, IDPLPS, IDPLPSDT, IDPLPSDTP5, MIG_FLAG, MIG_BATCH_ID, MIG_TIMESTAMP, MIG_MUTUAL_ID';
          ELSE

          --valex.14/9/16 - change the type of IDPLPSDT and IDPLPSDTP5 fields to varchar  in case of varchar vPK4 and/or vPK5 (vPK1 to vPK3 are always number)
           -- l_attrs := l_attrs || 'POLICY_REF NUMBER(10,0),INSRPRD NVARCHAR2(20), IDPL  NUMBER, IDPLPS  NUMBER, IDPLPSDT  NUMBER, IDPLPSDTP5   NUMBER, MIG_FLAG   NUMBER(*, 0), MIG_BATCH_ID  VARCHAR2(50), MIG_TIMESTAMP TIMESTAMP(6), MIG_MUTUAL_ID VARCHAR2(2 BYTE)';
            l_attrs := l_attrs || 'POLICY_REF NUMBER(10,0),INSRPRD NVARCHAR2(20), IDPL  NUMBER, IDPLPS  NUMBER, IDPLPSDT  NVARCHAR2(200), IDPLPSDTP5   NVARCHAR2(200), MIG_FLAG   NUMBER(*, 0), MIG_BATCH_ID  VARCHAR2(50), MIG_TIMESTAMP TIMESTAMP(6), MIG_MUTUAL_ID VARCHAR2(2 BYTE)';
            --valex.14/9/16 - end
          END IF;
        ELSE
          IF (NO_TYPES)
          THEN

            l_addtnl_fields := ' MIG_FLAG, MIG_BATCH_ID, MIG_TIMESTAMP';
            IF (ADDTNL)
            THEN
              l_addtnl_fields := 'POLICY_REF,IDPL, IDPLPS , IDPLPSDT , IDPLPSDTP5,' || l_addtnl_fields;
            END IF;
            l_attrs := l_attrs || l_addtnl_fields;
          ELSE

            l_addtnl_fields := 'MIG_FLAG NUMBER(*, 0), MIG_BATCH_ID  VARCHAR2(50), MIG_TIMESTAMP   TIMESTAMP(6)';
            IF (ADDTNL)
            THEN

            --valex.14/9/16 - change the type of IDPLPSDT and IDPLPSDTP5 fields to varchar  in case of varchar vPK4 and/or vPK5 (vPK1 to vPK3 are always number)
            --  l_addtnl_fields := 'POLICY_REF NUMBER(10,0),IDPL  NUMBER, IDPLPS   NUMBER, IDPLPSDT NUMBER, IDPLPSDTP5  NUMBER,' || l_addtnl_fields;
              l_addtnl_fields := 'POLICY_REF NUMBER(10,0),IDPL  NUMBER, IDPLPS   NUMBER, IDPLPSDT NVARCHAR2(200), IDPLPSDTP5  NVARCHAR2(200),' || l_addtnl_fields;
            --valex.14/9/16 -
            END IF;
            l_attrs := l_attrs || l_addtnl_fields;
          END IF;
        END IF;


      ELSE
        l_attrs := SUBSTR(l_attrs, 1, INSTR(l_attrs, ',', -1) - 1);
      END IF;
      RETURN l_attrs;

    EXCEPTION
      WHEN OTHERS THEN
              l_LogRec.mig_batch_id:='0-0';
                  l_LogRec.migrArea      :=   'MIGR_SETUP.FETCH_ATTR_ext' ;
                  l_LogRec.migrStep      :=  ' FETCH ATTR ext' ;
                  l_LogRec.migrRelTbl    :=   NULL;
                  l_LogRec.migrRelKey  :=   NULL;
                  l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(l_attrs, 1, 2000)   ;
                  MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
    END FETCH_ATTR_ext;


 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  --valex.15/9/16 - end

  --PROCEDURE THAT CREATES LA,SA and DF TABLES
  PROCEDURE CREATE_TABLES
    AS

     l_LogRec  MIGR_GVAR.LogRecTyp;

    BEGIN

      TBL_OPERATION_EXT('CREATE');
      TBL_OPERATION_LA('CREATE');
      TBL_OPERATION_SA('CREATE');
      CLIENT_TBL_OPERATION_EXT('CREATE'); --valex.1/3/17 - create CLIENT_LOAD
     -- TBL_OPERATION_SA_CLUSTERING('CREATE');
    EXCEPTION
      WHEN OTHERS THEN
             l_LogRec.mig_batch_id:='0-0';
                  l_LogRec.migrArea      :=   'MIGR_SETUP.CREATE_TABLES' ;
                  l_LogRec.migrStep      :=  ' CREATE TABLES' ;
                  l_LogRec.migrRelTbl    :=   NULL;
                  l_LogRec.migrRelKey  :=   NULL;
                  l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM   ;
                  MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END CREATE_TABLES;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE THAT DROPS ALL TABLE OBJECTS
  PROCEDURE DROP_TABLES_OBJS
    AS

     l_LogRec  MIGR_GVAR.LogRecTyp;

    BEGIN
      TBL_OPERATION_EXT('DROP');
      TBL_OPERATION_LA('DROP');
      TBL_OPERATION_SA('DROP');
      CLIENT_TBL_OPERATION_EXT('DROP'); --valex.1/3/17 - drop CLIENT_LOAD if exists
    --  TBL_OPERATION_SA_CLUSTERING('DROP');

    EXCEPTION
      WHEN OTHERS THEN

        l_LogRec.mig_batch_id:='0-0';
                  l_LogRec.migrArea      :=   'MIGR_SETUP.DROP_TABLES_OBJS' ;
                  l_LogRec.migrStep      :=  ' DROP TABLES' ;
                  l_LogRec.migrRelTbl    :=   NULL;
                  l_LogRec.migrRelKey  :=   NULL;
                  l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM   ;
                  MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;


    END DROP_TABLES_OBJS;

 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDURE THAT DROPS ALL DIRECTORY OBJECTS
  PROCEDURE DROP_DIR_OBJS
    AS
      l_object_name NVARCHAR2(50);
      l_create_st   VARCHAR(500);
      l_LogRec  MIGR_GVAR.LogRecTyp;

      CURSOR fetch_directory_objs IS
          SELECT OBJECT_NAME
            FROM ALL_OBJECTS
            WHERE OBJECT_NAME LIKE 'READ_DIR%'
      ;
    BEGIN
      OPEN fetch_directory_objs;
      LOOP
        FETCH fetch_directory_objs INTO l_object_name;
        EXIT WHEN fetch_directory_objs % NOTFOUND;

        l_create_st := 'DROP DIRECTORY ' || l_object_name;

        BEGIN

          EXECUTE IMMEDIATE l_create_st;
        EXCEPTION
          WHEN OTHERS THEN NULL;
        END;
      END LOOP;
      CLOSE fetch_directory_objs;

    EXCEPTION
      WHEN OTHERS THEN

        l_LogRec.mig_batch_id:='0-0';
                  l_LogRec.migrArea      :=   'MIGR_SETUP.DROP_DIR_OBJS' ;
                  l_LogRec.migrStep      :=  ' DROP DIR OBJS' ;
                  l_LogRec.migrRelTbl    :=   NULL;
                  l_LogRec.migrRelKey  :=   NULL;
                  l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || ' l_create_st:'|| l_create_st   ;
                  MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END DROP_DIR_OBJS;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --PROCEDUERE THAT INITIALIZES DIRECTORY OBJECTS
  PROCEDURE INIT_DIRECTORY_OBJECTS
    AS

       l_LogRec  MIGR_GVAR.LogRecTyp;

      CURSOR fetch_bolag_names IS
          SELECT ebi.BOLAG_NAME
            FROM ETL_BOLAG_INFO ebi;
      l_migg_dir      VARCHAR2(500);
      l_migg_arch_dir  VARCHAR2(500);
      l_bolag_name    VARCHAR2(50);
      l_stateme       VARCHAR2(1000);
     -- l_stateme_obj   VARCHAR2(100);
      IS_DIR_EXISTS   PLS_INTEGER;
      IS_OBJ_EXISTS   PLS_INTEGER;
    -- vg 2018-06-19
    L_OS_SLASH VARCHAR2(1);
    BEGIN
           l_LogRec.mig_batch_id:='0-0';
                  l_LogRec.migrArea      :=   'MIGR_SETUP.INIT_DIRECTORY_OBJECTS' ;
                  l_LogRec.migrStep      :=  ' INIT DIRECTORY OBJECTS' ;
                  l_LogRec.migrRelTbl    :=   NULL;
                  l_LogRec.migrRelKey  :=   NULL;
    -- vg 2018-06-19
      SELECT MIGG_DIR, OS_SLASH
        INTO l_migg_dir,L_OS_SLASH
        FROM ETL_SETUP_INFO;

      SELECT MIGG_DIR_ARCHIVE
        INTO l_migg_arch_dir
        FROM ETL_SETUP_INFO;

      OPEN fetch_bolag_names;
      LOOP
        FETCH fetch_bolag_names INTO l_bolag_name;
        EXIT WHEN fetch_bolag_names % NOTFOUND;
        --CREATION OF OBJECT DIRECTORIES : A directory object specifies an alias for a directory on the server file system where external binary file LOBs (BFILEs) and external table data are located.
        -- vg 2018-06-19
        --l_stateme := 'CREATE OR REPLACE DIRECTORY READ_DIR_' || l_bolag_name || ' as ''' || l_migg_dir || '\' || l_bolag_name || '''';
        l_stateme := 'CREATE OR REPLACE DIRECTORY READ_DIR_' || l_bolag_name || ' as ''' || l_migg_dir || L_OS_SLASH || l_bolag_name || '''';
        EXECUTE IMMEDIATE l_stateme;
        --CHECK DIRECTORY EXISTANCE
        SELECT DBMS_LOB.fileexists(BFILENAME('READ_DIR_' || l_bolag_name, '.'))
          INTO IS_DIR_EXISTS
          FROM DUAL;
        IF (IS_DIR_EXISTS = 0)
        THEN

              L_LogRec.logMsg        :=  'READ_DIR_'||l_bolag_name||' DOESN''T EXIST';
              MIGR_LOG.LOG_ERROR(l_LogRec) ;

        END IF;

        --CREATION OF ARCHIVE DIRECTORIES
        -- vg 2018-06-19
        -- l_stateme := 'CREATE OR REPLACE DIRECTORY READ_DIR_' || l_bolag_name || '_ARCHIVE as ''' || l_migg_arch_dir || '\' || l_bolag_name || '''';
        l_stateme := 'CREATE OR REPLACE DIRECTORY READ_DIR_' || l_bolag_name || '_ARCHIVE as ''' || l_migg_arch_dir || L_OS_SLASH || l_bolag_name || '''';
        --DBMS_OUTPUT.PUT_LINE(l_stateme);
        EXECUTE IMMEDIATE l_stateme;
        --CHECK DIRECTORY EXISTANCE
        SELECT DBMS_LOB.fileexists(BFILENAME('READ_DIR_' || l_bolag_name || '_ARCHIVE', '.'))
          INTO IS_DIR_EXISTS
          FROM DUAL;
        IF (IS_DIR_EXISTS = 0)
        THEN
              l_LogRec.logMsg        :=     'READ_DIR_'||l_bolag_name||'_ARCHIVE  DOESN''T EXISTS';
              MIGR_LOG.LOG_ERROR(l_LogRec) ;

        END IF;
      END LOOP;
      CLOSE fetch_bolag_names;
    EXCEPTION
      WHEN OTHERS THEN

              l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || ' l_stateme:'|| l_stateme   ;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END INIT_DIRECTORY_OBJECTS;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  -- This is to be placed between READ_EXCEL and CREATE_TABLES in MIGR_SETUP.RUN_SETUP
  -- Returns FALSE if problems were found; TRUE if no problems/errors

  FUNCTION VERIFY_ETL_TABLES
    RETURN BOOLEAN
    AS
      etl_tbl_def_rownum     NUMBER;
      etl_migg_source_rownum NUMBER;
      sum_of_nulls           NUMBER;
      vSQl                   VARCHAR2(2100);
     l_LogRec  MIGR_GVAR.LogRecTyp;

    BEGIN

      vSQl := '';

        l_LogRec.mig_batch_id:='0-0';
                  l_LogRec.migrArea      :=   'MIGR_SETUP.VERIFY_ETL_TABLES' ;
                  l_LogRec.migrStep      :=  ' VERIFY ETL TABLES' ;
                  l_LogRec.migrRelTbl    :=   NULL;
                  l_LogRec.migrRelKey  :=   NULL;



      SELECT COUNT(TBLNAME)
        INTO etl_tbl_def_rownum
        FROM ETL_TBL_DEF
        WHERE NVL(IS_ACTIVE, 'N') = 'Y';               --- +++ anb 2016-02-034 for NP427F

      IF etl_tbl_def_rownum = 0
      THEN
              L_LogRec.logMsg        :=  'Rowcount:' || etl_tbl_def_rownum;
                  MIGR_LOG.LOG_ERROR(l_LogRec) ;



        RETURN FALSE;
      END IF;
      SELECT COUNT(DISTINCT FILE_NAME)
        INTO etl_migg_source_rownum
        FROM ETL_MIGG_SOURCES;
      IF etl_migg_source_rownum = 0
      THEN
            L_LogRec.logMsg        := 'ETL_MIGG_SOURCES table is empty' ||   ' Rowcount:' || etl_migg_source_rownum;
             MIGR_LOG.LOG_ERROR(l_LogRec) ;

        RETURN FALSE;
      END IF;

      -- compare table counts from the 2 tables
      IF etl_tbl_def_rownum <> etl_migg_source_rownum
      THEN

            L_LogRec.logMsg        :=  'ETL table entries do not match.' ||  'ETL_DEF:' || etl_tbl_def_rownum || ' MIGG_SOURCES:' || etl_migg_source_rownum;
            MIGR_LOG.LOG_ERROR(l_LogRec) ;

        RETURN FALSE;
      END IF;

      -- Check structure of ETL_TBL_DEF i.e. correct numbers of PKs per table
      FOR cRecord IN (SELECT *
          FROM ETL_TBL_DEF etd
          WHERE NVL(IS_ACTIVE, 'N') = 'Y')
      LOOP
        sum_of_nulls := 0;
        IF cRecord.PK1 IS NULL
        THEN
          sum_of_nulls := sum_of_nulls + 1;
        END IF;
        IF cRecord.PK2 IS NULL
        THEN
          sum_of_nulls := sum_of_nulls + 1;
        END IF;
        IF cRecord.PK3 IS NULL
        THEN
          sum_of_nulls := sum_of_nulls + 1;
        END IF;
        IF cRecord.PK4 IS NULL
        THEN
          sum_of_nulls := sum_of_nulls + 1;
        END IF;
        IF cRecord.PK5 IS NULL
        THEN
          sum_of_nulls := sum_of_nulls + 1;
        END IF;

        IF (cRecord.NUM_KEYS <> (5 - sum_of_nulls))
        THEN

            L_LogRec.logMsg        :=  'ETL_TBL_DEF table:' || cRecord.TBLNAME || ' has wrong number of keys ' ||  'found :' || sum_of_nulls || ' defined:' || cRecord.NUM_KEYS;
            MIGR_LOG.LOG_ERROR(l_LogRec) ;

          RETURN FALSE;
        END IF;
      END LOOP;

      RETURN TRUE;

    EXCEPTION
      WHEN OTHERS THEN
             L_LogRec.logMsg        :=  SQLERRM;
             MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

          RETURN FALSE;

    END VERIFY_ETL_TABLES;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE READ_EXCEL
    AS
      vSQL            VARCHAR2(3000) := '';
      vMIGGSourcesDIR ETL_SETUP_INFO.MIGG_SOURCES_DIR % TYPE;
      vMIGGDir        ETL_SETUP_INFO.MIGG_DIR % TYPE;
       l_LogRec  MIGR_GVAR.LogRecTyp;

    BEGIN
           l_LogRec.mig_batch_id:='0-0';
            l_LogRec.migrArea      :=   'MIGR_SETUP.READ_EXCEL' ;
            l_LogRec.migrStep      :=  ' MIGG_SOURCES' ;
            l_LogRec.migrRelTbl    :=   NULL;
            l_LogRec.migrRelKey  :=   NULL;


      vSQL := 'TRUNCATE TABLE ETL_MIGG_SOURCES';
      EXECUTE IMMEDIATE vSQL;

     --FA.20160901 Add no data found exception
      BEGIN
        SELECT MIGG_SOURCES_DIR
          INTO vMIGGSourcesDIR
          FROM ETL_SETUP_INFO
          WHERE ROWNUM = 1;

        --CREATE OR REPLACE DIRECTORY MIGG_DIR AS
        vSQL := 'CREATE OR REPLACE DIRECTORY MIGG_SOURCE_DIR AS ' || '''' || vMIGGSourcesDIR || '''';
        EXECUTE IMMEDIATE vSQL;

      EXCEPTION
        WHEN NO_DATA_FOUND THEN

            L_LogRec.logMsg        :=  SQLERRM;
           MIGR_LOG.LOG_EXCEPTION(l_LogRec)  ;
      END;

      -- +++ anb 206-02-17 add row_nr to MIGG_SOURCES
      -- +++ valex.2/6/2016 add functionality for DATE type and include in processing B_PRSN

      vSQL := 'INSERT INTO ETL_MIGG_SOURCES (FILE_NAME, FIELD_NAME, DATA_TYPE, DATA_SIZE, ROW_NR) '
      || 'WITH main_qry AS ( '
      || ' SELECT SHEET_NAME, ROW_NR, COL_NR, CELL, CELL_TYPE, STRING_VAL, NUMBER_VAL '
      || ' FROM TABLE( as_read_xlsx.read( as_read_xlsx.file2blob(' || q'['MIGG_SOURCE_DIR']' || ', ' || q'['MIGG.xlsx']' || ' ) ) ) '
      || ' WHERE 1=1 )'
      || ' select sn.sheet_name '
      || ', (select y.string_val from main_qry y where y.cell = ' || q'['G']' || '||rn.ROW_NR AND y.sheet_name = sn.sheet_name) as Fieldname '
      || ', (case when (select substr(y.string_val,1,1) from main_qry y where y.cell = ' || q'['L']' || '||rn.ROW_NR '
      || ' AND y.sheet_name = sn.sheet_name)= ' || q'['A']' || ' '
      || '     then ' || q'['NVARCHAR2']'
      || ' when (select substr(y.string_val,1,1) from main_qry y where y.cell = ' || q'['L']' || '||rn.ROW_NR '
      || ' AND y.sheet_name = sn.sheet_name)= ' || q'['P']' || ' '
      || '     then ' || q'['NUMBER']'
      || ' else ' || q'['DATE']' || ' '
      || '    end) as cFieldType'
      || ', (case when (select substr(y.string_val,1,1) from main_qry y where y.cell = ' || q'['L']' || '||rn.ROW_NR '
      || ' AND y.sheet_name = sn.sheet_name) in (''P'',''D'') '
      || '     then (select (case WHEN y.CELL_TYPE=' || q'['S']' || ' then nvl(y.string_val,0) when y.CELL_TYPE=' || q'['N']' || ' '
      || ' then TO_CHAR(nvl(y.number_val,0)) else ' || q'['']' || ' end) '
      || ' from main_qry y where y.cell = ' || q'['I']' || '||rn.ROW_NR AND y.sheet_name = sn.sheet_name) || ' || q'[',']' || ' '
      || ' || (select (case when y.CELL_TYPE=' || q'['S']' || ' then nvl(y.string_val,0) when y.CELL_TYPE=' || q'['N']' || ' '
      || ' then TO_CHAR(nvl(y.number_val,0)) else ' || q'['']' || ' END) '
      || ' from main_qry y where y.cell = ' || q'['J']' || '||rn.ROW_NR AND y.sheet_name = sn.sheet_name) '
      || '     else (select (CASE when y.CELL_TYPE=' || q'['S']' || ' THEN NVL(y.STRING_VAL,0) WHEN y.CELL_TYPE=' || q'['N']' || ' '
      || ' then to_CHAR(NVL(y.number_val,0)) ELSE ' || q'['']' || ' END) '
      || ' from main_qry y where y.cell =' || q'['H']' || '||rn.ROW_NR AND y.sheet_name = sn.sheet_name) '
      || '  end ) as cFieldLenDec '
      || ', rn.ROW_NR '
      || ' from ( SELECT DISTINCT SHEET_NAME '
      || ' FROM main_qry '
--      || ' WHERE 1=1 and (SHEET_NAME LIKE ''KF%'' or SHEET_NAME LIKE ''NP%'' or SHEET_NAME = ''B_PRSN'' or SHEET_NAME = ''B_ADDRESS'')'
--      || ' WHERE 1=1 and (SHEET_NAME LIKE ''KF%'' or SHEET_NAME LIKE ''NP%'' or SHEET_NAME = ''B_PRSN'' or SHEET_NAME = ''B_ADDRESS'' OR SHEET_NAME = ''MD_DISCOUNTS'')' -- pl 20161219 add discount table
      || ' WHERE 1=1 and (SHEET_NAME LIKE ''KF%'' or SHEET_NAME LIKE ''NP%'' or SHEET_NAME = ''B_PRSN'' or SHEET_NAME = ''B_ADDRESS'' OR SHEET_NAME = ''MD_DISCOUNTS'' OR SHEET_NAME = ''BR161F'')' -- pl 20170321 add br161f
      || ' ) sn , '
      || '( SELECT DISTINCT sheet_name, ROW_NR '
      || '  FROM main_qry '
      || '  WHERE 1=1 AND NVL(STRING_VAL,' || q'['NULL']' || ')<>' || q'['NULL']' || ' '
      || '     AND ROW_NR>(case when sheet_name = ' || q'['KF100F']' || ' then 2 else 1 end) '
      || '     AND length(regexp_replace(STRING_VAL,''[[:space:]]*'',''''))>0 '     --valex 20/4/16 trim all spaces
      || ')  rn '
      || ' where 1=1  AND rn.sheet_name = sn.sheet_name '
      || ' ORDER by sn.sheet_name, rn.row_nr ';

      EXECUTE IMMEDIATE vSQL;

    EXCEPTION
      WHEN OTHERS THEN
          L_LogRec.logMsg        :=  SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END READ_EXCEL;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- +++ anb 2016-02-03 added LA, SA fields (for recon file NP427F)
  -- +++ valex 18/4/2016 added field EXTRA_WHERE to ETL_ENGINE
  -- +++ valex 19/4/2016 added field EXTRA_WHERE2 to ETL_ENGINE and renamed EXTRA_WHERE to EXTRA_WHERE1 (EW1 for renewals while EW2 for not renewals mode)
  -- +++ valex.2/6/2016 exclude B_PRSN from SA
  PROCEDURE REBUILD_ETL
    AS
      vSQL                VARCHAR2(2000);
      vSQL1               VARCHAR2(500);
      vSQL11              VARCHAR2(2000);
      vSQL111             VARCHAR2(2000);
      vSQL2               VARCHAR2(500);
      vSQL22              VARCHAR2(2000);
      vSQL222             VARCHAR2(2000);
      vSQL3               VARCHAR2(500);
      vSQL33              VARCHAR2(2000);
      vSQL333             VARCHAR2(2000);
      vSQL4               VARCHAR2(500);
      vSQL44              VARCHAR2(2000);
      vSQL444             VARCHAR2(2000);
      vSQL5               VARCHAR2(500);
      vSQL55              VARCHAR2(2000);
      vSQL555             VARCHAR2(2000);
      vSQLPK1PK2          VARCHAR2(2000);
      vSQLPK1PK2PK3       VARCHAR2(2000);
      vSQLPK1PK2PK3PK4    VARCHAR2(2000);
      vSQLPK1PK2PK3PK4PK5 VARCHAR2(2000);
      vSQLPolicyREF       VARCHAR2(100);
      vInsPrd             VARCHAR2(20);
      vOFFRN              VARCHAR2(20);

    --valex.3/11/2016 - archive process relative fields
      vsql6                VARCHAR2(2000);
      vsql7                VARCHAR2(2000);
      vSQL8           VARCHAR2(2000);
      v_master_iot_match  VARCHAR2(500);
      v_IOT_TBL VARCHAR2(500);
      v_null_fields VARCHAR2(1000);
      v_regex VARCHAR2(1000);
      v_la_check_tbl  VARCHAR2(30);
      v_master_load_tbl  VARCHAR2(300);
      v_master_load_join_condition VARCHAR2(2000);
      v_fields_identified VARCHAR2(2000);
      v_iot_fld   VARCHAR2(100);
      v_master_iot_not_match   VARCHAR2(100);
      v_iot_fields   VARCHAR2(100);
      v_mult_table   VARCHAR2(500);
      v_pk_list_tbl_identified VARCHAR2(2000);
   --valex.3/11/2016 - end

      vBlg                VARCHAR2(100);
      vPK1                VARCHAR2(2000);
      vPK2                VARCHAR2(2000);
      vPK3                VARCHAR2(2000);
      vPK4                VARCHAR2(2000);
      vPK5                VARCHAR2(2000);


      vCnt                BOOLEAN;
      vPrefix             VARCHAR2(50);
      vSRCE               VARCHAR2(100);
      vBolag_name         VARCHAR2(10);

      l_addtnl_fields     VARCHAR2(500);
      l_addtnl_fld_val    VARCHAR2(500);

        l_LogRec  MIGR_GVAR.LogRecTyp;
      -- +++ valex 18/4/2016  fields for renewals mode handling
      vRenewal            VARCHAR2(2100);
      vNotRenewal         VARCHAR2(50) := NULL;
      vMaster_file        VARCHAR2(30);


    BEGIN
      EXECUTE IMMEDIATE 'TRUNCATE TABLE ETL_ENGINE';

      SELECT tblname
        INTO vMaster_file
        FROM ETL_TBL_DEF
        WHERE file_role = 'Master';

--valex.3/11/2016 - new cursor to accomodate archive process needs
--      FOR cBlg IN (SELECT bi.BOLAG_ID,
--                          bi.BOLAG_NAME,
--                          etd.TBLNAME,
--                          etd.PK1,
--                          etd.PK2,
--                          etd.PK3,
--                          etd.PK4,
--                          etd.PK5,
--                          NVL(etd.LA, 'N') AS LA,
--                          NVL(etd.SA, 'N') AS SA,
--                          NVL(etd.ADDTNL, 'N') AS ADDTNL,
--                          etd.renewal_month,
--                          etd.RENEWAL_YEAR,
--                          etd.file_role
--
--          FROM ETL_BOLAG_INFO bi,
--               ETL_TBL_DEF etd
--          WHERE 1 = 1
--            AND NVL(bi.IS_ACTIVE, 0) = 1
--            AND NVL(etd.IS_ACTIVE, 'N') = 'Y')
--      LOOP
        FOR cBlg IN (SELECT bi.BOLAG_ID,
                            bi.BOLAG_NAME,
                            etd.TBLNAME,
                            etd.PK1,
                            etd.PK2,
                            etd.PK3,
                            etd.PK4,
                            etd.PK5,
                            NVL(etd.LA, 'N') AS LA,
                            NVL(etd.SA, 'N') AS SA,
                            NVL(etd.ADDTNL, 'N') AS ADDTNL,
                            etd.renewal_month,
                            etd.RENEWAL_YEAR,
                            etd.FILE_ROLE,
                            etd.IOT,
                            b.PK1  as pk_recon,
                            c.TBLNAME AS master_tblname,
                            (CASE WHEN etd.PK1 is NOT null THEN 'x.'|| etd.PK1 || ',' else null end) || (CASE WHEN etd.PK2 is NOT null THEN 'x.'||etd.PK2 || ',' else null end) AS PKS,
                            (CASE when etd.PK1 is NOT null THEN etd.PK1 else NULL END) ||(CASE when etd.PK2 is NOT null THEN ','||etd.PK2 else NULL END)|| (CASE when etd.PK3 is NOT null THEN ','||etd.PK3 else NULL END)||',mig_batch_id' as v_iot_fields
            FROM ETL_BOLAG_INFO bi,
                 ETL_TBL_DEF etd,
          (SELECT pk1 FROM ETL_TBL_DEF where FILE_ROLE='Reconciliation') b,
          (SELECT tblname FROM ETL_TBL_DEF where FILE_ROLE='Master') c
            WHERE 1 = 1
              AND NVL(bi.IS_ACTIVE, 0) = 1
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y')
        LOOP
--valex.3/11/2016 - end
      << field_loop >>
        vSQL := ' ';

        vSQL := FETCH_ATTR(cBlg.TBLNAME, TRUE, FALSE, FALSE, (CASE WHEN cBlg.ADDTNL = 'Y' THEN TRUE ELSE FALSE END));

        -- we assume that primary key PK1 is always filled
        vSQL1 := '';
        vSQL11 := '';
        vSQL111 := '';
        vSQL2 := '';
        vSQL22 := '';
        vSQL222 := '';
        vSQL3 := '';
        vSQL33 := '';
        vSQL333 := '';
        vSQL4 := '';
        vSQL44 := '';
        vSQL444 := '';
        vSQL5 := '';
        vSQL55 := '';
        vSQL555 := '';
        vSQLPK1PK2 := '';
        vSQLPK1PK2PK3 := '';
        vSQLPK1PK2PK3PK4 := '';
        vSQLPK1PK2PK3PK4PK5 := '';
        vSQLPolicyREF := ' ';
        v_master_load_join_condition:='';
--valex.3/11/2016 - initialization of archive relative fields
        v_pk_list_tbl_identified:='';
        v_fields_identified:='';
      --  v_iot_join_condition:='';
        v_master_iot_match:='';
        v_master_iot_not_match:='';
        v_mult_table:='';
        vSQL6 := '';
        vSQL7 := '';
        vSQL8 := '';
        v_IOT_TBL:='';
        v_null_fields:='';
        v_regex:='';
        v_la_check_tbl:='';
        v_master_load_tbl:='';
        v_iot_fld:='';
--valex.3/11/2016 - end

        IF cBlg.PK1 IS NOT NULL
        THEN
          vSQL1 := 'ON TL.' || cBlg.PK1 || '= TH.' || cBlg.PK1;
          vSQL6 := 'ON TL.' || cBlg.PK1 || '= TI.' || cBlg.PK1;                 --valex.3/11/2016 - join condition for IOT
          vSQL11 := 'TH.' || cBlg.PK1 || ' IS NULL';
          vSQL111 := cBlg.PK1;
        END IF;
        IF cBlg.PK2 IS NOT NULL
        THEN
          vSQL2 := ' AND TL.' || cBlg.PK2 || '= TH.' || cBlg.PK2;
          vSQL7 := ' AND TL.' || cBlg.PK2 || '= TI.' || cBlg.PK2;                 --valex.3/11/2016 - join condition for IOT
          vSQL22 := ' AND TH.' || cBlg.PK2 || ' IS NULL';
          vSQL222 := cBlg.PK2;
        END IF;
        IF cBlg.PK3 IS NOT NULL
        THEN
          vSQL3 := ' AND TL.' || cBlg.PK3 || '= TH.' || cBlg.PK3;
          vSQL8 := ' AND TL.' || cBlg.PK3 || '= TI.' || cBlg.PK3;                 --valex.3/11/2016 - join condition for IOT
          vSQL33 := ' AND TH.' || cBlg.PK3 || ' IS NULL';
          vSQL333 := cBlg.PK3;
        END IF;
--valex.3/11/2016 - PK4 and PK5 are commented out because PK1 to PK3 (IDPL,IDPLPS) are sufficient for duplicate checking
--        IF cBlg.PK4 IS NOT NULL
--        THEN
--          vSQL4 := ' AND TL.' || cBlg.PK4 || '= TH.' || cBlg.PK4;
--          vSQL44 := ' AND TH.' || cBlg.PK4 || ' IS NULL';
--          vSQL444 := cBlg.PK4;
--        END IF;
--        IF cBlg.PK5 IS NOT NULL
--        THEN
--          vSQL5 := ' AND TL.' || cBlg.PK5 || '= TH.' || cBlg.PK5;
--          vSQL55 := ' AND TH.' || cBlg.PK5 || ' IS NULL';
--          vSQL555 := cBlg.PK5;
--        END IF;
--valex.3/11/2016 - end

        vBolag_name := cBlg.BOLAG_NAME;

        v_master_iot_match:=TRIM(TRAILING ' ' FROM vSQL11) || TRIM(TRAILING ' ' FROM vSQL22);               --valex.3/11/2016 - match where condition with KF_100F_IOT has only KF100F fields for NORMAL files
        v_master_iot_not_match:=REGEXP_REPLACE(v_master_iot_match,'TH.','TI.',1,0);                       --valex.3/11/2016 - for LOG_RECORDS_NOT_IN_MASTER_FILE procedure purpose

        vSQL1 := TRIM(TRAILING ' ' FROM vSQL1) || TRIM(TRAILING ' ' FROM vSQL2)
        || TRIM(TRAILING ' ' FROM vSQL3) || TRIM(TRAILING ' ' FROM vSQL4) || TRIM(TRAILING ' ' FROM vSQL5);
        vSQL11 := TRIM(TRAILING ' ' FROM vSQL11) || TRIM(TRAILING ' ' FROM vSQL22)
        || TRIM(TRAILING ' ' FROM vSQL33) || TRIM(TRAILING ' ' FROM vSQL44) || TRIM(TRAILING ' ' FROM vSQL55);

        vSQL6:=TRIM(TRAILING ' ' FROM vSQL6) || TRIM(TRAILING ' ' FROM vSQL7) ;                              --valex.3/11/2016 - join condition with KF100_IOT (second left join) contains only PK fields of KF100F (PK1,PK2))



        vSQLPolicyREF := cBlg.PK1 || ' as POLICY_REF ';
        --- +++ anb 2016-02-04 IDPl must be BB FFFFFFF NNN : BB=Bolag ID, FFFFFFF = 7-digit FONR (right pad with 0), NNN=3digit FOVNR (right pad with 0)

        vBlg := 'SUBSTR(''' || '00' || '''||' || CHR(39) || cBlg.BOLAG_ID || CHR(39) || ',-2)';
        vPK1 := 'SUBSTR(''' || '0000000' || '''||' || NVL(vSQL111, '') || ',-7)';
        vPK2 := 'SUBSTR(''' || '000' || CASE WHEN vSQL222 IS NOT NULL THEN '''||' || vSQL222 ELSE '''' END || ',-3)';
        vPK3 := NVL(vSQL333, CHR(39) || '' || CHR(39));
        vPK4 := NVL(vSQL444, CHR(39) || '' || CHR(39));
        vPK5 := NVL(vSQL555, CHR(39) || '' || CHR(39));


        vSQLPK1PK2 := 'TO_NUMBER(' || vBlg || '||' || vPK1 || '||' || vPK2 || ') as IDPL';
        vSQLPK1PK2PK3 := 'TO_NUMBER(' || vBlg || '||' || vPK1 || '||' || vPK2 || '||' || vPK3 || ') as IDPLPS ';
   --valex.14/9/16 - change the type of IDPLPSDT and IDPLPSDTP5 fields to varchar  in case of varchar vPK4 and/or vPK5 (vPK1 to vPK3 are always number)
        -- vSQLPK1PK2PK3PK4 := 'TO_NUMBER(' || vBlg || '||' || vPK1 || '||' || vPK2 || '||' || vPK3 || '||' || vPK4 || ') as IDPLPSDT ';
        -- vSQLPK1PK2PK3PK4PK5 := 'TO_NUMBER(' || vBlg || '||' || vPK1 || '||' || vPK2 || '||' || vPK3 || '||' || vPK4 || '||' || vPK5 || ') as IDPLPSDTP5 ';
        vSQLPK1PK2PK3PK4 := 'TO_char(' || vBlg || '||' || vPK1 || '||' || vPK2 || '||' || vPK3 || '||' || vPK4 || ') as IDPLPSDT ';
        vSQLPK1PK2PK3PK4PK5 := 'TO_char(' || vBlg || '||' || vPK1 || '||' || vPK2 || '||' || vPK3 || '||' || vPK4 || '||' || vPK5 || ') as IDPLPSDTP5 ';
   --valex.14/9/16 - end

        -- +++ valex 18/4/2016 build extra where field



--valex.17/1/2017 - renewal date will be computed before insert_LA procedure and passed in it as a parameter for performance improvement purpose
--        vRenewal := ' WHERE TO_NUMBER(SUBSTR(''0000000''||' || cBlg.PK1 || ',-7)||SUBSTR(''000''||' || cBlg.PK2 || ',-3)) in '
--        || '( SELECT  TO_NUMBER(SUBSTR(''0000000''||' || cBlg.PK1 || ',-7)||SUBSTR(''000''||' || cBlg.PK2 || ',-3))  FROM LA_' || cBlg.BOLAG_NAME || '_' || vMaster_file || '_LOAD MASTER_FILE '
--        || ' WHERE TO_DATE(' || CHR(39) || ' 01- ' || CHR(39) || ' || MASTER_FILE.' || cBlg.renewal_month || ' || ' || CHR(39) || '-' || CHR(39) || '|| MASTER_FILE.' || cBlg.renewal_year || ', ' || CHR(39) || 'dd/mm/yy' || CHR(39) || ')  ='
--        --|| ' TO_DATE(' || CHR(39) || vdate || CHR(39) || ',' || CHR(39) || 'DD/MM/YYYY' || CHR(39) || ')) ' ;
--
--      --valex.9/1/2017 - renewal date will be obtained by ETL_MIGRATION_CONDITIONS
--      -- || ' (select trunc(NEXT_RENEWAL_DATE) from  ETL_RENEWAL_DATE))';        -- +++ valex 19/4/2016
--
--         || '(SELECT trunc(RENEWAL_DATE) FROM (SELECT *   FROM ETL_MIGRATION_CONDITIONS   WHERE 1=1      and ITERATION_STATUS=''Pending''   oRDER by id) where ROWNUM=1))';
--      --valex.9/1/2017 -  end

        vRenewal := ' TO_NUMBER(SUBSTR(''0000000''|| TL.' || cBlg.PK1 || ',-7)||SUBSTR(''000''|| TL.' || cBlg.PK2 || ',-3))';

--valex.17/1/2017 - end
          --- +++ anb 2016-02-03 check if table will be added to LA stage
        IF cBlg.LA = 'Y'
        THEN

          IF cBlg.ADDTNL = 'Y'
          THEN
            l_addtnl_fields := ',POLICY_REF,IDPL,IDPLPS,IDPLPSDT,IDPLPSDTP5,MIG_FLAG,MIG_BATCH_ID,MIG_TIMESTAMP';
            l_addtnl_fld_val := ',' || vSQLPolicyREF || ',' || vSQLPK1PK2 || ',' || vSQLPK1PK2PK3 || ',' || vSQLPK1PK2PK3PK4 || ',' || vSQLPK1PK2PK3PK4PK5;
          ELSE
            l_addtnl_fields := ',MIG_FLAG,MIG_BATCH_ID,MIG_TIMESTAMP';
            l_addtnl_fld_val := '';
          --  vRenewal := NULL;   -- +++ valex 18/4/2016 extra where when not in renewals mode
          END IF;


--valex.17/1/17 - logic for master LOAD table join ( renewal date purpose )

         v_master_load_tbl:='LA_' || cBlg.BOLAG_NAME || '_' || cBlg.master_tblname || '_LOAD';
         v_master_load_join_condition:=REGEXP_REPLACE(vSQL6,'TI.','ML.',1,0) || ' and ' ||REGEXP_REPLACE(REGEXP_REPLACE(vSQL6,'TL.','ML.',1,0),'ON ','',1,0) || ' and '
               || ' TO_DATE(' || CHR(39) || ' 01- ' || CHR(39) || ' || ML.' || cBlg.renewal_month || ' || ' || CHR(39) || '-' || CHR(39) || '|| ML.' || cBlg.renewal_year || ', ' || CHR(39) || 'dd-mm-yyyy' || CHR(39) || ')';



   --valex.3/11/2016 - construction of IOT fields according to file role

            v_la_check_tbl:='LA_' || cBlg.BOLAG_NAME || '_' || cBlg.TBLNAME||'_IOT';




            IF cBlg.FILE_ROLE='Normal' OR cBlg.FILE_ROLE='Discounts' THEN    --valex.3/1/2017 - treat discounts file as NORMAL ones

               v_master_iot_match:=REGEXP_REPLACE(REGEXP_REPLACE(v_master_iot_match,'IS NULL','IS NOT NULL',1,0),'TH.','TI.',1,0);
               v_IOT_TBL:='LA_' || cBlg.BOLAG_NAME || '_' || cBlg.master_tblname || '_IOT';
               v_iot_fld:=cBlg.v_iot_fields;

         --      v_mult_table:=' when (tbl=''IOT'') then into LA_' || cBlg.BOLAG_NAME || '_' || cBlg.TBLNAME|| '_IOT(' || v_iot_fields ||') values (' || v_iot_fields ||')';

            elsIF cBlg.FILE_ROLE='Reconciliation' THEN
               v_master_iot_match:= REGEXP_REPLACE(vSQL11,'TH.','TI.',1,0);
               v_IOT_TBL:='(select ''1'' as ' || cBLg.pk_recon || ' from dual)';
               v_la_check_tbl:='LA_' || cBlg.BOLAG_NAME || '_' || cBlg.TBLNAME;
               v_iot_fld:='';
               v_master_iot_not_match:='';
           --  vSQL11:='1=1';
             -- v_iot_join_condition:=
              v_master_load_join_condition:= REGEXP_REPLACE(vSQL6,'TI.','ML.',1,0) || ' and ' || REGEXP_REPLACE(REGEXP_REPLACE(vSQL11,'TH.','ML.',1,0),'IS','IS NOT',1,0);
              v_master_load_tbl:='LA_' || cBlg.BOLAG_NAME || '_' || cBlg.TBLNAME||'_LOAD';
              vRenewal:=NULL; --renewal date filter is not applicable for Reconciliation file
            else
               v_master_iot_not_match:='';
               v_master_iot_match:= REGEXP_REPLACE(vSQL11,'TH.','TI.',1,0);
               v_IOT_TBL:='(select 1 as ' || cBlg.pk1 || ',1 as ' || cBlg.PK2 || ' from dual)';   --dummy table so that all data of master table to be loaded
               v_iot_fld:=cBlg.v_iot_fields;
               v_master_load_join_condition:=REGEXP_REPLACE(vSQL6,'TI.','ML.',1,0) || ' and '
               || ' TO_DATE(' || CHR(39) || ' 01- ' || CHR(39) || ' || ML.' || cBlg.renewal_month || ' || ' || CHR(39) || '-' || CHR(39) || '|| ML.' || cBlg.renewal_year || ', ' || CHR(39) || 'dd-mm-yyyy' || CHR(39) || ')';

           --   v_mult_table:=' when (tbl=''IOT'') then  into LA_' || cBlg.BOLAG_NAME || '_' || cBlg.TBLNAME|| '_IOT(' || v_iot_fields ||') values (' || v_iot_fields ||')';

            END IF;

            v_pk_list_tbl_identified:=REGEXP_REPLACE(REGEXP_REPLACE(l_addtnl_fld_val,'('||cblg.PK1||')','TN.\1',1,0),'('||cblg.PK2||')','TN.\1',1,0);

            v_null_fields:=REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(','||REGEXP_replace(vsql,' ','',1,0)||',',','|| cblg.PK1||',',',',1,0),','|| cblg.PK2||',',',',1,0),','|| cblg.pk_recon||',',',',1,0);
            v_null_fields:=SUBSTR(v_null_fields,2,INSTR(v_null_fields,',',-1)-2);
            v_regex:=REGEXP_REPLACE(v_null_fields,',','|',1,0);

            v_null_fields:=cBlg.PKS || REGEXP_REPLACE(v_null_fields,'('||v_regex||')','null \1',1,0);
--            v_null_fields:=REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(vsql,'[ ]*'|| c.PK1||'[ ]*,','',1,0),'[ ]*'|| c.PK2||'[ ]*,','',1,0),'[ ]*'|| c.pk_recon||'[ ]*,','',1,0),' ','',1,0);
--            v_regex:=REGEXP_REPLACE(REGEXP_REPLACE(v_null_fields,' ','',1,0),',','|',1,0);
--            v_null_fields:=cBlg.PKS || REGEXP_REPLACE(' '||v_null_fields||' ','('||v_regex||')',''''' \1',1,0);

            v_fields_identified:=REGEXP_replace(vsql,' ','',1,0);
            v_regex:=REGEXP_replace(v_fields_identified,',','|',1,0);
            v_fields_identified:=REGEXP_replace(v_fields_identified,'('||v_regex||')','TL.\1',1,0);


   --valex.3/11/2016 - end


          INSERT INTO ETL_ENGINE (
   --valex.3/11/2016 - addition of archive process relative fields to etl_engine
--            BOLAG_ID, tblname, MIGRATION_AREA, STEP, SOURCE_TABLE, DEST_TABLE, FIELD_LIST, ADDFLDS, JOIN_CONDITION, NOMATCH1, PK_LIST, BOLAG_NAME, EXTRA_WHERE1, EXTRA_WHERE2       -- +++ valex 18/4/2016  addition of final field (extra where clause for renewals)
            BOLAG_ID, tblname, MIGRATION_AREA, STEP, SOURCE_TABLE, DEST_TABLE, FIELD_LIST, ADDFLDS, JOIN_CONDITION, NOMATCH1, PK_LIST, BOLAG_NAME, EXTRA_WHERE1, EXTRA_WHERE2,IOT_fields,PK_LIST_WITH_TBL_IDENTIFIER,IOT_JOIN_CONDITION,IOT_MATCH,IOT_TABLE,IOT_NULL_FIELDS,EXIST_IN_LA_TBL,FIELD_LIST1,IOT_NOT_MATCH ,master_load_tbl,master_load_join_condition       -- +++ valex 18/4/2016  addition of final field (extra where clause for renewals)
          )
--          VALUES (cBlg.BOLAG_ID, cBlg.TBLNAME, 'Landing', 'Copy', 'LA_' || cBlg.BOLAG_NAME || '_' || cBlg.TBLNAME || '_LOAD', 'LA_' || cBlg.BOLAG_NAME || '_' || cBlg.TBLNAME, vSQL, l_addtnl_fields, vSQL1, vSQL11, l_addtnl_fld_val, cBlg.BOLAG_NAME, vRenewal, vNotRenewal)    -- +++ valex 19/4/2016 addition of final field   -- +++ valex 18/4/2016
          VALUES (cBlg.BOLAG_ID, cBlg.TBLNAME, 'Landing', 'Copy', 'LA_' || cBlg.BOLAG_NAME || '_' || cBlg.TBLNAME || '_LOAD', 'LA_' || cBlg.BOLAG_NAME || '_' || cBlg.TBLNAME, vSQL, l_addtnl_fields, vSQL1, vSQL11, l_addtnl_fld_val, cBlg.BOLAG_NAME, vRenewal, vNotRenewal,v_iot_fld,v_pk_list_tbl_identified,vSQL6,v_master_iot_match,v_IOT_TBL,v_null_fields,v_la_check_tbl,v_fields_identified,v_master_iot_not_match, v_master_load_tbl,v_master_load_join_condition )    -- +++ valex 19/4/2016 addition of final field   -- +++ valex 18/4/2016
   --valex.3/11/2016 - end
          ;
        END IF;

        -- INSERT STAGING AREA STATEMENTS
        vInsPrd := CHR(39) || ' ' || CHR(39);        --- will be set at SA stage
        vOFFRN := CHR(39) || ' ' || CHR(39);         --- pl 20161031 will be set at SA stage
        --- +++ anb 2016-02-03 check if table will be added to SA stage
        --valex.2/6/2016 exclude B_PRSN from SA

        IF cBlg.SA = 'Y'
          AND cBlg.FILE_ROLE <> 'Derived'
        THEN
          INSERT INTO ETL_ENGINE (
            BOLAG_ID, tblname, MIGRATION_AREA, STEP, SOURCE_TABLE, DEST_TABLE, FIELD_LIST, ADDFLDS, JOIN_CONDITION, NOMATCH1, PK_LIST, BOLAG_NAME
          )
            -- pl 20161027 new offering code field
            -- VALUES (cBlg.BOLAG_ID, cBlg.TBLNAME, 'Staging', 'Copy', 'LA_' || cBlg.BOLAG_NAME || '_' || cBlg.TBLNAME, 'SA_' || cBlg.TBLNAME, vSQL, ',POLICY_REF,INSRPRD,IDPL,IDPLPS,IDPLPSDT,IDPLPSDTP5,MIG_FLAG,MIG_BATCH_ID,MIG_TIMESTAMP,MIG_MUTUAL_ID', vSQL1, vSQL11, ',' || vSQLPolicyREF || ',' || vInsPrd || ',' || vSQLPK1PK2 || ',' || vSQLPK1PK2PK3 || ',' || vSQLPK1PK2PK3PK4 || ',' || vSQLPK1PK2PK3PK4PK5, cBlg.BOLAG_NAME)
          VALUES (cBlg.BOLAG_ID, cBlg.TBLNAME, 'Staging', 'Copy', 'LA_' || cBlg.BOLAG_NAME || '_' || cBlg.TBLNAME, 'SA_' || cBlg.TBLNAME, vSQL, ',POLICY_REF,INSRPRD,OFFRNCODE,IDPL,IDPLPS,IDPLPSDT,IDPLPSDTP5,MIG_FLAG,MIG_BATCH_ID,MIG_TIMESTAMP,MIG_MUTUAL_ID', vSQL1, vSQL11, ',' || vSQLPolicyREF || ',' || vInsPrd || ',' || vOFFRN || ',' || vSQLPK1PK2 || ',' || vSQLPK1PK2PK3 || ',' || vSQLPK1PK2PK3PK4 || ',' || vSQLPK1PK2PK3PK4PK5, cBlg.BOLAG_NAME)
          ;
        END IF;

      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN
            l_LogRec.mig_batch_id := '0-0';
            l_LogRec.migrArea     := 'MIGR_SETUP.REBUILD_ETL';
            l_LogRec.migrStep     := 'REBUILD ETL';
            l_LogRec.migrRelTbl   := NULL;
            l_LogRec.migrRelKey   := NULL;
            l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM;
            MIGR_LOG.LOG_EXCEPTION(l_LogRec);
    END REBUILD_ETL;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- P_FLAG = 0 -> MIGR_SETUP
  --        = 1 -> MIGR_SIGNAL
  PROCEDURE CHECK_SID (p_flag IN PLS_INTEGER)
    AS
      l_LogRec   MIGR_GVAR.LogRecTyp;
      l_migr_env VARCHAR2(50);
      l_env      VARCHAR2(50);

  BEGIN
      l_LogRec.migrArea     := 'MIGR_SETUP.CHECK_SID';
      l_LogRec.migrRelTbl   := NULL;
      l_LogRec.migrRelKey   := NULL;

      SELECT UPPER(value) INTO l_env FROM V$PARAMETER WHERE name LIKE '%service_name%';

      SELECT UPPER(MIGRATION_ENVIRONMENT) INTO l_migr_env FROM ETL_SETUP_INFO;

      IF l_env <> l_migr_env AND p_flag = 0 THEN
         l_LogRec.mig_batch_id := '0-0';
         l_LogRec.migrStep := 'MIGR_SETUP';
         l_LogRec.logMsg   := 'SID: ' || l_env || ' <> Migration Environment: ' || l_migr_env;
         MIGR_LOG.LOG_ERROR(l_LogRec);
      ELSIF l_env <> l_migr_env AND p_flag = 1 THEN
         l_LogRec.mig_batch_id := '0-1';
         l_LogRec.migrStep := 'MIGR_SIGNAL';
         l_LogRec.logMsg   := 'SID: ' || l_env || ' <> Migration Environment: ' || l_migr_env;
         MIGR_LOG.LOG_ERROR(l_LogRec);
         MIGR_API_COMMON.SUSPEND_MIGRATION(l_LogRec.logMsg, MIGR_GVAR.GV_MSG_CODE_ENVIRONMENT_ERR);
         --MIGR_EMAIL_NOTIFICATION.SEND_EMAIL_IMMEDIATE(l_LogRec.logMsg, MIGR_GVAR.GV_MSG_CODE_ENVIRONMENT_ERR);
      END IF;

  EXCEPTION
    WHEN OTHERS THEN
        l_LogRec.logMsg := SQLCODE || ' - ' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);
  END CHECK_SID;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  --PROCEDURE Main Setup

  PROCEDURE RUN_SETUP(p_schema IN VARCHAR2)
    AS
      vDeleteTableObjs BOOLEAN := TRUE;
      vDeleteDirObjs   BOOLEAN := TRUE;
      vCreateDirObjs   BOOLEAN := TRUE;
      vReadExcel       BOOLEAN := TRUE;
      vCreateTables    BOOLEAN := TRUE;
      vRebuild         BOOLEAN := TRUE;
      vTruncateStats   BOOLEAN := TRUE;
      l_LogRec         MIGR_GVAR.LogRecTyp;
      l_username    INSIS_PEOPLE_V10.P_USER_ACCOUNTS.USER_NAME%TYPE;
  BEGIN

      MIGR_SYSTEM.INIT_SYSTEM();
      l_LogRec.mig_batch_id := '0-0';
      l_LogRec.migrArea     := 'MIGR_SYSTEM.INIT_SYSTEM';

      l_LogRec.mig_batch_id := '0-0';
      l_LogRec.migrStep     := 'INIT SYSTEM';
      l_LogRec.migrRelTbl   := NULL;
      l_LogRec.migrRelKey   := NULL;


      -- Deletes all table objects (SA, LA)
      IF vDeleteTableObjs = TRUE
      THEN
        DROP_TABLES_OBJS();
        l_LogRec.migrArea := 'MIGR_SETUP.DROP_TABLES_OBJS';

      END IF;

      -- Deletes all directory objects (READ_DIR_M43)
      IF vDeleteDirObjs = TRUE
      THEN
        DROP_DIR_OBJS();
        l_LogRec.migrArea := 'MIGR_SETUP.DROP_DIR_OBJS';

      END IF;

      -- Creates all directory objects
      IF vCreateDirObjs = TRUE
      THEN
        INIT_DIRECTORY_OBJECTS();
        l_LogRec.migrArea := 'MIGR_SETUP.INIT_DIRECTORY_OBJECTS';

      END IF;

      -- Read excel and populate data into ETL_MIGG_SOURCES
      IF vReadExcel = TRUE
      THEN
        READ_EXCEL();
        -- ADD_FLDS_RECON();                -- ++ anb 2016-02-03 add fields for reconciliation file NP427F
        l_LogRec.migrArea := 'MIGR_SETUP.READ_EXCEL';

      END IF;

      -- Verify that ETL_TBL_DEF and ETL_MIGG_SOURCES are in sync.
      IF VERIFY_ETL_TABLES() = TRUE
      THEN

        -- Creates tables SA, LA based on ETL_MIGG_SOURCES
        IF vCreateTables = TRUE
        THEN
          CREATE_TABLES();                  -- LA and SA tables
          l_LogRec.migrArea := 'MIGR_SETUP.CREATE_TABLES';

        END IF;

        --Populates etl engine
        IF vRebuild = TRUE
        THEN
          REBUILD_ETL();
          l_LogRec.migrArea := 'MIGR_SETUP.REBUILD_ETL';

        END IF;

        MIGR_MAPS.RUN_MAPS();
        l_LogRec.migrArea := 'MIGR_MAPS.RUN_MAPS';


        -- Clear migration statistics tables
        IF vTruncateStats = TRUE
        THEN
          TRUNCATE_STATS();
          l_LogRec.migrArea := 'MIGR_SETUP.TRUNCATE_STATS';


        END IF;

        -- MIGR_LA_SA.TRUNCATE_ALL;        -- LA and SA tables

        -- Move to migr truncate tables: TRUNCATE TABLE MIGR_IA_SA_LIST';

        MIGR_API.TRUNCATE_MIGR_TABLES;     -- API MIGR_tables
        l_LogRec.migrArea := 'MIGR_API.TRUNCATE_MIGR_TABLES';


        MIGR_IA.REBUILD_SA_IA;             -- Rebuild from views
        l_LogRec.migrArea := 'MIGR_IA.REBUILD_SA_IA';


        MIGR_IA.RUN_IA_SETUP();            -- Drop and create IA_ tables
        l_LogRec.migrArea := 'MIGR_IA.RUN_IA_SETUP';

        CHECK_SID(0);
        l_LogRec.migrArea := 'MIGR_SETUP.CHECK_SID';


        -- MIGRATION REPORTING VIEWS
        --MIGR_REPORTING.MIGR_FACT();      -- CREATE OR REPLACE MIGR_FACT VIEW
        --l_LogRec.migrArea := 'MIGR_REPORTING.MIGR_FACT';
        --MIGR_REPORTING.MIGR_PREMIUMS();  -- CREATE OR REPLACE MIGR_PREMIUMS VIEW
        --l_LogRec.migrArea := 'MIGR_REPORTING.MIGR_PREMIUMS';
        l_LogRec.migrArea := 'MIGR_REPORTING.REPORTING';
        MIGR_REPORTING.REPORTING();
        l_LogRec.migrArea := 'MIGR_SETUP.INSIS bolag accounts';    --EZ 14/5/2019

        --FA.20170613 Populate dynamically the  INSIS user accounts in etl_bolag_info table
        -- +++ anb 20190515 - ETL_BOLAG_INFO will now have prepopulated BOLAG_USERNAME according to list from Goran Ahs.
        --                    These USERNAMES must be copied in all environments before migration.
        --                    The check should be for existance of these UserNames within P_USER_ACCOUNTS. If cannot be found, then EXCEPTION No-Data-Found.
        BEGIN
        FOR C IN (SELECT ebi.DEFAULT_OFFICE , ebi.BOLAG_USERNAME, ebi.BOLAG_ID FROM ETL_BOLAG_INFO ebi WHERE ebi.IS_ACTIVE='1' )
          LOOP

              SELECT pua.USER_NAME
                INTO l_username
                FROM INSIS_PEOPLE_V10.P_STAFF ps, INSIS_PEOPLE_V10.P_USER_ACCOUNTS pua
               WHERE ps.MAX_QUAL_LEVEL = 100
                 AND ps.ACCOUNT_ID = pua.ACCOUNT_ID
                 AND ps.OFFICE_ID = C.DEFAULT_OFFICE
                 AND  C.BOLAG_USERNAME = pua.USER_NAME     --EZ 14/5/2019
               order by  C.BOLAG_ID;

             -- UPDATE ETL_BOLAG_INFO SET BOLAG_USERNAME = l_username where DEFAULT_OFFICE = C.DEFAULT_OFFICE; --EZ 14/5/2019

          END LOOP;
        EXCEPTION
           WHEN OTHERS THEN

               l_LogRec.logMsg := 'Failed to retrieve the INSIS bolag accounts. ' || SQLCODE || '-' || SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec);
         END;

        l_LogRec.migrArea := 'End of MIGR_SETUP';
        MIGR_LOG.LOG_INFO(l_LogRec)  ;

      ELSE

         l_LogRec.migrArea := 'MIGR_SETUP did NOT complete';
         MIGR_LOG.LOG_ERROR(l_LogRec)  ;

      END IF;    -- Verify ETL_TABLES

      --FA.20160410 COMMIT all pending inserts
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
          l_LogRec.logMsg := 'Last succesfull step: ' || l_LogRec.migrArea || SQLCODE || '-' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END RUN_SETUP;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --valex.1/3/17 - this proc drops if exists and creates external table of CLIENT file (according to ETL_SETUP_INFO) and creates necessary oracle directories
  PROCEDURE CLIENT_TBL_OPERATION_EXT(OPERATION IN VARCHAR2)
    AS

      l_file_name   NVARCHAR2(200);
      l_bolag_name  NVARCHAR2(50);
      l_dir_obj     NVARCHAR2(100);
      l_dir_obj_arc NVARCHAR2(100);

      l_file        VARCHAR2(100);
      l_ext_tbl     VARCHAR2(100);
      IS_DIR_EXISTS PLS_INTEGER;
      l_LogRec MIGR_GVAR.LogRecTyp;
      l_create_st   VARCHAR2(32000);
      l_tbl_cnt     PLS_INTEGER;

    BEGIN

    FOR c IN ( SELECT CLIENT_MIGG_DIR,client_file_name,MIGG_DELIMITER,CLIENT_MIGG_DIR_ARC
               FROM ETL_SETUP_INFO
    )
    loop

      l_file := SUBSTR(c.client_file_name,1,INSTR(c.client_file_name,'.')-1); -- Client file name without file extention
      ----DBMS_OUTPUT.PUT_LINE(l_file);
      l_ext_tbl := l_file||'_LOAD';   --external table name
      l_dir_obj := 'READ_DIR_' || l_file;   --oracle directory where client txt resides
      l_dir_obj_arc := 'READ_DIR_' || l_file||'_ARC';   --oracle directory where client txt will be archived

      ---- Directories creation
      l_create_st := 'CREATE OR REPLACE DIRECTORY ' || l_dir_obj || ' as ''' || c.CLIENT_MIGG_DIR || '''';
      EXECUTE IMMEDIATE l_create_st;

      l_create_st := 'CREATE OR REPLACE DIRECTORY ' || l_dir_obj_arc || ' as ''' || c.CLIENT_MIGG_DIR_ARC || '''';
      EXECUTE IMMEDIATE l_create_st;

      -- CHECK DIRECTORY EXISTeNCE dynamicaly (DBMS_LOB.fileexists produces error if directory is passed by variable. it needs to be passed with its actual value)

      SELECT DBMS_LOB.fileexists(BFILENAME('READ_DIR_' || l_file, '.'))
        INTO IS_DIR_EXISTS
        FROM DUAL;

      IF (IS_DIR_EXISTS = 0) THEN
        l_LogRec.logMsg := l_dir_obj || ' DOES NOT EXIST';
        MIGR_LOG.LOG_ERROR(l_LogRec);
      END IF;

      EXECUTE IMMEDIATE l_create_st;

        CASE OPERATION
          WHEN 'CREATE' THEN

              l_create_st := 'CREATE TABLE ' || l_ext_tbl || '(SSN VARCHAR2(12), BOLAG_ID NUMBER(10, 0) )'

                    || 'ORGANIZATION EXTERNAL ( TYPE oracle_loader DEFAULT DIRECTORY ' || l_dir_obj
                    || ' ACCESS PARAMETERS (RECORDS DELIMITED BY X' || q'['0D0A']' || ' CHARACTERSET WE8ISO8859P1 badfile '
                    || l_dir_obj || ':' || CHR(39) || l_file || '.bad' || CHR(39) || ' logfile '
                    || l_dir_obj || ':' || CHR(39) || l_file || '.log' || CHR(39) || ' FIELDS TERMINATED BY ''' || c.MIGG_DELIMITER || ''''
                    || ' LRTRIM MISSING FIELD VALUES ARE NULL) LOCATION (''' ||c.CLIENT_FILE_NAME ||''''
                    || ' ))REJECT LIMIT UNLIMITED';
          WHEN 'DROP' THEN

              SELECT COUNT(*)
                INTO l_tbl_cnt
                FROM USER_TABLES
                WHERE table_name = UPPER(l_ext_tbl);
              IF l_tbl_cnt = 1
              THEN
                -- +++ anb 2016-04-17 added CASCADE CONSTRAINTS PURGE

                l_create_st := 'DROP TABLE ' || l_ext_tbl || ' CASCADE CONSTRAINTS PURGE';
              END IF;
          ELSE

                l_LogRec.logMsg        :=     'Wrong OPERATION value' ;
                MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

        END CASE;



        BEGIN

          EXECUTE IMMEDIATE l_create_st;
        EXCEPTION
          WHEN OTHERS THEN

                l_LogRec.mig_batch_id:='0-0';
                l_LogRec.migrArea      :=   'MIGR_SETUP.CLIENT_TBL_OPERATION_EXT' ;
                l_LogRec.migrStep      :=  OPERATION ;
                l_LogRec.migrRelTbl    :=   NULL;
                l_LogRec.migrRelKey  :=   NULL;
                l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(l_create_st, 1, 2000)   ;
                MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

        END;



    end LOOP;




    EXCEPTION
      WHEN OTHERS THEN
            l_LogRec.mig_batch_id:='0-0';
            l_LogRec.migrArea      :=   'MIGR_SETUP.CLIENT_TBL_OPERATION_EXT' ;
            l_LogRec.migrStep      :=  'CLIENT_TBL_OPERATION_EXT' ;
            l_LogRec.migrRelTbl    :=   NULL;
            l_LogRec.migrRelKey  :=   NULL;
            l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM || '-' || SUBSTR(l_create_st, 1, 2000)   ;
            MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

    END CLIENT_TBL_OPERATION_EXT;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    /*
        lob_replace
        param p_lob     in out clob - The clob string
        param p_what    in varchar2 - The string we want to find and replace
        param p_with    in varchar2 - The string that will replace the p_what
        param p_occur   in  number  - The find occurrence
    */
procedure lob_replace(p_lob IN OUT CLOB,p_what IN VARCHAR2,p_with IN VARCHAR2,p_occur in number := 1, p_case in varchar2 := 'ci') as
    n   number;
begin
    n := dbms_lob.instr(p_lob,p_what,1,p_occur);
    --case insensitive
    if nvl(n,0) <= 0 and p_case = 'ci' then
            n := dbms_lob.instr(lower(p_lob),lower(p_what),1,p_occur);
    end if;

    if
        ( nvl(n,0) > 0 )
    then
        dbms_lob.copy(p_lob,p_lob,dbms_lob.getlength(p_lob),n + length(p_with),n + length(p_what) );
        dbms_lob.write(p_lob,length(p_with),n,p_with);
        if
            ( length(p_what) > length(p_with) )
        then
            dbms_lob.trim(p_lob,dbms_lob.getlength(p_lob) - (length(p_what) - length(p_with)));
        end if;
    end if;
    exception when others then
        dbms_output.put_line('Error in function lob_replace: '||SQLCODE || '-' || SQLERRM);
end lob_replace;

END MIGR_SETUP;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_SIGNAL IS

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
FUNCTION IS_FILE_EXISTS (DIR IN VARCHAR2, FILE_NAME IN VARCHAR2) RETURN PLS_INTEGER IS
    l_file_loc  PLS_INTEGER;
    l_LogRec    MIGR_GVAR.LogRecTyp;
    -- vg 2018-06-19
    L_OS_SLASH VARCHAR2(1);
  BEGIN
   -- vg 2018-06-19
  SELECT OS_SLASH
        INTO L_OS_SLASH
        FROM ETL_SETUP_INFO;


    SELECT dbms_lob.fileexists(bfilename(upper(DIR), FILE_NAME))
      INTO l_file_loc
      FROM DUAL;

    RETURN l_file_loc;

  EXCEPTION WHEN OTHERS THEN
        l_LogRec.mig_batch_id := '0-1';
        l_LogRec.migrArea     := 'MIGR_SIGNAL.IS_FILE_EXISTS';
        l_LogRec.migrStep     := 'IS FILE EXISTS';
        l_LogRec.migrRelTbl   := NULL;
        l_LogRec.migrRelKey   := NULL;
        -- vg 2018-06-19
        -- l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM || '-' || DIR || '\' || FILE_NAME;
        l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM || '-' || DIR || L_OS_SLASH || FILE_NAME;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END IS_FILE_EXISTS;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
--PROCEDURE THAT CHECKS THE EXISTENCE OF COMPLETED.TXT FILES
-- function CHECK_FILES(p_queued_flag IN VARCHAR2) RETURN VARCHAR2
PROCEDURE CHECK_FILES(p_queued_flag IN VARCHAR2)
    IS

    -- l_file_name          VARCHAR(50);
    l_act_file           VARCHAR(50);
    l_act_file_exists    PLS_INTEGER;
    l_bolag_name         VARCHAR2(50);
    l_tfile_name         VARCHAR2(50);
    l_tfile_etx          VARCHAR2(10);
    l_stateme            VARCHAR2(100);
    l_file_exists        PLS_INTEGER;
    l_file_flag          BOOLEAN;
    l_bolag_id           PLS_INTEGER;
    vMigrationBatchId    VARCHAR2(50);
    l_times_run          PLS_INTEGER;
    v_time               TIMESTAMP ;
    l_completed_found    PLS_INTEGER := 0;
    vsql                 VARCHAR2(100);
    v_not_finished       PLS_INTEGER;
    l_LogRec             MIGR_GVAR.LogRecTyp;
    v_scan_for_completed BOOLEAN ;
    v_scan_for_discounts boolean;
    v_id                 PLS_INTEGER;
    L_SRVERRMSG          SRVERRMSG;
    PIO_ERR			         SRVERR;
    l_completed          ETL_SETUP_INFO.MIGG_FILE_NAME%TYPE;
    l_discounts_file     VARCHAR2(100);
    l_discounts_exists   PLS_INTEGER := 0;
    l_waiting_count      PLS_INTEGER;
    V_STATUS            VARCHAR2(50);
    l_eventTimer         TIMESTAMP;
    v_scan_bolag_completed   BOOLEAN;
  v_scan_bolag_discounts BOOLEAN;
  BEGIN

        vMigrationBatchId := NULL;
        l_LogRec.migrArea := 'MIGR_SIGNAL.CHECK_FILES';
        l_LogRec.mig_batch_id := '0-1';
        l_LogRec.migrArea     := 'MIGR_SIGNAL.CHECK_FILES';
        l_LogRec.migrStep     := 'CHECK FILES';
        l_LogRec.migrRelTbl   := NULL;
        l_LogRec.migrRelKey   := NULL;

        l_eventTimer := SYSTIMESTAMP;

        -- coordinate actions across different migration month iterations
        MIGRATION_SCHEDULE(v_id, v_scan_for_completed, v_scan_for_discounts);



        -- if within migration time window
        IF v_scan_for_discounts OR v_scan_for_completed THEN


         IF   v_scan_for_discounts then
                    l_LogRec.logMsg := 'Migration scheduled returned with true for check discounts';
                                   MIGR_LOG.LOG_INFO(l_LogRec);
         END IF;

            SELECT MIGG_FILE_NAME, FILE_EXTN, DISCOUNTS_FILE_NAME
              INTO l_tfile_name, l_tfile_etx, l_discounts_file
              FROM ETL_SETUP_INFO;

            -- Iterate through directories in order to check for completed.txt and/or discounts.txt, if applicable (based on OUT params of MIGRATION_SCHEDULE)
            FOR c IN ( SELECT BOLAG_NAME, BOLAG_ID
                         FROM ETL_BOLAG_INFO , (SELECT APPLICABLE_BOLAGS, MISSED_DATA_DEADLINE FROM ETL_MIGRATION_CONDITIONS WHERE ID=v_id)
                        WHERE ',' || APPLICABLE_BOLAGS || ',' LIKE '%,' || SUBSTR(BOLAG_NAME, 2) || ',%'
                          AND ',' || MISSED_DATA_DEADLINE || ',' NOT LIKE '%,' || SUBSTR(BOLAG_NAME, 2) || ',%' -- if bolag missed upload deadline will not be scanned for discounts.txt

            )
            LOOP
                      v_scan_bolag_completed :=v_scan_for_completed;
                      v_scan_bolag_discounts:=v_scan_for_discounts;


               --FA.20180220 skip folders for bolags that are in queued, running or running discounts state
              BEGIN
              SELECT STATUS
                INTO V_STATUS
                FROM(
                 SELECT A.*,MAX(START_TIMESTAMP) OVER () AS MAX_CREATED
                 FROM MIG_MIGRATION_INFO A WHERE BOLAG_ID=c.BOLAG_ID   )
                WHERE   START_TIMESTAMP =  MAX_CREATED ;


              CASE
                WHEN V_STATUS IN
                     (MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC, MIGR_GVAR.GV_BATCH_STATUS_QUEUED,MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC)
                THEN       v_scan_bolag_completed :=FALSE;  v_scan_bolag_discounts:=FALSE;

                    l_LogRec.logMsg := 'Will not check for completed or discounts for bolag: ' || c.BOLAG_ID;
                    MIGR_LOG.LOG_INFO(l_LogRec);


                WHEN  V_STATUS=  MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC    THEN    v_scan_bolag_completed :=FALSE;

                    l_LogRec.logMsg := 'Will  check only  for discounts for bolag: ' || c.BOLAG_ID;
                    MIGR_LOG.LOG_INFO(l_LogRec);



                ELSE

                   NULL;

                END CASE;

             EXCEPTION
                  WHEN NO_DATA_FOUND THEN
                             v_scan_bolag_completed:=v_scan_for_completed;
                             v_scan_bolag_discounts:=v_scan_for_discounts;

              END;

                IF v_scan_for_completed  AND  v_scan_bolag_completed THEN

                    l_file_flag := TRUE;

                    ---FA.20161104 Added to support both modes of file name: with or without bolag prefix
                    IF SUBSTR(l_tfile_name,1,1) = '_' THEN
                      l_completed := c.bolag_name||l_tfile_name;
                    ELSE
                      l_completed := l_tfile_name;
                    END IF;

                    l_file_exists := IS_FILE_EXISTS('READ_DIR_' || c.bolag_name, l_completed);

                    IF (l_file_exists = 1) THEN
                                    l_LogRec.logMsg := 'completed file exists : ' || c.BOLAG_ID;
                                   MIGR_LOG.LOG_INFO(l_LogRec);
                        -- once 'completed.txt' is found, make sure all KFxxx files are present in the bolag directory
                        FOR i IN( SELECT etd.TBLNAME
                                    FROM ETL_TBL_DEF etd
                                   WHERE 1=1
                                     AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
                                  -- AND file_role<>'Derived'                      -- valex 2/6/16. exclude B_PRSN file
                                     AND FILE_ROLE NOT IN ('Derived', 'Discounts') -- valex.3/1/2017 - also, do not search for discounts.txt
                        )
                        LOOP
                              l_act_file := c.BOLAG_NAME || '_' || i.TBLNAME || '.' || l_tfile_etx;
                              l_act_file_exists := IS_FILE_EXISTS('READ_DIR_' || c.bolag_name, l_act_file);

                              IF (l_act_file_exists = 0) THEN
                                  l_LogRec.logMsg := 'Missing File: ' || l_act_file;
                                  MIGR_LOG.LOG_ERROR(l_LogRec);
                                  l_file_flag := FALSE;
                              END IF;

                        END LOOP;

                        IF l_file_flag THEN

                           vMigrationBatchId := INIT_BATCH2(c.bolag_id, p_queued_flag); -- let it run
                        ELSE
                           vMigrationBatchId := INSERT_BATCH_JOB(c.bolag_id, MIGR_GVAR.GV_BATCH_STATUS_REJECTED); -- 'Rejected');
                           --FA.20180220 Archive is called at signal start only
                           ---MIGR_ARCHIVE.ARCHIVE_COMPLETED_FILE(vMigrationBatchId);
                           -- pl 20170214 REJECTED BATCH EMAIL NOTIFICATION
                           MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchId, MIGR_GVAR.GV_MSG_CODE_MIGR_REJECTED );
                        END IF;

                    END IF;
                END IF;

                if  v_scan_for_discounts AND v_scan_bolag_discounts THEN

                    l_discounts_exists := IS_FILE_EXISTS('READ_DIR_' || c.bolag_name, c.BOLAG_NAME || '_' || l_discounts_file);
                    IF (l_discounts_exists = 1) THEN

                        SELECT COUNT(*)
                          INTO l_waiting_count
                          FROM MIG_MIGRATION_INFO
                         WHERE SUBSTR(MIGRATION_BATCH_ID, 1, 2) = SUBSTR(c.BOLAG_NAME, 2)
                           AND STATUS = MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC;


                          IF l_waiting_count=1 THEN
                            UPDATE MIG_MIGRATION_INFO
                               SET STATUS = MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC
                             WHERE SUBSTR(MIGRATION_BATCH_ID, 1, 2) = SUBSTR(c.BOLAG_NAME, 2)
                               AND STATUS = MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC;
                          ELSIF l_waiting_count>1 THEN
                            l_LogRec.logMsg := 'More than one batches wait for discounts for Bolag: ' || SUBSTR(c.BOLAG_NAME, 2);
                            MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                          END IF;
                    END IF;
                END IF;

            END LOOP;
        END IF;

        -- Start MIGR_RUN_PARALLEL_JOB
        FOR c IN (SELECT STATUS, MIGRATION_BATCH_ID
                    FROM MIG_MIGRATION_INFO
                   WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_QUEUED, MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC)
                     AND ROWNUM = 1
                     AND 1 = (SELECT COUNT('X') FROM USER_SCHEDULER_JOBS WHERE JOB_NAME = 'MIGR_RUN_PARALLEL_JOB' AND STATE <> 'RUNNING')
        )
        LOOP

             MIGR_SCHEDULED_JOBS.ENABLE_MIGR_JOB('MIGR_RUN_PARALLEL_JOB');
             l_LogRec.logMsg := 'MIGR_RUN_PARALLEL_JOB is spawned';
             MIGR_LOG.LOG_INFO(l_LogRec) ;

        END LOOP;


        -- start MIGR_RUN_API
        FOR C IN (SELECT ID
                    FROM MIG_MIGRATION_INFO
                   WHERE 1=1
                     AND ROWNUM = 1
                     AND (SELECT COUNT('X') FROM MIG_MIGRATION_INFO WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_QUEUED,MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC,MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC))>0
                     AND 1 = (SELECT COUNT('X') FROM USER_SCHEDULER_JOBS WHERE JOB_NAME='MIGR_RUN_API' AND STATE<>'RUNNING')
--  LM - 20180302 - Choose parallel level according to daily plan in ETL_PARALLEL_LEVEL_PER_TIME table - Start
--                     AND 0 = (SELECT COUNT('x') FROM ETL_SETUP_INFO WHERE NVL(PARALLEL_LEVEL, 0) = 0) -- dont start if parallel level is 0 or null
                     AND 0 = (SELECT COUNT('x') FROM (SELECT CASE
                                  (SELECT PLAN FROM ETL_PARALLEL_LEVEL_PER_TIME eplpt
                                    WHERE TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) >=eplpt.TIME_FROM
                                      AND TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) <= eplpt.TIME_TO)
                                WHEN 'HIGH' THEN NVL(PARALLEL_LEVEL, 0)
                                WHEN 'MID'  THEN NVL(MID_PARALLEL_LEVEL, 0)
                                WHEN 'MIN'  THEN NVL(MIN_PARALLEL_LEVEL, 0)
                                ELSE 0
                               END AS NEW_PRL_LEVEL FROM ETL_SETUP_INFO) WHERE NEW_PRL_LEVEL = 0) -- dont start if parallel level is 0 or null
--  LM - 20180302 - End
        )
        LOOP
           MIGR_SCHEDULED_JOBS.ENABLE_MIGR_JOB('MIGR_RUN_API');
           l_LogRec.logMsg := 'MIGR_RUN_API is spawned';
           MIGR_LOG.LOG_INFO(l_LogRec);

        END LOOP;


        l_LogRec.logMsg := 'Total CHECK_FILES Process runtime: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
        MIGR_LOG.LOG_INFO(l_LogRec);

  EXCEPTION WHEN OTHERS THEN
      l_LogRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END CHECK_FILES;


---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
PROCEDURE CLOSE_PREVIOUS_BATCH_JOBS(vBOLAG_ID IN PLS_INTEGER) AS
  l_LogRec MIGR_GVAR.LogRecTyp;
BEGIN
      UPDATE MIG_MIGRATION_INFO
         SET STATUS = MIGR_GVAR.GV_BATCH_STATUS_STOPPED, END_TIMESTAMP = SYSTIMESTAMP
       WHERE STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING AND BOLAG_ID = vBOLAG_ID;

-- +++ anb 2015-09-23
EXCEPTION WHEN OTHERS THEN
    l_LogRec.mig_batch_id := vBOLAG_ID;
    l_LogRec.migrArea     := 'MIGR_SIGNAL.CLOSE_PREVIOUS_BATCH_JOBS';
    l_LogRec.migrStep     := 'CLOSE_PREVIOUS_BATCH_JOBS';
    l_LogRec.migrRelTbl   := NULL;
    l_LogRec.migrRelKey   := NULL;
    l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END CLOSE_PREVIOUS_BATCH_JOBS;

---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
--valex.21/12/2016 conditional update to support Discounts batches
---FA. 2015-10-20 set to autonomous transaction
PROCEDURE MAKE_RUNNABLE(vMigrationBatchID IN VARCHAR2, v_status IN VARCHAR2) AS
PRAGMA AUTONOMOUS_TRANSACTION;
  l_LogRec MIGR_GVAR.LogRecTyp;
BEGIN

  IF v_status = MIGR_GVAR.GV_BATCH_STATUS_QUEUED THEN

    --FA.20171129 At resume the process overrides the start timestamps- The start timestamps should not be overriden
        UPDATE MIG_MIGRATION_INFO
           SET STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING, START_TIMESTAMP =  --= SYSTIMESTAMP
            case when START_TIMESTAMP IS NULL THEN  SYSTIMESTAMP
              ELSE     START_TIMESTAMP
              end
         WHERE MIGRATION_BATCH_ID = vMigrationBatchID;

        -- PL 20170213 EMAIL NOTIFICATION
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchID, MIGR_GVAR.GV_MSG_CODE_MIGR_STARTED );

  ELSIF v_status = MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC THEN
      --FA.20171129 At resume the process overrides the discounts start timestamps- The start timestamps should not be overriden
        UPDATE MIG_MIGRATION_INFO
           SET STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC, DISCOUNTS_START_TIMESTAMP=  -- = SYSTIMESTAMP
             case when DISCOUNTS_START_TIMESTAMP IS NULL THEN  SYSTIMESTAMP
              ELSE     DISCOUNTS_START_TIMESTAMP
              end
         WHERE MIGRATION_BATCH_ID = vMigrationBatchID;

        -- PL 20170213 PHASE 2 EMAIL NOTIFICATION
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchID, MIGR_GVAR.GV_MSG_CODE_MIGR_PHASE_2 );

  END IF;

  COMMIT;

EXCEPTION WHEN OTHERS THEN
  ROLLBACK;
    l_LogRec.mig_batch_id := vMigrationBatchID;
    l_LogRec.migrArea     := 'MIGR_SIGNAL.MAKE_RUNNABLE';
    l_LogRec.migrStep     := 'MAKE_RUNNABLE';
    l_LogRec.migrRelTbl   := NULL;
    l_LogRec.migrRelKey   := NULL;
    l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END MAKE_RUNNABLE;

---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
--valex.20/4/16 change batch status
--FA. 20151106 Change status to finished
PROCEDURE CLOSE_BATCH(vMigrationBatchID IN VARCHAR2, pStatus in varchar2)
  AS
      PRAGMA AUTONOMOUS_TRANSACTION;
      l_LogRec MIGR_GVAR.LogRecTyp;

BEGIN
      UPDATE MIG_MIGRATION_INFO
         -- SET STATUS = 'Finished', END_TIMESTAMP = SYSTIMESTAMP
         SET STATUS = pStatus, END_TIMESTAMP = SYSTIMESTAMP
       WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC) AND MIGRATION_BATCH_ID = vMigrationBatchID;

      -- PL 20170213 EMAIL NOTIFICATION
      IF pStatus = MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC THEN
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchID, MIGR_GVAR.GV_MSG_CODE_MIGR_WAIT_DISC );
      ELSIF pStatus = MIGR_GVAR.GV_BATCH_STATUS_FINISHED THEN
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchID, MIGR_GVAR.GV_MSG_CODE_MIGR_COMPLETED );
      ELSIF pStatus = MIGR_GVAR.GV_BATCH_STATUS_FAILED THEN
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( vMigrationBatchID, MIGR_GVAR.GV_MSG_CODE_MIGR_FAILED_API );
      END IF;

      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.mig_batch_id := vMigrationBatchID;
        l_LogRec.migrArea     := 'MIGR_SIGNAL.CLOSE_BATCH';
        l_LogRec.migrStep     := 'CLOSE_BATCH';
        l_LogRec.migrRelTbl   := NULL;
        l_LogRec.migrRelKey   := NULL;
        l_LogRec.logMsg       := SQLCODE || '-' || SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

        ROLLBACK;

END CLOSE_BATCH;

---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
--FA. 20151112 Insert batch with specific status e.g rejected when missing files
FUNCTION INSERT_BATCH_JOB(vBOLAG_ID IN PLS_INTEGER, p_status IN VARCHAR2)
RETURN VARCHAR2 IS

  PRAGMA AUTONOMOUS_TRANSACTION;
  vSQl  VARCHAR2(2100);
  VMigBatchID VARCHAR2(10);
  v_Bolag VARCHAR2(10);
  l_LogRec MIGR_GVAR.LogRecTyp;
  v_renewal DATE;

BEGIN
  --valex.15/3/2017 - RENEWAL_DATE will be inserted in MIG_MIGRATION_INFO below, in relative field
  SELECT trunc(RENEWAL_DATE)
    into v_renewal
  FROM (SELECT *   FROM ETL_MIGRATION_CONDITIONS   WHERE 1=1      and ITERATION_STATUS='Pending'   oRDER by id)
  where ROWNUM=1;
    --valex.15/3/2017 - end

  if LENGTH(vBOLAG_ID)=1 THEN
    v_Bolag:='0'||to_char(vBOLAG_ID);
  else
    v_Bolag:=to_char(vBOLAG_ID);
  END IF;

  VMigBatchID := '';
  IF p_status= 'Queued' THEN
    vsql := 'INSERT INTO MIG_MIGRATION_INFO (MIGRATION_BATCH_ID, START_TIMESTAMP, END_TIMESTAMP, STATUS, BOLAG_ID, ID, RENEWAL_DATE)
               SELECT   ''' || v_Bolag ||''' ||'||q'['-']'||'||LPAD( CAST(mmi2.newID AS VARCHAR2(6)),6,'||q'['0']'||') AS  MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS START_TIMESTAMP,
               NULL  AS END_TIMESTAMP ,'
              ||chr(39)|| p_status ||chr(39)||' AS STATUS,
               ' || vBOLAG_ID || ',
               mmi2.newID, ''' ||v_renewal||'''
              FROM DUAL ,(SELECT NVL(MAX(ID),0)+1 AS newID FROM MIG_MIGRATION_INFO) mmi2';
  ELSE
    vsql := 'INSERT INTO MIG_MIGRATION_INFO (MIGRATION_BATCH_ID, START_TIMESTAMP, END_TIMESTAMP, STATUS, BOLAG_ID, ID,RENEWAL_DATE)
               SELECT   ''' || v_Bolag ||''' ||'||q'['-']'||'||LPAD( CAST(mmi2.newID AS VARCHAR2(6)),6,'||q'['0']'||') AS  MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS START_TIMESTAMP,
               SYSTIMESTAMP  AS END_TIMESTAMP ,'
              ||chr(39)|| p_status ||chr(39)||' AS STATUS,
               ' || vBOLAG_ID || ',
               mmi2.newID, ''' ||v_renewal||'''
              FROM DUAL ,(SELECT NVL(MAX(ID),0)+1 AS newID FROM MIG_MIGRATION_INFO) mmi2';
 END IF;
  EXECUTE IMMEDIATE vSQL;
  COMMIT;

  SELECT MIGRATION_BATCH_ID
     INTO VMigBatchID
      FROM (
        SELECT MIGRATION_BATCH_ID
          FROM MIG_MIGRATION_INFO
          WHERE BOLAG_ID = vBOLAG_ID  and STATUS=p_status
          ORDER BY ID desc)
      where ROWNUM=1;


    RETURN VMigBatchID;

    EXCEPTION WHEN OTHERS THEN

        l_LogRec.mig_batch_id:=VMigBatchID;
        l_LogRec.migrArea      :=   'MIGR_SIGNAL.INSERT_BATCH_JOB' ;
        l_LogRec.migrStep      :=  ' INSERT_BATCH_JOB' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM    ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

      ROLLBACK;
      RETURN VMigBatchID;
END INSERT_BATCH_JOB;


---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
--Initialize batch   -- step10 from demo
FUNCTION INIT_BATCH2(vBOLAG_ID IN PLS_INTEGER,p_queued_flag IN VARCHAR2)
RETURN  VARCHAR2 AS
  MIGRATION_BATCH_ID  VARCHAR2(50);
  vBatchRunning   VARCHAR2(100);
  l_LogRec MIGR_GVAR.LogRecTyp;
BEGIN

-- +++ anb 2015-09-08   Batch should be closed after all processing is completed

      vBatchRunning := NULL;
      MIGRATION_BATCH_ID := NULL;

      BEGIN
          SELECT NVL(x.STATUS,' ') INTO vBatchRunning
            from (SELECT STATUS, MIGRATION_BATCH_ID, ID
                  FROM MIG_MIGRATION_INFO
                  WHERE BOLAG_ID = vBOLAG_ID
                  ORDER BY ID desc
            ) x
          WHERE 1=1
            AND ROWNUM =1;
          EXCEPTION WHEN NO_DATA_FOUND THEN
                vBatchRunning:=' ';
      END;

      -- FA. 2015-10-29 if flag value set to 'Y' then allow only one batch id per bolag in status Running or Queued
      -- if flag value is not 'Y' then keep the rule that should be maximum 1 batch Running and 1 batch Queued
      -- If no batch or batch_status<> Queued (ie Running, Stopped, Finished), then insert a new Queued one.

      IF p_queued_flag ='Y' THEN
         IF (NVL(vBatchRunning,' ') NOT IN ('Queued','Running') )  THEN
            MIGRATION_BATCH_ID := INSERT_BATCH_JOB(vBOLAG_ID,'Queued'); --- this will set it to 'Queued'
-- +++ anb 20151116 timing is on INSERT_NEW_BATCH_JOB
--            INIT_LOG_MIG_MIGRATION_STEPS(vBOLAG_ID); -- works
         END IF;

      ELSE
        IF (NVL(vBatchRunning,' ') =' '  OR NVL(vBatchRunning,' ')<>'Queued') THEN
            MIGRATION_BATCH_ID := INSERT_BATCH_JOB(vBOLAG_ID,'Queued'); --- this will set it to 'Queued'
-- +++ anb 20151116 timing is on INSERT_NEW_BATCH_JOB
--            INIT_LOG_MIG_MIGRATION_STEPS(vBOLAG_ID); -- works
        END IF;
      END IF;

      RETURN MIGRATION_BATCH_ID;
EXCEPTION WHEN OTHERS THEN
      l_LogRec.mig_batch_id:=MIGRATION_BATCH_ID;
        l_LogRec.migrArea      :=   'MIGR_SIGNAL.INIT_BATCH2' ;
        l_LogRec.migrStep      :=  ' INIT_BATCH2' ;
        l_LogRec.migrRelTbl    :=   NULL;
        l_LogRec.migrRelKey  :=   NULL;
        l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM    ;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

END INIT_BATCH2;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
--- FA. 2015-10-21 improve readibility and performance
FUNCTION GET_NEXT_QUEUED RETURN  VARCHAR2 IS
  vBatchQueued VARCHAR2(50);
  v_lock_name  VARCHAR2(128);
  v_got_lock   BOOLEAN;
  l_LogRec     MIGR_GVAR.LogRecTyp;
  v_status     VARCHAR2(50);

BEGIN

    vBatchQueued := ' ';
    v_got_lock := FALSE;
    l_LogRec.mig_batch_id:='0-2';
    l_LogRec.migrArea      :=   'MIGR_SIGNAL.GET_NEXT_QUEUED' ;
    l_LogRec.migrStep      :=  ' GET_NEXT_QUEUED' ;
    l_LogRec.migrRelTbl    :=   NULL;
    l_LogRec.migrRelKey  :=   NULL;
--- For every Bolag we can have maximum 1 Queued and 1 Running batch_ids
--- get first Batch_id that is queued and has no previous Running batch. Then make it 'Running'

--FA. 2015.10.29 : Require lock so not to start migration process with same batch id
    v_lock_name :=MIGR_LOCK_UTILS.GET_HANDLE('migr');
    v_got_lock:=MIGR_LOCK_UTILS.REQUEST_LOCK(v_lock_name,'migr');

    IF  v_got_lock THEN

      SELECT MIGRATION_BATCH_ID,status INTO vBatchQueued,v_status
      FROM (WITH ORDERED AS (SELECT MIGRATION_BATCH_ID
                                  ,STATUS
                                  ,BOLAG_ID
                                  ,ID
                                  ,ROW_NUMBER() OVER (PARTITION BY BOLAG_ID ORDER BY ID ASC) AS rn
                           FROM MIG_MIGRATION_INFO
                           WHERE 1 = 1
                              AND STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_QUEUED, MIGR_GVAR.GV_BATCH_STATUS_RUNNING))
          ,x AS (SELECT MIGRATION_BATCH_ID
               ,STATUS
              ,BOLAG_ID
               ,ID
          FROM ORDERED
            WHERE 1 = 1
            AND rn = 1
            AND STATUS = MIGR_GVAR.GV_BATCH_STATUS_QUEUED
          ORDER BY ID ASC)
        ,y AS (SELECT MIGRATION_BATCH_ID,STATUS FROM x
                UNION ALL                             --valex.20/12/2016 - addition of batches in 'Queued_Discounts' status for Discounts support purpose
               SELECT MIGRATION_BATCH_ID,status
               FROM MIG_MIGRATION_INFO
               WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC)
        SELECT * FROM y)
        WHERE ROWNUM = 1;

      MAKE_RUNNABLE( vBatchQueued ,v_status);

      MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
    END IF;

    RETURN vBatchQueued;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
      IF  v_got_lock THEN
        MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
      END IF;

      l_LogRec.logMsg        :=    'Queued Batch not found:' ||  SQLCODE || '-' || SQLERRM    ;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
      RETURN vBatchQueued;

    WHEN OTHERS THEN
      IF  v_got_lock THEN
        MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
      END IF;

      l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM    ;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

      RETURN vBatchQueued;

END GET_NEXT_QUEUED;

 ---------------------------------------------------
 ---------------------------------------------------

  FUNCTION GET_NEXT_QUEUED(P_BOLAG IN NUMBER) RETURN  VARCHAR2 IS
  vBatchQueued VARCHAR2(50);
  v_lock_name  VARCHAR2(128);
  v_got_lock   BOOLEAN;
  l_LogRec     MIGR_GVAR.LogRecTyp;
  v_status     VARCHAR2(50);

BEGIN

    vBatchQueued := ' ';
    v_got_lock := FALSE;
    l_LogRec.mig_batch_id:='0-2';
    l_LogRec.migrArea      :=   'MIGR_SIGNAL.GET_NEXT_QUEUED' ;
    l_LogRec.migrStep      :=  ' GET_NEXT_QUEUED' ;
    l_LogRec.migrRelTbl    :=   NULL;
    l_LogRec.migrRelKey  :=   NULL;
--- For every Bolag we can have maximum 1 Queued and 1 Running batch_ids
--- get first Batch_id that is queued and has no previous Running batch. Then make it 'Running'

--FA. 2015.10.29 : Require lock so not to start migration process with same batch id

    v_lock_name :=MIGR_LOCK_UTILS.GET_HANDLE('migr');
    v_got_lock:=MIGR_LOCK_UTILS.REQUEST_LOCK(v_lock_name,'migr');

    IF  v_got_lock THEN

      SELECT MIGRATION_BATCH_ID,status INTO vBatchQueued,v_status
      FROM (WITH ORDERED AS (SELECT MIGRATION_BATCH_ID
                                  ,STATUS
                                  ,BOLAG_ID
                                  ,ID
                                  ,ROW_NUMBER() OVER (PARTITION BY BOLAG_ID ORDER BY ID ASC) AS rn
                           FROM MIG_MIGRATION_INFO
                           WHERE 1 = 1
        AND  BOLAG_ID   =P_BOLAG
                              AND STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_QUEUED, MIGR_GVAR.GV_BATCH_STATUS_RUNNING))
          ,x AS (SELECT MIGRATION_BATCH_ID
               ,STATUS
              ,BOLAG_ID
               ,ID
          FROM ORDERED
            WHERE 1 = 1
            AND rn = 1
            AND STATUS = MIGR_GVAR.GV_BATCH_STATUS_QUEUED
          ORDER BY ID ASC)
        ,y AS (SELECT MIGRATION_BATCH_ID,STATUS FROM x
                UNION ALL                             --valex.20/12/2016 - addition of batches in 'Queued_Discounts' status for Discounts support purpose
               SELECT MIGRATION_BATCH_ID,status
               FROM MIG_MIGRATION_INFO
               WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC)
        SELECT * FROM y)
        WHERE ROWNUM = 1;

      MAKE_RUNNABLE( vBatchQueued ,v_status);

      MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
    END IF;

    RETURN vBatchQueued;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
      IF  v_got_lock THEN
        MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
      END IF;

      l_LogRec.logMsg        :=    'Queued Batch not found:' ||  SQLCODE || '-' || SQLERRM    ;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;
      RETURN vBatchQueued;

    WHEN OTHERS THEN
      IF  v_got_lock THEN
        MIGR_LOCK_UTILS.RELEASE_LOCK(v_lock_name);
      END IF;

      l_LogRec.logMsg        :=     SQLCODE || '-' || SQLERRM    ;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec) ;

      RETURN vBatchQueued;

END GET_NEXT_QUEUED;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
  ---FA.20180125 RAC addition:clean up process for RAC failovers :if pol jobs are less than policies in running state the api should be dropped in order to trigger the resume process
  PROCEDURE CLEANUP_PROCESS
  IS
    v_cleanup_time_interval  ETL_SETUP_INFO.CLEANUP_TIME_INTERVAL%TYPE;
    v_cleanup_checks            ETL_SETUP_INFO.CLEANUP_CHECKS%TYPE;
    PRAGMA AUTONOMOUS_TRANSACTION;
     l_LogRec           MIGR_GVAR.LogRecTyp;
     v_cnt_jobs      NUMBER;
     v_cnt_policies    NUMBER;
    BEGIN
       l_LogRec.migrArea := 'MIGR_SIGNAL.CLEANUP_PROCESS';


      SELECT esi.CLEANUP_TIME_INTERVAL, NVL(esi.CLEANUP_CHECKS ,0)
      INTO      v_cleanup_time_interval, v_cleanup_checks
      FROM ETL_SETUP_INFO esi;

       IF  v_cleanup_time_interval  = v_cleanup_checks THEN
           l_LogRec.logMsg := 'Entered Cleanup Process';
           MIGR_LOG.LOG_INFO(l_LogRec);
           SELECT COUNT (1) into v_cnt_jobs from USER_SCHEDULER_JOBS WHERE JOB_NAME LIKE 'POL_%';
           SELECT COUNT (1) into v_cnt_policies from IA_POLICY WHERE MIG_FLAG in (MIGR_GVAR.GV_MIG_FLAG_RUNNING, MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS);
           l_LogRec.logMsg := 'Running Policies:' || v_cnt_policies || '- Running Jobs:'|| v_cnt_jobs;
           MIGR_LOG.LOG_INFO(l_LogRec);

          IF  v_cnt_jobs<v_cnt_policies THEN
              l_LogRec.logMsg := 'Stop Migr Run API';
                MIGR_LOG.LOG_INFO(l_LogRec);
               MIGR_SCHEDULED_JOBS.STOP_MIGR_RUNNING_JOB('MIGR_RUN_API');

            FOR c in (SELECT *  FROM USER_SCHEDULER_JOBS  WHERE JOB_NAME like  ( 'POL%') )  LOOP
                       l_LogRec.logMsg := 'Drop Migr Pol Job:' || c.JOB_NAME;
                       MIGR_LOG.LOG_INFO(l_LogRec);
                      dbms_scheduler.drop_job(job_name=>c.job_name,force=>TRUE);
             END LOOP;

           END IF;
           UPDATE ETL_SETUP_INFO SET   CLEANUP_CHECKS =0;
       ELSE
             UPDATE ETL_SETUP_INFO SET   CLEANUP_CHECKS =v_cleanup_checks +1;
       END IF;

      COMMIT;

      EXCEPTION WHEN OTHERS then
                    l_LogRec.logMsg :=  SQLERRM;
                   MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                  ROLLBACK;
    END CLEANUP_PROCESS;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
-- FA. 2015-10-29
-- if p_queued flag is 'Y' then per bolag one batch id is allowed in ('QUEUED'/RUNNABLE)
PROCEDURE RUN_SIGNAL(p_queued_flag IN VARCHAR2)
  IS
    MIGRATION_BATCH_ID VARCHAR2(10);
    L_SRVERRMSG        SRVERRMSG;
    PIO_ERR			   SRVERR;
    vsql               VARCHAR2(200);
    l_LogRec           MIGR_GVAR.LogRecTyp;

    l_eventTimer       TIMESTAMP;

BEGIN

     l_LogRec.migrArea := 'MIGR_SIGNAL.RUN_SIGNAL';
     l_eventTimer := SYSTIMESTAMP;

     -- Create MIGR_RUN_API and MIGR_RUN_PARALLEL_JOB, if they do not exist in USER_SCHEDULER_JOBS
     MIGR_SCHEDULED_JOBS.START_JOBS();

      ---FA.20180125 RAC addition:clean up process for RAC failovers
    CLEANUP_PROCESS;


     -- valex.2/11/2016 - search for batches applicable for resumption and take relative actions
      ---FA.20180201 Alter Resume conditions for RAC
    /* FOR c IN (WITH x AS (SELECT MIGRATION_BATCH_ID, 'order' AS seq1
                            FROM mig_migration_info
                           WHERE 1=1
                             AND STATUS in (MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC)
                             AND 0=(SELECT count('x') FROM USER_SCHEDULER_JOBS WHERE job_name = 'MIGR_RUN_API' AND (STATE='RUNNING' OR STATE='SCHEDULED'))
                             AND 0=(SELECT count('x') FROM USER_SCHEDULER_JOBS WHERE job_name LIKE 'MIGRATE_BOLAG%' )
                           )
               ,y as     (select distinct  MIGRATION_BATCH_ID,seq1 from x)
               ,z as     (select MIGRATION_BATCH_ID,ROW_NUMBER() OVER (partition BY seq1 ORDER BY seq1) AS seq     from y)
                SELECT z.*,cnt   FROM z ,(SELECT count(*) as cnt FROM z)  ORDER BY seq   )
     LOOP*/

     FOR c IN (WITH running_jobs AS
      (SELECT   JOB_NAME  from  USER_SCHEDULER_JOBS  WHERE ( job_name like 'MIGRATE_BOLAG%')
       UNION ALL (SELECT   JOB_NAME  from  USER_SCHEDULER_JOBS WHERE  job_name = 'MIGR_RUN_API'   AND (STATE='RUNNING' OR STATE='SCHEDULED')))
   select b.migration_batch_id from mig_migration_info  b
     LEFT JOIN  running_jobs on bolag_id =   regexp_substr(job_name,'[0-9]+')     and  REGEXP_LIKE (JOB_NAME, 'MIGRATE_BOLAG_'|| '[0-9]')
      WHERE  status=MIGR_GVAR.GV_BATCH_STATUS_RUNNING  AND IA_COMPLETED='Pending'  and job_name is null
    UNION ALL
    select Migration_batch_id from mig_migration_info
    LEFT JOIN  running_jobs    on bolag_id =   regexp_substr(job_name,'[0-9]+')   and  job_name like 'MIGRATE_BOLAG_DISC%'
   WHERE status=MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC AND DISCOUNT_COMPLETED='Pending' and job_name is null
  UNION  ALL
      select migration_batch_id from mig_migration_info
      WHERE  0=(SELECT count('x') FROM running_jobs WHERE job_name = 'MIGR_RUN_API' )
        AND  (
                       ( status =  MIGR_GVAR.GV_BATCH_STATUS_RUNNING AND IA_COMPLETED='Finished' )
                OR  (STATUS=  MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC   AND DISCOUNT_COMPLETED='Finished' )
                   )
      )
    LOOP

        -- pl 20170214 RESUME EMAIL NOTIFICATION
         MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_RESUMED );
         ---FA.20180201 Alter Resume conditions for RAC
         ---- IF c.seq=1 THEN
          --l_LogRec.logMsg := 'Entered resume loop';
          l_LogRec.logMsg := 'Entered resume loop for batch: '||c.MIGRATION_BATCH_ID;
          MIGR_LOG.LOG_INFO(l_LogRec);
        ----END IF;

        MIGR_SETUP.CHECK_SID(1);

        UPDATE MIG_MIGRATION_INFO mmi
          SET mmi.resume_process='In Progress',mmi.STATUS=
          (CASE WHEN STATUS=MIGR_GVAR.GV_BATCH_STATUS_RUNNING THEN MIGR_GVAR.GV_BATCH_STATUS_QUEUED
          when STATUS=MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC THEN MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC END)
          WHERE  mmi.MIGRATION_BATCH_ID=c.MIGRATION_BATCH_ID;

        COMMIT;

    END LOOP;

    MIGR_ARCHIVE.ARCHIVE_MUTUAL;

    CHECK_FILES(p_queued_flag);

    l_LogRec.logMsg := 'Total Signal Process runtime: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
    MIGR_LOG.LOG_INFO(l_LogRec);

EXCEPTION
  WHEN OTHERS THEN
    l_LogRec.logMsg := SQLCODE || '-' || SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END RUN_SIGNAL;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
PROCEDURE LOG_NOT_MIGRATED_BOLAGS(p_id IN PLS_INTEGER, p_applicable_bolags IN VARCHAR2)
  IS

    i        PLS_INTEGER:=1;     -- variable gets positions of comma in p_applicable_bolags string
    v_bolag  VARCHAR2(10);
    v_flag   PLS_INTEGER:=0;
    l_LogRec MIGR_GVAR.LogRecTyp;
    l_list   VARCHAR2(200);
    l_count  PLS_INTEGER:=0;

begin

    l_LogRec.migrArea := 'MIGR_SIGNAL.LOG_NOT_MIGRATED_BOLAGS';
    l_LogRec.migrStep := 'Check for Bolags not included in the Migration Process';

    WHILE INSTR(p_applicable_bolags,',',i+1,1)<> 0   --search p_applicable_bolags string for the next comma until it does not exist
    loop

       v_bolag:=SUBSTR(p_applicable_bolags,INSTR(p_applicable_bolags,',',i,1)+1,2);      --variable carries the bolag which is after the current comma position, in the relative string

          --identify bolags which DO NOT have a batch in MIG_MIGRATION_INFO (all batches of previous renewal months are excluded)
          FOR c IN (SELECT a.bolag
                      FROM (SELECT v_bolag bolag FROM DUAL) a
                      --LEFT JOIN (SELECT MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO WHERE NVL(DATA_MOVED_TO_ARCHIVE,'0') <> MIGR_GVAR.GV_STATUS_FINISHED) b
                        LEFT JOIN (SELECT MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO WHERE NVL(DATA_MOVED_TO_ARCHIVE,'0') <> MIGR_GVAR.GV_STATUS_FINISHED
                                      --AND STATUS <> MIGR_GVAR.GV_STATUS_FAILED) b
                               --FA.20170921 Status should not be in either rejected-failed
                                  AND STATUS NOT IN ( MIGR_GVAR.GV_STATUS_FAILED,MIGR_GVAR.GV_BATCH_STATUS_REJECTED)  )b

                        ON a.bolag=SUBSTR(b.MIGRATION_BATCH_ID, 1, 2)
                     WHERE b.MIGRATION_BATCH_ID IS NULL
          )
          LOOP
              l_LogRec.logMsg := 'Bolag ' ||c.bolag || ' did not upload completed.txt, during renewal month with ID='||p_id;
              MIGR_LOG.LOG_INFO(l_LogRec);
              v_flag:=1;
              l_list:=l_list||c.bolag||',';

              SELECT COUNT('X') INTO l_count FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl WHERE menl.MIGRATION_BATCH_ID=c.BOLAG || '-' || LPAD(p_id, 2, 0) AND menl.MSG_CODE=MIGR_GVAR.GV_MSG_CODE_MIGR_MISSING_TXT;
              IF l_count=0 THEN
                  MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c.BOLAG || '-' || LPAD(p_id, 2, 0), MIGR_GVAR.GV_MSG_CODE_MIGR_MISSING_TXT );
              END IF;
          END LOOP;

          i:=INSTR(p_applicable_bolags,',',i+1,1);

    END LOOP;

    UPDATE ETL_MIGRATION_CONDITIONS SET missed_data_deadline=(CASE WHEN NVL(l_list,' ') <> ' ' then SUBSTR(l_list,1,LENGTH(l_list)-1) else 'All bolags uploaded mutual data' end) WHERE ID=p_id;

 EXCEPTION WHEN OTHERS THEN
    l_LogRec.logMsg := SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
END LOG_NOT_MIGRATED_BOLAGS;
  ---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
 --FA.20170921 Check if file exist in folder
  FUNCTION FILE_EXISTS (p_scan_for_completed IN BOOLEAN,p_scan_for_discounts IN BOOLEAN,l_id IN ETL_MIGRATION_CONDITIONS.ID%TYPE, p_BOLAG_ID IN MIG_MIGRATION_INFO.BOLAG_ID%type)
    RETURN BOOLEAN
    IS

    l_tfile_name         VARCHAR2(50);
    l_tfile_etx          VARCHAR2(10);
    l_file_exists        PLS_INTEGER;
    l_LogRec             MIGR_GVAR.LogRecTyp;
    l_completed          ETL_SETUP_INFO.MIGG_FILE_NAME%TYPE;
    l_discounts_file     VARCHAR2(100);
    l_discounts_exists   PLS_INTEGER := 0;
    l_bolag_name ETL_BOLAG_INFO.BOLAG_NAME%type;
  BEGIN

        l_LogRec.migrArea := 'MIGR_SIGNAL.FILE_EXISTS';
        l_LogRec.mig_batch_id := '0-1';
        l_LogRec.migrArea     := 'MIGR_SIGNAL.FILE_EXISTS';
        l_LogRec.migrStep     := 'FILE_EXISTS';
        l_LogRec.migrRelTbl   := NULL;
        l_LogRec.migrRelKey   := NULL;

        SELECT MIGG_FILE_NAME, FILE_EXTN, DISCOUNTS_FILE_NAME   INTO l_tfile_name, l_tfile_etx, l_discounts_file    FROM ETL_SETUP_INFO;

         -- Iterate through directories in order to check for completed.txt and/or discounts.txt, if applicable (based on OUT params of MIGRATION_SCHEDULE)
--         FOR c IN ( SELECT BOLAG_NAME, BOLAG_ID
--                         FROM ETL_BOLAG_INFO , (SELECT APPLICABLE_BOLAGS, MISSED_DATA_DEADLINE FROM ETL_MIGRATION_CONDITIONS WHERE ID=l_id)
--                        WHERE ',' || APPLICABLE_BOLAGS || ',' LIKE '%,' || SUBSTR(BOLAG_NAME, 2) || ',%'
--                          AND ',' || MISSED_DATA_DEADLINE || ',' NOT LIKE '%,' || SUBSTR(BOLAG_NAME, 2) || ',%' -- if bolag missed upload deadline will not be scanned for discounts.txt
--            )
--            LOOP

        SELECT BOLAG_NAME into l_bolag_name FROM ETL_BOLAG_INFO WHERE BOLAG_ID=p_BOLAG_ID;
                IF P_scan_for_completed THEN

                    ---FA.20161104 Added to support both modes of file name: with or without bolag prefix
                    IF SUBSTR(l_tfile_name,1,1) = '_' THEN
                      l_completed := l_bolag_name||l_tfile_name;
                    ELSE
                      l_completed := l_tfile_name;
                    END IF;

                    l_file_exists := IS_FILE_EXISTS('READ_DIR_' ||l_bolag_name, l_completed);

                    IF (l_file_exists = 1) THEN RETURN  TRUE;
                    ELSE    RETURN FALSE;
                    END IF;

               END IF;

                IF  P_scan_for_discounts THEN

                       l_discounts_exists := IS_FILE_EXISTS('READ_DIR_' || l_bolag_name, l_bolag_name || '_' || l_discounts_file);
                       l_LogRec.logMsg :=l_discounts_exists;
                       MIGR_LOG.LOG_INFO(l_LogRec);
                    IF (l_discounts_exists = 1) THEN RETURN TRUE;
                    ELSE  RETURN FALSE;
                    END IF;

                END IF;

  EXCEPTION WHEN OTHERS THEN
      l_LogRec.logMsg := SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
      RETURN FALSE;
END FILE_EXISTS;
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
PROCEDURE TXT_NOT_FOUND_REMINDER(p_id IN PLS_INTEGER, p_applicable_bolags IN VARCHAR2, p_status IN VARCHAR2)
  IS
    i         PLS_INTEGER:=1;     -- variable gets positions of comma in p_applicable_bolags string
    v_bolag   VARCHAR2(10);
    v_flag    PLS_INTEGER:=0;
    l_LogRec  MIGR_GVAR.LogRecTyp;
    l_list    VARCHAR2(200);
    l_count   PLS_INTEGER;
    l_days_left PLS_INTEGER;

BEGIN
    l_LogRec.migrArea := 'MIGR_SIGNAL.TXT_NOT_FOUND_REMINDER';
    l_LogRec.migrStep := 'MIGR_SIGNAL.TXT_NOT_FOUND_REMINDER';

    MIGR_LOG.LOG_INFO(l_LogRec);
    SELECT NVL(COMPLETED_REMINDER_DAYS_BEFORE,0)
      into l_days_left
    FROM ETL_SETUP_INFO;

    WHILE INSTR(p_applicable_bolags, ',', i+1, 1) <> 0  -- search p_applicable_bolags string for the next comma until it does not exist
    LOOP
       v_bolag := SUBSTR(p_applicable_bolags, INSTR(p_applicable_bolags, ',', i, 1) + 1, 2);  -- variable carries the bolag which is after the current comma position, in the relative string

       -- identify bolags which DO NOT have a batch in MIG_MIGRATION_INFO (all batches of previous renewal months are excluded)
          IF p_status = MIGR_GVAR.GV_MSG_CODE_MIGR_TXT_REMINDER THEN
       FOR c IN (SELECT a.BOLAG
                   FROM (SELECT v_bolag BOLAG FROM DUAL) a
                   LEFT JOIN (SELECT MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO WHERE NVL(DATA_MOVED_TO_ARCHIVE, '0') <> MIGR_GVAR.GV_STATUS_FINISHED
                      AND STATUS NOT IN ( MIGR_GVAR.GV_STATUS_FAILED,MIGR_GVAR.GV_BATCH_STATUS_REJECTED) )b
                     ON a.BOLAG=SUBSTR(b.MIGRATION_BATCH_ID, 1, 2)
                  WHERE b.MIGRATION_BATCH_ID is NULL
       )
       LOOP

              SELECT COUNT('X') INTO l_count FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl WHERE menl.MIGRATION_BATCH_ID=c.BOLAG || '-' || LPAD(p_id, 2, 0) AND menl.MSG_CODE=p_status;

              IF l_count=0 THEN
                     ---FA.20170921 Check if bolag has uploaded file  prior to sending the reminder
                   IF not FILE_EXISTS (TRUE,FALSE,p_id,c.BOLAG) THEN

                       l_LogRec.logMsg := 'Bolag ' ||c.bolag || ' did not upload Completed.txt yet. Only '|| l_days_left ||' days left!';
                       MIGR_LOG.LOG_INFO(l_LogRec);
                       --FA.20170915  Change to call email wiht dynamic text
                       ---MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c.BOLAG || '-' || LPAD(p_id, 6, 0), p_status );

                          MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_WITH_DYNAMIC_MSG(c.BOLAG || '-' || LPAD(p_id, 2, 0), p_status,   l_LogRec.logMsg);
                    END IF;
              END IF;

         END LOOP;
      END IF;
         IF p_status = MIGR_GVAR.GV_MSG_CODE_MIGR_DISC_REMINDER THEN
           FOR c IN (SELECT a.BOLAG
                   FROM (SELECT v_bolag BOLAG FROM DUAL) a
                    JOIN (SELECT MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO WHERE NVL(DATA_MOVED_TO_ARCHIVE, '0') <> MIGR_GVAR.GV_STATUS_FINISHED
            AND STATUS=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC) b
                     ON a.BOLAG=SUBSTR(b.MIGRATION_BATCH_ID, 1, 2)

       )
       LOOP
              SELECT COUNT('X') INTO l_count FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl WHERE menl.MIGRATION_BATCH_ID=c.BOLAG || '-' || LPAD(p_id, 2, 0) AND menl.MSG_CODE=p_status;

              IF l_count=0 THEN

                       l_LogRec.logMsg := 'Bolag ' ||c.bolag || ' did not upload MD_Discounts.txt yet. Only '|| l_days_left ||' days left!';
                       MIGR_LOG.LOG_INFO(l_LogRec);
                        --FA.20170915  Change to call email wiht dynamic text
                       -- MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c.BOLAG || '-' || LPAD(p_id, 6, 0), p_status );
                      MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_WITH_DYNAMIC_MSG(c.BOLAG || '-' || LPAD(p_id, 2, 0), p_status,   l_LogRec.logMsg);

              END IF;

       END LOOP;
           END IF;
       i := INSTR(p_applicable_bolags, ',', i+1, 1);

    END LOOP;

 EXCEPTION
    WHEN OTHERS THEN
      l_LogRec.logMsg := SQLCODE || ' - ' || SQLERRM;
      MIGR_LOG.LOG_EXCEPTION(l_LogRec);

END TXT_NOT_FOUND_REMINDER;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
PROCEDURE MIGRATION_SCHEDULE (v_id OUT PLS_INTEGER, v_scan_for_completed OUT BOOLEAN, v_scan_for_discounts OUT boolean)
  IS

    v_not_finished      PLS_INTEGER;
    l_LogRec            MIGR_GVAR.LogRecTyp;
    l_remove_interval   PLS_INTEGER:=0;
    l_Waiting_discounts PLS_INTEGER:=0;
    l_appl_bolags       VARCHAR2(100);
    l_all_batch_completed  BOOLEAN;
    l_days   NUMBER;
    l_eventTimer        TIMESTAMP;
    l_failDataArc NUMBER;
    l_incompleteCycles NUMBER;
    l_pendingArc number;
    l_count   NUMBER;
  begin
     l_LogRec.migrArea := 'MIGR_SIGNAL.MIGRATION_SCHEDULE';
     l_LogRec.migrStep := 'Application of Renewal months schedule';

     l_eventTimer := SYSTIMESTAMP;

     v_scan_for_completed := FALSE;
     v_scan_for_discounts := FALSE;

     MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;

     SELECT NVL(COMPLETED_REMINDER_DAYS_BEFORE,0) into l_days FROM ETL_SETUP_INFO  ;

     for c in (with x AS (SELECT *
                          FROM ETL_MIGRATION_CONDITIONS
                          WHERE 1=1
                            and ITERATION_STATUS='Pending'
                          oRDER by id )
               ,y AS (SELECT *
                      FROM x
                      where ROWNUM=1)
               ,z AS (SELECT y.*
                          ,(CASE WHEN (select count(*) from ETL_MIGRATION_CONDITIONS)=id then null else (select renewal_date from ETL_MIGRATION_CONDITIONS where id=y.ID+1) end) next_renewal
                          ,(CASE WHEN (select count(*) from ETL_MIGRATION_CONDITIONS)=id then null else (select migr_start_date from ETL_MIGRATION_CONDITIONS where id=y.ID+1) end) next_start
                          ,(CASE WHEN (select count(*) from ETL_MIGRATION_CONDITIONS)=id then null else (select id from ETL_MIGRATION_CONDITIONS where id=y.ID+1) end) next_id
                      from y )
               SELECT *
                 from z
      )
      LOOP
          v_id:=c.id;

          SELECT COUNT('x')  INTO l_Waiting_discounts  FROM MIG_MIGRATION_INFO mmi  WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC  AND ROWNUM = 1;

          -- create and send via email the discounts file to bolags, if not done aready
          MIGR_MD_DISCOUNTS.SEND_MD_DISCOUNTS_FILE;

          -- pl 20170626 migration daily progress email notification
          MIGR_REPORTING.DAILY_PROGRESS( c.RENEWAL_DATE );

          IF SYSDATE < c.migr_start_date THEN

             IF SYSDATE < ( c.MIGR_START_DATE- l_days) THEN

                 l_LogRec.logMsg := 'MIGR_RUN_SIGNAL_JOB next run will be postponed:' ||l_days   ||  ' prior to MIGR_START_DATE of current renewal month with ID=' || c.ID;
                  MIGR_LOG.LOG_INFO(l_LogRec);

                  --FA.20170911 Signal should be postponed n days prior to next run in order to send the reminder for missing completed files
                  DBMS_SCHEDULER.SET_ATTRIBUTE (name => 'MIGR_RUN_SIGNAL_JOB',attribute =>'start_date', VALUE => (c.MIGR_START_DATE-l_days));

                  -- Signal postponement email
                  MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION('0-0', MIGR_GVAR.GV_MSG_CODE_MIGR_SIGNAL_POSTP);
                  MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;

              END IF;

              -- PL 20170214 Email reminder for missing completed.txt files
              FOR c_1 IN (SELECT ','|| NVL(APPLICABLE_BOLAGS, 0) ||',' AS APPL_BOLAGS
                            FROM (SELECT APPLICABLE_BOLAGS
                                    FROM ETL_MIGRATION_CONDITIONS
                                   WHERE ITERATION_STATUS = 'Pending'   AND TRUNC(SYSDATE) = TRUNC(MIGR_END_DATE)-l_days
                                   ORDER BY ID ASC)
                           WHERE ROWNUM = 1
              )
              LOOP
                    TXT_NOT_FOUND_REMINDER(c.ID, c_1.APPL_BOLAGS, MIGR_GVAR.GV_MSG_CODE_MIGR_TXT_REMINDER);

                    --FA.20170919 send email immediately - Signal may be postponed
                    MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;

              END LOOP;

          ELSIF SYSDATE <= c.migr_end_date THEN

              v_scan_for_completed := TRUE; -- scan for completed.txt
              IF l_Waiting_discounts = 1 THEN
                v_scan_for_discounts := TRUE; -- scan for discounts.txt
                --MIGR_MD_DISCOUNTS.SEND_MD_DISCOUNTS_FILE; -- create and send via email the discounts file to bolags, if not done aready
              END IF;

          ELSIF SYSDATE <= c.discounts_end_date THEN

              --IF v_not_finished=0 AND NVL(c.MISSED_DATA_DEADLINE,'0')='0' THEN  --if all batches finished or failed and the relative check has not been performed previously
               --FA.20170921 If remain here then is called very on minute and enters one log per minute- As the deadline will pass for all bolags call it only once
                 IF C.missed_data_deadline IS NULL THEN
                          LOG_NOT_MIGRATED_BOLAGS(c.id, ',' || c.applicable_bolags || ',');  --beware! second parameter is enclosed in commas
                 END IF;
                  IF l_Waiting_discounts = 1 THEN
                    v_scan_for_discounts := TRUE; -- scan for discounts.txt

                  END IF;

                  --FA.20170921 Send reminders for bolags that have not missed the completed deadline
                  FOR c_2 IN (SELECT  ',' || NVL( listagg(BOLAG_ID,',')   within GROUP(ORDER by bolag_id) , 0) || ',' AS APPL_BOLAGS
                                       FROM ETL_BOLAG_INFO ,
                                      (SELECT APPLICABLE_BOLAGS, MISSED_DATA_DEADLINE
                                        FROM ETL_MIGRATION_CONDITIONS
                                        WHERE ITERATION_STATUS = 'Pending' AND id=c.id
                                         AND TRUNC(SYSDATE) = TRUNC(DISCOUNTS_END_DATE-(SELECT NVL(COMPLETED_REMINDER_DAYS_BEFORE,0) FROM ETL_SETUP_INFO) )
                                       )
                        WHERE ',' || APPLICABLE_BOLAGS || ',' LIKE '%,' || SUBSTR(BOLAG_NAME, 2) || ',%'
                          AND ',' || MISSED_DATA_DEADLINE || ',' NOT LIKE '%,' || SUBSTR(BOLAG_NAME, 2) || ',%' )
                LOOP

                      TXT_NOT_FOUND_REMINDER(c.ID, c_2.APPL_BOLAGS, MIGR_GVAR.GV_MSG_CODE_MIGR_DISC_REMINDER);
                END LOOP;

           ELSIF SYSDATE > c.discounts_end_date THEN --AND (SYSDATE < c.next_start OR c.next_start IS NULL) THEN
                --FA.20170406 If incomplete batch found notify users and do not close iteration batch and do not archive data
                LOG_NOT_MIGRATED_BOLAGS_DISC(c.id, ',' || c.applicable_bolags || ','); -- beware! second parameter is enclosed in commas
                l_all_batch_completed := TRUE;

              --FA. 20170615 Check if  Phase 1 running batch exist and send delay notification
                  FOR r IN (SELECT MIGRATION_BATCH_ID,PHASE1_DELAY  FROM MIG_MIGRATION_INFO WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_RUNNING)
                  LOOP
                       IF R.PHASE1_DELAY IS NULL THEN
                            MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_WITH_DYNAMIC_MSG (R.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_PROCESS_DELAY,
                            'The deadline for uploading discounts has passed and Phase 1 for batch: ' || r.MIGRATION_BATCH_ID || ' has not been completed. Process may not be able to complete current iteration cycle. When Phase 1 completes processing, Phase 2 will be triggered automatically with zero discounts. Immediate action is required to investigate the cause of delay.  ' );
                            UPDATE MIG_MIGRATION_INFO set PHASE1_DELAY=SYSTIMESTAMP WHERE MIGRATION_BATCH_ID = r.MIGRATION_BATCH_ID;
                       END IF;
                       l_all_batch_completed := FALSE;
                  END LOOP;

                  FOR c_INCOMPLETE IN (SELECT MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC)
                  LOOP
                      l_all_batch_completed := FALSE;
                      -- UPDATE MIG_MIGRATION_INFO SET STATUS=MIGR_GVAR.GV_BATCH_STATUS_INCOMPLETE WHERE STATUS=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC; --close relative batches status, so that flag l_Waiting_discounts not be raised erronesously, during next months scans
                      -- pl 20170214 INCOMPLETE BATCH EMAIL NOTIFICATION

                      MIGR_MD_DISCOUNTS.DEFAULT_MD_DISCOUNTS_FILE(c_INCOMPLETE.MIGRATION_BATCH_ID);
                      SELECT COUNT(1) into l_count from MIGR_EMAIL_NOTIFICATIONS_LOG WHERE MIGRATION_BATCH_ID= c_INCOMPLETE.MIGRATION_BATCH_ID and  MSG_CODE= MIGR_GVAR.GV_MSG_CODE_MIGR_DEFAULT_DISC;
                      IF l_count =0 THEN
                          MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c_INCOMPLETE.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_MIGR_DEFAULT_DISC );
                      END IF;
                      v_scan_for_discounts := TRUE; -- scan for discounts.txt
                  END LOOP;

                  SELECT COUNT(*)     INTO v_not_finished
                    FROM MIG_MIGRATION_INFO
                   WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

                    IF v_not_finished=0 AND l_all_batch_completed then -- if all batches are either finished or failed their discount phase
                              MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;

                        ---FA.20170919 Check if there are pending batces for archive
                        SELECT COUNT(1) into l_pendingArc FROM MIG_MIGRATION_INFO mmi WHERE mmi.DATA_MOVED_TO_ARCHIVE IN( 'Pending','Failed');
                       ---FA.20170928 For BI reporting reasons do not archive until next start date -1 -For the last run give  10-days to complete phase 2 and extract BI final reports
                       IF l_pendingArc>0  AND  TRUNC(SYSDATE)>= TRUNC(NVL(c.next_start, c.discounts_end_date+10)) -1   then
                            MIGR_ARCHIVE.MOVE_TO_ARCHIVE_SCHEMA;
                      --- END IF;

                       SELECT COUNT('x') into l_failDataArc from mig_migration_info WHERE renewal_date=c.renewal_date AND DATA_MOVED_TO_ARCHIVE<>MIGR_GVAR.GV_STATUS_FINISHED;

                       IF l_failDataArc =0 THEN
                        UPDATE ETL_MIGRATION_CONDITIONS SET ITERATION_STATUS = 'Completed' WHERE ID=c.id;

                       ELSE
                           --FA.20170919 Check if notification was sent before registering message
                            SELECT COUNT('X') INTO l_count  FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl WHERE menl.MIGRATION_BATCH_ID='00'|| '-' || C.ID AND menl.MSG_CODE=MIGR_GVAR.GV_MSG_CODE_FAIL_ARCHIVE_DATA;

                           IF l_count =0 THEN
                                  MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ('00'|| '-' || C.ID, MIGR_GVAR.GV_MSG_CODE_FAIL_ARCHIVE_DATA );
                                  MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;

                                   END IF;
                              END IF;

                        IF c.next_renewal IS NOT NULL THEN  -- not the last month

                            NULL;
                        ELSE  -- last month
                           --FA.20170918 Check if last cycle has been completed
                             select COUNT (1) INTO l_incompleteCycles FROM ETL_MIGRATION_CONDITIONS emc  WHERE iteration_status <> MIGR_GVAR.GV_ITERATION_COMPLETED;

                            IF l_incompleteCycles =0 THEN
                                  l_LogRec.logMsg := 'Migration for all months is finished. MIGR_RUN_SIGNAL_JOB will be disabled' || c.next_start;
                                  MIGR_LOG.LOG_INFO(l_LogRec);
                                  l_remove_interval := 1;  -- signal job minutely interval will be removed at the end of the procedure

                                  -- End of migration!
                                  MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( '0-0', MIGR_GVAR.GV_MSG_CODE_MIGR_END );
                                   --FA.20170915 Send email as signal will be dropped
                                      MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;
                             END IF;
                        END IF;

                    END IF;
                    END IF;
              --FA. 20170615 If next iteration date has arrived and the iteration cycle has not been completed send a notification
                  IF c.next_start IS NOT NULL  THEN
                      IF SYSDATE >= c.next_start THEN -----OR c.next_start IS NULL THEN
                            FOR r IN (SELECT MIGRATION_BATCH_ID,MIGRATION_DELAY  FROM MIG_MIGRATION_INFO WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING,MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC)  )
                            LOOP
                              IF R.MIGRATION_DELAY IS NULL THEN
                                  MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_WITH_DYNAMIC_MSG ( R.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_PROCESS_DELAY,
                                  'Batch: ' || R.MIGRATION_BATCH_ID || ' for renewal date: ' || TO_CHAR(TRUNC(c.renewal_date), 'dd-mm-yyyy') || ' has not been completed. The next migration iteration for the: ' || TO_CHAR(TRUNC(c.next_renewal), 'dd-mm-yyyy') || ' renewal date cannot be triggered. Immediate action is required. ' );
                                  UPDATE MIG_MIGRATION_INFO SET MIGRATION_DELAY=SYSTIMESTAMP WHERE MIGRATION_BATCH_ID =r.MIGRATION_BATCH_ID;
                              END IF;

                            END LOOP;
                        END IF;
                   END IF;
          ELSE
              l_LogRec.logMsg := 'Dates inconsistency for renewal month with ID: ' || c.id;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          END IF;
      END LOOP;


      IF l_remove_interval=1 THEN
        DBMS_SCHEDULER.SET_ATTRIBUTE_NULL (name => 'MIGR_RUN_SIGNAL_JOB', attribute => 'repeat_interval');
      END IF;

      l_LogRec.logMsg := 'Total MIGRATION_SCHEDULE Process runtime: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
      MIGR_LOG.LOG_INFO(l_LogRec);

  EXCEPTION WHEN OTHERS THEN
        l_LogRec.logMsg := SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

 END MIGRATION_SCHEDULE;

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
PROCEDURE LOG_NOT_MIGRATED_BOLAGS_DISC(p_id IN PLS_INTEGER, p_applicable_bolags IN VARCHAR2)
  IS

    i        PLS_INTEGER:=1;   -- variable gets positions of comma in p_applicable_bolags string
    v_bolag  VARCHAR2(10);
    v_flag   PLS_INTEGER:=0;
    l_LogRec MIGR_GVAR.LogRecTyp;
    l_list   VARCHAR2(200);
    l_count  PLS_INTEGER:=0;

begin

    l_LogRec.migrArea := 'MIGR_SIGNAL.LOG_NOT_MIGRATED_BOLAGS_DISC';
    l_LogRec.migrStep := 'Check for Bolags not uploaded MD_DISCOUNTS.txt';

    WHILE INSTR(p_applicable_bolags,',',i+1,1)<> 0   --search p_applicable_bolags string for the next comma until it does not exist
    loop
          v_bolag:=SUBSTR(p_applicable_bolags,INSTR(p_applicable_bolags,',',i,1)+1,2);  --variable carries the bolag which is after the current comma position, in the relative string

          --identify bolags which have a batch in MIG_MIGRATION_INFO in status Wait_Discounts (all batches of previous renewal months are excluded)
          FOR c IN (SELECT a.bolag ,b.MIGRATION_BATCH_ID
                    from (SELECT v_bolag bolag FROM DUAL) a  JOIN (select MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO where NVL(DATA_MOVED_TO_ARCHIVE,'0') <> MIGR_GVAR.GV_STATUS_FINISHED and status=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC) b ON a.bolag=SUBSTR(b.MIGRATION_BATCH_ID,1,2)
          )
          LOOP
              l_LogRec.logMsg := 'Bolag ' ||c.bolag || ' did not upload MD_DISCOUNTS.txt, during renewal month with ID='||p_id;
              MIGR_LOG.LOG_INFO(l_LogRec);
              v_flag:=1;
              l_list:=l_list||c.bolag||',';

              SELECT COUNT('X') INTO l_count FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl WHERE menl.MIGRATION_BATCH_ID=c.MIGRATION_BATCH_ID AND menl.MSG_CODE=MIGR_GVAR.GV_MSG_CODE_MIGR_MISSING_DISC;
              IF l_count=0 THEN
                  ---MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c.BOLAG || '-' || LPAD(p_id, 6, 0), MIGR_GVAR.GV_MSG_CODE_MIGR_MISSING_DISC );
                      MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_MIGR_MISSING_DISC );

              END IF;
          END LOOP;

          i:=INSTR(p_applicable_bolags,',',i+1,1);

    end loop;

    UPDATE ETL_MIGRATION_CONDITIONS SET MISSED_DISCOUNTS_DEADLINE=(CASE when NVL(l_list,' ') <> ' ' THEN SUBSTR(l_list,1,LENGTH(l_list)-1) ELSE 'All bolags (which entered migr process) uploaded MD_DISCOUNTS.txt' END) WHERE ID=p_id;

 EXCEPTION WHEN OTHERS THEN
    l_LogRec.logMsg := SQLERRM;
    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
end LOG_NOT_MIGRATED_BOLAGS_DISC;

  -------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_SIGNAL;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_SYSTEM
  IS
-----------------------------------------------------------------------------------------------------
--    ALTER SESSION SET NLS_LANGUAGE = 'ENGLISH';

-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
-- MIGR_LOG_LINE_R
--Usage
--  declare EvLog  MIGR_SYSTEM.LogLineRecTyp;
--  EvLog.MIGRATION_BATCH_ID  := '2-2';
--  EvLog.MIGRATION_AREA      := 'COMMON AREA';
--  EvLog.MIGRATION_STEP      := 'First Step to log event';
--  EvLog.EVENT_TYPE          := 'TEST';
--  EvLog.EVENT_MESSAGE       := 'TESTING LOG';
--  EvLog.RELATED_TABLE       := 'Main Table';
--  EvLog.RELATED_KEY         := 'No related key was found';
--  MIGR_SYSTEM.MIGR_LOG_LINE_R('FALSE', EvLog);

-----------------------------------------------------------------------------------------------------
--v.alex.29/7/16. adhoc executed code which deletes all policies from MIGR_POLICY
/*PROCEDURE DELETE_INSIS_POLICY
AS
  L_IN_CONTEXT  SRVCONTEXT;
  L_OUT_CONTEXT SRVCONTEXT;
  PIO_ERR       SRVERR;
  l_policyId    POLICY.policy_id % TYPE;
  L_RESULT      VARCHAR2(50);
  l_policyRec   MIGR_GVAR.PolicyRecTyp;
  l_evres       PLS_INTEGER;
  L_ADDRESS_ID  NUMBER;
  migr_user VARCHAR2(30);
  l_LogRec      MIGR_GVAR.LogRecTyp;
  cnt pls_integer;
    v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

begin
   l_LogRec.migrStep := 'Delete Insis Policies';
   l_LogRec.logMsg := '';
   l_LogRec.migrArea := 'MIGR_SYSTEM.DELETE_INSIS_POLICY';



   EXECUTE immediate  ' ALTER SESSION SET NLS_DATE_FORMAT = ''MM/DD/SYYYY HH24:MI:SS''';
   EXECUTE immediate  ' ALTER SESSION SET NLS_TIMESTAMP_TZ_FORMAT = ''MM/DD/SYYYY HH24:MI:SS.FF TZH:TZM''';
   EXECUTE immediate  ' ALTER SESSION SET NLS_TIMESTAMP_FORMAT = ''MM/DD/SYYYY HH24:MI:SS.FF''';
   EXECUTE immediate  ' ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
   EXECUTE immediate  ' ALTER SESSION SET NLS_NCHAR_CONV_EXCP = FALSE';
   EXECUTE immediate  ' ALTER SESSION SET TIME_ZONE = ''+01:00''';


   SELECT migration_user
    into migr_user
   from ETL_SETUP_INFO;

   INSIS_SYS_V10.INSIS_CONTEXT.Prepare_Session(Pi_App       => 'GEN',
                                                    Pi_Action    => 'InsisPolicyGen',
                                                    -- FA. 20160405 Change user to migration user
                                                    Pi_Username  => migr_user   , --For SYT:insis_gen_v10    FOR DEVMIG:insis_mig_user
                                                    Pi_User_Role => 'InsisStaff',
                                                    Pi_Lang      => NULL,
                                                    Pi_Country   => NULL);

   for c IN (SELECT POLICY_ID
             FROM MIGR_POLICY
   )
   LOOP
       cnt:=cnt+1;
       SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, c.POLICY_ID);
       v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('DEL_POLICY');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
      EXECUTE IMMEDIATE v_stmst
      USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

       --MIGR_SYSTEM.CALL_EVENT('DEL_POLICY', L_IN_CONTEXT, MIGR_API_COMMON.GV_DEBUG, L_OUT_CONTEXT, PIO_ERR);
       if cnt=1000 THEN
        COMMIT;
        cnt:=0;
       end if;
   end LOOP;

   COMMIT;

  EXCEPTION WHEN OTHERS THEN
          l_LogRec.logMsg := SQLERRM ;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);



END DELETE_INSIS_POLICY;
   */
--v.alex.29/7/16.end
-------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------
--v.alex.9/9/16 - second version of overloaded procedure DELETE_INSIS_POLICY, which takes specific policy_id as a parameter
  /*
PROCEDURE DELETE_INSIS_POLICY(p_policy_id IN MIGR_POLICY.POLICY_ID % TYPE)
AS
  L_IN_CONTEXT  SRVCONTEXT;
  L_OUT_CONTEXT SRVCONTEXT;
  PIO_ERR       SRVERR;
  l_policyId    POLICY.policy_id % TYPE;
  L_RESULT      VARCHAR2(50);
  l_policyRec   MIGR_GVAR.PolicyRecTyp;
  l_evres       PLS_INTEGER;
  L_ADDRESS_ID  NUMBER;
  migr_user VARCHAR2(30);
  l_LogRec      MIGR_GVAR.LogRecTyp;

    v_stmst    VARCHAR2( 400);
      v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;

begin
   l_LogRec.migrStep := 'Delete Specific Insis Policy';
   l_LogRec.logMsg := '';
   l_LogRec.migrArea := 'MIGR_SYSTEM.DELETE_INSIS_POLICY';



   EXECUTE immediate  ' ALTER SESSION SET NLS_DATE_FORMAT = ''MM/DD/SYYYY HH24:MI:SS''';
   EXECUTE immediate  ' ALTER SESSION SET NLS_TIMESTAMP_TZ_FORMAT = ''MM/DD/SYYYY HH24:MI:SS.FF TZH:TZM''';
   EXECUTE immediate  ' ALTER SESSION SET NLS_TIMESTAMP_FORMAT = ''MM/DD/SYYYY HH24:MI:SS.FF''';
   EXECUTE immediate  ' ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
   EXECUTE immediate  ' ALTER SESSION SET NLS_NCHAR_CONV_EXCP = FALSE';
   EXECUTE immediate  ' ALTER SESSION SET TIME_ZONE = ''+01:00''';


   SELECT migration_user
    into migr_user
   from ETL_SETUP_INFO;

   INSIS_SYS_V10.INSIS_CONTEXT.Prepare_Session(Pi_App       => 'GEN',
                                                    Pi_Action    => 'InsisPolicyGen',
                                                    -- FA. 20160405 Change user to migration user
                                                    Pi_Username  => migr_user   , --For SYT:insis_gen_v10    FOR DEVMIG:insis_mig_user
                                                    Pi_User_Role => 'InsisStaff',
                                                    Pi_Lang      => NULL,
                                                    Pi_Country   => NULL);


       SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policy_id);

      v_event:=MIGR_API_COMMON.GET_INSIS_EVENT('DEL_POLICY');

      v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
      EXECUTE IMMEDIATE v_stmst
      USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

       --MIGR_SYSTEM.CALL_EVENT('DEL_POLICY', L_IN_CONTEXT, MIGR_API_COMMON.GV_DEBUG, L_OUT_CONTEXT, PIO_ERR);


   COMMIT;

  EXCEPTION WHEN OTHERS THEN
          l_LogRec.logMsg := SQLERRM ;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);



END DELETE_INSIS_POLICY;
  */
--v.alex.9/9/16 - end
-------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------
  --FA.20161221 Use one log mechanism- Avoid package state invalidation
/*PROCEDURE MIGR_LOG_LINE_R (
    P_DEBUG             IN VARCHAR2
  , rLogLine            IN MIGR_SYSTEM.LogLineRecTyp
)
AS
    --command to start an autonomous transaction
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
--  IF P_DEBUG = INSIS_GEN_CFG_V10.GVAR_RB.FLG_TRUE THEN

  INSERT INTO MIGR_API_DETAIL_LOG (  LOG_ID, MIGRATION_BATCH_ID ,EVENT_TIMESTAMP
                                    ,MIGRATION_AREA ,EVENT_TYPE, EVENT_MESSAGE
                                    ,MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
      ) VALUES (
                  MIGR_DETAIL_SEQ.NEXTVAL, rLogLine.MIGRATION_BATCH_ID, SYSTIMESTAMP
                , substr(rLogLine.MIGRATION_AREA,1,50), SUBSTR(rLogLine.EVENT_TYPE,1,50), SUBSTR(rLogLine.EVENT_MESSAGE,1,2000)
                , SUBSTR(rLogLine.MIGRATION_STEP,1,256), SUBSTR(rLogLine.RELATED_TABLE,1,2000), SUBSTR(rLogLine.RELATED_KEY,1,2000)
    ) ;

  --KB 2015-09-28 added
  COMMIT;

-- In an autonomous transaction you have either to commit or rollback
-- in order to terminate the transaction
  IF P_DEBUG = GVAR_RB.FLG_TRUE THEN
      DBMS_OUTPUT.PUT_LINE( rLogLine.MIGRATION_AREA || '.' || rLogLine.MIGRATION_STEP || ': = ' || rLogLine.EVENT_MESSAGE || ' ' || rLogLine.RELATED_KEY || ' ( ' || rLogLine.RELATED_TABLE ||' )');
  END IF;

  --KB 2015-09-28 added
EXCEPTION WHEN OTHERS
THEN
    ROLLBACK;
END MIGR_LOG_LINE_R;
*/
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
--Usage
--    L_MIGRATION_BATCH_ID  NUMBER;
--    L_MIGRATION_AREA      VARCHAR2(50);
--    L_MIGRATION_STEP      VARCHAR2(256);
--    L_ERROR_TYPE          VARCHAR2(50);
--    L_ERROR_MESSAGE       VARCHAR2(256);
--    L_RELATED_TABLE      MIGR_API_DETAIL_LOG.RELATED_TABLE%TYPE;     --VARCHAR2(2000);
--    L_RELATED_KEY        MIGR_API_DETAIL_LOG.RELATED_KEY%TYPE;        --;VARCHAR2(2000);
--    L_MIGRATION_BATCH_ID  := 1;
--    L_MIGRATION_AREA      := 'MIGR_API_MAIN';
--    L_MIGRATION_STEP      := 'Checking Agents';
--    L_ERROR_TYPE          := 'Information';
--    L_ERROR_MESSAGE       := '  Agent No ';
--    L_RELATED_TABLE       := 'IA_AGENTS';
--    L_RELATED_KEY         := '11111111';
--  MIGR_SYSTEM.MIGR_LOG_LINE( 'FALSE' , L_MIGRATION_BATCH_ID, L_MIGRATION_AREA, L_MIGRATION_STEP,  L_ERROR_TYPE, L_ERROR_MESSAGE, L_RELATED_TABLE, L_RELATED_KEY )  ;


PROCEDURE MIGR_LOG_LINE (
    P_DEBUG             IN VARCHAR2
  , MIGRATION_BATCH_ID  IN VARCHAR2
  , MIGRATION_AREA      IN VARCHAR2
  , MIGRATION_STEP      IN VARCHAR2
  , ERROR_TYPE          IN VARCHAR2
  , ERROR_MESSAGE       IN VARCHAR2
  , RELATED_TABLE       IN VARCHAR2
  , RELATED_KEY         IN VARCHAR2
)
AS
    --command to start an autonomous transaction
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
--  IF P_DEBUG = INSIS_GEN_CFG_V10.GVAR_RB.FLG_TRUE THEN

  INSERT INTO MIGR_API_DETAIL_LOG (  LOG_ID, MIGRATION_BATCH_ID ,EVENT_TIMESTAMP
                                    ,MIGRATION_AREA ,EVENT_TYPE, EVENT_MESSAGE
                                    ,MIGRATION_STEP, RELATED_TABLE, RELATED_KEY
      ) VALUES (
                  MIGR_DETAIL_SEQ.NEXTVAL, MIGRATION_BATCH_ID, SYSTIMESTAMP
                , substr(MIGRATION_AREA,1,50), SUBSTR(ERROR_TYPE,1,50), SUBSTR(ERROR_MESSAGE,1,2000)
                , SUBSTR(MIGRATION_STEP,1,256), SUBSTR(RELATED_TABLE,1,2000), SUBSTR(RELATED_KEY,1,2000)
    ) ;

  --KB 2015-09-28 added
  COMMIT;

-- In an autonomous transaction you have either to commit or rollback
-- in order to terminate the transaction
  IF P_DEBUG = GVAR_RB.FLG_TRUE THEN
      DBMS_OUTPUT.PUT_LINE( MIGRATION_AREA || '.' || MIGRATION_STEP || ': = ' || ERROR_MESSAGE || ' ' || RELATED_KEY || ' ( ' || RELATED_TABLE ||' )');
  END IF;

  --KB 2015-09-28 added
EXCEPTION WHEN OTHERS
THEN
    ROLLBACK;
END MIGR_LOG_LINE;
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------

PROCEDURE MIGR_LOG_ERR (
    P_DEBUG     VARCHAR2
  , P_EVENT     IN VARCHAR2
  , PIO_ERR     IN OUT SRVERR)
AS
BEGIN

--  , MIGRATION_BATCH_ID  IN NUMBER
--  , MIGRATION_AREA      IN VARCHAR2
--  , MIGRATION_STEP      IN VARCHAR2
--  , ERROR_TYPE          IN VARCHAR2
--  , ERROR_MESSAGE       IN VARCHAR2
--  , RELATED_TABLE       IN VARCHAR2
--  , RELATED_KEY         IN VARCHAR2

--  IF P_DEBUG = GVAR_RB.FLG_TRUE THEN
      FOR I IN PIO_ERR.FIRST..PIO_ERR.LAST
      LOOP
          MIGR_SYSTEM.MIGR_LOG_LINE( 'TRUE' , 1, 'MIGR_API_EVENT: ' || P_EVENT,  PIO_ERR(I).ERRTYPE, 'ERROR', PIO_ERR(I).ERRMESSAGE, '','' )  ;
--          DBMS_OUTPUT.PUT_LINE('---------------ERROR---------------------------');
--          DBMS_OUTPUT.PUT_LINE('ERROR:'||PIO_ERR(I).ERRCODE);
--          DBMS_OUTPUT.PUT_LINE('TYPE:'||PIO_ERR(I).ERRTYPE );
--          DBMS_OUTPUT.PUT_LINE('MESSAGE:'||PIO_ERR(I).ERRMESSAGE );
      END LOOP;
--  END IF;
END MIGR_LOG_ERR;

-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
--FA.20151117 AUTONOMOUS TRANSACTION TO INSERT INTO MIGR_VOLUME_LOG

PROCEDURE MIGR_LOG_VOLUME (
      p_MIGRATION_BATCH_ID  IN VARCHAR2
    , p_MIGRATION_AREA      IN VARCHAR2
    , p_RELATED_TABLE       IN VARCHAR2
    , p_beginTimer          TIMESTAMP WITH TIME ZONE
    , p_EndTimer            TIMESTAMP WITH TIME ZONE
    , p_status              IN VARCHAR2
    , p_TotRows             PLS_INTEGER
    , p_RowsSuccess         PLS_INTEGER
    , p_RowsSkipped         PLS_INTEGER
    , p_RowsErrors          PLS_INTEGER
)
AS

    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN

   INSERT INTO MIGR_VOLUME_LOG(MIGRATION_BATCH_ID, MIGRATION_AREA, TABLE_NAME, LOG_START, LOG_END, DURATION, STATUS, TOTROWS, ROWSSUCCESS, ROWSSKIPPED, ROWSERRORS)
   VALUES (p_MIGRATION_BATCH_ID, p_MIGRATION_AREA, p_RELATED_TABLE, p_beginTimer, p_EndTimer, MIGR_SYSTEM.fn_ELAPSEDms(p_EndTimer, p_beginTimer), p_status, p_TotRows, p_RowsSuccess, p_RowsSkipped, p_RowsErrors);

 COMMIT;

EXCEPTION WHEN OTHERS THEN
    ROLLBACK;
END MIGR_LOG_VOLUME;
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------

PROCEDURE PRINT_LINE (
    P_DEBUG     VARCHAR2
  , MSG_LINE IN VARCHAR2 )
AS
BEGIN
--  IF P_DEBUG = INSIS_GEN_CFG_V10.GVAR_RB.FLG_TRUE THEN
  IF P_DEBUG = GVAR_RB.FLG_TRUE THEN
      DBMS_OUTPUT.PUT_LINE(MSG_LINE);
  END IF;
END PRINT_LINE;
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
PROCEDURE PRINT_ERR (
    P_DEBUG     VARCHAR2
  , PIO_ERR     IN OUT SRVERR)
AS
BEGIN
  IF P_DEBUG = GVAR_RB.FLG_TRUE THEN
      FOR I IN PIO_ERR.FIRST..PIO_ERR.LAST
      LOOP
          DBMS_OUTPUT.PUT_LINE('---------------ERROR---------------------------');
          DBMS_OUTPUT.PUT_LINE('ERROR:'||PIO_ERR(I).ERRCODE);
          DBMS_OUTPUT.PUT_LINE('TYPE:'||PIO_ERR(I).ERRTYPE );
          DBMS_OUTPUT.PUT_LINE('MESSAGE:'||PIO_ERR(I).ERRMESSAGE );

          MIGR_SYSTEM.MIGR_LOG_LINE('FALSE', 'Event', 'Event', 'Call Event', 'Information', 'ERROR: '||PIO_ERR(I).ERRCODE || 'MESSAGE: '||PIO_ERR(I).ERRMESSAGE, '', '');
      END LOOP;
  END IF;
END PRINT_ERR;
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
--- +++ anb 2015-09-18
PROCEDURE PRINT_EXCEPTION (
    P_DEBUG     IN VARCHAR2
  , MSG_LINE    IN VARCHAR2
  , PIO_ERR     IN OUT SRVERR)
AS
BEGIN
  IF P_DEBUG = GVAR_RB.FLG_TRUE THEN
      MIGR_SYSTEM.PRINT_LINE(P_DEBUG,'Exception msg: ' ||MSG_LINE);
      MIGR_SYSTEM.PRINT_ERR(P_DEBUG,PIO_ERR);
  END IF;
END PRINT_EXCEPTION;
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
PROCEDURE PRINT_CONTEXT
(
    DEBUG_ON        IN  VARCHAR2
  , IN_MSG          IN  VARCHAR2
  , IN_CONTEXT      IN  SRVCONTEXT
)
AS
    VAR             VARCHAR2(4000);
BEGIN
      IF DEBUG_ON = GVAR_RB.FLG_TRUE THEN
          PRINT_LINE( DEBUG_ON , '');
          IF IN_CONTEXT IS NOT NULL THEN
                PRINT_LINE( DEBUG_ON , 'Contents of ' || IN_MSG);
                FOR I IN IN_CONTEXT.FIRST..IN_CONTEXT.LAST
          			LOOP
          				SRV_CONTEXT.GETCONTEXTATTRCHAR( IN_CONTEXT, IN_CONTEXT(I).ATTRCODE, VAR);
                  PRINT_LINE( DEBUG_ON , IN_CONTEXT(I).ATTRCODE||':'||VAR);

          			END LOOP;
          ELSE
                PRINT_LINE( DEBUG_ON , 'There are NO Contents for ' || IN_MSG);
    		  END IF;
      END IF;
END PRINT_CONTEXT;
-----------------------------------------------------------------------------------------------------
PROCEDURE CALL_EVENT
(
    EVENT_NAME      IN  VARCHAR2
  , IN_CONTEXT      IN  SRVCONTEXT
  , DEBUG_ON        IN  VARCHAR2
  , OUT_CONTEXT     OUT SRVCONTEXT
  , PIO_ERR         IN OUT SRVERR
  , LOG_ERR         IN  VARCHAR2            -- overloading , log errors  -- +++ anb 2016-05-20
)
AS

    VAR             VARCHAR2(4000);
BEGIN
  IF DEBUG_ON = GVAR_RB.FLG_TRUE THEN
      PRINT_LINE( DEBUG_ON , '--------INVOKING EVENT '||EVENT_NAME||' --------');

      IF IN_CONTEXT IS NOT NULL
    			THEN
          PRINT_LINE( DEBUG_ON , '');
          PRINT_LINE( DEBUG_ON , '-------------------INPUT-------------------');
          FOR I IN IN_CONTEXT.FIRST..IN_CONTEXT.LAST
    			LOOP
    				SRV_CONTEXT.GETCONTEXTATTRCHAR( IN_CONTEXT, IN_CONTEXT(I).ATTRCODE, VAR);
            PRINT_LINE( DEBUG_ON , IN_CONTEXT(I).ATTRCODE||':'||VAR);

    			END LOOP;
      END IF;
  END IF;

-- +++ anb 2015-09-11 DUMMY EVENT for testing
  IF EVENT_NAME <> 'MIGR_DUMMY_EVENT' THEN
      SRV_EVENTS.SYSEVENT( EVENT_NAME,IN_CONTEXT, OUT_CONTEXT, PIO_ERR);
  ELSE
      PRINT_LINE( DEBUG_ON , 'MIGR_DUMMY_EVENT was executed ');
  END IF;
-- +++ end anb 2015-09-11 DUMMY EVENT for testing


	IF SRV_ERROR.RQSTATUS( PIO_ERR ) THEN
      PRINT_CONTEXT( DEBUG_ON, '-- Output Results ----' , OUT_CONTEXT  );
  ELSE
      IF LOG_ERR = 'TRUE' THEN                    -- +++ anb 2016-05-20
--      PRINT_ERR( GVAR_RB.FLG_TRUE , PIO_ERR);
        MIGR_LOG_ERR( GVAR_RB.FLG_TRUE, EVENT_NAME , PIO_ERR);
      END IF;
  END IF;

END CALL_EVENT;

-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
PROCEDURE CALL_EVENT
(
    EVENT_NAME      IN  VARCHAR2
  , IN_CONTEXT      IN  SRVCONTEXT
  , DEBUG_ON        IN  VARCHAR2
  , OUT_CONTEXT     OUT SRVCONTEXT
  , PIO_ERR         IN OUT SRVERR
)
AS

    VAR             VARCHAR2(4000);
BEGIN
  --FA.20161216 No need to  to reference other schema variable
 -- IF DEBUG_ON = GVAR_RB.FLG_TRUE THEN
   IF DEBUG_ON = 'TRUE'  THEN
      PRINT_LINE( DEBUG_ON , '--------INVOKING EVENT '||EVENT_NAME||' --------');

      IF IN_CONTEXT IS NOT NULL
    			THEN
          PRINT_LINE( DEBUG_ON , '');
          PRINT_LINE( DEBUG_ON , '-------------------INPUT-------------------');
          FOR I IN IN_CONTEXT.FIRST..IN_CONTEXT.LAST
    			LOOP
    				SRV_CONTEXT.GETCONTEXTATTRCHAR( IN_CONTEXT, IN_CONTEXT(I).ATTRCODE, VAR);
            PRINT_LINE( DEBUG_ON , IN_CONTEXT(I).ATTRCODE||':'||VAR);

    			END LOOP;
      END IF;
  END IF;

-- +++ anb 2015-09-11 DUMMY EVENT for testing
   --FA.20161216 No need to  test it
 -- IF EVENT_NAME <> 'MIGR_DUMMY_EVENT' THEN
      SRV_EVENTS.SYSEVENT( EVENT_NAME,IN_CONTEXT, OUT_CONTEXT, PIO_ERR);
 -- ELSE
 ---     PRINT_LINE( DEBUG_ON , 'MIGR_DUMMY_EVENT was executed ');
 --- END IF;
-- +++ end anb 2015-09-11 DUMMY EVENT for testing
   --FA.20161216 No need to  print  it
	---IF SRV_ERROR.RQSTATUS( PIO_ERR ) THEN
   ---   PRINT_CONTEXT( DEBUG_ON, '-- Output Results ----' , OUT_CONTEXT  );
 --- ELSE
    ---    NULL;
--      PRINT_ERR( GVAR_RB.FLG_TRUE , PIO_ERR);
      --FA.20160307  MIGR_LOG_ERR( GVAR_RB.FLG_TRUE, EVENT_NAME , PIO_ERR);
 --- END IF;

END CALL_EVENT;

-----------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------
---  calculate elapsed time (ms)
---         elapsed_ms NUMBER := fn_Elapsedms( end_time, start_time);
---
FUNCTION fn_ELAPSEDms (
            p_end   in TIMESTAMP with time zone
          , p_start in TIMESTAMP with time zone
  )
  RETURN NUMBER
IS
        L_elapsed      INTERVAL DAY TO SECOND;

    BEGIN
        L_elapsed := p_end - p_start ;
        return (extract ( day from L_elapsed )*24*60*60*1000 +
                          extract ( hour from L_elapsed )*60*60*1000 +
                          extract ( minute from L_elapsed )*60*1000 +
                          extract ( second from L_elapsed )*1000
                );
    END;      -- function
-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
PROCEDURE INIT_SYSTEM AS
    vSQL    VARCHAR2(2100);
BEGIN


  vSQL := 'TRUNCATE TABLE MIGR_API_DETAIL_LOG';
  EXECUTE IMMEDIATE vSQL;

  vSQL := 'TRUNCATE TABLE MIGR_API_CLOB_LOG';       -- +++ anb 2018-11-11 clob logging
  EXECUTE IMMEDIATE vSQL;
  --COMMIT;

  vSQL := 'DROP SEQUENCE MIGR_DETAIL_SEQ';
  EXECUTE IMMEDIATE vSQL;
  --COMMIT;

  vSQL := 'CREATE SEQUENCE MIGR_DETAIL_SEQ
                  INCREMENT BY 1
                  START WITH 1
                  NOMAXVALUE
                  NOCYCLE
                  CACHE 1000';
  EXECUTE IMMEDIATE vSQL;
  ---COMMIT;

  vSQL := 'DROP SEQUENCE MIGR_EMAIL_NOTIF_SEQ';
  EXECUTE IMMEDIATE vSQL;
  --COMMIT;

  vSQL := 'CREATE SEQUENCE MIGR_EMAIL_NOTIF_SEQ
                  INCREMENT BY 1
                  START WITH 1
                  NOMAXVALUE
                  NOCYCLE
                  CACHE 10';
  EXECUTE IMMEDIATE vSQL;
  ---COMMIT;

EXCEPTION WHEN OTHERS THEN
    MIGR_SYSTEM.PRINT_LINE ( 'TRUE', 'EXCEPTION on MIGR_SYSTEM.INIT_SYSTEM : '|| SQLERRM || ' ... '|| vSQL );

END INIT_SYSTEM;

-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
--valex.30/9/2016 - prints la,sa,rules and ia steps duration in output for specific batch_id
PROCEDURE batch_steps_duration (batch_id in  varchar2)
  AS
  CURSOR c1 IS
    SELECT EVENT_MESSAGE as step ,TO_CHAR(EVENT_TIMESTAMP)AS  duration
    FROM MIGR_API_DETAIL_LOG madl;

  TYPE row_type IS TABLE OF c1%ROWTYPE;
  l_rows row_type;

begin

--LA
  WITH x AS (SELECT EVENT_TIMESTAMP,ROW_NUMBER() OVER (partition BY MIGRATION_BATCH_ID ORDER BY MIGRATION_BATCH_ID) AS cnt
             FROM MIGR_API_DETAIL_LOG
             WHERE 1=1
               AND (EVENT_MESSAGE='Started Loading from LOAD to LA' OR EVENT_MESSAGE='Finished Loading from LOAD to LA')
               AND MIGRATION_BATCH_ID=batch_id
            order by LOG_ID desc)
  ,y as (
  SELECT * FROM x
  PIVOT( MIN(EVENT_TIMESTAMP) FOR cnt IN(1 as endtm,2 as starttm)))

--SA
  , a AS (SELECT EVENT_TIMESTAMP,ROW_NUMBER() OVER (partition BY MIGRATION_BATCH_ID ORDER BY MIGRATION_BATCH_ID) AS cnt
           FROM MIGR_API_DETAIL_LOG
           WHERE 1=1
             AND (EVENT_MESSAGE='Starting Loading from LA to SA' OR EVENT_MESSAGE='Finished Loading from LA to SA')
             AND MIGRATION_BATCH_ID=batch_id
           order by LOG_ID desc)
  ,b as (
  SELECT * FROM a
  PIVOT( MIN(EVENT_TIMESTAMP) FOR cnt IN(1 as endtm,2 as starttm)))

--RULES
  , c AS (SELECT EVENT_TIMESTAMP,ROW_NUMBER() OVER (partition BY MIGRATION_BATCH_ID ORDER BY MIGRATION_BATCH_ID) AS cnt
           FROM MIGR_API_DETAIL_LOG
           WHERE 1=1
             AND (EVENT_MESSAGE='Finished Loading from LA to SA' OR EVENT_MESSAGE='Started IA processing')
             AND MIGRATION_BATCH_ID=batch_id
           order by LOG_ID desc)
   ,d as (
  SELECT * FROM c
  PIVOT( MIN(EVENT_TIMESTAMP) FOR cnt IN(1 as endtm,2 as starttm)))

--IA
  , e AS (SELECT EVENT_TIMESTAMP,ROW_NUMBER() OVER (partition BY MIGRATION_BATCH_ID ORDER BY MIGRATION_BATCH_ID) AS cnt
           FROM MIGR_API_DETAIL_LOG
           WHERE 1=1
             AND (EVENT_MESSAGE='Started IA processing' OR EVENT_MESSAGE='Finished IA processing')
             AND MIGRATION_BATCH_ID=batch_id
           order by LOG_ID desc)
  ,f as (
  SELECT * FROM e
  PIVOT( MIN(EVENT_TIMESTAMP) FOR cnt IN(1 as endtm,2 as starttm)))

--union
  ,main as (SELECT 'LA duration:' AS step, endtm-starttm as duration
            FROM y
                UNION ALL
            SELECT 'SA duration:' AS step, endtm-starttm as duration
            FROM b
                UNION ALL
           SELECT 'RULES duration:' AS step, endtm-starttm as duration
           FROM d
              UNION ALL
           SELECT 'IA duration:' AS step, endtm-starttm as duration
           FROM f)
  select *
    bulk COLLECT INTO l_rows
  FROM main;

--print to output
  FOr i IN l_rows.FIRST..l_rows.COUNT
  LOOP
      dbms_output.put_line(l_rows(i).step || ' --> ' || SUBSTR(l_rows(i).duration,12));
  end LOOP;

END batch_steps_duration;

-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
--FA.20180108 The Policy may be registered in INSIS but not in migr_policy in case of system failure. Pass argument bolag id in order to  find bolag's username
PROCEDURE CANCEL_INSIS_POLICY(p_policy_id IN MIGR_POLICY.POLICY_ID % TYPE, p_bolag_id IN VARCHAR2)
AS
  L_IN_CONTEXT  SRVCONTEXT;
  L_OUT_CONTEXT SRVCONTEXT;
  PIO_ERR       SRVERR;
  L_RESULT      VARCHAR2(50);
  l_policyRec   MIGR_GVAR.PolicyRecTyp;
  l_evres       PLS_INTEGER;
  migr_user VARCHAR2(30);
  v_stmst    VARCHAR2( 400);
   v_event  MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME%TYPE;
  l_LogRec      MIGR_GVAR.LogRecTyp;


begin
   l_LogRec.migrStep := 'Cancel Insis Policy';
   l_LogRec.logMsg := '';
   l_LogRec.migrArea := 'MIGR_SYSTEM.CANCEL_INSIS_POLICY';
   l_LogRec.migrRelKey:=p_policy_id;


 SELECT ebi.BOLAG_USERNAME INTO migr_user
  FROM ETL_BOLAG_INFO ebi WHERE ebi.BOLAG_ID =p_bolag_id ; --- ( select SUBSTR(POLICY_IDPL, 1, 2) FROM MIGR_POLICY WHERE POLICY_ID=p_policy_id)  ;


   INSIS_SYS_V10.INSIS_CONTEXT.Prepare_Session(Pi_App       => 'GEN',
                                                    Pi_Action    => 'InsisPolicyGen',
                                                    Pi_Username  => migr_user   ,
                                                    Pi_User_Role => 'InsisStaff',
                                                    Pi_Lang      => NULL,
                                                    Pi_Country   => NULL);


   SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'POLICY_ID', SRV_CONTEXT.Integers_Format, p_policy_id);
   SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'REASON_ID', SRV_CONTEXT.Integers_Format, 38);
    v_event:='MIGR_APPL_CANC';

    v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
    EXECUTE IMMEDIATE v_stmst
    USING in v_event, in L_IN_CONTEXT,in MIGR_GVAR.GV_DEBUG, out L_OUT_CONTEXT,in out PIO_ERR;

--     IF  PIO_ERR IS NOT NULL THEN
--          FOR I IN PIO_ERR.FIRST .. PIO_ERR.LAST    LOOP
--               DBMS_OUTPUT.PUT_LINE( 'ERROR:' || PIO_ERR(I).ERRCODE || '' || 'TYPE:' || PIO_ERR(I).ERRTYPE || ' MESSAGE:' ||             PIO_ERR(I).ERRMESSAGE);
--
--          END LOOP;
--    END IF;
    l_LogRec.logMsg :=  'Policy with policy_id: '||p_policy_id || ' is canceled';
    MIGR_LOG.LOG_INFO(l_LogRec);

   COMMIT;

  EXCEPTION WHEN OTHERS THEN
          l_LogRec.logMsg := SQLERRM ;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END CANCEL_INSIS_POLICY;

-----------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------

END MIGR_SYSTEM;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_TST_PRC_API
  AS
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  -- Returns batch number and its status according to api preferences.
  PROCEDURE GET_NEXT_BATCH(vMigrationBatchId OUT MIGR_POLICY.MIG_BATCH_ID % TYPE,
                           vStatus           OUT VARCHAR2)
    AS
      vPREF_NO NUMBER(2);
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN
      l_LogRec.migrArea := 'MIGR_API_RESUME.GET_NEXT_BATCH';
      l_LogRec.migrStep := 'MIGR_API_RESUME.GET_NEXT_BATCH';
      l_LogRec.migrRelTbl := '';

      SELECT NVL(PREF_NO, 0)
        INTO vPREF_NO
        FROM ETL_API_PREFERENCES
        WHERE 1 = 1
          AND IS_ACTIVE = 'Y'
          AND ROWNUM = 1;

      CASE vPREF_NO
        WHEN 0 THEN vMigrationBatchId := NULL;
            vStatus := NULL;
        WHEN 1 THEN SELECT MIGRATION_BATCH_ID,
                           STATUS
              INTO vMigrationBatchId,
                   vStatus
              FROM (SELECT mmi.MIGRATION_BATCH_ID,
                           mmi.STATUS,
                           mmi.START_TIMESTAMP
                  FROM MIG_MIGRATION_INFO mmi
                  WHERE 1 = 1
                    AND ((mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING
                    AND mmi.IA_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED)
                    OR (mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC
                    AND mmi.DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED))
                  ORDER BY mmi.START_TIMESTAMP ASC)
              WHERE 1 = 1
                AND ROWNUM = 1;

        WHEN 2 THEN SELECT MIG_BATCH_ID,
                           STATUS
              INTO vMigrationBatchId,
                   vStatus
              FROM (SELECT ip.MIG_BATCH_ID,
                           mmi.STATUS,
                           COUNT(*) AS COUNTER
                  FROM IA_POLICY ip
                    JOIN MIG_MIGRATION_INFO mmi
                      ON ip.MIG_BATCH_ID = mmi.MIGRATION_BATCH_ID
                  WHERE 1 = 1
                    AND ((mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING
                    AND mmi.IA_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED
                    AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_PENDING)
                    OR (mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC
                    AND mmi.DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED
                    AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS))
                  GROUP BY ip.MIG_BATCH_ID,
                           mmi.STATUS
                  ORDER BY COUNTER ASC)
              WHERE 1 = 1
                AND ROWNUM = 1;

        WHEN 3 THEN SELECT MIG_BATCH_ID,
                           STATUS
              INTO vMigrationBatchId,
                   vStatus
              FROM (SELECT ip.MIG_BATCH_ID,
                           mmi.STATUS,
                           COUNT(*) AS COUNTER
                  FROM IA_POLICY ip
                    JOIN MIG_MIGRATION_INFO mmi
                      ON ip.MIG_BATCH_ID = mmi.MIGRATION_BATCH_ID
                  WHERE 1 = 1
                    AND ((mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING
                    AND mmi.IA_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED
                    AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_PENDING)
                    OR (mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC
                    AND mmi.DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED
                    AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS))
                  GROUP BY ip.MIG_BATCH_ID,
                           mmi.STATUS
                  ORDER BY COUNTER DESC)
              WHERE 1 = 1
                AND ROWNUM = 1;

        ELSE vMigrationBatchId := NULL;
          vStatus := NULL;
      END CASE;

      l_LogRec.MIG_BATCH_ID := vMigrationBatchId;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN vMigrationBatchId := NULL;
          vStatus := NULL;
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
    END GET_NEXT_BATCH;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  ---Serves next policy to API according to the input batch number and status. If has pending policies and status is Running then turn policy flag to running  to trigger API phase 1
  -- If has pending policies and status is Running Discounts  then turn policy flag to running discounts  to trigger API phase 2
  PROCEDURE GET_NEXT_IDPL(vNextIDPL         OUT MIGR_POLICY.POLICY_IDPL % TYPE,
                          vMigrationBatchId IN  MIGR_POLICY.MIG_BATCH_ID % TYPE,
                          vStatus           IN  VARCHAR2)
    AS
      l_LogRec MIGR_GVAR.LogRecTyp;

    BEGIN
      l_LogRec.migrArea := 'MIGR_API_RESUME.GET_NEXT_IDPL';
      l_LogRec.migrStep := 'MIGR_API_RESUME.GET_NEXT_IDPL';
      l_LogRec.mig_batch_id := vMigrationBatchId;
      l_LogRec.migrRelTbl := 'Status: ' || vStatus;

      SELECT ip.IA_IDPL
        INTO vNextIDPL
        FROM IA_POLICY ip
          JOIN MIG_MIGRATION_INFO mmi
            ON ip.MIG_BATCH_ID = mmi.MIGRATION_BATCH_ID
        WHERE 1 = 1
          AND mmi.MIGRATION_BATCH_ID = vMigrationBatchId
          AND mmi.STATUS = vStatus
          AND ((mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING
          AND mmi.IA_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED
          AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_PENDING)
          OR (mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC
          AND mmi.DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED
          AND ip.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS))
          AND ROWNUM = 1;

      l_LogRec.migrRelKey := vNextIDPL;

      IF NOT vNextIDPL IS NULL
        AND vStatus = MIGR_GVAR.GV_BATCH_STATUS_RUNNING
      THEN
        -- Update IA_POLICY -> MIG_FLAG RUNNING!
        MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(vNextIDPL, MIGR_GVAR.GV_MIG_FLAG_RUNNING, vMigrationBatchId);

      ELSIF NOT vNextIDPL IS NULL
        AND vStatus = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC
      THEN
        -- Update IA_POLICY -> MIG_FLAG RUNNING DISCOUNTS!
        MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(vNextIDPL, MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS, vMigrationBatchId);
      END IF;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN vNextIDPL := NULL;
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          -- Update IA_POLICY -> MIG_FLAG FAILED!
          IF vStatus = MIGR_GVAR.GV_BATCH_STATUS_RUNNING
          THEN
            MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(vNextIDPL, MIGR_GVAR.GV_MIG_FLAG_FAILED, vMigrationBatchId);
          ELSE
            MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(vNextIDPL, MIGR_GVAR.GV_MIG_FLAG_FAILED_DISCOUNTS, vMigrationBatchId);
          END IF;
    END GET_NEXT_IDPL;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Truncates MIGR_ tables
  PROCEDURE TRUNCATE_MIGR_TABLES
    AS
      vSQL     VARCHAR2(2100);
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN

      vSQL := 'TRUNCATE TABLE MIGR_O_ENGINE';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_SHIP';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_POLICY';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_VOLUME_LOG';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_IA_SA_LIST';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_CONTENT_COOP';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_INDIVIDUAL_COVERS';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_LEISURE_HOME';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_LEISURE_MOBILE_HOME';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_POLICY_PARTICIPANTS';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_VILLAHEM';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_TRAVEL';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_ACCIDENT';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_CONTENT_ONLY';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_LEISURE_CONT_ONLY';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_LEISURE_COOP';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_O_BUILDING_VILLA';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_FAILED_POLICY';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'TRUNCATE TABLE MIGR_IA_SA_LIST';
      EXECUTE IMMEDIATE vSQL;
    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-0';
          l_LogRec.migrArea := 'TRUNCATE MIGR TABLES';
          l_LogRec.migrStep := 'MIGR_API_RESUME.TRUNCATE_MIGR_TABLES';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM || ' sql: ' || vSQL;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END TRUNCATE_MIGR_TABLES;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---Waits timeout seconds to receive alert message from an alert registered for session
  --If alert occured then remove alert from registration list and reduce the  reserved resources
  PROCEDURE WAIT_ANY_API_ALERT(vCOUNTER           IN OUT PLS_INTEGER,
                               vEXCEPTION_COUNTER IN OUT PLS_INTEGER)
    IS
      l_log_rec    MIGR_GVAR.LogRecTyp;

      /* Alert Variables */
      vAlertName   VARCHAR2(30);
      vAlertMsg    VARCHAR2(250);
      vAlertStatus VARCHAR2(1);
      v_cnt        NUMBER;
      v_alrt       NUMBER;
    BEGIN
      l_log_rec.mig_batch_id := '0-0';
      l_log_rec.migrArea := 'MIGR_API_RESUME.WAIT_ANY_API_ALERT';
      l_log_rec.migrRelTbl := '';

      DBMS_ALERT.WAITANY(vAlertName, vAlertMsg, vAlertStatus, 600); -- 10min
      -- vAlertMsg values returned: 0 - alert occurred, 1 - timeout occurred
      -- If alert occurred -> remove from alert list
      IF vAlertStatus = 0
      THEN
        l_Log_Rec.migrRelTbl := 'POLICY JOB';
        l_Log_Rec.logMsg := 'About to REMOVE: ' || vAlertName || ' Running Jobs: ' || vCOUNTER;
        l_log_rec.migrRelKey := vAlertMsg;
        MIGR_LOG.LOG_INFO(l_Log_Rec);

        DBMS_ALERT.REMOVE(vAlertName);
        -- We have one job free, go start a new! JOB may still exist in scheduler for few more seconds
        vCOUNTER := vCOUNTER - 1;
      -- If timeout occurred Log and wait again
      ELSIF vAlertStatus = 1
      THEN
        l_Log_Rec.migrRelTbl := 'POLICY JOB';
        l_Log_Rec.logMsg := 'ALERT_TIME_OUT: ' || vAlertName || ' Running Jobs: ' || vCOUNTER;
        l_log_rec.migrRelKey := vAlertMsg;
        MIGR_LOG.LOG_INFO(l_Log_Rec);

      END IF;

      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN vEXCEPTION_COUNTER := vEXCEPTION_COUNTER + 1;
          l_Log_Rec.logMsg := 'Exception No: ' || vEXCEPTION_COUNTER || ' | Alert Error - ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);
    END WAIT_ANY_API_ALERT;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --API State Mechanism that decides whether to submit a policy job , wait until server has available resources or exit migration
  PROCEDURE STATE_MACHINE_RUN_API
    IS
      l_log_rec          MIGR_GVAR.LogRecTyp;
      vLogRow            MIGR_PARALLEL_PROCESS_LOG % ROWTYPE;
      vNextPolicyRecord  IA_POLICY % ROWTYPE;
      vStatus            VARCHAR2(50);
      vNextIDPL          MIGR_POLICY.POLICY_IDPL % TYPE;
      vMigBatchId        MIGR_POLICY.MIG_BATCH_ID % TYPE;
      vCOUNTER           PLS_INTEGER;
      vMAX_RESOURCES     PLS_INTEGER;
      vEXCEPTION_COUNTER PLS_INTEGER;
      IA_COUNTER         PLS_INTEGER;
      Migrate_Policy     BOOLEAN;
      /* Job Variables */
      vJOB_NAME          VARCHAR2(30);
      vJOB_TYPE          VARCHAR2(15);
      vJOB_ACTION        VARCHAR2(4000);
      vJOB_NAME_TMPL     VARCHAR2(30);
      vJOB_COUNTER       PLS_INTEGER;
      vAlertCounter      PLS_INTEGER;
      vSTATE             VARCHAR2(30);
      vNEXT_STATE        VARCHAR2(30);
      vRESOURCES_NEEDED  PLS_INTEGER;

      vSQL               VARCHAR2(200);
      v_my_schema        VARCHAR2(50);
      --  v_mig_insis_user   ETL_SETUP_INFO.MIGRATION_USER%TYPE;
      l_runPhase2        PLS_INTEGER;
    BEGIN
      l_log_rec.mig_batch_id := '0-0';
      l_log_rec.migrArea := 'MIGR_API_RESUME.STATE_MACHINE_RUN_API';
      l_log_rec.migrRelTbl := '';

      vCOUNTER := 0;
      vRESOURCES_NEEDED := 0;
      vAlertCounter := 0;
      vEXCEPTION_COUNTER := 0;

      vSQL := 'ALTER SESSION SET NLS_DATE_FORMAT = ''YYYY-MM-DD''';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'ALTER SESSION SET NLS_LANGUAGE = ''ENGLISH''';
      EXECUTE IMMEDIATE vSQL;
      vSQL := 'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
      EXECUTE IMMEDIATE vSQL;

      --valex.18/11/2016 - Clean up policies with mig flag = 6 (if exist), as a result of preceding system outage
      MIGR_TST_PRC_RESUME.initialize_Running_policies;
      --FA.20170807 Check if at least one batch is in Phase 2 Running State to configure lower INSIS log level and prevent tablespace issues caused by extensive logging

      SELECT COUNT(*)
        INTO l_runPhase2
        FROM MIG_MIGRATION_INFO mmi
        WHERE mmi.STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC, MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC);
      IF l_runPhase2 > 0
      THEN
        MIGR_API_COMMON.DISABLE_INSIS_LOG_LEVEL;
      END IF;


      vJOB_TYPE := 'PLSQL_BLOCK';
      vJOB_COUNTER := 0;

      SELECT TASK_NAME
        INTO vJOB_NAME_TMPL
        FROM ETL_SETUP_INFO;

      -- dbms_alert init
      DBMS_ALERT.SET_DEFAULTS(1);  -- dbms_alert sensitivity - polling interval, in seconds, to sleep between polls
      -- Do not REMOVEALL!  DBMS_ALERT.REMOVEALL();      -- dbms_alert clean up

      Migrate_Policy := TRUE;
      vSTATE := 'GetPolicy';

      WHILE Migrate_Policy
        LOOP

          -- Check the PARALLEL_LEVEL field from ETL_SETUP_INFO
          --20170424     Select parallel level according to time windows options for system performance
          SELECT CASE WHEN TRIM(TO_CHAR(SYSDATE, 'DAY')) IN ('MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY') AND
              (TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) >= NVL(WORK_START_TIME, '06:00:00') AND
              TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) <= NVL(WORK_END_TIME, '18:00:00')) -- work day
              THEN NVL(MIN_PARALLEL_LEVEL, 1) WHEN (TRIM(TO_CHAR(SYSDATE, 'DAY')) IN ('TUESDAY', 'WEDNESDAY', 'THURSDAY') AND
              (TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) < NVL(WORK_START_TIME, '06:00:00') OR
              TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) > NVL(WORK_END_TIME, '18:00:00')))  -- work night
              OR (TRIM(TO_CHAR(SYSDATE, 'DAY')) = 'FRIDAY' AND
              TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) < NVL(WORK_START_TIME, '06:00:00'))                                         -- early friday
              OR (TRIM(TO_CHAR(SYSDATE, 'DAY')) = 'MONDAY' AND
              TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) > NVL(WORK_END_TIME, '18:00:00'))                                           -- late monday
              THEN NVL(MID_PARALLEL_LEVEL, 1) WHEN TRIM(TO_CHAR(SYSDATE, 'DAY')) IN ('SATURDAY', 'SUNDAY')                                                                                  -- weekend
              OR (TRIM(TO_CHAR(SYSDATE, 'DAY')) = 'FRIDAY' AND
              TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) > NVL(WORK_END_TIME, '18:00:00'))                -- late friday
              OR (TRIM(TO_CHAR(SYSDATE, 'DAY')) = 'MONDAY' AND
              TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) < NVL(WORK_START_TIME, '06:00:00'))              -- early monday
              THEN NVL(PARALLEL_LEVEL, 1) ELSE 1 END AS NEW_PRL_LEVEL
            INTO vMAX_RESOURCES
            FROM ETL_SETUP_INFO;
          --- SELECT NVL(PARALLEL_LEVEL, 0) INTO vMAX_RESOURCES FROM ETL_SETUP_INFO;

          IF vMAX_RESOURCES = 0
          THEN
            vRESOURCES_NEEDED := vMAX_RESOURCES;
            vSTATE := 'Flush_Queue';
            vNEXT_STATE := 'Stop_Migration';
          END IF;

          CASE vSTATE
            WHEN 'GetPolicy' THEN GET_NEXT_BATCH(vMigBatchId, vStatus);
                GET_NEXT_IDPL(vNextIDPL, vMigBatchId, vStatus);

                IF NOT vNextIDPL IS NULL
                  AND NOT vMigBatchId IS NULL
                  AND NOT vStatus IS NULL
                THEN
                  vRESOURCES_NEEDED := vRESOURCES_NEEDED + 1;
                  vSTATE := 'Check_Resources';
                ELSE
                  -- Check if mig_migration info has any pending batches :Pending batches conditions :Batch Status Running and ia pending or batch status Running_Discounts and Discount_Completed pending
                  -- Fa.20170109 Add condition:  OR  (STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC AND DISCOUNT_COMPLETED = 'Pending' )
                  -- valex.11/1/2017 - added Queued status so that API does not exit right after it starts, as a result of no applicable IDPL in IA_POLICY and no batch in Running status)
                  -- SELECT COUNT(*) INTO IA_COUNTER FROM MIG_MIGRATION_INFO WHERE (STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING AND IA_COMPLETED = 'Pending' ) OR  (STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC AND DISCOUNT_COMPLETED = 'Pending' ) ;
                  SELECT COUNT(*)
                    INTO IA_COUNTER
                    FROM MIG_MIGRATION_INFO
                    WHERE (STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_QUEUED)
                      AND IA_COMPLETED = MIGR_GVAR.GV_STATUS_PENDING)
                      OR (STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC, MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC)
                      AND DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_PENDING);

                  IF IA_COUNTER = 0
                  THEN
                    vRESOURCES_NEEDED := vMAX_RESOURCES;
                    vSTATE := 'Flush_Queue';
                    vNEXT_STATE := 'Exit_Migration';
                  END IF;
                END IF;

            WHEN 'Check_Resources' THEN IF vCOUNTER < vMAX_RESOURCES
                THEN
                  vJOB_COUNTER := vJOB_COUNTER + 1;
                  vJOB_NAME := vJOB_NAME_TMPL || vJOB_COUNTER;

                  vJOB_ACTION := 'BEGIN MIGR_TST_PRC_API_POLICY.MIGRATE_POLICY( ''' || vMigBatchId || ''', ''' || vNextIDPL || ''' ); DBMS_ALERT.SIGNAL( ''' || vJOB_NAME || ''', ''' || vNextIDPL || ''' ); COMMIT; END;';

                  l_Log_Rec.migrRelKey := vNextIDPL;
                  l_Log_Rec.migrRelTbl := 'POLICY JOB';
                  l_Log_Rec.logMsg := 'About to CREATE: ' || vJOB_NAME || ' Running Jobs: ' || vCOUNTER;
                  MIGR_LOG.LOG_INFO(l_Log_Rec);

                  -- Start a new job
                  BEGIN
                    -- Increase current running jobs + 1 and resources needed - 1
                    vCOUNTER := vCOUNTER + 1;
                    vRESOURCES_NEEDED := vRESOURCES_NEEDED - 1;

                    vSTATE := 'GetPolicy';

                    l_Log_Rec.migrRelTbl := 'POLICY JOB';
                    l_Log_Rec.logMsg := 'About to REGISTER: ' || vJOB_NAME || ' Running Jobs: ' || vCOUNTER;
                    l_log_rec.migrRelKey := vNextIDPL;
                    MIGR_LOG.LOG_INFO(l_Log_Rec);
                    DBMS_ALERT.REGISTER(vJOB_NAME);

                    COMMIT;

                    l_Log_Rec.logMsg := 'Scheduler - ';
                    DBMS_SCHEDULER.CREATE_JOB(
                    JOB_NAME => vJOB_NAME,
                    JOB_TYPE => vJOB_TYPE,
                    JOB_ACTION => vJOB_ACTION,
                    START_DATE => NULL,        -- Schedule job will run as soon as it is enabled
                    REPEAT_INTERVAL => NULL,        -- Schedule job will run only once
                    ENABLED => TRUE,
                    AUTO_DROP => TRUE
                    );

                    COMMIT;

                  EXCEPTION
                    WHEN OTHERS THEN vSTATE := 'Check_Resources';
                        vCOUNTER := vCOUNTER - 1;
                        vRESOURCES_NEEDED := vRESOURCES_NEEDED + 1;

                        FOR xx IN (SELECT ai.NAME
                            FROM SYS.DBMS_ALERT_INFO ai
                            WHERE UPPER(ai.NAME) = UPPER(vJOB_NAME))
                        LOOP
                          l_Log_Rec.migrRelTbl := 'POLICY JOB';
                          l_Log_Rec.logMsg := 'About to CLEAN UP Alert Info: ' || xx.NAME || ' Running Jobs: ' || vCOUNTER;
                          MIGR_LOG.LOG_INFO(l_Log_Rec);
                          DBMS_ALERT.REMOVE(xx.NAME);
                        END LOOP;

                        vEXCEPTION_COUNTER := vEXCEPTION_COUNTER + 1;
                        l_Log_Rec.logMsg := SQLERRM || ' - ' || vJOB_ACTION;
                        MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);

                  END;

                ELSE
                  vSTATE := 'Flush_Queue';
                  vNEXT_STATE := 'Check_Resources';

                END IF;

            WHEN 'Flush_Queue' THEN
                WHILE vRESOURCES_NEEDED > vMAX_RESOURCES - vCOUNTER
                LOOP
                    WAIT_ANY_API_ALERT(vCOUNTER, vEXCEPTION_COUNTER);
                END LOOP;
                vSTATE := vNEXT_STATE;

                IF vSTATE = 'Exit_Migration' OR MOD(vJOB_COUNTER, 1000) = 0  THEN
                     l_log_rec.migrRelKey := NULL;
                     l_Log_Rec.migrRelTbl := 'POLICY JOB';
                    --Fa.20170108 Check whether to turn status to Waiting Discounts or to Finished
                    FOR c IN (
                          SELECT mm.MIGRATION_BATCH_ID,
                           --FA.20180222 Change conditions that mark batch as Finished or Wait discounts pending only to succesfully migrated policies
                             (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_success
                         --  (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_FAILED AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_failed,
                           ---  (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_all
                             FROM MIG_MIGRATION_INFO mm
                            WHERE mm.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING
                              AND mm.IA_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED
                              AND 0=(SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_PENDING AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID))
                    LOOP
                        l_Log_Rec.logMsg := 'About to Set Migration Batch ID: ' || c.MIGRATION_BATCH_ID || ' to Waiting Discounts';
                        MIGR_LOG.LOG_INFO(l_Log_Rec);
                        --if at least one policy has been succesfully migrated then turn batch to wait discounts else turn batch to failed
                        IF c.c_success >=1 then
                          MIGR_TST_PRC_SIGNAL.CLOSE_BATCH(c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC);
                        ELSE
                          MIGR_TST_PRC_SIGNAL.CLOSE_BATCH(c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_BATCH_STATUS_FAILED);
                          l_Log_Rec.logMsg := 'All batch policies failed migration';
                          MIGR_LOG.LOG_ERROR(l_Log_Rec);
                        END IF;
                    END LOOP;

                  FOR c IN (
                      SELECT mm.MIGRATION_BATCH_ID ,
                        --FA.20180222 Change conditions that mark batch as Finished or Wait discounts pending only to succesfully migrated policies
                       (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_SUCCESS AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_success
                      ---  (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_FAILED_DISCOUNTS AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_failed,
                       ---  (SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID) c_all
                         FROM MIG_MIGRATION_INFO mm
                        WHERE mm.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC
                          AND mm.DISCOUNT_COMPLETED = MIGR_GVAR.GV_STATUS_FINISHED
                          AND 0=(SELECT COUNT('c') FROM IA_POLICY ia WHERE ia.MIG_FLAG=MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS AND ia.MIG_BATCH_ID=mm.MIGRATION_BATCH_ID))
                    LOOP
                    -- if at least one policy has been succesfully completed migration then turn batch to finished else turn batch to failed
                      IF c.c_success >=1 then
                        l_Log_Rec.logMsg := 'About to Set Migration Batch ID: ' || c.MIGRATION_BATCH_ID || ' to Finished';
                        l_log_rec.migrRelKey := NULL;
                        MIGR_LOG.LOG_INFO(l_Log_Rec);
                        MIGR_TST_PRC_SIGNAL.CLOSE_BATCH(c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_BATCH_STATUS_FINISHED);

                        UPDATE MIG_MIGRATION_INFO
                          SET DISCOUNTS_FILE_CREATED = MIGR_GVAR.GV_STATUS_PENDING
                          WHERE MIGRATION_BATCH_ID = c.MIGRATION_BATCH_ID;

                      ELSE
                        MIGR_TST_PRC_SIGNAL.CLOSE_BATCH(c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_BATCH_STATUS_FAILED);
                        l_Log_Rec.logMsg := 'All batch policies failed migration';
                        MIGR_LOG.LOG_ERROR(l_Log_Rec);

                      END IF;
                  END LOOP;

                END IF;

            WHEN 'Stop_Migration' THEN Migrate_Policy := FALSE;
                l_Log_Rec.logMsg := 'Policy Migration process stopped. MAX_RESOURCES = ' || vMAX_RESOURCES;
                l_log_rec.migrRelKey := NULL;
                MIGR_LOG.LOG_INFO(l_Log_Rec);

            WHEN 'Exit_Migration' THEN
                ---FA.20170127 Check if ia_policy has pending policies before stopping API
                FOR cRec IN (SELECT COUNT('x') CNT
                    FROM IA_POLICY ia
                      JOIN MIG_MIGRATION_INFO mmi
                        ON ia.MIG_BATCH_ID = mmi.MIGRATION_BATCH_ID
                    WHERE ia.MIG_FLAG IN (MIGR_GVAR.GV_MIG_FLAG_PENDING, MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS)
                      AND NOT mmi.STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_INCOMPLETE, MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC))--mmi.STATUS <> MIGR_GVAR.GV_BATCH_STATUS_INCOMPLETE) --'0')
                LOOP
                  IF cRec.CNT = 0
                  THEN
                    Migrate_Policy := FALSE;
                    l_Log_Rec.logMsg := 'End of Policy Migration process.';
                    l_log_rec.migrRelKey := NULL;
                    MIGR_LOG.LOG_INFO(l_Log_Rec);
                    --FA.20170807 Call to restore INSIS Log Level at the end of migration process
                    MIGR_API_COMMON.RESTORE_INSIS_LOG_LEVEL;
                  ELSE
                    vSTATE := 'GetPolicy';
                    vRESOURCES_NEEDED := 0;
                  END IF;
                END LOOP;

            ELSE vRESOURCES_NEEDED := vMAX_RESOURCES;
              vSTATE := 'Flush_Queue';
              vNEXT_STATE := 'Exit_Migration';
              l_Log_Rec.logMsg := 'Policy Migration process stopped.';
              MIGR_LOG.LOG_INFO(l_Log_Rec);

          END CASE;

        END LOOP;

      DBMS_ALERT.REMOVEALL();

      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN l_log_rec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_log_rec);

    END STATE_MACHINE_RUN_API;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
END MIGR_TST_PRC_API;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_TST_PRC_API_POLICY
  AS

  FUNCTION INSERT_ANTICIMEX_DATA(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      l_evres       PLS_INTEGER;
      i             PLS_INTEGER;
    BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Insert Anticimex Data';
      l_policyRec.migrArea := 'MIGR_API_POLICY_RESUME.INSERT_ANTICIMEX_DATA';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

      DBMS_LOCK.SLEEP(5);

      l_policyRec.logMsg := 'Insert Anticimex Data. ';
      MIGR_LOG.LOG_INFO(l_policyRec);

      RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := 'Could not insert Anticimex Data: ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr := FALSE;
          l_policyRec.policy_final_step := 'CONFIRMED';
          RETURN l_policyRec;
    END;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Migrate Policy Agent: BelongsTo is a mandatory role for the policy consistency
  FUNCTION SET_POLICY_AGENT_BELONGSTO(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp

    IS
      l_policyRec         MIGR_GVAR.PolicyRecTyp;
      l_PolicyAgentRecord INSIS_GEN_V10.P_AGENT_TYPE;
      PIO_ERR             SRVERR;
    BEGIN

      l_policyRec := p_policyRec;
      l_policyRec.migrArea := 'MIGR_API_POLICY_RESUME.SET_POLICY_AGENT_BELONGSTO';

      DBMS_LOCK.SLEEP(5);

      l_policyRec.logMsg := 'BelongsTo agent add';
      MIGR_LOG.LOG_INFO(l_policyRec);


      RETURN l_policyRec;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := 'Could not add required agent role:BelongsTo: ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr := FALSE;
          RETURN l_policyRec;

    END SET_POLICY_AGENT_BELONGSTO;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Migrate Policy Agent sales2 if provided by MIGG  - Should be moved to common
  FUNCTION SET_POLICY_AGENT_SALES2(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS
      l_policyRec         MIGR_GVAR.PolicyRecTyp;
      l_PolicyAgentRecord INSIS_GEN_V10.P_AGENT_TYPE;
      PIO_ERR             SRVERR;
    BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrArea := 'Set Policy Agents';

      DBMS_LOCK.SLEEP(5);

      l_policyRec.logMsg := 'Sales2 agent add';
      MIGR_LOG.LOG_INFO(l_policyRec);


      RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := 'Could not add  agent role:BelongsTo2: ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr := FALSE;
          RETURN l_policyRec;

    END SET_POLICY_AGENT_SALES2;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  ---Set migrated policy values: Policy Id and step
  ---Is called to retrieve phase 1 policy values when phase 2 is triggered
  FUNCTION SET_MIGRATED_POLICY_VAL(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS
      l_policyRec MIGR_GVAR.PolicyRecTyp;
      l_cnt       NUMBER;
    BEGIN
      l_policyRec := p_policyRec;
      l_cnt := 0;

      SELECT POLICY_STEP,
             POLICY_ID
        INTO l_policyRec.policy_final_step,
             l_policyRec.policy_id
        FROM MIGR_POLICY
        WHERE POLICY_IDPL = l_policyRec.policy_idpl;

      --Check if discount has been applied to policy so to rerun calaculate premium step
      SELECT COUNT('*')
        INTO l_cnt
        FROM IA_MD_DISCOUNTS
        WHERE IA_IDPL = l_policyRec.policy_idpl
          AND IA_DISCOUNT IS NOT NULL
          AND IA_DISCOUNT <> 0;

      IF l_cnt = 1
      THEN
        l_policyRec.has_discount := TRUE;
      ELSE
        l_policyRec.has_discount := FALSE;
      END IF;

      RETURN l_policyRec;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := 'Could not retrieve migrated policy data from MIGR_POLICY table: ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr := FALSE;
          RETURN l_policyRec;

    END SET_MIGRATED_POLICY_VAL;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Clients should be migrated prior to policy registration and this function returns INSIS ids from MIGR_CLIENT table
  FUNCTION GET_POLICY_CLIENT(p_policyRec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS
      l_policyRec MIGR_GVAR.PolicyRecTyp;
    BEGIN
      l_policyRec := p_policyRec;

      DBMS_LOCK.SLEEP(5);

      l_policyRec.logMsg := 'GET_POLICY_CLIENT';
      MIGR_LOG.LOG_INFO(l_policyRec);

      RETURN l_policyRec;

    END GET_POLICY_CLIENT;
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Set default values to mandatory roles- - Should be moved to common
  FUNCTION SET_DEFAULT_AGENT_IDS(p_policy_rec IN MIGR_GVAR.PolicyRecTyp)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS

      l_policyRec MIGR_GVAR.PolicyRecTyp;
      l_agent_id  INSIS_PEOPLE_V10.P_AGENTS.AGENT_ID % TYPE;
    BEGIN
      l_policyRec := p_policy_rec;

      DBMS_LOCK.SLEEP(5);

      l_policyRec.logMsg := 'default agent add';
      MIGR_LOG.LOG_INFO(l_policyRec);

      RETURN l_policyRec;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := 'Could not retrieve default agent id due to exception:' || SQLCODE || ' - ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr := FALSE;
          RETURN l_policyRec;
    END SET_DEFAULT_AGENT_IDS;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Set policy record agent ids for, sales, sales2 and belongs to-- Should be moved to common
  FUNCTION SET_POLICY_AGENT_IDS(p_policyRec IN  MIGR_GVAR.PolicyRecTyp,
                                p_ia_policy_rec IA_POLICY % ROWTYPE)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS
      l_agent_id  INSIS_PEOPLE_V10.P_AGENTS.AGENT_ID % TYPE;
      l_policyRec MIGR_GVAR.PolicyRecTyp;
    BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.agent_id := NULL;
      l_policyRec.agent_belongsTo := NULL;

      DBMS_LOCK.SLEEP(5);

      l_policyRec.logMsg := 'SET_POLICY_AGENT_IDS';
      MIGR_LOG.LOG_INFO(l_policyRec);

      RETURN l_policyRec;

    EXCEPTION

      WHEN OTHERS THEN l_policyRec.logMsg := 'Could not retrieve agent id for mandatory agents due to exception:' || SQLCODE || ' - ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr := FALSE;

          RETURN l_policyRec;
    END SET_POLICY_AGENT_IDS;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Call INSIS event to apply automatic rule discounts on policy level
  PROCEDURE APPLY_RULE_POLICY_DISC(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)

    AS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Apply Rule Policy Discounts';
      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.APPLIED_RULE_POLICY_DISC';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      DBMS_LOCK.SLEEP(5);

      p_policyrec.logMsg := 'APPLY_RULE_POLICY_DISC';
      MIGR_LOG.LOG_INFO(p_policyrec);

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;
    END APPLY_RULE_POLICY_DISC;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Call INSIS event to retreive policy conditions through Rule Bus and fill in POLICY_CONDITIONS table.
  PROCEDURE FILL_POLICY_CONDITIONS(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    AS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Fill Policy Conditions';
      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.FILLED_POLICY_CONDITIONS';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      DBMS_LOCK.SLEEP(5);

      p_policyrec.logMsg := 'FILL_POLICY_CONDITIONS';
      MIGR_LOG.LOG_INFO(p_policyrec);

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;

    END FILL_POLICY_CONDITIONS;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---Updates INSIS policy with migg values regarding insurance begin, installments etc.
  PROCEDURE UPDATE_POLICY(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT   SRVCONTEXT;
      L_OUT_CONTEXT  SRVCONTEXT;
      PIO_ERR        SRVERR;
      l_evres        PLS_INTEGER;
      v_stmst        VARCHAR2(400);
      v_event        MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
      l_policyrecord INSIS_GEN_V10.P_POLICY_TYPE;
      L_RESULT       VARCHAR2(50);
      l_policyState  INSIS_GEN_V10.POLICY.POLICY_STATE % TYPE;
      l_POLICY_LOT   INSIS_GEN_V10.POLICY.POLICY_lot % TYPE;
      l_attr6        INSIS_GEN_V10.POLICY.ATTR6 % TYPE;
    BEGIN

      DBMS_LOCK.SLEEP(5);
      p_policyrec.migrStep := 'Check Record Policy';
      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.CHECK_RECORD_POLICY';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      p_policyrec.logMsg := 'UPDATE_POLICY';
      MIGR_LOG.LOG_INFO(p_policyrec);


    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;
    END UPDATE_POLICY;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- Retrieves address directly from INSIS and store primary address as policy address
  PROCEDURE INSERT_POLICY_ADDRESS(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
      l_address_id  NUMBER;
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);

    BEGIN

      DBMS_LOCK.SLEEP(5);

      p_policyrec.logMsg := 'INS_POLICY_ADDRESS';
      MIGR_LOG.LOG_INFO(p_policyrec);

    EXCEPTION
      WHEN NO_DATA_FOUND THEN p_policyrec.logMsg := ' Client has no primary  address  in INSIS ';
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;
      WHEN TOO_MANY_ROWS THEN p_policyrec.logMsg := ' More than one primary  addresses were found in INSIS ';
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;

    END INSERT_POLICY_ADDRESS;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Call to INSIS event to insert dummy policy for specified product and client
  PROCEDURE CREATE_DUMMY_POL(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    AS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      l_policyId    POLICY.POLICY_ID % TYPE;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      L_ADDRESS_ID  NUMBER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

    BEGIN

      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Create Dummy Policy';
      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.CREATE_DUMMY_POL';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      DBMS_LOCK.SLEEP(5);

      p_policyrec.logMsg := 'CREATE_DUMMY_POL';
      MIGR_LOG.LOG_INFO(p_policyrec);


    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;
    END CREATE_DUMMY_POL;
  -------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------

  --Register MIGG data to INSIS - There is one package per each product that handles registration of object's data and product's specific required info
  --Common package handles the common registration actions according to produt configuration: covers, questions, endorsemenets , deductibles etc.
  PROCEDURE MIGRATE_POLICY_OBJECTS(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      l_eventTimer TIMESTAMP;

    BEGIN
      l_eventTimer := SYSTIMESTAMP;

      CASE p_policyrec.INSRPRD
        WHEN 'BOAT' THEN p_policyrec.logMsg := 'Start migrating Boat Product';
            --            p_policyrec := MIGR_API_BOAT.MIGRATE_BOAT(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'VILLAHEM' THEN p_policyrec.logMsg := 'Start migrating Villahem Product';
            --            p_policyrec := MIGR_API_VILLAHEM.MIGRATE_VILLAHEM(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'LEISURE_HOME' THEN p_policyrec.logMsg := 'Start migrating Leisure Home  Product';
            --            p_policyrec := MIGR_API_LEISURE_HOME.MIGRATE_LEISURE_HOME(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'LEISURE_MOBILE_HOME' THEN p_policyrec.logMsg := 'Start migrating Leisure Mobile Home Product';
            --            p_policyrec := MIGR_API_LEISURE_MOBILE_HOME.MIGRATE_LEISURE_MOBILE_HOME(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'CONTENT_COOP' THEN p_policyrec.logMsg := 'Start migrating Content and Cooperative Product';
            --            p_policyrec := MIGR_API_CONTENT_COOP.MIGRATE_CONTENT_COOP(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'INDIVIDUAL_COVERS' THEN p_policyrec.logMsg := 'Start migrating Individual Covers Product';
            --            p_policyrec := MIGR_API_INDIVIDUAL_COVERS.MIGRATE_INDIVIDUAL_COVERS(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'CHILD_ACC' THEN p_policyrec.logMsg := 'Start migrating Children Accident Product';
            --            p_policyrec := MIGR_API_ACCIDENT.MIGRATE_CHILD_ACC(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'INDIV_ACC_60' THEN p_policyrec.logMsg := 'Start migrating Children Accident Product';
            --            p_policyrec := MIGR_API_ACCIDENT.MIGRATE_INDIV60_ACC(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'RED_CHILD_ACC' THEN p_policyrec.logMsg := 'Start migrating Children Accident Product';
            --            p_policyrec := MIGR_API_ACCIDENT.MIGRATE_RED_CHILD_ACC(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'INDIV_ACC' THEN p_policyrec.logMsg := 'Start migrating Children Accident Product';
            --            p_policyrec := MIGR_API_ACCIDENT.MIGRATE_INDIV_ACC(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'RED_ACC' THEN p_policyrec.logMsg := 'Start migrating Children Accident Product';
            --            p_policyrec := MIGR_API_ACCIDENT.MIGRATE_RED_ACC(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'TRAVEL' THEN p_policyrec.logMsg := 'Start migrating Travel Product';
            --            p_policyrec := MIGR_API_TRAVEL.MIGRATE_TRAVEL(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'BUILDING_VILLA' THEN p_policyrec.logMsg := 'Start migrating Building Villa  Product';
            --            p_policyrec := MIGR_API_BUILDING_VILLA.MIGRATE_BUILDING_VILLA(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'CONTENT_ONLY' THEN p_policyrec.logMsg := 'Start migrating Content Only Product';
            --            p_policyrec := MIGR_API_CONTENT_ONLY.MIGRATE_CONTENT_ONLY(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'LEISURE_COOP' THEN p_policyrec.logMsg := 'Start migrating Content Only Product';
            --            p_policyrec := MIGR_API_LEISURE_COOP.MIGRATE_LEISURE_COOP(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        WHEN 'LEISURE_CONT_ONLY' THEN p_policyrec.logMsg := 'Start migrating Content Only Product';
            --            p_policyrec := MIGR_API_LEISURE_CONT_ONLY.MIGRATE_LEISURE_CONT_ONLY(p_policyrec);
            DBMS_LOCK.SLEEP(5);

        ELSE p_policyrec.logMsg := 'Policy Failed due to UNDEFINED OBJECT';
          MIGR_LOG.LOG_ERROR(p_policyrec);
          p_policyrec.continue_migr := FALSE;
          DBMS_LOCK.SLEEP(5);

      END CASE;

      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.MIGRATE_POLICY_OBJECTS';
      MIGR_LOG.LOG_INFO(p_policyrec);

      p_policyrec.migrArea := 'MIGR_API_QUESTIONS.MIGRATE_POLICY_QUESTIONS';
      IF p_policyRec.require_quest = 'N'
      THEN
        p_policyrec.logMsg := 'Questions migration is skipped ';
        MIGR_LOG.LOG_INFO(p_policyrec);
      ELSE
        DBMS_LOCK.SLEEP(5);
        p_policyrec.logMsg := 'MIGR_API_QUESTIONS.MIGRATE_POLICY_QUESTIONS';
        MIGR_LOG.LOG_INFO(p_policyrec);
      END IF;

      p_policyrec.migrArea := 'MIGR_API_COMMON.MIGRATE_ENDORSMENTS';
      IF p_policyrec.ia_endorsementsTbl IS NULL
      THEN
        p_policyrec.logMsg := 'Endorsements migration is skipped ';
        MIGR_LOG.LOG_INFO(p_policyrec);
      ELSE
        DBMS_LOCK.SLEEP(5);
        p_policyrec.logMsg := 'MIGR_API_COMMON.MIGRATE_ENDORSMENTS';
        MIGR_LOG.LOG_INFO(p_policyrec);
      END IF;
      -- LM - 20170302 - ENDORSEMENTS - END

      --valex.10/2/2017 - migrate discounts
      p_policyrec.migrArea := 'MIGR_TST_PRC_MD_DISC.RUN_DISCOUNTS';
      IF p_policyrec.ia_discountsTbl IS NULL
      THEN
        p_policyrec.logMsg := 'No Discounts table in MIGR IA. Discounts are skipped ';
        MIGR_LOG.LOG_exception(p_policyrec);
      ELSE
        DBMS_LOCK.SLEEP(5);
        p_policyrec.logMsg := ' MIGR_TST_PRC_MD_DISC.RUN_DISCOUNTS';
        MIGR_LOG.LOG_exception(p_policyrec);
        MIGR_TST_PRC_MD_DISC.RUN_DISCOUNTS(p_policyrec);
      END IF;
      --valex.10/2/2017 - end


      -- 20170307 -FA.Migrate policy documents when required at policy and objetc level

      IF p_policyrec.require_documents = 'Y'
        AND p_policyRec.ia_coversInsValTbl IS NOT NULL
      THEN
        DBMS_LOCK.SLEEP(5);
        p_policyrec.logMsg := 'MIGR_API_COMMON.LOAD_POLICY_DOCUMENTS';
        MIGR_LOG.LOG_INFO(p_policyrec);
      ELSE
        p_policyrec.logMsg := 'No mandatory documents at policy level exist for migration ';
        MIGR_LOG.LOG_INFO(p_policyrec);
      END IF;

      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.MIGRATE_POLICY_OBJECTS';
      p_policyrec.migrStep := 'Migrate Policy Objects';
      p_policyrec.logMsg := p_policyrec.insrprd || ':' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
      MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM();
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
    END MIGRATE_POLICY_OBJECTS;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --INSIS set of operations that should be executed to migrate policy header prior to policy data registration
  PROCEDURE MIGRATE_POLICY_GENERAL(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      l_eventTimer TIMESTAMP;

    BEGIN
      p_policyrec.migrArea := 'Policy General Migration ';

      p_policyrec.POLICY_ID := NULL;
      l_eventTimer := SYSTIMESTAMP;

      CREATE_DUMMY_POL(p_policyrec);

      p_policyrec.logMsg := 'CREATE DUMMY:  ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
      MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

      --Add policy agents
      p_policyrec := SET_POLICY_AGENT_BELONGSTO(p_policyRec);
      p_policyrec := SET_POLICY_AGENT_SALES2(p_policyRec);
      ----Do not start migration if policy id was not returned by insis
      IF p_policyrec.continue_migr
      THEN
        --FA.Policy addresses are added vis created dummy pol  INSERT_POLICY_ADDRESS(p_policyrec);

        l_eventTimer := SYSTIMESTAMP;

        --FA. 20170302 In order to calculate renewal date correctly we have to call check record policy prior to  update policy and provide as update input context thecheck record output context
        UPDATE_POLICY(p_policyrec);

        IF p_policyrec.continue_migr
        THEN
          p_policyrec.logMsg := 'POLICY UPDATE:  ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
          MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
          l_eventTimer := SYSTIMESTAMP;

          IF p_policyRec.continue_migr
          THEN

            --LM - 20170425 - UPDATE_CUST_CORRESPONDENCE - START
            --            MIGR_API_COMMON.UPDATE_CUST_CORRESPONDENCE(p_policyrec);
            DBMS_LOCK.SLEEP(5);
            p_policyrec.logMsg := 'MIGR_API_COMMON.UPDATE_CUST_CORRESPONDENCE';
            MIGR_LOG.LOG_INFO(p_policyrec);

            IF p_policyrec.continue_migr
            THEN
              p_policyrec.logMsg := 'CUST_CORRESPONDENCE UPDATE:  ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
              MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
              l_eventTimer := SYSTIMESTAMP;
              --LM - 20170425 - UPDATE_CUST_CORRESPONDENCE - END

              --LM 20170224 - Update POLICY_ENGAGEMENT_BILLING table (P_ENGAGEMENT_BILLING_TYPE) - START
              --              MIGR_API_COMMON.UPDATE_ENG_BILLING(p_policyrec);
              DBMS_LOCK.SLEEP(5);
              p_policyrec.logMsg := 'MIGR_API_COMMON.UPDATE_CUST_CORRESPONDENCE';
              MIGR_LOG.LOG_INFO(p_policyrec);

              IF p_policyrec.continue_migr
              THEN
                p_policyrec.logMsg := 'POLICY_ENGAGEMENT_BILLING UPDATE:  ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
                MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
                l_eventTimer := SYSTIMESTAMP;
                --LM 20170224 - Update ENGAGEMENT_BILLING table (P_ENGAGEMENT_BILLING_TYPE) - END

                --FA.20161118 Turned to configurable to decide if property is mandatory
                IF p_policyrec.require_property = 'Y'
                THEN

                  --                  MIGR_API_COMMON.REGISTER_PROPERTY_ID(p_policyrec);
                  DBMS_LOCK.SLEEP(5);
                  p_policyrec.logMsg := 'MIGR_API_COMMON.REGISTER_PROPERTY_ID';
                  MIGR_LOG.LOG_INFO(p_policyrec);

                  IF p_policyrec.continue_migr
                  THEN
                    p_policyrec.logMsg := 'REGISTER_PROPERTY: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
                    MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

                  END IF;
                  l_eventTimer := SYSTIMESTAMP;
                END IF;

                FILL_POLICY_CONDITIONS(p_policyrec);

                IF p_policyrec.continue_migr
                THEN
                  p_policyrec.logMsg := 'FILL POLICY CONDITIONS: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
                  MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
                  l_eventTimer := SYSTIMESTAMP;


                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      ----    END IF;
      --  END IF;

      END IF;

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;

    END MIGRATE_POLICY_GENERAL;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Checks if agent, insurance type and client exist in policy  and in INSIS
  PROCEDURE IS_VALID_POLICY(P_POLICYREC IN OUT MIGR_GVAR.PolicyRecTyp,
                            is_valid    OUT    BOOLEAN)
    IS
    BEGIN
      is_valid := TRUE;
      P_POLICYREC.logMsg := NULL;
      DBMS_LOCK.SLEEP(5);
      p_policyrec.logMsg := 'IS_VALID_POLICY';
      MIGR_LOG.LOG_INFO(p_policyrec);

    END IS_VALID_POLICY;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA.20160531 Approve Underwriting Task --Policies that require underwriting will be updated to approved instead of creating a task
  FUNCTION APPROVE_UW(P_POLICYREC IN MIGR_GVAR.PolicyRecTyp)
    RETURN BOOLEAN
    IS


      l_policyRec       MIGR_GVAR.PolicyRecTyp;

      l_ins_obj_id      INSURED_OBJECT.INSURED_OBJ_ID % TYPE;
      l_object_id       INSURED_OBJECT.object_id % TYPE;
      l_org_uwlist_type INSIS_CUST.P_CUST_UWLIST_TYPE;
      l_SrvErrMsg       SRVERRMSG;
      PIO_ERR           SRVERR;
    BEGIN

      l_policyRec := P_POLICYREC;
      l_policyRec.migrStep := 'Approve Underwriting';
      l_policyRec.migrArea := 'MIGR_API_POLICY_RESUME.APPROVE_UW';
      l_policyRec.migrRelTbl := 'CUST_OBJECT';

      DBMS_LOCK.SLEEP(5);

      l_policyRec.logMsg := 'UnderWriting List has been aproved';
      MIGR_LOG.LOG_INFO(l_policyRec);
      RETURN TRUE;
    EXCEPTION
      WHEN OTHERS THEN l_policyRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN FALSE;
    END APPROVE_UW;
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Caclulates policy premium
  PROCEDURE CALCULATE_PREMIUM(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    AS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);

      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Calculate Policy Premium';
      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.PREMIUM_CALCULATED';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      DBMS_LOCK.SLEEP(5);
      p_policyrec.logMsg := 'CALCULATE_PREMIUM';
      MIGR_LOG.LOG_INFO(p_policyrec);

    --TEMPORARY WORKAROUND
    ---p_policyrec:=SET_POLICY_AGENT_COMMISSIONS(p_policyrec);
    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;
    END CALCULATE_PREMIUM;
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  ---Check if policy should be sent to  underwriter
  PROCEDURE START_AUTO_UW(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Start UnderWriting Process';
      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.START_AUTO_UW';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      DBMS_LOCK.SLEEP(5);
      p_policyrec.logMsg := 'START_AUTO_UW';
      MIGR_LOG.LOG_INFO(p_policyrec);


    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;
    END START_AUTO_UW;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20170808 Check if consistency error is the Premium not calculated error and if so re-calculate premium and re-execute the consistency check
  PROCEDURE CHECK_CALC_PREM_CONSISTECY_ERR(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp,
                                           PIO_ERROR   IN     SRVERR)
    IS

      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
      l_calcPremErr BOOLEAN;
    BEGIN
      l_calcPremErr := FALSE;


      p_policyrec.migrStep := 'Check Policy Consistency';
      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.CHECK_POLICY_CONSISTENCY';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      DBMS_LOCK.SLEEP(5);
      p_policyrec.logMsg := 'CHECK_CALC_PREM_CONSISTECY_ERR';
      MIGR_LOG.LOG_INFO(p_policyrec);


    END CHECK_CALC_PREM_CONSISTECY_ERR;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --  Check policy consistency
  PROCEDURE CHECK_POLICY_CONSISTENCY(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;

      p_policyrec.migrStep := 'Check Policy Consistency';
      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.CHECK_POLICY_CONSISTENCY';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      DBMS_LOCK.SLEEP(5);
      p_policyrec.logMsg := 'CHECK_POLICY_CONSISTENCY';
      MIGR_LOG.LOG_INFO(p_policyrec);

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;

    END CHECK_POLICY_CONSISTENCY;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  ---Confirm application -If succeded turn policy status to : -2
  PROCEDURE CONFIRM_APPLICATION(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    AS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;
      SAVEPOINT pol_conf;
      p_policyrec.migrStep := 'Confirm Application';
      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.APPLICATION_CONFIRMED';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      DBMS_LOCK.SLEEP(5);
      p_policyrec.logMsg := 'CONFIRM_APPLICATION';
      MIGR_LOG.LOG_INFO(p_policyrec);

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;
          ROLLBACK TO pol_conf;
    END CONFIRM_APPLICATION;

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---Last step of application operation to convert it to contract
  PROCEDURE CONVERT_APPLICATION(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      PIO_ERR       SRVERR;
      L_RESULT      VARCHAR2(50);
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
      l_renewalDate VARCHAR2(20);
    BEGIN
      L_IN_CONTEXT := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR := NULL;
      SAVEPOINT pol_conv;
      p_policyrec.migrStep := 'Convert Application to Contract';
      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.CONVERT_APPLICATION';
      p_policyrec.migrRelTbl := 'INSIS_EVENT';

      DBMS_LOCK.SLEEP(5);
      p_policyrec.logMsg := 'CONVERT_APPLICATION';
      MIGR_LOG.LOG_INFO(p_policyrec);


    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;
          ROLLBACK TO pol_conv;
    END CONVERT_APPLICATION;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Check LANSBONUS: pl 20170518
  PROCEDURE CHECK_LANSBONUS(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      v_max_tries      INTEGER := 0;
      v_exit           BOOLEAN := FALSE;
      v_continue_migr  BOOLEAN := TRUE;

      v_cond_value     VARCHAR2(50);
      v_discount_value NUMBER;

    BEGIN
      p_policyrec.migrStep := 'Check Lansbonus';
      p_policyrec.migrArea := 'MIGR_API_POLICY_RESUME.CHECK_LANSBONUS';
      p_policyrec.migrRelTbl := '';

      DBMS_LOCK.SLEEP(5);
      p_policyrec.logMsg := 'CHECK_LANSBONUS';
      MIGR_LOG.LOG_INFO(p_policyrec);

    EXCEPTION
      WHEN OTHERS THEN p_policyrec.logMsg := SQLCODE || '-' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyrec);
          p_policyrec.continue_migr := FALSE;
    END CHECK_LANSBONUS;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE MIGRATE_APPLICATION(p_policyrec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      is_migrated  BOOLEAN;
      l_eventTimer TIMESTAMP;

    BEGIN
      IF p_policyrec.process_steps.EXISTS('PREM')
        AND p_policyrec.continue_migr
        AND (p_policyrec.api_steps_order('PREMIUM_CALCULATED') - p_policyrec.api_steps_order(p_policyrec.policy_final_step) <= 1)
      THEN

        ---skip recalculate premium if no discount was provided
        --if last step is policy data migration  re-run calc prem
        IF p_policyrec.mig_flag = MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS
          AND NOT p_policyrec.has_discount
          AND (p_policyrec.api_steps_order('PREMIUM_CALCULATED') - p_policyrec.api_steps_order(p_policyrec.policy_final_step) != 1)
        THEN
          p_policyrec.logMsg := 'PREMIUM_CALCULATED will not run due to zero premium adjustment. ';
          MIGR_LOG.LOG_INFO(p_policyrec);

        ELSE
          l_eventTimer := SYSTIMESTAMP;
          CALCULATE_PREMIUM(p_policyrec);
          p_policyrec.logMsg := 'PREMIUM_CALCULATED: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
          MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

        END IF;
      END IF;

      IF (p_policyrec.mig_flag = MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS
        AND p_policyrec.continue_migr)
      THEN

        l_eventTimer := SYSTIMESTAMP;
        CHECK_LANSBONUS(p_policyrec);
        p_policyrec.logMsg := 'CHECK LANSBONUS: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
        MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

      END IF;

      IF p_policyrec.process_steps.EXISTS('CONS')
        AND p_policyrec.continue_migr
        AND (p_policyrec.api_steps_order('CONSISTENCY_CHECKED') - p_policyrec.api_steps_order(p_policyrec.policy_final_step) <= 1)
      THEN

        l_eventTimer := SYSTIMESTAMP;
        CHECK_POLICY_CONSISTENCY(p_policyrec);
        p_policyrec.logMsg := 'CHECK_POLICY_CONSISTENCY: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
        MIGR_LOG.LOG_EVENT_TIME(p_policyrec);

      END IF;

      IF p_policyrec.process_steps.EXISTS('UW')
        AND p_policyrec.continue_migr
        AND (p_policyrec.api_steps_order('REQUIRE_UNDERWITING') - p_policyrec.api_steps_order(p_policyrec.policy_final_step) <= 1)
      THEN

        l_eventTimer := SYSTIMESTAMP;
        START_AUTO_UW(p_policyrec);
        p_policyrec.logMsg := 'START_AUTO_UW: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
        MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
      END IF;

      IF p_policyrec.process_steps.EXISTS('CONF')  ---AND  p_policyrec.policy_final_step = 'TO_BE_CONFIRMED'
        AND (p_policyrec.api_steps_order('CONFIRMED') - p_policyrec.api_steps_order(p_policyrec.policy_final_step) <= 1)
        AND p_policyrec.continue_migr
      THEN

        l_eventTimer := SYSTIMESTAMP;
        CONFIRM_APPLICATION(p_policyrec);
        p_policyrec.logMsg := 'CONFIRMED: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
        MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
      END IF;

      IF p_policyrec.process_steps.EXISTS('CONV')  ---AND  p_policyrec.policy_final_step = 'TO_BE_CONFIRMED'
        AND (p_policyrec.api_steps_order('CONVERT') - p_policyrec.api_steps_order(p_policyrec.policy_final_step) <= 1)
        AND p_policyrec.continue_migr
      THEN

        l_eventTimer := SYSTIMESTAMP;
        CONVERT_APPLICATION(p_policyrec);
        p_policyrec.logMsg := 'CONVERTED: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
        MIGR_LOG.LOG_EVENT_TIME(p_policyrec);
      END IF;

    END MIGRATE_APPLICATION;
  --------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA.20161220 Migrate Policy Flow should support autonomus step migration funcionality
  --API job serves next pending policy to be migrate to INSIS
  PROCEDURE MIGRATE_POLICY(P_MIGRBATCHID IN MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                           P_IDPL        IN VARCHAR2)
    AS
      p_ia_policy_rec    IA_POLICY % ROWTYPE;
      l_beginTimer       TIMESTAMP WITH TIME ZONE;
      l_beginStepTimer   TIMESTAMP WITH TIME ZONE;
      l_eventTimer       TIMESTAMP WITH TIME ZONE;
      is_migrated        BOOLEAN;
      is_valid           BOOLEAN;
      l_policyRec        MIGR_GVAR.PolicyRecTyp;
      l_migrated         BOOLEAN;
      v_allowed_products VARCHAR2(2100);
      l_has_failed       BOOLEAN;
      -- v_mig_default_user CHAR(1);
      v_mig_insis_user   ETL_BOLAG_INFO.BOLAG_USERNAME % TYPE;
      v_cnt              NUMBER;
      v_alrt             NUMBER;
    BEGIN


      DBMS_LOCK.SLEEP(30);

      l_policyRec.migrArea := 'MIGR_API_POLICY_RESUME.MIGRATE_POLICY';
      l_policyRec.migrRelTbl := 'IA_POLICY';
      l_policyRec.migrStep := 'Create Policy Application';
      l_policyRec.MIG_BATCH_ID := P_MIGRBATCHID;

      SELECT *
        INTO p_ia_policy_rec
        FROM IA_POLICY ip
        WHERE ip.MIG_BATCH_ID = P_MIGRBATCHID
          AND ip.IA_IDPL = P_IDPL;


      l_beginTimer := SYSTIMESTAMP;
      l_eventTimer := SYSTIMESTAMP;
      l_has_failed := FALSE;
      l_policyRec.policy_idpl := p_ia_policy_rec.IA_IDPL;
      -- MIGR_LOG.LOG_INFO(l_policyRec);


      --Due to layers functionality only bolag users are able to view offerings, tariffs etc for their bolag
      --if FADATA provides a solution for this then a super user is rewuired to be added to MIG_DEFAULT_USER at setup info
      --if not one account per each bolag should be created by Client and aad their usernames in  ETL_BOLAG_INFO
      -- SELECT esi.MIG_DEFAULT_USER INTO v_mig_default_user FROM ETL_SETUP_INFO esi;

      ---  IF v_mig_default_user = 'Y' THEN
      ---    SELECT esi.MIGRATION_USER INTO v_mig_insis_user FROM ETL_SETUP_INFO esi;
      ---  ELSE
      SELECT ebi.BOLAG_USERNAME
        INTO v_mig_insis_user
        FROM ETL_BOLAG_INFO ebi
        WHERE ebi.BOLAG_ID = SUBSTR(l_policyRec.MIG_BATCH_ID, 1, 2);
      ----  END IF;

      -- Initializes the connection session
      INSIS_SYS_V10.INSIS_CONTEXT.Prepare_Session(Pi_App => 'GEN',
      Pi_Action => 'InsisPolicyGen',
      Pi_Username => v_mig_insis_user,
      Pi_User_Role => 'InsisStaff',
      Pi_Lang => NULL,
      Pi_Country => NULL);

      --set default values according to etl_setup_info configuration
      --      MIGR_API_COMMON.SET_DEFAULT_VALUES(SUBSTR(l_policyRec.MIG_BATCH_ID, 1, 2));
      DBMS_LOCK.SLEEP(5);
      l_policyRec.logMsg := 'MIGR_API_COMMON.SET_DEFAULT_VALUES';
      MIGR_LOG.LOG_INFO(l_policyRec);

      v_allowed_products := MIGR_PROCESS.SKIP_INSIS_REG(l_policyRec.MIG_BATCH_ID, p_ia_policy_rec.MIG_FLAG, p_ia_policy_rec.IA_INSRPRD);

      IF v_allowed_products = '1'
      THEN

        --Initialize Policy Record
        l_policyRec.mig_flag := p_ia_policy_rec.MIG_FLAG;
        l_policyRec.INSRPRD := p_ia_policy_rec.IA_INSRPRD;
        l_policyRec.POLICY_IDPL := p_ia_policy_rec.IA_IDPL;
        l_policyRec.office_id := p_ia_policy_rec.IA_OFFICE_ID;
        l_policyRec.numInstalments := p_ia_policy_rec.IA_NUMINSTALLMENTS;
        l_policyRec.policyYear := p_ia_policy_rec.IA_POLICY_YEAR;
        --LM 12062017 - PRODUCT LABEL - OFFERING CODES DEACTIVATED - START
        l_policyRec.productLabel := p_ia_policy_rec.IA_PRODUCT_LABEL;
        --LM 12062017 - END
        l_policyRec.insr_begin := p_ia_policy_rec.IA_INSR_BEGIN;
        l_policyRec.POLICY_REF := p_ia_policy_rec.IA_POLICY_REF;
        l_policyRec.EGN := p_ia_policy_rec.IA_EGN;
        l_policyRec.AGENT_NO := p_ia_policy_rec.IA_AGENT_NO;
        --Due to offerings solution the insr_type is the offrncode and the insured product is stored at parent_insr_type
        l_policyRec.insr_type := p_ia_policy_rec.IA_INSR_TYPE;
        l_policyRec.parent_insr_type := p_ia_policy_rec.IA_PARENT_INSR_TYPE;
        l_policyRec.object_fail_log := '';
        l_policyRec.deduct_val := p_ia_policy_rec.IA_DEDUCT_VALUE;
        l_policyRec.IA_PAYM_WAY := p_ia_policy_rec.IA_PAYM_WAY;
        l_policyRec.IA_BANK_ID := p_ia_policy_rec.IA_BANK_ID;
        l_policyRec.IA_INVOICE := p_ia_policy_rec.IA_INVOICE;
        l_policyRec.IA_DISTR_METHOD := p_ia_policy_rec.IA_DISTR_METHOD;
        l_policyRec.continue_migr := TRUE;
        l_policyRec.has_discount := FALSE;

        is_valid := TRUE;
        l_policyRec.continue_migr := TRUE;

        --FA.20170519 Set agents and client only at phase A
        IF l_policyRec.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_RUNNING
        THEN
          l_policyRec := GET_POLICY_CLIENT(l_policyRec);

          --since new roles were added call to set the policy records  l_policyRec.AGENT_ID := GET_AGENT_ID(l_policyRec.AGENT_NO);
          l_policyRec := SET_POLICY_AGENT_IDS(l_policyRec, p_ia_policy_rec);
        END IF;

        IF l_policyRec.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS
        THEN
          l_policyRec := SET_MIGRATED_POLICY_VAL(l_policyRec);
        END IF;

        --Get api steps to execute- if mig_flag =0 get steps else get resume api steps
        l_policyRec.process_steps := MIGR_PROCESS.GET_API_PROCESS_PLAN(l_policyRec.MIG_BATCH_ID, l_policyRec.INSRPRD, l_policyRec.MIG_FLAG);

        --Get api steps order
        l_policyRec.api_steps_order := MIGR_PROCESS.GET_API_STEPS_ORDER;

        l_policyRec := MIGR_API_COMMON.GET_IA_CONFIGURATION(l_policyRec);

        --each api step should be completely autonomous
        --if step is xecuted according to plan then if succeeds should update the policy fina step record field

        IF l_policyRec.process_steps.EXISTS('VALIDATE')
        THEN
          IS_VALID_POLICY(l_policyRec, is_valid);

          IF is_valid
          THEN
            l_policyRec.policy_final_step := 'VALIDATE';
          END IF;
        END IF;

        IF is_valid
        THEN
          IF l_policyRec.process_steps.EXISTS('POL_REG')
            AND (l_policyRec.api_steps_order('POLICY_GENERAL') - l_policyRec.api_steps_order(l_policyRec.policy_final_step) <= 1)
          THEN

            l_policyRec.POLICY_ID := NULL;

            l_policyRec.logMsg := ' Start migrating Policy with insurance type: ' || l_policyRec.INSR_TYPE || ' CLIENT_ID= ' || l_policyRec.CLIENT_ID || ' AGENT_ID= ' || l_policyRec.AGENT_ID;
            MIGR_LOG.LOG_INFO(l_policyRec);

            is_migrated := FALSE;
            l_beginStepTimer := SYSTIMESTAMP;

            MIGRATE_POLICY_GENERAL(l_policyRec);
            DBMS_LOCK.SLEEP(30);
--            IF l_policyRec.policy_id IS NOT NULL
--            THEN
              l_policyRec.policy_final_step := 'POLICY_GENERAL';
--            ELSE
--              l_has_failed := TRUE;
--              MIGR_LOG.LOG_FAILED_POLICY(l_policyRec, l_beginTimer, l_policyRec.policy_final_step);
--            END IF;
          ELSE
            l_policyRec.logMsg := 'Step Policy registration was skipped';
            MIGR_LOG.LOG_INFO(l_policyRec);
          END IF;
        ELSE
          l_has_failed := TRUE;
          l_policyRec.continue_migr := FALSE;
          l_policyRec.logMsg := 'Policy was not valid';
          MIGR_LOG.LOG_INFO(l_policyRec);
          MIGR_LOG.LOG_FAILED_POLICY(l_policyRec, l_beginTimer, l_policyRec.policy_final_step);
        END IF;

        IF l_policyRec.process_steps.EXISTS('POL_DATA')
          AND l_policyRec.policy_id IS NOT NULL
          AND l_policyRec.continue_migr
          AND (l_policyRec.api_steps_order('POLICY_DATA_MIGRATION') - l_policyRec.api_steps_order(l_policyRec.policy_final_step) <= 1)
        THEN

          MIGRATE_POLICY_OBJECTS(l_policyRec);
          DBMS_LOCK.SLEEP(300);
          IF l_policyRec.continue_migr
          THEN
            l_policyRec.policy_final_step := 'POLICY_DATA_MIGRATION';
            --FA.20170510 Integration opens a new transaction for lansbonus -must commit prior to calculate premium call  to release any locks held by INSIS policy data registration events else timeouts will be received due to lock db objects
            COMMIT;
          END IF;

        END IF;

        --FA.20161121 Continue only if all policy data were migrated succesfully
        IF l_policyRec.continue_migr
        THEN
          IF l_policyRec.MIG_FLAG = MIGR_GVAR.GV_MIG_FLAG_RUNNING
          THEN
            l_policyRec.logMsg := 'All policy data has been succesfully migrated so we are about to call application operations';
            MIGR_LOG.LOG_INFO(l_policyRec);
          END IF;
          MIGRATE_APPLICATION(l_policyRec);
          DBMS_LOCK.SLEEP(30);
        END IF;

        --insert into migr_policy
        IF NOT l_has_failed
        THEN
          MIGR_LOG.LOG_POLICY(l_policyRec, l_beginTimer, l_policyRec.policy_final_step);
        END IF;

      ELSE
        MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(l_policyRec.policy_idpl, MIGR_GVAR.GV_MIG_FLAG_SKIPPED, P_MIGRBATCHID);


      END IF;

    EXCEPTION
      WHEN OTHERS THEN l_policyRec.continue_migr := FALSE;
          MIGR_LOG.LOG_FAILED_POLICY(l_policyRec, l_beginTimer, l_policyRec.policy_final_step);
          l_policyRec.logMsg := l_policyRec.policy_final_step || ' - ' || SQLERRM || ' for policy ' || P_IDPL;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
    END MIGRATE_POLICY;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


END MIGR_TST_PRC_API_POLICY;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_TST_PRC_IA
  AS
  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  -- Transfer data from SA_ tables to IA tables
  -- requires ETL_SA_IA table.
  --          ETL_SA_IA fields      ETL_ID       - define the order that the process will run
  --                                SOURCE_VIEW  - the view from SA->MAP that contains the IA_ fields
  --                                DEST_TABLE   - the name of the IA_ table to be created/insert upon
  --                                UNIQ_KEY     - IA_ field name that will be used for checking for duplicates
  --                                ALLOW_DUPL   - 'TRUE'/'FALSE' to signify if IA_ table can have duplicate UNIQ_KEY records
  --                                MIGRATION_AREA - Always = SA_IA
  --                                STEP          - user-friendly Name of table (appears in MIGR_LOGs)
  --
  --                                FIELD_LIST   - will be filled automatically by the REBUILD_SA_IA routine (takes SOURCE_VIEW.IA_fields)
  --
  -- requires ETL_VIEW_TBLS table.  SOURCE_VIEW, TABLE_NAME - contains SA_ tables used in view. It is rebuilt in REBUILD_SA_IA()
  --
  --  REBUILD_SA_IA()   -- for each record from ETL_SA_IA table, reads SOURCE_VIEW.IA_  columns and builds the field list. then UPDATE set FIELD_LIST =.
  --                    --   It also populates the ETL_VIEW_TBLS to be used by IA_UPD_SA()
  --  RUN_IA_SETUP();   -- for each record from ETL_SA_IA table, executes 'CREATE TABLE' statement for creation of IA_ tables.
  --  RUN_IA_MAIN();    -- each record from ETL_SA_IA table, log step, if no dupl then log dupl, insert records in IA_ , log accepted.
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE TRUNCATE_IA_TABLES
    AS
      vSQL     VARCHAR2(2100);
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN

      vSQL := 'TRUNCATE TABLE MIGR_IA_SA_LIST';
      EXECUTE IMMEDIATE vSQL;
    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-0';
          l_LogRec.migrArea := 'TRUNCATE IA TABLES';
          l_LogRec.migrStep := 'MIGR_IA.TRUNCATE_IA_TABLES';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM || '-vsql:' || vSQL;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);


    END TRUNCATE_IA_TABLES;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE IA_LOG_VOL(Migration_area    IN VARCHAR2,
                       Step_message      IN VARCHAR2,
                       Status            IN VARCHAR2,
                       TableName         IN VARCHAR2,
                       vMigrationBatchId IN VARCHAR2)
    AS
      vSQL VARCHAR2(2100);
      PRAGMA AUTONOMOUS_TRANSACTION;

    BEGIN

      vSQL := ' INSERT INTO MIG_VOLUMETRIC_ANALYSIS (MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME)'
      || ' SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID, SYSTIMESTAMP AS LOG_TIMESTAMP '
      || '  , ' || CHR(39) || Migration_area || CHR(39) || ' AS MIGRATION_AREA '
      || '  , ' || CHR(39) || Step_message || CHR(39) || ' AS STEP_MESSAGE '
      || '  , ' || CHR(39) || Status || CHR(39) || ' AS STATUS '
      || '  , MVA.CNT AS VOLUME '
      || 'FROM ( SELECT  MIGRATION_BATCH_ID '
      || '  FROM MIG_MIGRATION_INFO '
      || '  WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || vMigrationBatchId || CHR(39)
      || ' ) MMI, ( '
      || '          SELECT COUNT(*) AS CNT '
      || '          FROM ' || TableName
      || '          WHERE  MIG_FLAG = 0 '
      || ' ) MVA '
      || ' WHERE 1=1';

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END IA_LOG_VOL;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --  REBUILD_SA_IA()   -- for each record from ETL_SA_IA table, reads SOURCE_VIEW.IA_  columns and builds the field list. then UPDATE set FIELD_LIST =.
  --  PROCEDURE REBUILD_SA_IA (p_schema IN VARCHAR2) -- +++ anb 2016-04-18 no need for parameter passing
  PROCEDURE REBUILD_SA_IA
    AS
      L_ERRMSG    SRVERRMSG;
      L_SRVERRMSG SRVERRMSG;
      PIO_ERR     SRVERR;
      vFldLst     VARCHAR2(2100);
      vSQL        VARCHAR2(2100);
      v_my_schema VARCHAR2(50);         -- +++ anb 2016-04-18
      l_LogRec    MIGR_GVAR.LogRecTyp;
    BEGIN

      EXECUTE IMMEDIATE 'TRUNCATE TABLE ETL_VIEW_TBLS';
      EXECUTE IMMEDIATE 'TRUNCATE TABLE MIGR_IA_SA_LIST';

      -- +++ anb 2016-04-18 no need for parameter passing
      SELECT SYS_CONTEXT('userenv', 'current_schema')
        INTO v_my_schema
        FROM DUAL;

      FOR tRec IN (SELECT SOURCE_VIEW,
                          VIEW_NAME,
                          DEST_TABLE
          FROM ETL_SA_IA,
               ETL_MIGR_MAPS_INTERMEDIATE
          WHERE 1 = 1
            AND Migration_area = 'SA_IA'
            AND SOURCE_VIEW = TABLE_NAME
            AND ETL_SA_IA.IS_ACTIVE = 'TRUE'
          ORDER BY ETL_SA_IA.ETL_ID)
      LOOP

      << ETL_tbl_loop >>
        vFldLst := ' ';

        FOR cRec IN (SELECT COLUMN_NAME
            FROM ALL_TAB_COLUMNS
            WHERE OWNER = v_my_schema   --'       +++ anb 2016-04-18
              AND TABLE_NAME = tRec.SOURCE_VIEW
              AND (COLUMN_NAME LIKE 'IA_%')
            ORDER BY COLUMN_ID    --valex.6/3/2017 - so as to ensure that we keep the same column order with corresponding temporary tables
        )
        LOOP

        << field_loop >>
          IF vFldLst <> ' '
          THEN
            vFldLst := vFldLst || ' , ';
          END IF;

          vFldLst := vFldLst || cRec.COLUMN_NAME;

        END LOOP field_loop;
        vFldLst := vFldLst || ', MIG_MUTUAL_ID, MIG_BATCH_ID, MIG_FLAG, MIG_TIMESTAMP';

        vSQL := 'UPDATE ETL_SA_IA SET FIELD_LIST = ' || CHR(39) || vFldLst || CHR(39)
        || ' WHERE MIGRATION_AREA = ' || CHR(39) || 'SA_IA' || CHR(39)
        || ' and SOURCE_VIEW = ' || CHR(39) || tRec.SOURCE_VIEW || CHR(39) || ' and DEST_TABLE = ' || CHR(39) || tRec.DEST_TABLE || CHR(39);

        EXECUTE IMMEDIATE vSQL;

        FOR uRec IN (SELECT ud.NAME AS SOURCE_VIEW,
                            ud.REFERENCED_NAME AS TABLE_NAME
            FROM USER_DEPENDENCIES ud
            WHERE 1 = 1
              AND ud.REFERENCED_OWNER = v_my_schema
              AND ud.TYPE = 'VIEW'
              AND ud.REFERENCED_TYPE = 'TABLE'
              AND ud.REFERENCED_NAME LIKE 'SA_%'
              AND ud.NAME = tRec.VIEW_NAME
            ORDER BY ud.REFERENCED_NAME)
        LOOP

        << ViewTablesLoop >>
          vSQL := '  INSERT INTO ETL_VIEW_TBLS (SOURCE_VIEW, TABLE_NAME) VALUES ( '
          || CHR(39) || tRec.SOURCE_VIEW || CHR(39) || ', ' || CHR(39) || uRec.TABLE_NAME || CHR(39) || ' )';

          EXECUTE IMMEDIATE vSQL;

        END LOOP ViewTablesLoop;

      END LOOP ETL_tbl_loop;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-2';
          l_LogRec.migrArea := 'REBUILD SA IA';
          l_LogRec.migrStep := 'MIGR_IA.REBUILD_SA_IA';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM || '-vsql:' || vSQL;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END REBUILD_SA_IA;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --  RUN_IA_SETUP();   -- for each record from ETL_SA_IA table, executes 'CREATE TABLE' statement for creation of IA_ tables.

  PROCEDURE RUN_IA_SETUP
    AS

      L_ERRMSG    SRVERRMSG;
      L_SRVERRMSG SRVERRMSG;
      PIO_ERR     SRVERR;
      vFldLst     VARCHAR2(2100);
      vSQL        VARCHAR2(2100);
      l_LogRec    MIGR_GVAR.LogRecTyp;
    BEGIN

      FOR tRec IN (SELECT STEP,
                          SOURCE_VIEW,
                          DEST_TABLE,
                          FIELD_LIST,
                          UNIQ_KEY,
                          ALLOW_DUPL
          FROM ETL_SA_IA
          WHERE 1 = 1
            AND Migration_area = 'SA_IA'
            AND IS_ACTIVE = 'TRUE'
          ORDER BY ETL_ID ASC)
      LOOP

      << ETL_tbl_loop >>
        vSQL := ' DROP TABLE ' || tRec.DEST_TABLE;

        BEGIN
          EXECUTE IMMEDIATE vSQL;
        EXCEPTION
          WHEN OTHERS THEN NULL;
        END;

        --FA.20160824 Add NOLOGGING mode to minimize redo information size.

        BEGIN
          vSQL := ' CREATE TABLE ' || tRec.DEST_TABLE || '  NOLOGGING  AS ('
          || 'SELECT' || tRec.FIELD_LIST
          || ' FROM ' || tRec.SOURCE_VIEW
          || ' WHERE 1=2 )';

          EXECUTE IMMEDIATE vSQL;

        EXCEPTION
          WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-2';
              l_LogRec.migrArea := 'RUN IA SETUP ';
              l_LogRec.migrStep := 'MIGR_IA.RUN_IA_SETUP';
              l_LogRec.migrRelTbl := tRec.DEST_TABLE;
              l_LogRec.migrRelKey := NULL;
              l_LogRec.logMsg := SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec);

        END;

      END LOOP ETL_tbl_loop;

      --LM - 12-02-2018 - Modify IA_DESCRIPTION in all tables with Specified Items - START
      FOR ctab IN (SELECT epo.IA_OBJ_TABLE
          FROM ETL_PRODUCT_OBJECTS epo
          WHERE epo.HAS_SPECIFIED = 'Y'
            AND epo.IS_ACTIVE = 'Y')
      LOOP

        VSQL := 'ALTER table ' || ctab.IA_OBJ_TABLE || ' MODIFY ( IA_DESCRIPTION VARCHAR2(2000))';
        EXECUTE IMMEDIATE VSQL;

      END LOOP;
    --LM - 12-02-2018 - END

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-2';
          l_LogRec.migrArea := 'RUN IA SETUP ';
          l_LogRec.migrStep := 'MIGR_IA.RUN_IA_SETUP';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM || ' vSQL:' || vSQL;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);


    END RUN_IA_SETUP;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Clean up SA Xferred records all tables from 1 view
  PROCEDURE IA_UPD_SA(vIA_TableName IN VARCHAR2,
                      vSourceView   IN VARCHAR2,
                      vStatus       IN VARCHAR2,
                      vSQL_ID_List  IN VARCHAR2)
    AS
      l_LogRec    MIGR_GVAR.LogRecTyp;
      vSQL        VARCHAR2(2100);
      L_ERRMSG    SRVERRMSG;
      L_SRVERRMSG SRVERRMSG;
      PIO_ERR     SRVERR;
      vMigFlag    PLS_INTEGER;

    BEGIN
      IF vStatus = 'Accepted'
      THEN
        vMigFlag := 1;
      ELSIF vStatus = 'Duplicate'
      THEN
        vMigFlag := 2;
      END IF;

      FOR cTbl IN (SELECT evt.TABLE_NAME AS TblNameFromView
          FROM ETL_VIEW_TBLS evt
          WHERE 1 = 1
            AND evt.SOURCE_VIEW = vSourceView)
      LOOP

      << ViewTablesLoop >>

        vSQL := 'UPDATE ' || cTbl.TblNameFromView
        || '    SET MIG_FLAG = ' || vMigFlag
        || ' WHERE ' || cTbl.TblNameFromView || '.IDPL IN ( '
        || vSQL_ID_List
        || ' )';

        EXECUTE IMMEDIATE vSQL;
      END LOOP ViewTablesLoop;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-2';
          l_LogRec.migrArea := 'IA UPDATE SA ';
          l_LogRec.migrStep := 'MIGR_IA.IA_UPD_SA';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM || ' vSQL:' || vSQL;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END IA_UPD_SA;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE UPDATE_SA_IA(p_MigrationId IN VARCHAR2)
    AS

      L_SRVERRMSG SRVERRMSG;
      l_LogRec    MIGR_GVAR.LogRecTyp;
      p_status    VARCHAR2(20) := 'COMPLETE'; --valex.23/9/16 - status for update_ia_tables
    BEGIN


      FOR LI IN (SELECT MIG_FLAG
          FROM MIGR_IA_SA_LIST
          WHERE MIG_BATCH_ID = p_MigrationId
          GROUP BY MIG_FLAG)
      LOOP

        -- +++ anb 20151117 time each table separately
        l_LogRec.migrStep := 'Intermediate';
        l_LogRec.logMsg := 'Begin marking KF100 with IA Status ';
        l_LogRec.MIG_BATCH_ID := p_MigrationId;
        MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);

        UPDATE SA_KF100F
          SET MIG_FLAG = LI.MIG_FLAG
          WHERE MIG_FLAG = 0
          AND MIG_BATCH_ID = p_MigrationId
          AND IDPL IN (SELECT dups.IDPL
              FROM MIGR_IA_SA_LIST dups
              WHERE dups.MIG_BATCH_ID = p_MigrationId
                --FA.20161031 only master table records are inserted in table
                ---AND dups.DEST_TABLE = 'IA_POLICY'
                AND MIG_FLAG = LI.MIG_FLAG);


      END LOOP;

      -- +++ anb 20151117 time each table separately
      l_LogRec.logMsg := 'End marking KF100 with IA Status ';
      COMMIT;
      MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);
      MIGR_RULES.UPDATE_SA_TABLES(p_MigrationId, 'Intermediate - Update SA', p_status);       -- times its own logging

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END UPDATE_SA_IA;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE IA_MAIN(p_migrBatchId IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                    O_STATUS      OUT VARCHAR2)
    AS

      vSQL               VARCHAR2(32000);
      vSQLIns_log        VARCHAR2(2100);
      vSQLlower          VARCHAR2(2100);
      vSQLcore           VARCHAR2(2100);
      vSQL_ID_List       VARCHAR2(2100);
      l_LogRec           MIGR_GVAR.LogRecTyp;
      vSQL_ID_ListIns    VARCHAR2(2100);
      V_MIG_FLAG         PLS_INTEGER;
      ex_IaRollback      EXCEPTION;
      l_NumRec           NUMBER;
      v_query_str        VARCHAR2(2100);

      V_ROWS_AFFECTED    PLS_INTEGER;
      v_allowed_products VARCHAR2(2100);
    BEGIN
      l_LogRec.MIG_BATCH_ID := p_migrBatchId;
      IF MIGR_PROCESS.PROCESS_STEPS(l_LogRec.MIG_BATCH_ID, 'IA', NULL) = 1
      THEN

        l_LogRec.migrArea := 'MIGR_IA.IA_MAIN';
        l_LogRec.migrStep := 'Staging Maps to Intermediate area';
        l_LogRec.logMsg := 'Running SA MAPS to IA';
        MIGR_LOG.LOG_INFO(l_LogRec);


        --valex.21/2/2017 - ETL_MIGR_MAPS_INTERMEDIATE has been joined so as to identify which temp tables refer to descounts. for these tables corresponding select and group by statements are constructed to support the grouping and correct calculation of discount value when temp tables are loaded to IA
        FOR tRec IN (SELECT a.STEP,
                            a.SOURCE_VIEW,
                            a.DEST_TABLE,
                            a.FIELD_LIST,
                            a.UNIQ_KEY,
                            a.ALLOW_DUPL,
                            a.is_master,
                            b.DISCOUNTS,
                            CASE WHEN b.DISCOUNTS = 'Y' THEN REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(a.FIELD_LIST, 'IA_DISCOUNT_VALUE[ ]{0,},', ''), 'IA_DISC_NFKKD[ ]{0,},', ''), 'IA_DISC_ORDER[ ]{0,},', '') || ', round(exp(sum(ln(ia_discount_value))),4) as IA_DISCOUNT_VALUE ' || ', LISTAGG(to_char(IA_DISC_NFKKD), '','') WITHIN GROUP (ORDER BY (IA_DISC_NFKKD)) AS IA_DISC_NFKKD ' || ', LISTAGG(to_char(IA_DISC_ORDER), '','') WITHIN GROUP (ORDER BY (IA_DISC_ORDER)) AS IA_DISC_ORDER ' ELSE NULL END discounts_select_prc,
                            CASE WHEN b.DISCOUNTS = 'Y' THEN REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(a.FIELD_LIST, 'IA_DISCOUNT_VALUE[ ]{0,},', ''), 'IA_DISC_NFKKD[ ]{0,},', ''), 'IA_DISC_ORDER[ ]{0,},', '') || ', sum(ia_discount_value) as IA_DISCOUNT_VALUE ' || ', LISTAGG(to_char(IA_DISC_NFKKD), '','') WITHIN GROUP (ORDER BY (IA_DISC_NFKKD)) AS IA_DISC_NFKKD ' || ', LISTAGG(to_char(IA_DISC_ORDER), '','') WITHIN GROUP (ORDER BY (IA_DISC_ORDER)) AS IA_DISC_ORDER ' ELSE NULL END discounts_select_lumps,
                            CASE WHEN b.DISCOUNTS = 'Y' THEN REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(a.FIELD_LIST, 'IA_DISCOUNT_VALUE[ ]{0,},', ''), 'IA_DISC_NFKKD[ ]{0,},', ''), 'IA_DISC_ORDER[ ]{0,},', ''), 'IA_DISCOUNT_CALC_MODE[ ]{0,},', '') || ', IA_DISCOUNT_VALUE , IA_DISC_NFKKD, IA_DISC_ORDER ' ELSE NULL END discounts_select1,
                            CASE WHEN b.DISCOUNTS = 'Y' THEN REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(a.FIELD_LIST, 'IA_DISCOUNT_VALUE[ ]{0,},', ''), 'IA_DISC_NFKKD[ ]{0,},', ''), 'IA_DISC_ORDER[ ]{0,},', ''), 'IA_DISCOUNT_CALC_MODE[ ]{0,},', '') || ', (case when ia_discount_calc_mode=''PRC'' then (IA_DISCOUNT_VALUE - 1) *100  else IA_DISCOUNT_VALUE *100 end) as IA_DISCOUNT_VALUE  ,IA_DISC_NFKKD, IA_DISC_ORDER ' ELSE NULL END discounts_select2,
                            CASE WHEN b.DISCOUNTS = 'Y' THEN REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(a.FIELD_LIST, 'IA_DISCOUNT_VALUE[ ]{0,},', ''), 'IA_DISC_NFKKD[ ]{0,},', ''), 'IA_DISC_ORDER[ ]{0,},', '') ELSE NULL END discounts_group_by
            FROM ETL_SA_IA a
              JOIN ETL_MIGR_MAPS_INTERMEDIATE b
                ON a.SOURCE_VIEW = b.TABLE_NAME
            WHERE 1 = 1
              -- AND ',' || MIGR_PROCESS.PROCESS_STEPS(l_LogRec.MIG_BATCH_ID, NULL, NULL) || ',' like '%,' || a.INSR_PRODUCT || ',%'
              AND a.Migration_area = 'SA_IA'
              AND a.IS_ACTIVE = 'TRUE'
            ORDER BY a.ETL_ID)
        LOOP

        << ETL_tbl_loop >>
          BEGIN
            l_LogRec.migrStep := 'Intermediate';
            l_LogRec.logMsg := 'Begin IA for DEST_TABLE: ' || tRec.DEST_TABLE;
            l_LogRec.migrRelTbl := tRec.DEST_TABLE;
            MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);

            --valex.27/4/16 allowed products from process_steps
            v_allowed_products := MIGR_PROCESS.PROCESS_STEPS(l_LogRec.MIG_BATCH_ID, NULL, NULL);

            --- duplicates allowed ?
            IF tRec.ALLOW_DUPL = 'FALSE'
            THEN                 -- LOG duplicates in ERROR LOG

              vSQLIns_log := 'INSERT INTO MIG_DETAIL_ERROR_LOG '
              || '(MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY) '
              || ' SELECT   x.MIG_BATCH_ID, x.ERROR_TIMESTAMP, x.MIGRATION_AREA '
              || '    , x.ERROR_TYPE, x.ERROR_MESSAGE ,x.MIGRATION_STEP, x.RELATED_TABLE, x.RELATED_KEY  ';

              vSQLcore := 'SELECT IA_IDPL as IDPL, ' || CHR(39) || tRec.DEST_TABLE || CHR(39) || ' AS RELATED_TABLE, ' || q'['Record id: ']' || ' || ' || tRec.UNIQ_KEY || ' AS RELATED_KEY '
              || '    , MIG_BATCH_ID, SYSTIMESTAMP AS ERROR_TIMESTAMP, ' || q'['Intermediate']' || ' AS MIGRATION_AREA '
              || '    , ' || q'['Warning']' || ' AS ERROR_TYPE, ' || q'['Record has already been migrated']' || ' AS ERROR_MESSAGE '
              || '    , ' || q'['Loading Intermediate Area tables']' || ' AS MIGRATION_STEP '
              || ' FROM ' || tRec.SOURCE_VIEW
              || ' WHERE 1=1 AND MIG_FLAG=0 '
              || '   AND ' || tRec.UNIQ_KEY || ' IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')'
              || '   AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);

              vSQLlower := ' FROM ( ' || vSQLcore || ' ) x ';

              vSQL := vSQLIns_log || vSQLlower;

              EXECUTE IMMEDIATE vSQL;
              V_ROWS_AFFECTED := SQL % ROWCOUNT;

              COMMIT;
              -- mark SA_ tables of view as Duplicates
              vSQL_ID_List := 'SELECT x.IDPL ' || vSQLlower;
              --FA.20160408 iNSERT ONLY IF DUPLICATES FOUND
              ---IA_KEEP_SA_LIST(l_LogRec.mig_batch_id, tRec.DEST_TABLE, tRec.SOURCE_VIEW, vSQL_ID_List, 'Duplicate');
              --FA.20161031 insert into migr_ia_sa_list only values from master table
              IF V_ROWS_AFFECTED > 0
                AND tRec.is_master = 'Y'
              THEN
                BEGIN
                  vSQL := 'INSERT INTO MIGR_IA_SA_LIST '
                  || '  SELECT ' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39)
                  || ', ' || CHR(39) || tRec.SOURCE_VIEW || CHR(39)
                  || ', ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                  --                  || ', ' || CHR(39) || '1' || CHR(39)
                  || ', ' || CHR(39) || '2' || CHR(39)
                  || ', RELATED_KEY'
                  || '  FROM MIG_DETAIL_ERROR_LOG '
                  || ' WHERE RELATED_TABLE = ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                  || ' AND ERROR_MESSAGE = ' || q'['Record has already been migrated']'
                  || ' AND MIGRATION_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);

                  EXECUTE IMMEDIATE vSQL;
                EXCEPTION
                  WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM();
                      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                END;
              END IF;
            END IF;

            l_LogRec.migrRelTbl := tRec.DEST_TABLE;

            --valex.21/2/2017 - for dicount tables, a grouping is applied (if there are lines whichj refer to the same entity, object or policy) before loading to IA. depending on discount calculation mode (lumpsum or percent) different aggregate function is used
            IF tRec.DISCOUNTS = 'Y'
            THEN

              vsql := ' INSERT INTO ' || tRec.DEST_TABLE || ' (' || trec.discounts_select1 || ') '
              || 'with lumps as ('
              || 'SELECT ' || trec.discounts_select_lumps
              || ' FROM ' || tRec.SOURCE_VIEW
              || ' WHERE 1=1 AND MIG_FLAG=0 and ia_discount_calc_mode=''LUMPS'' '
              || ' AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);
              IF tRec.ALLOW_DUPL = 'FALSE'
              THEN
                vSQL := vsql || ' AND ' || tRec.UNIQ_KEY || ' NOT IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')';
              END IF;
              vsql := vsql || ' group by ' || tRec.discounts_group_by || ')'
              || ' ,prc as ('
              || 'SELECT ' || trec.discounts_select_prc
              || ' FROM ' || tRec.SOURCE_VIEW
              || ' WHERE 1=1 AND MIG_FLAG=0 and ia_discount_calc_mode=''PRC'' '
              || ' AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);
              IF tRec.ALLOW_DUPL = 'FALSE'
              THEN
                vSQL := vsql || ' AND ' || tRec.UNIQ_KEY || ' NOT IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')';
              END IF;
              vsql := vsql || ' group by ' || tRec.discounts_group_by || ')'

              || 'select ' || trec.discounts_select2
              || ' from ('
              || ' select * from lumps '
              || '    union all '
              || ' select * from prc) ';
            ELSE
              vSQL := ' INSERT INTO ' || tRec.DEST_TABLE || ' (' || tRec.FIELD_LIST || ') '
              || 'SELECT ' || tRec.FIELD_LIST
              || ' FROM ' || tRec.SOURCE_VIEW
              || ' WHERE 1=1 AND MIG_FLAG=0 '
              || ' AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);

              IF tRec.ALLOW_DUPL = 'FALSE'
              THEN
                vSQL := vSQL || ' AND ' || tRec.UNIQ_KEY || ' NOT IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')';
              END IF;
            END IF;

            BEGIN
              EXECUTE IMMEDIATE vSQL;

            EXCEPTION
              WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || vSQL;
                  MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                  RAISE ex_IaRollback;
            END;

            --FA.20161031 insert into migr_ia_sa_list only values from master table
            IF tRec.is_master = 'Y'
            THEN
              BEGIN
                vSQL := 'INSERT INTO MIGR_IA_SA_LIST '
                || '  SELECT ' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39)
                || ', ' || CHR(39) || tRec.SOURCE_VIEW || CHR(39)
                || ', ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                || ', ' || CHR(39) || '1' || CHR(39)
                || ', ia_IDPL'
                || '  FROM '
                || tRec.DEST_TABLE
                || ' WHERE 1=1 AND MIG_FLAG=0'
                || ' AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);


                EXECUTE IMMEDIATE vSQL;
              EXCEPTION
                WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM();
                    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
              END;
            END IF;

            COMMIT;

            IA_LOG_VOL('Intermediate', tRec.STEP, 'Accepted', tRec.DEST_TABLE, l_LogRec.MIG_BATCH_ID);
            l_LogRec.logMsg := 'End IA for DEST_TABLE: ' || tRec.DEST_TABLE;
            MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);

          EXCEPTION

            WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
                l_LogRec.migrRelTbl := vSQL;
                MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                RAISE ex_IaRollback;

          END;

        END LOOP ETL_tbl_loop;

        ---FA.20160420 Populate all covers insured values tables
        BEGIN
          FOR tRec IN (SELECT IA_COVER_VALUES_TBL,
                              IA_COVER_TBL,
                              esaa.FIELD_LIST,
                              conf.HST_COVER_TBL
              FROM ETL_IA_INSRPRD_CONFIG conf,
                   ETL_SA_IA esa,
                   ETL_SA_IA esaa
              WHERE esa.IS_ACTIVE = 'TRUE'
                AND esa.DEST_TABLE = conf.IA_COVER_TBL

                AND esaa.DEST_TABLE = conf.IA_COVER_VALUES_TBL
                AND conf.IA_COVER_VALUES_TBL IS NOT NULL)
          LOOP

            vSQL := 'DECLARE CURSOR KF is '
            || '    SELECT   ' || tRec.FIELD_LIST
            || ' FROM ' || tRec.IA_COVER_VALUES_TBL || '; '
            || ' TYPE KF_tab IS TABLE OF KF%ROWTYPE; '
            || ' KF_all_records   KF_tab:= KF_tab(); '
            || 'BEGIN '
            || 'SELECT ' || REPLACE(tRec.FIELD_LIST, 'IA_INSURED_VALUE', 'MIGR_API_COVERS.GET_COVER_INSURED_VALUE(hvc.INSURED_VAL,hvc.num_params,ct.ia_IDPL,ct.ia_IDPLPS, ct.IA_OBJECT_ID,ct.MIG_BATCH_ID)')
            || ' BULK COLLECT INTO KF_all_records '
            || ' FROM ' || tRec.IA_COVER_TBL || ' ct  LEFT JOIN ' || tRec.HST_COVER_TBL || ' hvc ON ct.IA_COVER = hvc.INSIS_COVER_ID  '
            || ' WHERE 1=1 AND MIG_FLAG=0'
            --FA.20160825 Add applicable bolags condition
            || '  and '',''||HVC.APPLICABLE_BOLAGS||'','' like ''%,''||ct.MIG_MUTUAL_ID||'',%'' '
            || ' AND MIG_BATCH_ID =' || CHR(39) || p_migrBatchId || CHR(39)
            || ';'
            || ' FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT '
            || '  INSERT INTO ' || tRec.IA_COVER_VALUES_TBL || ' VALUES KF_all_records(i); '
            || 'END; ';

            EXECUTE IMMEDIATE vSQL;
          END LOOP;

        EXCEPTION
          WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || '  ' || vSQL;
              MIGR_LOG.LOG_EXCEPTION(l_LogRec);
        END;

        -- pl 20161110: RUN_COVER_UPDATE_RULES
        MIGR_RULES.RUN_COVER_UPDATE_RULES(p_migrBatchId);
        -- pl 20170516
        MIGR_RULES.UPDATE_COVER_ON_DEDUCT_RULES(p_migrBatchId);

        --LM - 04-12-2017 - Procedure for translating according to the language of the user.
        MIGR_RULES.RUN_TRANSLATION_RULES(p_migrBatchId);

        --LM - 17-01-2018 - procedure for unmapped outhouse labels - no mapping for BENNG values.
        MIGR_RULES.UPDATE_MAP_OUTHOUSE_LABEL(p_migrBatchId);

        --LM - 12-02-2018 - procedure for updating description of Specified Items (add description from entries with KF208F.FBLKR = 0).
        MIGR_RULES.UPDATE_SPECIFIED_DESCRIPTION(p_migrBatchId);

        UPDATE_SA_IA(l_LogRec.MIG_BATCH_ID);
        O_STATUS := 'COMPLETE';

      END IF;
      COMMIT;
    EXCEPTION
      WHEN ex_IaRollback THEN O_STATUS := 'ROLLBACK_IA';
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END IA_MAIN;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE IA_MAIN_TBL(--p_migrBatchId IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                        p_LogRec     MIGR_GVAR.LogRecTyp,
                        O_STATUS OUT VARCHAR2,
                        p_status IN  VARCHAR2)
    AS

      vSQL               VARCHAR2(2100);
      vSQLIns_log        VARCHAR2(2100);
      vSQLlower          VARCHAR2(2100);
      vSQLcore           VARCHAR2(2100);
      vSQL_ID_List       VARCHAR2(2100);
      l_LogRec           MIGR_GVAR.LogRecTyp;
      vSQL_ID_ListIns    VARCHAR2(2100);
      V_MIG_FLAG         PLS_INTEGER;
      ex_IaRollback      EXCEPTION;
      l_NumRec           NUMBER;
      v_query_str        VARCHAR2(2100);

      V_ROWS_AFFECTED    PLS_INTEGER;
      v_allowed_products VARCHAR2(2100);
    BEGIN
      l_LogRec := p_LogRec;

      IF MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id, 'IA', NULL) = 1
      THEN

        l_LogRec.migrArea := 'MIGR_IA.IA_MAIN_TBL';
        l_LogRec.migrStep := 'Staging ' || l_LogRec.migrRelTbl || ' to Intermediate area';
        l_LogRec.logMsg := 'Running ' || l_LogRec.migrRelTbl || ' MAPS to IA';
        MIGR_LOG.LOG_INFO(l_LogRec);

        FOR tRec IN (SELECT STEP,
                            SOURCE_VIEW,
                            DEST_TABLE,
                            FIELD_LIST,
                            UNIQ_KEY,
                            ALLOW_DUPL,
                            is_master
            FROM ETL_SA_IA
            WHERE 1 = 1
              AND ',' || MIGR_PROCESS.PROCESS_STEPS(l_LogRec.MIG_BATCH_ID, NULL, NULL) || ',' LIKE '%,' || INSR_PRODUCT || ',%'
              AND Migration_area = 'SA_IA'
              AND IS_ACTIVE = 'TRUE'
              AND SOURCE_VIEW = l_LogRec.migrRelTbl
            ORDER BY ETL_ID)
        LOOP

        << ETL_tbl_loop >>
          BEGIN
            l_LogRec.migrStep := 'Intermediate';
            l_LogRec.logMsg := 'Begin IA for DEST_TABLE: ' || tRec.DEST_TABLE;
            --------            l_LogRec.migrRelTbl := tRec.DEST_TABLE;
            MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, p_status);

            --valex.27/4/16 allowed products from process_steps
            v_allowed_products := MIGR_PROCESS.PROCESS_STEPS(l_LogRec.mig_batch_id, NULL, NULL);

            --- duplicates allowed ?
            IF tRec.ALLOW_DUPL = 'FALSE'
            THEN                 -- LOG duplicates in ERROR LOG

              vSQLIns_log := 'INSERT INTO MIG_DETAIL_ERROR_LOG '
              || '(MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY) '
              || ' SELECT   x.MIG_BATCH_ID, x.ERROR_TIMESTAMP, x.MIGRATION_AREA '
              || '    , x.ERROR_TYPE, x.ERROR_MESSAGE ,x.MIGRATION_STEP, x.RELATED_TABLE, x.RELATED_KEY  ';

              vSQLcore := 'SELECT IA_IDPL as IDPL, ' || CHR(39) || tRec.DEST_TABLE || CHR(39) || ' AS RELATED_TABLE, ' || q'['Record id: ']' || ' || ' || tRec.UNIQ_KEY || ' AS RELATED_KEY '
              || '    , MIG_BATCH_ID, SYSTIMESTAMP AS ERROR_TIMESTAMP, ' || q'['Intermediate']' || ' AS MIGRATION_AREA '
              || '    , ' || q'['Warning']' || ' AS ERROR_TYPE, ' || q'['Record has already been migrated']' || ' AS ERROR_MESSAGE '
              || '    , ' || q'['Loading Intermediate Area tables']' || ' AS MIGRATION_STEP '
              || ' FROM ' || tRec.SOURCE_VIEW
              || ' WHERE 1=1 AND MIG_FLAG=0 '
              || '   AND ' || tRec.UNIQ_KEY || ' IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')'
              || '   AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);

              vSQLlower := ' FROM ( ' || vSQLcore || ' ) x ';

              vSQL := vSQLIns_log || vSQLlower;

              EXECUTE IMMEDIATE vSQL;
              V_ROWS_AFFECTED := SQL % ROWCOUNT;

              COMMIT;
              -- mark SA_ tables of view as Duplicates
              vSQL_ID_List := 'SELECT x.IDPL ' || vSQLlower;
              --FA.20160408 iNSERT ONLY IF DUPLICATES FOUND
              ---IA_KEEP_SA_LIST(l_LogRec.mig_batch_id, tRec.DEST_TABLE, tRec.SOURCE_VIEW, vSQL_ID_List, 'Duplicate');
              --FA.20161031 insert into migr_ia_sa_list only values from master table
              IF V_ROWS_AFFECTED > 0
                AND tRec.is_master = 'Y'
              THEN
                BEGIN
                  vSQL := 'INSERT INTO MIGR_IA_SA_LIST '
                  || '  SELECT ' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39)
                  || ', ' || CHR(39) || tRec.SOURCE_VIEW || CHR(39)
                  || ', ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                  --                  || ', ' || CHR(39) || '1' || CHR(39)
                  || ', ' || CHR(39) || '2' || CHR(39)
                  || ', RELATED_KEY'
                  || '  FROM MIG_DETAIL_ERROR_LOG '
                  || ' WHERE RELATED_TABLE = ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                  || ' AND ERROR_MESSAGE = ' || q'['Record has already been migrated']'
                  || ' AND MIGRATION_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);

                  EXECUTE IMMEDIATE vSQL;
                EXCEPTION
                  WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM();
                      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                END;
              END IF;
            END IF;

            l_LogRec.migrRelTbl := tRec.DEST_TABLE;
            vSQL := ' INSERT INTO ' || tRec.DEST_TABLE || ' (' || tRec.FIELD_LIST || ') '
            || 'SELECT' || tRec.FIELD_LIST
            || ' FROM ' || tRec.SOURCE_VIEW
            || ' WHERE 1=1 AND MIG_FLAG=0'
            || ' AND MIG_BATCH_ID =' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);
            IF tRec.ALLOW_DUPL = 'FALSE'
            THEN
              vSQL := vSQL || ' AND ' || tRec.UNIQ_KEY || ' NOT IN (SELECT ' || tRec.UNIQ_KEY || ' FROM ' || tRec.DEST_TABLE || ')';
            END IF;

            BEGIN
              EXECUTE IMMEDIATE vSQL;

            EXCEPTION
              WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || vSQL;
                  MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                  RAISE ex_IaRollback;
            END;

            --FA.20161031 insert into migr_ia_sa_list only values from master table
            IF tRec.is_master = 'Y'
            THEN
              BEGIN
                vSQL := 'INSERT INTO MIGR_IA_SA_LIST '
                || '  SELECT ' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39)
                || ', ' || CHR(39) || tRec.SOURCE_VIEW || CHR(39)
                || ', ' || CHR(39) || tRec.DEST_TABLE || CHR(39)
                || ', ' || CHR(39) || '1' || CHR(39)
                || ', ia_IDPL'
                || '  FROM '
                || tRec.DEST_TABLE
                || ' WHERE 1=1 AND MIG_FLAG=0'
                || ' AND MIG_BATCH_ID = ' || CHR(39) || l_LogRec.MIG_BATCH_ID || CHR(39);


                EXECUTE IMMEDIATE vSQL;
              EXCEPTION
                WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM();
                    MIGR_LOG.LOG_EXCEPTION(l_LogRec);
              END;
            END IF;

            COMMIT;

            IA_LOG_VOL('Intermediate', tRec.STEP, 'Accepted', tRec.DEST_TABLE, l_LogRec.MIG_BATCH_ID);
            l_LogRec.logMsg := 'End IA for DEST_TABLE: ' || tRec.DEST_TABLE;
            MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, p_status);

          EXCEPTION

            WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || ' - ' || vSQL;
                MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                RAISE ex_IaRollback;

          END;

        END LOOP ETL_tbl_loop;
        O_STATUS := 'COMPLETE';

      END IF;

      COMMIT;

    EXCEPTION
      WHEN ex_IaRollback THEN O_STATUS := 'ROLLBACK_IA';
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END IA_MAIN_TBL;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --valex.8/9/16 - all IA processes in one procedure
  PROCEDURE RUN_IA(p_migrBatchId IN  VARCHAR2,
                   IA_Status     OUT VARCHAR2)
    AS
      l_LogRec         MIGR_GVAR.LogRecTyp;
      vSql             VARCHAR2(2000);
      l_status         VARCHAR2(30);
      l_migrateClients ETL_SETUP_INFO.MIGRATE_CLIENTS % TYPE;
      v_mig_insis_user ETL_BOLAG_INFO.BOLAG_USERNAME % TYPE;
    BEGIN
      IA_Status := 'COMPLETE';
      l_LogRec.migrArea := 'MIGR_IA.RUN_IA';
      l_LogRec.MIG_BATCH_ID := p_migrBatchId;
      l_LogRec.logMsg := 'Started IA processing';
      MIGR_LOG.LOG_INFO(l_LogRec);

      --FA.20161027 Add condition for client migration
      SELECT MIGRATE_CLIENTS
        INTO l_migrateClients
        FROM ETL_SETUP_INFO;

      IF MIGR_INTERMEDIATE_OBJECTS.POPULATE_INTERMEDIATE_TABLES(l_LogRec.MIG_BATCH_ID)
      THEN

        l_LogRec.logMsg := 'Populated Intermediate Objects';
        MIGR_LOG.LOG_INFO(l_LogRec);
        --FA.20161109 Run Exclusion Object Rules
        MIGR_RULES.RUN_OBJ_EXCLUSION_RULES;
        l_LogRec.logMsg := 'Run Excusion Rules';
        MIGR_LOG.LOG_INFO(l_LogRec);
        MIGR_IA.IA_MAIN(l_LogRec.MIG_BATCH_ID, l_status);

        DBMS_LOCK.SLEEP(60);

        IF l_status = 'COMPLETE'
        THEN

          --FA.20161027 Add condition for client migration
          IF l_migrateClients = 'Y'
          THEN
            l_LogRec.logMsg := 'Client Migration started';
            MIGR_LOG.LOG_INFO(l_LogRec);

            MIGR_API_COMMON.SET_DEFAULT_VALUES(SUBSTR(l_LogRec.MIG_BATCH_ID, 1, 2));
            vSql := 'ALTER SESSION SET NLS_DATE_FORMAT = ''DD-MM-RRRR''';
            EXECUTE IMMEDIATE vSql;

            --!!!!!!!!!CLEAN UP PROCESS WHEN ROLLABACK STATUS !!!!!!!!!!!!!!!!!!!!!!!!
            -----FA.20160705 API Process is triggered by api_scheduled job when a batch has finished IA step
            ----MIGR_API.RUN_API(L_DEBUG, l_LogRec.mig_batch_id);
            --The following code should be removed once desgn for customer migration will be finalized
            SELECT ebi.BOLAG_USERNAME
              INTO v_mig_insis_user
              FROM ETL_BOLAG_INFO ebi
              WHERE ebi.BOLAG_ID = SUBSTR(l_LogRec.MIG_BATCH_ID, 1, 2);
            INSIS_SYS_V10.INSIS_CONTEXT.Prepare_Session(Pi_App => 'GEN',
            Pi_Action => 'InsisPolicyGen',
            Pi_Username => v_mig_insis_user,
            Pi_User_Role => 'InsisStaff',
            Pi_Lang => NULL,
            Pi_Country => NULL);


            MIGR_API_CLIENTS.SETUP_CLIENT(l_LogRec.MIG_BATCH_ID);
            MIGR_API_CLIENTS.SETUP_CLIENT_ADDRESS(l_LogRec.MIG_BATCH_ID);
            l_LogRec.logMsg := 'Finished  clients';
            MIGR_LOG.LOG_INFO(l_LogRec);

          ELSE
            l_LogRec.logMsg := 'Skip Client Migration';
            MIGR_LOG.LOG_INFO(l_LogRec);
          END IF;

          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.IA_COMPLETED = 'Finished'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;

        ELSE

          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.IA_COMPLETED = 'Failed', Status = 'Failed', END_TIMESTAMP = SYSTIMESTAMP
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;
          IA_Status := 'INCOMPLETE';
        END IF;

      ELSE

        UPDATE MIG_MIGRATION_INFO mmi
          SET mmi.IA_COMPLETED = 'Failed', Status = 'Failed', END_TIMESTAMP = SYSTIMESTAMP
          WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;
        IA_Status := 'INCOMPLETE';

      END IF;

      ----Rejected policies in IA area will be inserted in MIGR_FAILED_POLICY
      FOR c IN (SELECT ip.IA_POLICY_REF,
                       ip.IA_INSRPRD,
                       ip.MIG_BATCH_ID,
                       ip.IA_IDPL,
                       ip.IA_INSR_TYPE
          FROM IA_POLICY ip
          WHERE ip.MIG_FLAG = 3
            AND ip.MIG_BATCH_ID = l_LogRec.MIG_BATCH_ID)
      LOOP
        INSERT INTO MIGR_FAILED_POLICY (
          POLICY_REF, CLIENT_ID, AGENT_ID, INSRPRD, POLICY_STEP, INS_DATE, INS_MS, MIG_BATCH_ID, POLICY_IDPL, ERROR_MESSAGE, MIG_START, MIG_END, OFFRNCODE
        )
        VALUES (c.IA_POLICY_REF, NULL, NULL, c.IA_INSRPRD, NULL, SYSDATE, NULL, c.MIG_BATCH_ID, c.IA_IDPL, 'Policy was rejected in IA area.', NULL, NULL, c.IA_INSR_TYPE);
      END LOOP;


      l_LogRec.logMsg := 'Finished IA processing';
      l_LogRec.migrRelTbl := '';
      l_LogRec.migrRelKey := '';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          IA_Status := 'INCOMPLETE';
          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.IA_COMPLETED = 'Failed', Status = 'Failed'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;

    END RUN_IA;

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --Clean up SA Xferred records

  PROCEDURE IA_CLEAN_UP_XFER(vMigrationBatchId IN VARCHAR2)
    AS
      vSQL        VARCHAR2(21000);
      L_ERRMSG    SRVERRMSG;
      L_SRVERRMSG SRVERRMSG;
      PIO_ERR     SRVERR;
      l_LogRec    MIGR_GVAR.LogRecTyp;
    BEGIN

      -- +++ anb 2015-09-16 needs rework to include all SA_ tables and also to select IDPL from IA_POLICY, vMigBatchId
      --                    currently it assumes that SA_ has only BOAT policies.....
      NULL;

    ------      IA_UPD_SA_OLD('SA_KF100F', 1);
    ------      IA_UPD_SA_OLD('SA_KF108F', 1);
    ------      IA_UPD_SA_OLD('SA_KF109F', 1);
    ------      IA_UPD_SA_OLD('SA_KF125F', 1);
    ------      IA_UPD_SA_OLD('SA_KF165F', 1);
    ------      IA_UPD_SA_OLD('SA_KF210F', 1);
    ------      -- log Rejected Policies
    ------      MIGR_IA.IA_LOG_VOL('Intermediate', 'POLICY', 'Rejected', 'SA_KF100F', vMigrationBatchId);
    -----      --MIGR_IA.IA_LOG_POLICY_REJECT('POLICY', 'SA_KF100F');    -- Load rejected records (Policies) to MIG_DETAIL_ERROR_LOG
    ------      -- log Rejected Addresses
    ------      MIGR_IA.IA_LOG_VOL('Intermediate', 'ADDRESS', 'Rejected', 'SA_KF100F', vMigrationBatchId);
    -----      --MIGR_IA.IA_LOG_POLICY_REJECT('ADDRESS', 'SA_KF100F');    -- Load rejected records (Policies) to MIG_DETAIL_ERROR_LOG
    ------      -- log Rejected Clients
    ------      MIGR_IA.IA_LOG_VOL('Intermediate', 'CLIENT', 'Rejected', 'SA_KF100F', vMigrationBatchId);
    ------      --MIGR_IA.IA_LOG_POLICY_REJECT('CLIENT', 'SA_KF100F');    -- Load rejected records (Policies) to MIG_DETAIL_ERROR_LOG
    ------      -- log Rejected Agents
    ------      MIGR_IA.IA_LOG_VOL('Intermediate', 'AGENTS', 'Rejected', 'SA_KF100F', vMigrationBatchId);
    ------      --MIGR_IA.IA_LOG_POLICY_REJECT('AGENTS', 'SA_KF100F');    -- Load rejected records (Policies) to MIG_DETAIL_ERROR_LOG
    ------      -- log Rejected O_Ships
    ------      MIGR_IA.IA_LOG_VOL('Intermediate', 'O_SHIP', 'Rejected', 'SA_KF165F', vMigrationBatchId);
    ------      --MIGR_IA.IA_LOG_POLICY_REJECT('O_SHIP', 'SA_KF165F');    -- Load rejected records (Policies) to MIG_DETAIL_ERROR_LOG
    ------      --Update rest records as not migrated
    ------      UPDATE SA_KF100F
    ------        SET MIG_FLAG = 2
    ------        WHERE MIG_FLAG = 0
    ------        AND MIG_BATCH_ID = vMigrationBatchId;
    ------      UPDATE SA_KF125F
    ------        SET MIG_FLAG = 2
    ------        WHERE MIG_FLAG = 0
    ------        AND MIG_BATCH_ID = vMigrationBatchId;
    ------      UPDATE SA_KF165F
    ------        SET MIG_FLAG = 2
    ------        WHERE MIG_FLAG = 0
    ------        AND MIG_BATCH_ID = vMigrationBatchId;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-2';
          l_LogRec.migrArea := 'IA CLEAN_UP XFER';
          l_LogRec.migrStep := 'MIGR_IA.IA_CLEAN_UP_XFER';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);


    END IA_CLEAN_UP_XFER;


END MIGR_TST_PRC_IA;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_TST_PRC_LA_SA
  AS
  -------------------------------------------------------------------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------------------------------------------------------------------
  PROCEDURE fill_SA_B_PRSN(p_migrBatchId IN VARCHAR2)
    AS
      l_LogRec MIGR_GVAR.LogRecTyp;
      vsql     VARCHAR2(200);

    BEGIN
      l_LogRec.migrStep := 'Second Phase of Staging area';
      l_LogRec.logMsg := '';
      l_LogRec.mig_batch_id := p_migrBatchId;
      l_LogRec.migrArea := 'MIGR_LA_SA.FILL_SA_B_PRSN';

      vsql := 'SELECT * from RLG_LOCK_TBL WHERE tbl=''SA_B_PRSN'' FOR UPDATE';
      EXECUTE IMMEDIATE vsql;

      MERGE INTO SA_B_PRSN t
      USING (WITH union_DATA AS (SELECT DISTINCT LPAD(CAST(PENRs AS NVARCHAR2(2)), 2, '0') || LPAD(CAST(PENR AS NVARCHAR2(10)), 10, '0') AS G_EGN,
                                                 LPAD(CAST(PENR AS NVARCHAR2(10)), 10, '0') AS penr,
                                                 LPAD(CAST(PENRs AS NVARCHAR2(2)), 2, '0') AS penrs,
                                                 'KF100F' AS origin  --, NAMN,NAMNI
                                                 -- LM - 20170309 - JOIN SA_B_PRSN.PENR with the rest SA_KF TABLES should be replaced with the source PENR and PENRS (use PENR_SRC not the converted PENR with leading zeroes)
                                                 ,
                                                 PENR AS PENR_SRC,
                                                 PENRS AS PENRS_SRC
              FROM SA_KF100F
              WHERE 1 = 1
                AND MIG_BATCH_ID = p_migrBatchId
                AND PENRS IN (18, 19, 20)
                AND REGEXP_LIKE(penr, '^[0-9]{1,}$')
              UNION ALL
            SELECT DISTINCT LPAD(CAST(PENRs AS NVARCHAR2(2)), 2, '0') || LPAD(CAST(PENR AS NVARCHAR2(10)), 10, '0') AS G_EGN,
                            LPAD(CAST(PENR AS NVARCHAR2(10)), 10, '0') AS penr,
                            LPAD(CAST(PENRs AS NVARCHAR2(2)), 2, '0') AS penrs,
                            'KF170F' AS origin --,NAMN,NAMNI
                            ,
                            PENR AS PENR_SRC,
                            PENRS AS PENRS_SRC
              FROM SA_KF170F
              WHERE 1 = 1
                AND MIG_BATCH_ID = p_migrBatchId
                AND PENRS IN (18, 19, 20)
                AND REGEXP_LIKE(penr, '^[0-9]{1,}$')
              UNION ALL
            SELECT DISTINCT LPAD(CAST(PENRs AS NVARCHAR2(2)), 2, '0') || LPAD(CAST(PENR AS NVARCHAR2(10)), 10, '0') AS G_EGN,
                            LPAD(CAST(PENR AS NVARCHAR2(10)), 10, '0') AS penr,
                            LPAD(CAST(PENRs AS NVARCHAR2(2)), 2, '0') AS penrs,
                            'KF221F' AS origin --,NAMN,NAMNI
                            ,
                            PENR AS PENR_SRC,
                            PENRS AS PENRS_SRC
              FROM SA_KF221F
              WHERE 1 = 1
                AND MIG_BATCH_ID = p_migrBatchId
                AND PENRS IN (18, 19, 20)
                AND REGEXP_LIKE(penr, '^[0-9]{1,}$')
              UNION ALL
            SELECT DISTINCT LPAD(CAST(olpNs AS NVARCHAR2(2)), 2, '0') || LPAD(CAST(olpnr AS NVARCHAR2(10)), 10, '0') AS G_EGN,
                            LPAD(CAST(olpnr AS NVARCHAR2(10)), 10, '0') AS penr,
                            LPAD(CAST(olPNs AS NVARCHAR2(2)), 2, '0') AS penrs,
                            'KF152F' AS origin --,OLNAM AS NAMN,OLNAI as NAMNI
                            ,
                            OLPNR AS PENR_SRC,
                            OLPNS AS PENRS_SRC
              FROM SA_KF152F
              WHERE 1 = 1
                AND MIG_BATCH_ID = p_migrBatchId
                AND OLPNS IN (18, 19, 20)
                AND REGEXP_LIKE(olpnr, '^[0-9]{1,}$')
          --                            UNION ALL
          --                         SELECT distinct CAST(mfpns AS NCHAR(2)) || CAST(mfpnr AS NCHAR(10)) as G_EGN, CAST(mfpnr AS NCHAR(10)) AS penr, CAST(mfpns AS NCHAR(2)) AS penrs,'KF110F' as origin --,MFNAM as NAMN,MFNAI as NAMNI
          --                         FROM SA_KF110F
          --                         where 1=1
          --                          and MIG_BATCH_ID=p_migrBatchId
          --                          AND mfPNS in (19,20)
          ),
          extra_flds AS (SELECT g_egn,
                                penr,
                                penrs,
                                origin
                                -- LM - 20170309 - use the source PENR and PENRS - start
                                ,
                                PENR_SRC,
                                PENRS_SRC
                                -- LM - 20170309 - end
                                ,
                                DECODE(LENGTH(UD.PENR), 10, (CASE WHEN CAST(SUBSTR(UD.PENR, 3, 2) AS NUMBER(2, 0)) > 12 THEN 1 ELSE 0 END), 10) AS IA_Company,
                                DECODE(LENGTH(UD.PENR), 10, (CASE WHEN UD.PENRS IN ('18', '19', '20') THEN 1 ELSE 0 END), 10) AS Century_OK,
                                DECODE(LENGTH(PENR), 10, (CASE WHEN CAST(PENRS || SUBSTR(PENR, 1, 2) AS NUMBER(4, 0)) >= (SELECT EXTRACT(YEAR FROM SYSDATE)
                                        FROM DUAL) THEN 0 ELSE 1 END), 10) AS Year_OK,
                                DECODE(LENGTH(UD.PENR), 10, (CASE WHEN CAST(SUBSTR(UD.PENR, 3, 2) AS NUMBER(2, 0)) BETWEEN 1 AND 12 THEN 1 ELSE 0 END), 10) AS Month_OK,
                                DECODE(LENGTH(UD.PENR), 10, (CASE WHEN CAST(SUBSTR(UD.PENR, 5, 2) AS NUMBER(2, 0)) BETWEEN 1 AND 31 THEN 1 ELSE 0 END), 10) AS Day_ok,
                                DECODE(LENGTH(UD.PENR), 10,
                                (CASE WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND
                                    (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND
                                    (UD.PENRS IN ('19', '20')) THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2) THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END) WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 32 AND 59) AND
                                    (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND
                                    (UD.PENRS IN ('19', '20')) THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (TO_NUMBER(SUBSTR(UD.PENR, 5, 2)) - 30) THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 30), 'YYYY-MM-DD') ELSE NULL END) WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 92 AND 99) AND
                                    (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND
                                    (UD.PENRS IN ('19', '20')) THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 90) THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 90), 'YYYY-MM-DD') ELSE NULL END) WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 61 AND 91) AND
                                    (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND
                                    (UD.PENRS IN ('19', '20')) THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 60) THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 60), 'YYYY-MM-DD') ELSE NULL END) WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND
                                    (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND
                                    (UD.PENRS = '18') AND
                                    (SUBSTR(UD.PENR, 1, 2) <> 10) THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2) THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END) WHEN (UD.PENRS = '18') AND
                                    (SUBSTR(UD.PENR, 1, 2) = 10) THEN TO_DATE('1810-01-01', 'YYYY-MM-DD') ELSE NULL END), TO_DATE('9999-12-31', 'YYYY-MM-DD')) AS IA_BIRTH_DATE,
                                DECODE(LENGTH(UD.PENR), 10, (CASE WHEN CAST(SUBSTR(UD.PENR, 3, 2) AS NUMBER(2, 0)) > 12 THEN 10 ELSE (CASE WHEN SUBSTR(UD.penr, 9, 1) IN ('0', '2', '4', '6', '8') THEN 2 ELSE 1 END)
                                -- ELSE  (CASE mod(SUBSTR(cte.penr,9,1),2)  when 0 THEN 2 ELSE 1 END)
                                END), 10) AS IA_SEX,
                                FLOOR(MONTHS_BETWEEN(SYSDATE, (DECODE(LENGTH(UD.PENR), 10,
                                (CASE WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND
                                    (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND
                                    (UD.PENRS IN ('19', '20')) THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2) THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END) WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 32 AND 59) AND
                                    (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND
                                    (UD.PENRS IN ('19', '20')) THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (TO_NUMBER(SUBSTR(UD.PENR, 5, 2)) - 30) THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 30), 'YYYY-MM-DD') ELSE NULL END) WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 92 AND 99) AND
                                    (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND
                                    (UD.PENRS IN ('19', '20')) THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 90) THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 90), 'YYYY-MM-DD') ELSE NULL END) WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 61 AND 91) AND
                                    (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND
                                    (UD.PENRS IN ('19', '20')) THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= (SUBSTR(UD.PENR, 5, 2) - 60) THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || (SUBSTR(UD.PENR, 5, 2) - 60), 'YYYY-MM-DD') ELSE NULL END) WHEN (SUBSTR(UD.PENR, 5, 2) BETWEEN 1 AND 31) AND
                                    (SUBSTR(UD.PENR, 3, 2) BETWEEN 1 AND 12) AND
                                    (UD.PENRS = '18') AND
                                    (SUBSTR(UD.PENR, 1, 2) <> 10) THEN (CASE WHEN EXTRACT(DAY FROM (LAST_DAY(TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || '01', 'YYYY-MM-DD')))) >= SUBSTR(UD.PENR, 5, 2) THEN TO_DATE(UD.PENRS || SUBSTR(UD.PENR, 1, 2) || '-' || SUBSTR(UD.PENR, 3, 2) || '-' || SUBSTR(UD.PENR, 5, 2), 'YYYY-MM-DD') ELSE NULL END) WHEN (UD.PENRS = '18') AND
                                    (SUBSTR(UD.PENR, 1, 2) = 10) THEN TO_DATE('1810-01-01', 'YYYY-MM-DD') ELSE NULL END), TO_DATE('9999-12-31', 'YYYY-MM-DD')))) / 12) AS ia_age,
                                0 AS MIG_FLAG,
                                MM.MIGRATION_BATCH_ID AS MIG_BATCH_ID,
                                SYSTIMESTAMP AS MIG_TIMESTAMP
              FROM union_data ud,
                   (SELECT MIGRATION_BATCH_ID
                       FROM MIG_MIGRATION_INFO
                       WHERE STATUS = 'Running'
                         AND MIGRATION_BATCH_ID = p_migrBatchId) mm)
        SELECT *
          FROM extra_flds
          PIVOT (MIN(ORIGIN) FOR ORIGIN IN ('KF100F' AS KF100F, 'KF170F' AS KF170F, 'KF221F' AS KF221F, 'KF152F' AS KF152F/*,'KF110F' as KF110F*/))) S
      ON (t.G_EGN = s.G_EGN)
      WHEN MATCHED THEN UPDATE
        SET t.kf100f = NVL(s.kf100f, t.kf100f), t.kf170f = NVL(s.kf170f, t.kf170f), t.kf221f = NVL(s.kf221f, t.kf221f), t.kf152f = NVL(s.kf152f, t.kf152f)
      WHEN NOT MATCHED THEN INSERT (
        t.G_EGN, t.PENR, t.PENRS,/* t.IA_FNAME, t.IA_FULL_NAME, t.IA_GNAME, t.IA_SNAME,*/ t.IA_COMPANY, t.CENTURY_OK, t.YEAR_OK, t.MONTH_OK, t.DAY_OK, t.IA_BIRTH_DATE, t.IA_AGE, t.IA_SEX, t.kf100f, t.kf170f, t.kf221f, t.kf152f,/*,t.kf110f*/ t.MIG_FLAG, t.MIG_BATCH_ID, t.MIG_TIMESTAMP
      )
      -- LM - 20170309 - use the source PENR and PENRS - start
      --values (s.G_EGN, s.PENR, s.PENRS,/* s.IA_FNAME, s.IA_FULL_NAME, s.IA_GNAME, s.IA_SNAME, */s.IA_COMPANY, s.CENTURY_OK, s.YEAR_OK, s.MONTH_OK, s.DAY_OK, s.IA_BIRTH_DATE, s.IA_AGE, s.IA_SEX, s.kf100f,s.kf170f, s.kf221f,s.kf152f,/*s.kf110f*/ s.MIG_FLAG,s.MIG_BATCH_ID, s.MIG_TIMESTAMP );
      VALUES (s.G_EGN, s.PENR_SRC, s.PENRS_SRC,/* s.IA_FNAME, s.IA_FULL_NAME, s.IA_GNAME, s.IA_SNAME, */ s.IA_COMPANY, s.CENTURY_OK, s.YEAR_OK, s.MONTH_OK, s.DAY_OK, s.IA_BIRTH_DATE, s.IA_AGE, s.IA_SEX, s.kf100f, s.kf170f, s.kf221f, s.kf152f,/*s.kf110f*/ s.MIG_FLAG, s.MIG_BATCH_ID, s.MIG_TIMESTAMP);
      -- LM - 20170309 - end
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || ' sql:' || vsql;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END fill_SA_B_PRSN;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE fill_SA_B_ADDRESS(p_migrBatchId IN VARCHAR2)
    AS
      l_LogRec MIGR_GVAR.LogRecTyp;
      vsql     VARCHAR2(2500);
      v_fields VARCHAR2(1000);

    BEGIN

      l_LogRec.migrStep := 'Second Phase of Staging area';
      l_LogRec.logMsg := '';
      l_LogRec.mig_batch_id := p_migrBatchId;
      l_LogRec.migrArea := 'MIGR_LA_SA.FILL_SA_B_ADDRESS';

      v_fields := MIGR_SETUP.fetch_attr('B_ADDRESS', TRUE, TRUE, FALSE, TRUE);

      vsql := 'insert INTO SA_B_address '
      || ' with cte AS (SELECT idpl,FSTBS,FSTNR,FSTL,MIG_FLAG,MIG_BATCH_ID,MIG_TIMESTAMP '
      || '       FROM SA_KF109F '
      || '          where MIG_BATCH_ID= :BatchId) '
      || '  , transposed as ( '
      || '                        SELECT * FROM cte '
      || '                PIVOT( MIN(FSTL) FOR FSTBS IN(''F'' as FSTBS_F,''P'' as FSTBS_P,''G'' as FSTBS_G,''Q'' AS FSTBS_Q))) '
      || ' sELECT ' || v_fields || ' FROM transposed';
      EXECUTE IMMEDIATE vsql
      USING p_migrBatchId;


    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || ' sql:' || vsql;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END fill_SA_B_ADDRESS;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  ------------------------ STAGING AREA ROW COUNT ---------------------------------------------
  PROCEDURE LOG_MIG_ANAL_ROW_COUNT_SA(p_LogRec MIGR_GVAR.LogRecTyp)
    AS

      PRAGMA AUTONOMOUS_TRANSACTION;
      vSQL         VARCHAR2(32000);
      l_dest_table ETL_ENGINE.DEST_TABLE % TYPE;
      l_LogRec     MIGR_GVAR.LogRecTyp;
    BEGIN
      l_LogRec := p_LogRec;
      l_LogRec.migrArea := 'MIGR_LA_SA.LOG_MIG_ANAL_ROW_COUNT_SA';
      SELECT ee.DEST_TABLE
        INTO l_dest_table
        FROM ETL_ENGINE ee
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(l_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = l_LogRec.migrRelTbl
          AND ee.MIGRATION_AREA = 'Staging';

      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS
          (MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME)
          SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID,
            SYSTIMESTAMP AS LOG_TIMESTAMP,'
      || CHR(39) || 'Staging' || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_dest_table || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Accepted' || CHR(39) || ' AS STATUS, '
      || 'MVA.CNT AS VOLUME
          FROM (
                SELECT  MIGRATION_BATCH_ID
                FROM MIG_MIGRATION_INFO
                WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || l_LogRec.mig_batch_id || CHR(39) || ' ) MMI,
            (SELECT COUNT(*) AS CNT
              FROM ' || l_dest_table || CHR(10)
      || ' WHERE MIG_MUTUAL_ID = ' || CHR(39) || SUBSTR(l_LogRec.mig_batch_id, 1, 2) || CHR(39) || CHR(10)
      || 'AND MIG_FLAG = 0) MVA'
      ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_MIG_ANAL_ROW_COUNT_SA;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------

  --FA. 20170323 Always set record's migr_step prior to porcedure execution
  FUNCTION INSERT_RECORDS_IN_HISTORY_SA(p_LogRec    MIGR_GVAR.LogRecTyp,
                                        p_Status IN VARCHAR2)
    RETURN BOOLEAN
    AS
      vSQL           VARCHAR2(32000);
      v_srcDumplCond VARCHAR2(4000);
      l_LogRec       MIGR_GVAR.LogRecTyp;
      l_DEST_TABLE   ETL_ENGINE.DEST_TABLE % TYPE;
      l_FIELD_LIST   ETL_ENGINE.FIELD_LIST % TYPE;
      l_ADDFLDS      ETL_ENGINE.ADDFLDS % TYPE;
      l_PK_LIST      ETL_ENGINE.PK_LIST % TYPE;
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      l_srcDupl      NUMBER;
      v_avtdt        VARCHAR2(10);
    BEGIN
      l_LogRec := p_LogRec;
      l_LogRec.migrArea := 'MIGR_LA_SA.INSERT_RECORDS_IN_HISTORY_SA';
      v_srcDumplCond := '';
      -- l_LogRec.logMsg := SQLERRM || l_LogRec.migrRelTbl  ||  ' ' || l_LogRec.migrStep;
      -- MIGR_LOG.LOG_iNfo(l_LogRec);
      SELECT ee.DEST_TABLE,
             ee.FIELD_LIST,
             ee.ADDFLDS,
             ee.PK_LIST,
             ee.SOURCE_TABLE
        INTO l_DEST_TABLE,
             l_FIELD_LIST,
             l_ADDFLDS,
             l_PK_LIST,
             l_SOURCE_TABLE
        FROM ETL_ENGINE ee
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(l_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = l_LogRec.migrRelTbl
          AND ee.MIGRATION_AREA = l_LogRec.migrStep; --'Staging';

      SELECT TO_CHAR(TRUNC(RENEWAL_DATE), 'YYYYMMDD')
        INTO v_avtdt
        FROM (SELECT *
            FROM ETL_MIGRATION_CONDITIONS
            WHERE 1 = 1
              AND ITERATION_STATUS = 'Pending'
            ORDER BY id)
        WHERE ROWNUM = 1;

      ---Check if table contain avtdt column in pk list in order to use it to exclude duplicates
      SELECT COUNT('*')
        INTO l_srcDupl
        FROM ETL_TBL_DEF
        WHERE ',' || (PK3 || ',' || PK4 || ',' || PK5) || ',' LIKE '%,' || 'AVTDT' || ',%'
          AND TBLNAME = l_LogRec.migrRelTbl;
      IF l_srcDupl = 1
      THEN
        v_srcDumplCond := ' AND AVTDT= ' || CHR(39) || v_avtdt || CHR(39);

      END IF;




      ---FA. 20160331 Bulk collect change for performance improvement
      vSQL := 'DECLARE '
      || ' CURSOR KF is '
      || '    SELECT ' || l_FIELD_LIST || l_ADDFLDS    -- ,''  as POLICY_REF,'' as IDPL,'' as IDPLPS,'' as IDPLPSDT,'' as IDPLPSDTP5,'' as MIG_FLAG,systimestamp as MIG_TIMESTAMP,'' AS mig_batch_id
      || ' FROM ' || l_DEST_TABLE || '; '
      || ' TYPE KF_tab IS TABLE OF KF%ROWTYPE; '
      || ' KF_all_records   KF_tab:= KF_tab(); '
      || 'BEGIN '
      || 'SELECT DISTINCT ' || l_FIELD_LIST || l_PK_LIST || ', 0 AS MIG_FLAG, MMI.MIGRATION_BATCH_ID AS MIG_BATCH_ID,'
      || 'SYSTIMESTAMP AS MIG_TIMESTAMP, ' || CHR(39) || SUBSTR(l_LogRec.mig_batch_id, 1, 2) || CHR(39) || ' AS MIG_MUTUAL_ID '
      || ' BULK COLLECT INTO KF_all_records '
      || 'FROM '
      || '(SELECT *'
      || ' FROM ' || l_SOURCE_TABLE
      || ' WHERE MIG_FLAG = 0'
      || v_srcDumplCond
      || '  ) TL, '
      || '(SELECT MIGRATION_BATCH_ID '
      || ' FROM MIG_MIGRATION_INFO '
      || ' WHERE STATUS = ' || CHR(39) || p_Status || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || l_LogRec.mig_batch_id || CHR(39) || ') MMI;'

      || '  FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT '
      || '    INSERT INTO ' || l_DEST_TABLE || ' VALUES KF_all_records(i); '
      || 'END; ';

      EXECUTE IMMEDIATE vSQL;

      COMMIT;

      RETURN TRUE;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || ' ' || l_SOURCE_TABLE || ' ' || l_DEST_TABLE;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          RETURN FALSE;

    END INSERT_RECORDS_IN_HISTORY_SA;

  --------------------------------------------------------------------
  --------------------------------------------------------------------

  FUNCTION landing_extra_where(p_LogRec MIGR_GVAR.LogRecTyp)
    RETURN VARCHAR2
    IS
      v_date        VARCHAR2(20);
      v_extra_where VARCHAR2(2100);
      l_LogRec      MIGR_GVAR.LogRecTyp;
    BEGIN
      l_LogRec := p_LogRec;
      v_extra_where := NULL;
      FOR c IN (SELECT ee.EXTRA_WHERE1,
                       ee.EXTRA_WHERE2,
                       TO_CHAR(rd.RENEWAL_DATE, 'DD/MM/YYYY') AS renewal_dt
          FROM ETL_ENGINE ee,
               (WITH x AS (SELECT renewal_date
                       FROM ETL_MIGRATION_CONDITIONS
                       WHERE 1 = 1
                         AND ITERATION_STATUS = 'Pending'
                       ORDER BY id)
                 SELECT RENEWAL_DATE
                   FROM x
                   WHERE ROWNUM = 1) rd
          WHERE 1 = 1
            AND ee.BOLAG_ID = SUBSTR(l_LogRec.mig_batch_id, 1, 2)
            AND ee.TBLNAME = l_LogRec.migrRelTbl
            AND ee.MIGRATION_AREA = 'Landing')
      LOOP

        v_extra_where := c.EXTRA_WHERE1;

      END LOOP;

      RETURN v_extra_where;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
    END landing_extra_where;
  --------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------
  FUNCTION INSERT_RECORDS_IN_HISTORY(p_LogRec     MIGR_GVAR.LogRecTyp,
                                     p_Status  IN VARCHAR2,
                                     p_renewal IN DATE)
    RETURN BOOLEAN
    AS
      vSQL     VARCHAR2(32000);
      l_LogRec MIGR_GVAR.LogRecTyp;
    ---     v_date DATE:=p_renewal;

    BEGIN
      l_LogRec := p_LogRec;

      l_LogRec.migrArea := 'MIGR_LA_SA.INSERT_RECORDS_IN_HISTORY';

      l_LogRec.logMsg := 'Inserting Data in Landing area for batch: ' || l_LogRec.mig_batch_id || ' and Renewal Date: ' || TO_CHAR(p_renewal, 'yyyy-mm-dd');
      MIGR_LOG.LOG_INFO(l_LogRec);

      FOR cRec IN (SELECT ee.DEST_TABLE,
                          ee.FIELD_LIST,
                          ee.ADDFLDS,
                          ee.PK_LIST,
                          ee.SOURCE_TABLE,
                          ee.JOIN_CONDITION,
                          ee.NOMATCH1,
                          ee.BOLAG_NAME,
                          ee.TBLNAME,
                          ee.iot_fields,
                          ee.PK_LIST_with_tbl_identifier,
                          ee.IOT_TABLE,
                          ee.IOT_JOIN_CONDITION,
                          ee.IOT_MATCH,
                          ee.IOT_NULL_FIELDS,
                          ee.EXIST_IN_LA_TBL,
                          ee.FIELD_LIST1,
                          etd.FILE_ROLE,
                          ee.MASTER_LOAD_TBL,
                          ee.master_load_join_condition
          --   ee.ADDFLDS1
          -- (CASE WHEN etd.file_role<>'Reconciliation' THEN 'LA_'||BOLAG_NAME||'_KF100F_IOT' ELSE '(select ''1'' as KF_TABLE from dual)' end)AS kf_IOT,
          --(CASE WHEN  etd.tblname='KF100F' THEN 1 ELSE 0 END ) AS seq
          FROM ETL_ENGINE ee,
               MIG_MIGRATION_INFO mmi,
               etl_tbl_def etd
          WHERE 1 = 1
            AND ee.BOLAG_ID = mmi.BOLAG_ID
            AND mmi.STATUS = p_Status --'Running'
            AND mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id
            AND ee.MIGRATION_AREA = l_LogRec.migrStep --'Landing'
            AND ee.tblname = etd.TBLNAME
            AND ee.TBLNAME = l_LogRec.migrRelTbl)
      --valex.3/11/2016 - end
      LOOP


        vSQL := 'INSERT /*+ append */ INTO ' || cRec.DEST_TABLE || '(' || cRec.FIELD_LIST || cRec.ADDFLDS || ') '
        || 'SELECT DISTINCT ' || cRec.FIELD_LIST || cRec.PK_LIST || ', 0 AS MIG_FLAG,''' || l_LogRec.mig_batch_id || ''' AS MIG_BATCH_ID,'
        || 'SYSTIMESTAMP AS MIG_TIMESTAMP '
        || ' FROM '
        || '(SELECT TL.*'
        || ' FROM ' || cRec.SOURCE_TABLE || ' TL'
        || ' LEFT OUTER JOIN  ' || CREC.exist_in_la_tbl || ' TH ' || cRec.JOIN_CONDITION
        || '   LEFT JOIN ' || cRec.IOT_TABLE || ' TI ' || cRec.IOT_JOIN_CONDITION
        -- || '     JOIN ' || crec.MASTER_LOAD_tbl || ' ML ' || cRec.MASTER_LOAD_JOIN_CONDITION
        --FA.20170907 All KF files will be archived at phase 1 completion so _LOAD will be either empty or have next;s exctraction 's data. No check for MD_DISCOUNTS
        || CASE WHEN CREC.tblname <> 'BR161F' AND
              CREC.tblname <> 'MD_DISCOUNTS' THEN ' JOIN ' || crec.MASTER_LOAD_tbl || ' ML ' || cRec.MASTER_LOAD_JOIN_CONDITION ELSE NULL END
        ---20171117      || case when CREC.FILE_ROLE <> 'Reconciliation' and CREC.tblname<>'BR161F'    AND CREC.tblname<>'MD_DISCOUNTS'  THEN ' = ' ||'to_date('''||p_renewal||''',''yyyy-mm-dd'')' else null END
        || CASE WHEN CREC.FILE_ROLE <> 'Reconciliation' AND
              CREC.tblname <> 'BR161F' AND
              CREC.tblname <> 'MD_DISCOUNTS' THEN ' = :1 ' ELSE NULL END

        || '  WHERE (' || cRec.NOMATCH1 || ')and (' || CREC.IOT_MATCH || ') '
        || CASE WHEN CREC.FILE_ROLE = 'Discounts' THEN ' and TL.policy_id is not null ' ELSE NULL END
        || ' )';


        ---FA.20171117 Fix bug caused by the  to_date an already date parameter. Oracle implicitly converted the date to varchar and this depends on session parameters
        IF CREC.FILE_ROLE <> 'Reconciliation'
          AND CREC.tblname <> 'BR161F'
          AND CREC.tblname <> 'MD_DISCOUNTS'
        THEN
          EXECUTE IMMEDIATE vSQL
          USING p_renewal;
        ELSE
          EXECUTE IMMEDIATE vSQL;

        END IF;

        COMMIT;


        IF CREC.FILE_ROLE <> 'Reconciliation'
        THEN
          vSQL := 'INSERT /*+ append */ INTO ' || cRec.DEST_TABLE || '_IOT(' || cRec.IOT_FIELDS || ')'
          || 'SELECT DISTINCT ' || cRec.IOT_FIELDS
          || ' FROM ' || cRec.DEST_TABLE
          || ' where mig_batch_id=''' || l_LogRec.mig_batch_id || '''';

          EXECUTE IMMEDIATE vSQL;
          COMMIT;

        END IF;
      --valex.3/11/2016 - end

      END LOOP;
      RETURN TRUE;
    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          RETURN FALSE;
    END INSERT_RECORDS_IN_HISTORY;
  --------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_NON_MATCH(p_LogRec    MIGR_GVAR.LogRecTyp,
                                       p_Status IN VARCHAR2)
    AS
      vSQL         VARCHAR2(32000);

      l_DEST_TABLE ETL_ENGINE.DEST_TABLE % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      SELECT ee.DEST_TABLE
        INTO l_DEST_TABLE
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF etd
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND etd.TBLNAME = p_LogRec.migrRelTbl
          AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = p_LogRec.migrStep --'Landing'
          AND NOT (ee.TBLNAME LIKE 'NP%')  --valex.20/4/16 exclude NP427F from process
      ;

      --Log MIG_VOLUMETRIC_ANALYSIS - No matching Records (Accepted)
      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS '
      || '(MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME) '
      || ' SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID, '
      || ' SYSTIMESTAMP AS LOG_TIMESTAMP, '
      || CHR(39) || p_LogRec.migrStep || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_DEST_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Accepted' || CHR(39) || ' AS STATUS, '
      || ' MVA.CNT AS VOLUME '
      || ' FROM '
      || '     (SELECT MIGRATION_BATCH_ID '
      || '  FROM MIG_MIGRATION_INFO '
      || '  WHERE STATUS = ' || CHR(39) || p_Status || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || p_LogRec.mig_batch_id || CHR(39) || ') MMI, '
      || ' (SELECT COUNT(*) AS CNT '
      || '  FROM ' || l_DEST_TABLE || ' THIST'
      || '  WHERE MIG_FLAG = 0) MVA';

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;

    END LOG_MIG_VOL_ANAL_NON_MATCH;
  ----------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_VOL_ANAL_NON_MATCH_LA(p_LogRec MIGR_GVAR.LogRecTyp)
    AS
      vSQL         VARCHAR2(32000);


      l_DEST_TABLE ETL_ENGINE.DEST_TABLE % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      SELECT ee.DEST_TABLE
        INTO l_DEST_TABLE
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF etd
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND etd.TBLNAME = p_LogRec.migrRelTbl
          AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = 'Landing'
          AND NOT (ee.TBLNAME LIKE 'NP%')  --valex.20/4/16 exclude NP427F from process
      ;


      --Log MIG_VOLUMETRIC_ANALYSIS - No matching Records (Accepted)
      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS '
      || '(MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME) '
      || ' SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID, '
      || ' SYSTIMESTAMP AS LOG_TIMESTAMP, '
      || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_DEST_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Accepted' || CHR(39) || ' AS STATUS, '
      || ' MVA.CNT AS VOLUME '
      || ' FROM '
      || '     (SELECT MIGRATION_BATCH_ID '
      || '  FROM MIG_MIGRATION_INFO '
      || '  WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || p_LogRec.mig_batch_id || CHR(39) || ') MMI, '
      || ' (SELECT COUNT(*) AS CNT '
      || '  FROM ' || l_DEST_TABLE || ' THIST'
      || '  WHERE MIG_FLAG = 0) MVA';

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;

    END LOG_MIG_VOL_ANAL_NON_MATCH_LA;
  ----------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_VOL_ANAL_MATCHING(p_LogRec    MIGR_GVAR.LogRecTyp,
                                      p_Status IN VARCHAR2)
    AS
      vSQL           VARCHAR2(32000);

      l_DEST_TABLE   ETL_ENGINE.DEST_TABLE % TYPE;
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      l_PK1          ETL_TBL_DEF.PK1 % TYPE;
      l_PK2          ETL_TBL_DEF.PK2 % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      SELECT ee.DEST_TABLE,
             ee.SOURCE_TABLE,
             td.PK1,
             td.PK2
        INTO l_DEST_TABLE,
             l_SOURCE_TABLE,
             l_PK1,
             l_PK2
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF td
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND td.TBLNAME = p_LogRec.migrRelTbl
          AND NVL(td.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = p_LogRec.migrStep --'Landing'
          AND NOT (ee.TBLNAME LIKE 'NP%')  --valex.20/4/16 exclude NP427F from process
      ;

      --Log MIG_VOLUMETRIC_ANALYSIS - Matching Records
      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS '
      || '(MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME) '
      || ' SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID, '
      || ' SYSTIMESTAMP AS LOG_TIMESTAMP, '
      || CHR(39) || p_LogRec.migrStep || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_DEST_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Rejected' || CHR(39) || ' AS STATUS, '
      || ' MVA.CNT AS VOLUME '
      || '   FROM '
      || '  (SELECT MIGRATION_BATCH_ID '
      || '   FROM MIG_MIGRATION_INFO '
      || '   WHERE STATUS = ' || CHR(39) || p_Status || CHR(39) || ' AND MIGRATION_BATCH_ID = ' || CHR(39) || p_LogRec.mig_batch_id || CHR(39) || ') MMI, '
      || '  (SELECT COUNT(*) AS CNT '
      || '   FROM ' || l_SOURCE_TABLE || ' TLOAD'
      || '        INNER JOIN ' || l_DEST_TABLE || ' THIST'
      || '           ON TLOAD.' || l_PK1 || ' = THIST.' || l_PK1
      || '          AND TLOAD.' || l_PK2 || ' = THIST.' || l_PK2 || ') MVA'
      ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_MIG_VOL_ANAL_MATCHING;
  -----------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_VOL_ANAL_MATCHING_LA(p_LogRec MIGR_GVAR.LogRecTyp)
    AS
      vSQL           VARCHAR2(32000);

      l_DEST_TABLE   ETL_ENGINE.DEST_TABLE % TYPE;
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      l_PK1          ETL_TBL_DEF.PK1 % TYPE;
      l_PK2          ETL_TBL_DEF.PK2 % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      SELECT ee.DEST_TABLE,
             ee.SOURCE_TABLE,
             td.PK1,
             td.PK2
        INTO l_DEST_TABLE,
             l_SOURCE_TABLE,
             l_PK1,
             l_PK2
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF td
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND td.TBLNAME = p_LogRec.migrRelTbl
          AND NVL(td.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = 'Landing'
          AND NOT (ee.TBLNAME LIKE 'NP%')  --valex.20/4/16 exclude NP427F from process
      ;


      --Log MIG_VOLUMETRIC_ANALYSIS - Matching Records
      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS '
      || '(MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME) '
      || ' SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID, '
      || ' SYSTIMESTAMP AS LOG_TIMESTAMP, '
      || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_DEST_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Rejected' || CHR(39) || ' AS STATUS, '
      || ' MVA.CNT AS VOLUME '
      || '   FROM '
      || '  (SELECT MIGRATION_BATCH_ID '
      || '   FROM MIG_MIGRATION_INFO '
      || '   WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID=' || CHR(39) || p_LogRec.mig_batch_id || CHR(39) || ') MMI, '
      || '  (SELECT COUNT(*) AS CNT '
      || '   FROM ' || l_SOURCE_TABLE || ' TLOAD'
      || '        INNER JOIN ' || l_DEST_TABLE || ' THIST'
      || '            ON TLOAD.' || l_PK1 || ' = THIST.' || l_PK1
      || '            AND TLOAD.' || l_PK2 || ' = THIST.' || l_PK2 || ') MVA'
      ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_MIG_VOL_ANAL_MATCHING_LA;

  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_MATCHING_RECORDS(p_LogRec    MIGR_GVAR.LogRecTyp,
                                     p_Status IN VARCHAR2)
    AS
      vSQL VARCHAR2(32000);

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      FOR c IN (SELECT ee.SOURCE_TABLE,
                       etd.PK1,
                       etd.PK2,
                       ee.DEST_TABLE,
                       ee.EXIST_IN_LA_TBL,
                       ee.JOIN_CONDITION
          FROM ETL_ENGINE ee,
               ETL_TBL_DEF etd
          WHERE 1 = 1
            AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
            AND ee.TBLNAME = p_LogRec.migrRelTbl
            AND etd.TBLNAME = p_LogRec.migrRelTbl
            AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
            AND ee.MIGRATION_AREA = 'Landing'
            AND NOT (ee.TBLNAME LIKE 'NP%')  --valex.20/4/16 exclude NP427F from process
      )
      LOOP

        --Log matching records (already loaded) to MIG_DETAIL_ERROR_LOG
        vSQL := 'INSERT INTO MIG_DETAIL_ERROR_LOG '
        || '(MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY) '
        || ' SELECT ''' || p_LogRec.mig_batch_id || ''', '
        || ' SYSTIMESTAMP AS ERROR_TIMESTAMP, '
        || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
        || CHR(39) || 'Critical Error' || CHR(39) || ' AS ERROR_TYPE, '
        || CHR(39) || 'Record has already been migrated' || CHR(39) || ' AS ERROR_MESSAGE, '
        || CHR(39) || 'Transfering from _LOAD to historical tables' || CHR(39) || ' AS MIGRATION_STEP, '
        || CHR(39) || c.SOURCE_TABLE || CHR(39) || ' AS RELATED_TABLE, '
        || CHR(39) || c.PK1 || ':' || CHR(39) || '|| TMATCH.' || c.PK1 || ' || '' '' ||'
        || CHR(39) || c.PK2 || ':' || CHR(39) || ' || TMATCH.' || c.PK2 || ' AS RELATED_KEY '
        || 'FROM (SELECT TH.' || c.PK1 || ' , ' || 'TH.' || c.PK2
        || '      FROM ' || c.SOURCE_TABLE || ' TL'
        || '        JOIN  ' || C.exist_in_la_tbl || ' TH ' || c.JOIN_CONDITION || ') TMATCH '

        ;

        EXECUTE IMMEDIATE vSQL;

      END LOOP;



    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_MIG_MATCHING_RECORDS;

  -----------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------
  PROCEDURE LOG_MIG_MATCHING_RECORDS(p_LogRec MIGR_GVAR.LogRecTyp)
    AS
      vSQL           VARCHAR2(32000);
      l_DEST_TABLE   ETL_ENGINE.DEST_TABLE % TYPE;
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      l_PK1          ETL_TBL_DEF.PK1 % TYPE;
      l_PK2          ETL_TBL_DEF.PK2 % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      SELECT ee.SOURCE_TABLE,
             etd.PK1,
             etd.PK2,
             ee.DEST_TABLE
        INTO l_SOURCE_TABLE,
             l_PK1,
             l_PK2,
             l_DEST_TABLE
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF etd
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND etd.TBLNAME = p_LogRec.migrRelTbl
          AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = 'Landing'
          AND NOT (ee.TBLNAME LIKE 'NP%')  --valex.20/4/16 exclude NP427F from process
      ;
      --Log matching records (already loaded) to MIG_DETAIL_ERROR_LOG
      vSQL := 'INSERT INTO MIG_DETAIL_ERROR_LOG '
      || '(MIGRATION_BATCH_ID, ERROR_TIMESTAMP, MIGRATION_AREA, ERROR_TYPE, ERROR_MESSAGE, MIGRATION_STEP, RELATED_TABLE, RELATED_KEY) '
      || ' SELECT MMI.MIGRATION_BATCH_ID, '
      || ' SYSTIMESTAMP AS ERROR_TIMESTAMP, '
      || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || 'Critical Error' || CHR(39) || ' AS ERROR_TYPE, '
      || CHR(39) || 'Record has already been migrated' || CHR(39) || ' AS ERROR_MESSAGE, '
      || CHR(39) || 'Transfering from _LOAD to historical tables' || CHR(39) || ' AS MIGRATION_STEP, '
      || CHR(39) || l_SOURCE_TABLE || CHR(39) || ' AS RELATED_TABLE, '
      || CHR(39) || l_PK1 || ':' || CHR(39) || '|| TMATCH.' || l_PK1 || ' || '
      || CHR(39) || l_PK2 || ':' || CHR(39) || ' || TMATCH.' || l_PK2 || ' AS RELATED_KEY '
      || 'FROM (SELECT THIST.' || l_PK1 || ' , ' || 'THIST.' || l_PK2
      || ' FROM ' || l_SOURCE_TABLE || ' TLOAD'
      || ' INNER JOIN ' || l_DEST_TABLE || ' THIST'
      || '  ON TLOAD.' || l_PK1 || ' = THIST.' || l_PK1
      || '  AND TLOAD.' || l_PK2 || ' = THIST.' || l_PK2 || ') TMATCH, '
      || '(SELECT MIGRATION_BATCH_ID '
      || ' FROM MIG_MIGRATION_INFO '
      || ' WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID =' || CHR(39) || p_LogRec.mig_batch_id || CHR(39) || ') MMI'
      ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END LOG_MIG_MATCHING_RECORDS;

  ---------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_ROW_COUNT(p_LogRec    MIGR_GVAR.LogRecTyp,
                                       p_Status IN VARCHAR2)
    AS
      vSQL           VARCHAR2(32000);
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;

    BEGIN

      SELECT ee.SOURCE_TABLE
        INTO l_SOURCE_TABLE
        FROM ETL_ENGINE ee
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND ee.MIGRATION_AREA = p_LogRec.migrStep; --'Landing';

      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS'
      || ' (MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME)
               SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS LOG_TIMESTAMP,'
      --           || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || p_LogRec.migrStep || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_SOURCE_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Accepted' || CHR(39) || ' AS STATUS, '
      || 'MVA.CNT AS VOLUME
               FROM (SELECT MIGRATION_BATCH_ID
                       FROM MIG_MIGRATION_INFO
                      WHERE STATUS = ' || CHR(39) || p_Status || CHR(39) || ' AND MIGRATION_BATCH_ID =' || CHR(39) || p_LogRec.mig_batch_id || CHR(39)
      || ' ) MMI,
              (SELECT COUNT(*) AS CNT
              FROM ' || l_SOURCE_TABLE
      || ') MVA'
      ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;

    END LOG_MIG_VOL_ANAL_ROW_COUNT;

  ---------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------

  PROCEDURE LOG_MIG_VOL_ANAL_ROW_COUNT_LA(p_LogRec MIGR_GVAR.LogRecTyp)
    AS
      vSQL           VARCHAR2(32000);
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      PRAGMA AUTONOMOUS_TRANSACTION;

    BEGIN

      SELECT ee.SOURCE_TABLE
        INTO l_SOURCE_TABLE
        FROM ETL_ENGINE ee
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(p_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = p_LogRec.migrRelTbl
          AND ee.MIGRATION_AREA = 'Landing';

      vSQL := 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS
          (MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME)
          SELECT MMI.MIGRATION_BATCH_ID AS MIGRATION_BATCH_ID,
            SYSTIMESTAMP AS LOG_TIMESTAMP,'
      || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
      || CHR(39) || l_SOURCE_TABLE || CHR(39) || ' AS STEP_MESSAGE, '
      || CHR(39) || 'Accepted' || CHR(39) || ' AS STATUS, '
      || 'MVA.CNT AS VOLUME
          FROM (
                SELECT MIGRATION_BATCH_ID
                FROM MIG_MIGRATION_INFO
                WHERE STATUS = ' || CHR(39) || 'Running' || CHR(39) || ' AND MIGRATION_BATCH_ID =' || CHR(39) || p_LogRec.mig_batch_id || CHR(39)
      || ' ) MMI,
            (SELECT COUNT(*) AS CNT
              FROM ' || l_SOURCE_TABLE
      || ') MVA'
      ;

      EXECUTE IMMEDIATE vSQL;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;

    END LOG_MIG_VOL_ANAL_ROW_COUNT_LA;

  ---------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------

  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(p_LogRec    MIGR_GVAR.LogRecTyp,
                                           p_Status IN VARCHAR2)
    IS
      PRAGMA AUTONOMOUS_TRANSACTION;

    BEGIN

      INSERT INTO MIG_MIGRATION_STEPS (
        MIGRATION_BATCH_ID, STEP_TIMESTAMP, STEP_AREA, STEP_MESSAGE, TABLENAME
      )
        SELECT MMI.MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS STEP_TIMESTAMP,
               p_LogRec.migrStep AS STEP_AREA,
               p_LogRec.logMsg AS STEP_MESSAGE,
               p_LogRec.migrRelTbl AS TABLENAME
          FROM MIG_MIGRATION_INFO MMI
          WHERE STATUS = p_Status --'Running'
            AND MMI.MIGRATION_BATCH_ID = p_LogRec.mig_batch_id;

      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;

    END UPDATE_LOG_MIG_MIGRATION_STEPS;

  ---------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------

  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(p_LogRec MIGR_GVAR.LogRecTyp)
    IS

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      INSERT INTO MIG_MIGRATION_STEPS (
        MIGRATION_BATCH_ID, STEP_TIMESTAMP, STEP_AREA, STEP_MESSAGE, TABLENAME
      )
        SELECT MMI.MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS STEP_TIMESTAMP,
               p_LogRec.migrStep AS STEP_AREA,
               p_LogRec.logMsg AS STEP_MESSAGE,
               p_LogRec.migrRelTbl AS TABLENAME
          FROM MIG_MIGRATION_INFO MMI
          WHERE STATUS = 'Running'
            AND MMI.MIGRATION_BATCH_ID = p_LogRec.mig_batch_id;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;

    END UPDATE_LOG_MIG_MIGRATION_STEPS;
  ---------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------
  PROCEDURE TRUNCATE_ALL
    AS
      vSQL     VARCHAR2(1000);
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN

      vSQL := '';

      MIGR_SETUP.TBL_OPERATION_LA('TRUNCATE');          --Truncate Landing Tables

      MIGR_SETUP.TBL_OPERATION_SA('TRUNCATE');          --Truncate Staging Tables


    --Truncate Intermediate Tables    -- runs from MIGR_IA.RUN_IA_SETUP()

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-1';
          l_LogRec.migrArea := 'MIGR_LA_SA.TRUNCATE_ALL';
          l_LogRec.migrStep := ' TRUNCATE_ALL';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLCODE || '-' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);


    END TRUNCATE_ALL;
  -----------------------------------------------------------------------------------------


  ------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LA_MIG_FLAG(p_LogRec MIGR_GVAR.LogRecTyp)
    AS
      vSQL           VARCHAR2(32000);

      l_LogRec       MIGR_GVAR.LogRecTyp;
      l_DEST_TABLE   ETL_ENGINE.DEST_TABLE % TYPE;
      l_SOURCE_TABLE ETL_ENGINE.SOURCE_TABLE % TYPE;
      l_PK1          ETL_TBL_DEF.PK1 % TYPE;
      l_PK2          ETL_TBL_DEF.PK2 % TYPE;
      l_PK3          ETL_TBL_DEF.PK2 % TYPE;
      l_PK4          ETL_TBL_DEF.PK2 % TYPE;
      l_PK5          ETL_TBL_DEF.PK2 % TYPE;
    BEGIN
      l_LogRec := p_LogRec;
      l_LogRec.migrArea := 'MIGR_LA_SA.UPDATE_LA_MIG_FLAG';
      SELECT ee.SOURCE_TABLE,
             etd.PK1,
             etd.PK2,
             ee.DEST_TABLE,
             etd.PK3,
             etd.PK4,
             etd.PK5
        INTO l_SOURCE_TABLE,
             l_PK1,
             l_PK2,
             l_DEST_TABLE,
             l_PK3,
             l_PK4,
             l_PK5
        FROM ETL_ENGINE ee,
             ETL_TBL_DEF etd
        WHERE 1 = 1
          AND ee.BOLAG_ID = SUBSTR(l_LogRec.mig_batch_id, 1, 2)
          AND ee.TBLNAME = l_LogRec.migrRelTbl
          AND ee.TBLNAME = etd.TBLNAME
          AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
          AND ee.MIGRATION_AREA = 'Staging';

      IF NOT l_PK1 IS NULL
        AND NOT l_PK2 IS NULL
      THEN
        vSQL := 'UPDATE ' || l_SOURCE_TABLE
        || ' SET MIG_FLAG = 1
          WHERE EXISTS
         (SELECT ' || l_PK1 || ', ' || l_PK2 || CHR(10)
        || ' FROM ' || l_DEST_TABLE || CHR(10)
        || ' WHERE MIG_MUTUAL_ID = ' || CHR(39) || SUBSTR(l_LogRec.mig_batch_id, 1, 2) || CHR(39) || CHR(10)
        || (CASE WHEN l_PK1 IS NOT NULL THEN ' AND ' || l_SOURCE_TABLE || '.' || l_PK1 || ' = ' || l_DEST_TABLE || '.' || l_PK1 || CHR(10) ELSE NULL END)
        || (CASE WHEN l_PK2 IS NOT NULL THEN ' AND ' || l_SOURCE_TABLE || '.' || l_PK2 || ' = ' || l_DEST_TABLE || '.' || l_PK2 || CHR(10) ELSE NULL END)
        || (CASE WHEN l_PK3 IS NOT NULL THEN ' AND ' || l_SOURCE_TABLE || '.' || l_PK3 || ' = ' || l_DEST_TABLE || '.' || l_PK3 || CHR(10) ELSE NULL END)
        || (CASE WHEN l_PK4 IS NOT NULL THEN ' AND ' || l_SOURCE_TABLE || '.' || l_PK4 || ' = ' || l_DEST_TABLE || '.' || l_PK4 || CHR(10) ELSE NULL END)
        || (CASE WHEN l_PK5 IS NOT NULL THEN ' AND ' || l_SOURCE_TABLE || '.' || l_PK5 || ' = ' || l_DEST_TABLE || '.' || l_PK5 || CHR(10) ELSE NULL END)
        || ')'
        ;
        l_LogRec.migrRelTbl := vSQL;

        EXECUTE IMMEDIATE vSQL;
        COMMIT;
      END IF;

    EXCEPTION
      WHEN OTHERS THEN
          --        MIGR_SYSTEM.MIGR_LOG_LINE('FALSE', '0-1', 'MIGR_LA_SA.UPDATE_LA_MIG_FLAG', NULL, 'EXCEPTION',  SQLERRM, vSQL, NULL);
          l_LogRec.logMsg := SQLERRM;

          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
    END UPDATE_LA_MIG_FLAG;
  ------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------
  PROCEDURE UPDATE_LOG_MIG_MIGRATION_STEPS(steparea          IN VARCHAR2,
                                           stepmessage       IN VARCHAR2,
                                           vMigrationBatchId IN VARCHAR2,
                                           vtablename        IN VARCHAR2)
    IS
      L_SRVERRMSG SRVERRMSG;
      PIO_ERR     SRVERR;

      PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

      INSERT INTO MIG_MIGRATION_STEPS (
        MIGRATION_BATCH_ID, STEP_TIMESTAMP, STEP_AREA, STEP_MESSAGE, TABLENAME
      )
        SELECT MMI.MIGRATION_BATCH_ID,
               SYSTIMESTAMP AS STEP_TIMESTAMP,
               steparea AS STEP_AREA,
               stepmessage AS STEP_MESSAGE,
               vtablename AS TABLENAME
          FROM MIG_MIGRATION_INFO MMI
          WHERE STATUS = 'Running'
            AND MMI.MIGRATION_BATCH_ID = vMigrationBatchId;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN ROLLBACK;
    END UPDATE_LOG_MIG_MIGRATION_STEPS;


  -----------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------
  --valex.1/9/2016 - RUN_LA_SA is split to RUN_LA and RUN_SA
  PROCEDURE RUN_LA(p_migrBatchId IN  VARCHAR2,
                   LA_Status     OUT VARCHAR2)
    AS


      l_LogRec      MIGR_GVAR.LogRecTyp;
      ex_LaRollback EXCEPTION;
      vSql          VARCHAR2(2000);
      --  V_COUNT       INTEGER;   --valex.27/4/16
      v_recon       VARCHAR2(30);  --valex.20/4/16  it holds _LOAD name of bolag reonciliation file

      --valex.20/4/16.start declaration of objects needed for _LOAD - ReconFile consistency check
      TYPE t_bulk_collect IS TABLE OF VARCHAR2(30);
      l_tab         t_bulk_collect;
      l_cursor      SYS_REFCURSOR;
      --valex.20/4/16.end
      l_kf100f_recs PLS_INTEGER;
      v_renewal     DATE;

    BEGIN
      LA_Status := 'COMPLETE';
      l_LogRec.migrArea := 'MIGR_LA_SA.RUN_LA';
      l_LogRec.mig_batch_id := p_migrBatchId;


      l_LogRec.migrStep := 'Loading to Landing area';
      l_LogRec.logMsg := 'Started Loading from LOAD to LA';
      l_LogRec.migrStep := 'Landing';
      MIGR_LOG.LOG_INFO(l_LogRec);
      -- +++ anb 2015-11-17 time inside loop
      --        MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Landing', 'Begin loading Landing Area', vMigrationBatchID, NULL);

      SELECT TRUNC(RENEWAL_DATE)
        INTO v_renewal
        FROM (SELECT *
            FROM ETL_MIGRATION_CONDITIONS
            WHERE 1 = 1
              AND ITERATION_STATUS = 'Pending'
            ORDER BY id)
        WHERE ROWNUM = 1;

      l_LogRec.logMsg := 'The configured date in migration schedule is: ' || TO_CHAR(v_renewal, 'dd-mm-yyyy');
      MIGR_LOG.LOG_INFO(l_LogRec);

      FOR cBolag IN (SELECT ebi.BOLAG_ID
          FROM MIG_MIGRATION_INFO ebi
          WHERE 1 = 1
            AND ebi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id)
      LOOP


        FOR cTable IN (
          --valex.3/11/2016 - KF100F file and its IOT are loaded first, as loading of NORMAL files depends on the latter
          --                      SELECT etd.TBLNAME,
          --                      etd.LA
          --                      FROM ETL_TBL_DEF etd
          --                      WHERE 1 = 1
          --                        AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
          --                        AND NVL(etd.LA, 'N') = 'Y'                 -- +++ anb 2016-02-03 skip reconciliation file
          SELECT etd.TBLNAME,
                 etd.LA,
                 (CASE WHEN etd.FILE_ROLE = 'Master' THEN 1 ELSE 0 END) seq
            FROM ETL_TBL_DEF etd
            WHERE 1 = 1
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
              AND NVL(etd.LA, 'N') = 'Y'
              AND FILE_ROLE <> 'Discounts'   --valex.3/1/2017 - do not process MD_DISCOUNTS file during first stage of migration
            ORDER BY seq DESC
        --valex.3/11/2016 - end
        )
        LOOP

          l_LogRec.migrRelTbl := cTable.TBLNAME;
          l_LogRec.migrRelKey := cTable.TBLNAME || '.' || cBolag.BOLAG_ID;
          l_LogRec.migrStep := 'Landing';


          UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);

          LOG_MIG_VOL_ANAL_ROW_COUNT_LA(l_LogRec);

          LOG_MIG_MATCHING_RECORDS(l_LogRec);

          LOG_MIG_VOL_ANAL_MATCHING_LA(l_LogRec);

          IF NOT INSERT_RECORDS_IN_HISTORY(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING, v_renewal)
          THEN
            RAISE ex_LaRollback;


          END IF;
          LOG_RECORDS_NOT_IN_MASTER_FILE(l_LogRec, v_renewal);  --valex.3/11/2016 - log policies of NORMAL files not in Master file

          LOG_MIG_VOL_ANAL_NON_MATCH_LA(l_LogRec);


          UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);
        --MIGR_LOG.LOG_INFO(l_LogRec);

        END LOOP;

        --valex.20/4/16.start logic for record count check among _LOAD tables and corresponding records counts in reconciliation file
        SELECT b.source_table
          INTO v_recon
          FROM etl_tbl_def a,
               etl_engine b
          WHERE 1 = 1
            AND a.file_role = 'Reconciliation'
            AND b.BOLAG_ID = cBolag.BOLAG_ID
            AND a.tblname = b.tblname;

        OPEN l_cursor FOR 'SELECT a.tblname'
        || ' FROM  ETL_ENGINE a inner join MIG_VOLUMETRIC_ANALYSIS b on a.source_table = b.table_name'
        || ' inner join ' || v_recon || ' c on a.tblname = c.KF_TABLE'
        || ' WHERE 1=1'
        || ' AND b.MIGRATION_BATCH_ID = ''' || l_LogRec.mig_batch_id || ''''
        || ' AND b.VOLUME <> c.REC_COUNT'
        || ' and a.migration_area= ''Landing''';
        FETCH l_cursor
        BULK COLLECT INTO l_tab;
        CLOSE l_cursor;


        FOR i IN 1 .. l_tab.COUNT
        LOOP
          LA_Status := 'INCOMPLETE';
          l_LogRec.logMsg := 'LA - ReconFile record count inconsistency for file: ' || l_tab(i);
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
        END LOOP;
        IF LA_Status <> 'COMPLETE'
        THEN
          RAISE ex_LaRollback;
        END IF;
        --valex.20/4/16.end


        --valex.6/9/16 - issue a warning status, if no data from bolag's KF100F_LOAD are inserted in LA
        FOR c IN (SELECT tblname
            FROM ETL_TBL_DEF etd
            WHERE file_role = 'Master')
        LOOP
          vSql := 'SELECT VOLUME '
          || 'FROM MIG_VOLUMETRIC_ANALYSIS '
          || 'WHERE 1=1 '
          || '  AND MIGRATION_BATCH_ID = ''' || l_LogRec.mig_batch_id || ''''
          || '  and status=''Accepted'''
          || '  and TABLE_NAME=''LA_M'' || ''' || SUBSTR(l_LogRec.mig_batch_id, 1, 2) || '''|| ''_''||''' || c.TBLNAME || '''';
          EXECUTE IMMEDIATE vSql
            INTO l_kf100f_recs;
          IF l_kf100f_recs = 0
          THEN

            l_LogRec.logMsg := 'No policies were loaded from KF files to Landing area. Please check that the KF files contains the  expected by migration schedule renewal date and  all batch policies were not included in previous runs.';
            MIGR_LOG.LOG_ERROR(l_LogRec);
            LA_Status := 'NO_DATA_MIGRATED';
          END IF;
        END LOOP;

      --valex.6/9/16 - end

      END LOOP;

      DBMS_LOCK.SLEEP(120);

      --FA.20160705 Change LA status in mig_migration_info in order to fire archive job
      IF LA_Status = 'COMPLETE'
      THEN
        UPDATE MIG_MIGRATION_INFO mmi
          SET mmi.LA_COMPLETED = 'Finished'
          WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
      ELSIF LA_Status = 'NO_DATA_MIGRATED'
      THEN
        UPDATE MIG_MIGRATION_INFO mmi
          SET mmi.LA_COMPLETED = 'No_data_migrated'
          WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
      END IF;

      l_LogRec.logMsg := 'Finished Loading from LOAD to LA';
      l_LogRec.migrRelTbl := '';
      l_LogRec.migrRelKey := '';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;


    EXCEPTION
      WHEN ex_LaRollback THEN LA_Status := 'ROLLBACK_LA';
          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.LA_COMPLETED = 'Failed'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
          COMMIT;
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          LA_Status := 'INCOMPLETE';


    END RUN_LA;


  -----------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------

  PROCEDURE RUN_SA(p_migrBatchId IN  VARCHAR2,
                   SA_Status     OUT VARCHAR2)
    AS

      l_LogRec      MIGR_GVAR.LogRecTyp;
      ex_SaRollback EXCEPTION;
      vSql          VARCHAR2(2000);

    BEGIN
      SA_Status := 'COMPLETE';
      l_LogRec.migrArea := 'MIGR_LA_SA.RUN_SA';
      l_LogRec.mig_batch_id := p_migrBatchId;

      l_LogRec.migrRelTbl := '';
      l_LogRec.migrRelKey := '';
      l_LogRec.migrStep := 'Landing to Staging area';
      l_LogRec.logMsg := 'Starting Loading from LA to SA';
      MIGR_LOG.LOG_INFO(l_LogRec);

      --Log MIG_MIGRATION_STEPS - Initialize loading
      UPDATE_LOG_MIG_MIGRATION_STEPS('Staging', 'Begin loading Staging Area', l_LogRec.mig_batch_id, NULL);

      --FA.20161108 get kf100f table first in order to store renewal date
      FOR cTable IN (SELECT etd.TBLNAME,
                            (CASE WHEN etd.FILE_ROLE = 'Master' THEN 1 ELSE 0 END) seq
          FROM ETL_TBL_DEF etd
          WHERE 1 = 1
            AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
            AND NVL(etd.SA, 'N') = 'Y'                         -- +++ anb 2016-02-03 NP427F
            AND etd.FILE_ROLE NOT IN ('Derived', 'Discounts')                    --valex.3/1/2017 add exclusion for discounts.txt
          ORDER BY seq DESC)
      LOOP
        --Log MIG_MIGRATION_STEPS - Initialize loading
        -- +++ anb 2015-11-17 time inside loop
        --             MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging', 'Begin loading table ' || cTable.TBLNAME, vMigrationBatchID, cTable.TBLNAME);

        FOR cBolag IN (SELECT ebi.BOLAG_ID
            FROM MIG_MIGRATION_INFO ebi
            WHERE 1 = 1
              AND ebi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id)
        LOOP

          -- l_LogRec.mig_bolag_id := cBolag.BOLAG_ID;
          l_LogRec.migrRelTbl := cTable.TBLNAME;
          l_LogRec.logMsg := 'Begin loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
          MIGR_LOG.log_info(l_LogRec);
          --Log MIG_MIGRATION_STEPS - Load from landing M43_KF100F
          UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);
          --FA. 20170323 Always set migr_step prior to porcedure execution
          l_LogRec.migrStep := 'Staging';
          IF NOT INSERT_RECORDS_IN_HISTORY_SA(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING)
          THEN
            RAISE ex_SaRollback;
          END IF;
          --Update MIG_FLAG in M43_KFXXXF - Rows that have been imported
          UPDATE_LA_MIG_FLAG(l_LogRec);

          LOG_MIG_ANAL_ROW_COUNT_SA(l_LogRec);

          --Log MIG_MIGRATION_STEPS - Load from landing M43_KFXXXF
          l_LogRec.logMsg := 'End loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
          UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);
        END LOOP;
      --Log MIG_MIGRATION_STEPS - Finish KFXXXF for staging area
      -- +++ anb 2015-11-17 time inside loop
      --              MIGR_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS('Staging', 'End loading table ' || cTable.TBLNAME, vMigrationBatchID, cTable.TBLNAME);
      END LOOP;
      l_LogRec.logMsg := 'End loading Staging Area';
      UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec);

      --FA.20160407 Moved rules execution outside sa step
      -- RULES take care of their own logging
      --MIGR_RULES.RUN_RULES(l_LogRec.mig_batch_id);

      --valex populate SA_B_* tables
      fill_SA_B_PRSN(l_LogRec.mig_batch_id);    --valex.2/6/2016
      fill_SA_B_address(l_LogRec.mig_batch_id);    --valex.24/8/16
      --valex.end

      DBMS_LOCK.SLEEP(60);


      UPDATE MIG_MIGRATION_INFO mmi
        SET mmi.SA_COMPLETED = 'Finished'
        WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
      l_LogRec.logMsg := 'Finished Loading from LA to SA';
      l_LogRec.migrRelTbl := '';
      l_LogRec.migrRelKey := '';
      MIGR_LOG.LOG_INFO(l_LogRec);




    EXCEPTION
      WHEN ex_SaRollback THEN SA_Status := 'ROLLBACK_SA';
          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.SA_COMPLETED = 'Failed'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          SA_Status := 'INCOMPLETE';
          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.SA_COMPLETED = 'Failed'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;


    END RUN_SA;

  --valex.1/9/2016 - end

  -----------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------

  PROCEDURE LOG_RECORDS_NOT_IN_MASTER_FILE(p_LogRec  MIGR_GVAR.LogRecTyp,
                                           p_renewal DATE)
    AS
      vSQL     VARCHAR2(32000);
      l_LogRec MIGR_GVAR.LogRecTyp;
      vfields  VARCHAR2(100);
    --v_run_renewals     BOOLEAN;
    --v_date             VARCHAR2(20);
    -- l_SOURCE_TABLE_REN ETL_ENGINE.SOURCE_TABLE % TYPE;
    --vsqlRenewals       VARCHAR2(4000);
    BEGIN
      l_LogRec := p_LogRec;

      l_LogRec.migrArea := 'MIGR_LA_SA.LOG_RECORDS_NOT_IN_MASTER_FILE';
      --- +++ anb 2016-02-04 beware of string size for SELECT INTO  - cannot exceed 2100 !!!

      FOR cRec IN (SELECT ee.DEST_TABLE,
                          ee.FIELD_LIST,
                          ee.ADDFLDS,
                          ee.PK_LIST,
                          etd.pk1,
                          etd.pk2,
                          ee.SOURCE_TABLE,
                          ee.JOIN_CONDITION,
                          ee.NOMATCH1,
                          ee.BOLAG_NAME,
                          ee.TBLNAME,
                          ee.iot_fields,
                          ee.PK_LIST_with_tbl_identifier,
                          ee.IOT_TABLE,
                          ee.IOT_JOIN_CONDITION,
                          ee.IOT_MATCH,
                          ee.IOT_NULL_FIELDS,
                          ee.EXIST_IN_LA_TBL,
                          ee.FIELD_LIST1,
                          ee.IOT_NOT_MATCH,
                          ee.MASTER_LOAD_TBL,
                          ee.master_load_join_condition
          -- ee.ADDFLDS1
          -- (CASE WHEN etd.file_role<>'Reconciliation' THEN 'LA_'||BOLAG_NAME||'_KF100F_IOT' ELSE '(select ''1'' as KF_TABLE from dual)' end)AS kf_IOT,
          -- (CASE WHEN  etd.tblname='KF100F' THEN 1 ELSE 0 END ) AS seq
          FROM ETL_ENGINE ee,
               MIG_MIGRATION_INFO mmi,
               etl_tbl_def etd
          WHERE 1 = 1
            AND ee.BOLAG_ID = mmi.BOLAG_ID
            AND mmi.STATUS = 'Running'
            AND mmi.migration_batch_id = l_LogRec.mig_batch_id
            AND ee.MIGRATION_AREA = 'Landing'
            AND ee.TBLNAME = etd.TBLNAME
            AND ee.TBLNAME = l_LogRec.migrRelTbl
            AND FILE_ROLE = 'Normal'

            AND ee.TBLNAME <> 'BR161F')
      LOOP
        vSQL := 'DECLARE '
        || ' CURSOR KF is '
        || '    SELECT * '
        || '    FROM MIG_DETAIL_ERROR_LOG; '
        || ' TYPE KF_tab IS TABLE OF KF%ROWTYPE; '
        || ' KF_all_records   KF_tab:= KF_tab(); '
        || ' cnt pls_integer:=0;'
        || 'BEGIN '
        || ' SELECT ''' || l_LogRec.mig_batch_id || ''','
        || ' SYSTIMESTAMP AS ERROR_TIMESTAMP, '
        || CHR(39) || 'Landing' || CHR(39) || ' AS MIGRATION_AREA, '
        || CHR(39) || 'Critical Error' || CHR(39) || ' AS ERROR_TYPE, '
        || CHR(39) || 'IDPL does not exist in Master table' || CHR(39) || ' AS ERROR_MESSAGE, '
        || CHR(39) || 'Transfering from _LOAD to historical tables' || CHR(39) || ' AS MIGRATION_STEP, '
        || CHR(39) || CREC.dest_TABLE || CHR(39) || ' AS RELATED_TABLE, ''' || crec.PK1 || ':''||' || crec.PK1 || '||'',''||''' || crec.PK2 || ':''||' || crec.PK2 || '  AS RELATED_KEY '   --fix it
        || ' BULK COLLECT INTO KF_all_records '
        || 'FROM '
        || '(SELECT TI.*'
        || ' FROM ' || cRec.IOT_TABLE || ' TL'
        || ' RIGHT JOIN  ' || cRec.SOURCE_TABLE || ' TI ' || cRec.IOT_JOIN_CONDITION
        || '  inner join ' || CREC.MASTER_LOAD_TBL || ' ML ' || CREC.master_load_join_condition || ' = ' || 'to_date(''' || p_renewal || ''',''yyyy-mm-dd'')'
        || ' WHERE ' || cRec.iot_not_mATCH || ') '


        || ';'
        || ' cnt:=KF_all_records.COUNT;'

        || '  FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT '
        || '    INSERT  INTO MIG_DETAIL_ERROR_LOG VALUES KF_all_records(i); '

        || 'INSERT INTO MIG_VOLUMETRIC_ANALYSIS '
        || '(MIGRATION_BATCH_ID, LOG_TIMESTAMP, MIGRATION_AREA, TABLE_NAME, STATUS, VOLUME) '
        || ' values (''' || l_LogRec.mig_batch_id || ''','
        || ' SYSTIMESTAMP,'
        || '''Landing'','
        || '''' || CREC.DEST_TABLE || ''','
        || '''Rejected - IDPL not in Master table'','
        || ' cnt);'
        || 'END; ';



        EXECUTE IMMEDIATE vSQL;
        COMMIT;

      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || ' vsql:' || vsql;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END LOG_RECORDS_NOT_IN_MASTER_FILE;

-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------








END MIGR_TST_PRC_LA_SA;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_TST_PRC_MD_DISC
  AS

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Load discounts into Landing area table
  --No reconciliation checks are performed between discounts file an kf100f or between waiting discounts polciy in ia_policy and discounts file
  PROCEDURE RUN_LA_DISCOUNTS(p_migrBatchId IN  VARCHAR2,
                             LA_Status     OUT VARCHAR2)
    AS
      vSQL                 VARCHAR2(2000);
      l_LogRec             MIGR_GVAR.LogRecTyp;
      ex_LaRollback        EXCEPTION;
      l_md_discounts_count PLS_INTEGER;
      l_ia_count           PLS_INTEGER;
      v_renewal            DATE;

      l_bolag_id           VARCHAR2(10);
      l_tbl_name           VARCHAR2(50);
      l_tbl_row_cnt        PLS_INTEGER;
      l_file_row_cnt       PLS_INTEGER;

      v_query              VARCHAR2(1024);
      v_count              PLS_INTEGER;
    BEGIN
      LA_Status := MIGR_GVAR.GV_MD_DISC_STATUS_INCOMPLETE; --'INCOMPLETE';
      l_LogRec.migrArea := 'MIGR_TST_PRC_MD_DISC.RUN_LA_DISCOUNTS';
      l_LogRec.migrStep := 'Loading to Landing area';
      l_LogRec.logMsg := 'Started Loading Discounts from LOAD to LA';
      l_LogRec.mig_batch_id := p_migrBatchId;
      MIGR_LOG.LOG_INFO(l_LogRec);

      l_bolag_id := SUBSTR(p_migrBatchId, 1, 2);
      l_tbl_name := 'LA_M' || l_bolag_id || '_MD_DISCOUNTS_LOAD';

      -- Table counter
      EXECUTE IMMEDIATE 'SELECT COUNT(''X'') FROM ' || l_tbl_name || ' WHERE NOT BOLAG_ID IS NULL'
        INTO l_tbl_row_cnt;

      -- File counter
      l_file_row_cnt := MD_DISCOUNTS_FILE_ROW_COUNTER(p_migrBatchId);



      -- Policy IDPL validation
      v_query := 'SELECT COUNT(*)'
      || '  FROM ' || l_tbl_name -- i.e. 'LA_M27_MD_DISCOUNTS_LOAD '
      || ' WHERE 1=1'
      || '  AND MIGG_POLICY_IDPL = BOLAG_ID || LPAD(FNR, 7, ''0'') || LPAD(FVNR, 3, ''0'')';

      EXECUTE IMMEDIATE v_query
        INTO v_count;

      l_LogRec.logMsg := 'Load table row count: ' || l_tbl_row_cnt || ' Discount file row count: ' || l_file_row_cnt || ' IDPL Validation counter: ' || v_count;
      MIGR_LOG.LOG_INFO(l_LogRec);

      DBMS_LOCK.SLEEP(60);

      IF NOT l_file_row_cnt IS NULL
        AND l_file_row_cnt = l_tbl_row_cnt
        AND v_count = l_file_row_cnt
      THEN
        --Get current renewal date from migration plan schedule
        SELECT TRUNC(RENEWAL_DATE)
          INTO v_renewal
          FROM (SELECT *
              FROM ETL_MIGRATION_CONDITIONS
              WHERE 1 = 1
                AND ITERATION_STATUS = 'Pending'
              ORDER BY id)
          WHERE ROWNUM = 1;

        FOR cBolag IN (SELECT ebi.BOLAG_ID
            FROM MIG_MIGRATION_INFO ebi
            WHERE 1 = 1
              AND ebi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id)
        LOOP
          FOR cTable IN (SELECT etd.TBLNAME,
                                etd.LA
              FROM ETL_TBL_DEF etd
              WHERE 1 = 1
                AND etd.file_role = 'Discounts'
                AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
                AND NVL(etd.LA, 'N') = 'Y')
          LOOP
            l_LogRec.migrRelTbl := cTable.TBLNAME;
            l_LogRec.migrRelKey := cTable.TBLNAME || '.' || cBolag.BOLAG_ID;
            l_LogRec.migrStep := 'Landing';
            l_LogRec.logMsg := 'Begin loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
            MIGR_LOG.LOG_INFO(l_LogRec);
            MIGR_TST_PRC_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

            MIGR_TST_PRC_LA_SA.LOG_MIG_VOL_ANAL_ROW_COUNT(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

            MIGR_TST_PRC_LA_SA.LOG_MIG_MATCHING_RECORDS(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

            MIGR_TST_PRC_LA_SA.LOG_MIG_VOL_ANAL_MATCHING(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

            --Commits for every table load
            IF NOT MIGR_TST_PRC_LA_SA.INSERT_RECORDS_IN_HISTORY(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC, v_renewal)
            THEN
              RAISE ex_LaRollback;
            END IF;

            l_LogRec.logMsg := 'End loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
            MIGR_LOG.LOG_INFO(l_LogRec);
            MIGR_TST_PRC_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

          END LOOP;
          LA_Status := MIGR_GVAR.GV_MD_DISC_STATUS_COMPLETE; --'COMPLETE';

        END LOOP;
      ELSE
        LA_Status := MIGR_GVAR.GV_MD_DISC_STATUS_FAILED_DISC;

      END IF;

      l_LogRec.logMsg := 'Finished Loading Discounts from LOAD to LA with status: ' || LA_Status;
      l_LogRec.migrRelTbl := '';
      l_LogRec.migrRelKey := '';
      MIGR_LOG.LOG_INFO(l_LogRec);



    EXCEPTION
      WHEN ex_LaRollback THEN LA_Status := 'ROLLBACK_LA';
          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.DISCOUNT_COMPLETED = 'Failed'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
          l_LogRec.logMsg := 'ex_LaRollback Exception';
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          COMMIT;
      WHEN OTHERS THEN LA_Status := MIGR_GVAR.GV_MD_DISC_STATUS_INCOMPLETE; --'INCOMPLETE';
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.DISCOUNT_COMPLETED = 'Failed'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
          COMMIT;

    END RUN_LA_DISCOUNTS;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Load discounts into Staging area table
  PROCEDURE RUN_SA_DISCOUNTS(p_migrBatchId IN  VARCHAR2,
                             SA_Status     OUT VARCHAR2)
    AS
      vSql          VARCHAR2(2000);
      l_LogRec      MIGR_GVAR.LogRecTyp;
      ex_SaRollback EXCEPTION;

    BEGIN
      SA_Status := 'INCOMPLETE';
      l_LogRec.migrArea := 'MIGR_TST_PRC_MD_DISC.RUN_SA_DISCOUNTS';
      l_LogRec.migrStep := 'Landing to Staging area';
      l_LogRec.logMsg := 'Starting Loading Discounts from LA to SA';
      l_LogRec.mig_batch_id := p_migrBatchId;
      MIGR_LOG.LOG_INFO(l_LogRec);

      FOR cTable IN (SELECT etd.TBLNAME
          FROM ETL_TBL_DEF etd
          WHERE 1 = 1
            AND etd.TBLNAME = 'MD_DISCOUNTS'
            AND NVL(etd.IS_ACTIVE, 'N') = 'Y'
            AND NVL(etd.SA, 'N') = 'Y')
      LOOP
        FOR cBolag IN (SELECT ebi.BOLAG_ID
            FROM MIG_MIGRATION_INFO ebi
            WHERE 1 = 1
              AND ebi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id)
        LOOP
          l_LogRec.migrRelTbl := cTable.TBLNAME;
          l_LogRec.migrRelKey := cTable.TBLNAME || '.' || cBolag.BOLAG_ID;
          l_LogRec.migrStep := 'Staging';
          l_LogRec.logMsg := 'Begin loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
          MIGR_LOG.LOG_INFO(l_LogRec);

          MIGR_TST_PRC_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

          IF NOT MIGR_TST_PRC_LA_SA.INSERT_RECORDS_IN_HISTORY_SA(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC)
          THEN
            RAISE ex_SaRollback;
          ELSE
            SA_Status := 'COMPLETE';
          END IF;

          MIGR_TST_PRC_LA_SA.UPDATE_LA_MIG_FLAG(l_LogRec);

          MIGR_TST_PRC_LA_SA.LOG_MIG_VOL_ANAL_ROW_COUNT(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

          l_LogRec.logMsg := 'End loading table ' || cTable.TBLNAME || ' from Mutual ' || cBolag.BOLAG_ID;
          MIGR_LOG.LOG_INFO(l_LogRec);

          MIGR_TST_PRC_LA_SA.UPDATE_LOG_MIG_MIGRATION_STEPS(l_LogRec, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);

        END LOOP;

      END LOOP;

      l_LogRec.logMsg := 'Finished Loading Discounts from LA to SA';
      l_LogRec.migrRelTbl := '';
      l_LogRec.migrRelKey := '';
      MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION
      WHEN ex_SaRollback THEN l_LogRec.logMsg := 'Exception ex_SaRollback';
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          SA_Status := 'ROLLBACK_SA';
          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.DISCOUNT_COMPLETED = 'Failed'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
      WHEN OTHERS THEN SA_Status := 'INCOMPLETE';
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.DISCOUNT_COMPLETED = 'Failed'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;

    END RUN_SA_DISCOUNTS;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Load Discounts in Intermediate Area
  PROCEDURE RUN_IA_DISCOUNTS(p_migrBatchId IN  VARCHAR2,
                             IA_Status     OUT VARCHAR2)
    AS
      vSql          VARCHAR2(2000);
      l_LogRec      MIGR_GVAR.LogRecTyp;
      ex_SaRollback EXCEPTION;

    BEGIN
      IA_Status := 'INCOMPLETE';
      l_LogRec.migrArea := 'MIGR_TST_PRC_MD_DISC.RUN_IA_DISCOUNTS';
      l_LogRec.migrStep := 'Staging to Intermediate area';
      l_LogRec.logMsg := 'Started IA Discounts processing';
      l_LogRec.mig_batch_id := p_migrBatchId;
      MIGR_LOG.LOG_INFO(l_LogRec);

      l_LogRec.migrRelTbl := 'MD_DISCOUNTS';
      --Populate temporary table  MD_DISCOUNTS
      IF MIGR_INTERMEDIATE_OBJECTS.POPULATE_INTERMEDIATE_TABLE(l_LogRec)
      THEN
        l_LogRec.logMsg := 'Populated Intermediate Objects';
        MIGR_LOG.LOG_INFO(l_LogRec);
        --IA_Status := 'COMPLETE';
        --Populate  table  IA_MD_DISCOUNTS
        MIGR_IA.IA_MAIN_TBL(l_LogRec, IA_Status, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC);
      ELSE
        UPDATE MIG_MIGRATION_INFO mmi
          SET mmi.DISCOUNT_COMPLETED = 'Failed', Status = 'Failed', END_TIMESTAMP = SYSTIMESTAMP
          WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;

      END IF;


      l_LogRec.logMsg := 'Finished IA processing';
      l_LogRec.migrRelTbl := '';
      l_LogRec.migrRelKey := '';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN IA_Status := 'INCOMPLETE';
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.DISCOUNT_COMPLETED = 'Failed', Status = 'Failed'
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.MIG_BATCH_ID;
          COMMIT;
    END RUN_IA_DISCOUNTS;
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  --Update INSIS discounts table: INSIS_GEN_V10.GEN_RISK_DISCOUNT
  --The function is called by discount flow and by  premiums adjustment flow
  FUNCTION UPDATE_MD_DISCOUNTS(p_policyRec        MIGR_GVAR.PolicyRecTyp,
                               p_discount_type IN VARCHAR2)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS
      L_IN_CONTEXT     SRVCONTEXT;
      L_OUT_CONTEXT    SRVCONTEXT;
      L_RESULT         VARCHAR2(50);
      pio_err          SRVERR;

      l_policyRec      MIGR_GVAR.PolicyRecTyp;
      l_evres          PLS_INTEGER;
      v_stmst          VARCHAR2(400);
      v_event          MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;

      R_DISCOUNT       INSIS_GEN_V10.P_DISCOUNT_TYPE;
      l_discount_id    NUMBER;
      l_discount_value NUMBER;

    BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Update Policy MD Discounts';
      l_policyRec.migrArea := 'MIGR_MD_DISCOUNTS.UPDATE_MD_DISCOUNT';
      l_policyRec.migrRelTbl := 'INSIS_EVENT';

      --Find discount id in INSIS. If  INSURED_OBJ_ID is null than the discount applies to policy level
      IF l_policyRec.insured_object_id IS NULL
      THEN
        SELECT grd.DISCOUNT_ID
          INTO l_discount_id
          FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
          WHERE grd.POLICY_ID = l_policyRec.policy_id
            AND grd.DISCOUNT_TYPE = p_discount_type
            AND grd.INSURED_OBJ_ID IS NULL
            AND grd.CLIENT_GROUP = 0
            AND NVL(grd.COVER_TYPE, '0') = '0'
            AND grd.ANNEX_ID = MIGR_GVAR.GV_ANNEX_ID;
      ELSE
        SELECT grd.DISCOUNT_ID
          INTO l_discount_id
          FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
          WHERE grd.POLICY_ID = l_policyRec.policy_id
            AND grd.DISCOUNT_TYPE = p_discount_type
            AND grd.INSURED_OBJ_ID = l_policyRec.insured_object_id
            AND grd.CLIENT_GROUP = 0
            AND NVL(grd.COVER_TYPE, '0') = '0'
            AND grd.ANNEX_ID = MIGR_GVAR.GV_ANNEX_ID;
      END IF;

      ---Get discount value from IA_MD_DISCOUNTS
      SELECT imd.IA_DISCOUNT
        INTO l_discount_value
        FROM IA_MD_DISCOUNTS imd
        WHERE imd.IA_POLICY_ID = l_policyRec.policy_id;

--      IF MIGR_GVAR.GV_MIGRATION_METHOD = 'EVENT'
--      THEN
--
--        L_IN_CONTEXT := NULL;
--        L_OUT_CONTEXT := NULL;
--        L_RESULT := NULL;
--        pio_err := NULL;
--
--        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'DISCOUNT_ID', SRV_CONTEXT.INTEGERS_FORMAT, l_discount_id);
--        SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'DISCOUNT_VALUE', SRV_CONTEXT.REAL_NUMBER_FORMAT, l_discount_value);
--
--        v_event := MIGR_API_COMMON.GET_INSIS_EVENT('UPD_DISCOUNT');
--
--        v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
--        EXECUTE IMMEDIATE v_stmst
--        USING IN v_event, IN L_IN_CONTEXT, IN 'FALSE', OUT L_OUT_CONTEXT, IN OUT pio_err;
--
--        SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);
--
--        l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, L_RESULT);
--
--        IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
--        THEN
--          l_policyRec.logMsg := 'Updated Discounts succesfully for policy :' || l_policyRec.policy_id || ' and  Insured Object for object_id: ' || l_policyRec.object_id || '-RESULT:' || L_RESULT;
--          MIGR_LOG.LOG_INFO(l_policyRec);
--
--        ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
--        THEN
--          l_policyRec.logMsg := 'Update Discounts returned with warning -RESULT:' || L_RESULT;
--          MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
--
--        ELSE
--          l_policyRec.logMsg := 'Failed to Update Discounts-RESULT ' || L_RESULT;
--          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
--
--          l_policyRec.logMsg := 'ERROR';
--          l_policyRec.continue_migr := FALSE;
--        END IF;
--
--      --------------------------------------------------------
--
--
--      ELSE
--
--
--
--        R_DISCOUNT := NEW INSIS_GEN_V10.P_DISCOUNT_TYPE(l_discount_id);
--        --          R_DISCOUNT.INSURED_OBJ_ID    :=
--        --          R_DISCOUNT.COVER_TYPE        :=
--        --          R_DISCOUNT.POLICY_ID         := l_policyRec.policy_id;
--        --          R_DISCOUNT.ANNEX_ID          := MIGR_GVAR.GV_ANNEX_ID; -- ?
--        --          R_DISCOUNT.CLIENT_GROUP      :=
--        --          R_DISCOUNT.DISCOUNT_TYPE     :=
--        R_DISCOUNT.DISCOUNT_VALUE := l_discount_value;
--        --          R_DISCOUNT.ACCUMULATIVE_FLAG :=
--        --          R_DISCOUNT.APPLIED           :=
--        --          R_DISCOUNT.TARIFF_DISCOUNT   :=
--        --          R_DISCOUNT.DISCOUNT_ORDER    :=
--        --          R_DISCOUNT.LUMP_SUM_DISCOUNT :=
--        --          R_DISCOUNT.DISCOUNT_ID       :=
--        --          R_DISCOUNT.SEPARATE_ACCOUNT  :=
--        --          R_DISCOUNT.CORRECTION_AMOUNT :=
--        --          R_DISCOUNT.CALCULATION_MODE  :=
--        --          R_DISCOUNT.EFFECTIVE_FROM    :=
--        --          R_DISCOUNT.EFFECTIVE_TO      :=
--
--        IF NOT R_DISCOUNT.UpdateDiscount(PIO_ERR)
--        THEN
--          MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
--          l_policyRec.logMsg := 'ERROR';
--        END IF;
--
--      END IF;

      IF l_policyRec.logMsg = 'ERROR'
      THEN
        -- UPDATE IA_POLICY -> MIG_FLAG FAILED DISCOUNTS!
        MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(l_policyRec.policy_idpl, MIGR_GVAR.GV_MIG_FLAG_FAILED_DISCOUNTS, l_policyRec.MIG_BATCH_ID);

      END IF;

      RETURN l_policyRec;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN l_policyRec.logMsg := 'No discount found in GEN_RISK_DISCOUNT for discount type: ' || p_discount_type || ' ERR: ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr := FALSE;
          RETURN l_policyRec;
      WHEN OTHERS THEN l_policyRec.logMsg := 'ERR: ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          l_policyRec.continue_migr := FALSE;
          RETURN l_policyRec;

    END UPDATE_MD_DISCOUNTS;
  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------
  --  PROCEDURE LOAD_MD_DISCOUNTS(p_migrBatchId IN VARCHAR2, LOAD_Status OUT VARCHAR2)
  --    AS
  --      vSql             VARCHAR2(2000);
  --      l_LogRec         MIGR_GVAR.LogRecTyp;
  --      ex_SaRollback    EXCEPTION;
  --      l_policyRec      MIGR_GVAR.PolicyRecTyp;
  --      l_discount_type  VARCHAR2(10);
  --
  --  BEGIN
  --      LOAD_Status           := 'COMPLETE';
  --      l_LogRec.migrArea     := 'MIGR_MD_DISCOUNTS.LOAD_MD_DISCOUNTS';
  --      l_LogRec.migrStep     := 'Loading MD Discounts to INSIS area';
  --      l_LogRec.logMsg       := 'Started MD Discounts loading';
  --      l_LogRec.mig_batch_id := p_migrBatchId;
  --      l_LogRec.migrRelTbl   := 'IA_MD_DISCOUNTS';
  --      MIGR_LOG.LOG_INFO(l_LogRec);
  --
  --      SELECT DISCOUNT_TYPE INTO l_discount_type FROM ETL_SETUP_INFO;
  --
  --      FOR cRec IN (SELECT * FROM IA_MD_DISCOUNTS imd WHERE imd.MIG_BATCH_ID = p_migrBatchId AND NVL(imd.IA_DISCOUNT, '0') <> 0)
  --      LOOP
  --        l_policyRec.mig_batch_id := cRec.MIG_BATCH_ID;
  --        l_policyRec.policy_id    := cRec.IA_POLICY_ID;
  --        l_policyRec.policy_idpl  := cRec.IA_IDPL;
  --
  --        l_policyRec := UPDATE_MD_DISCOUNTS(l_policyRec, l_discount_type);
  --
  ----        IF l_policyRec.logMsg = 'ERROR' THEN
  ----          RAISE ex_SaRollback;
  ----        END IF;
  --
  --      END LOOP;
  --
  --      UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Finished', DISCOUNTS_END_TIMESTAMP=SYSTIMESTAMP ----FA.20170127 Only API should be able to turn status to Finished ,status ='Finished'
  --        WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
  --
  --      COMMIT;
  --      l_LogRec.logMsg       := 'Finished MD Discounts loading';
  --      MIGR_LOG.LOG_INFO(l_LogRec);
  --
  --
  --    EXCEPTION
  ----    WHEN ex_SaRollback THEN
  ----      LOAD_Status := 'ROLLBACK_LOAD';
  ----      UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Failed' WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
  --    WHEN OTHERS THEN
  --      LOAD_Status := 'INCOMPLETE';
  --      l_LogRec.logMsg := SQLERRM;
  --      MIGR_LOG.LOG_EXCEPTION(l_LogRec);
  --      UPDATE MIG_MIGRATION_INFO mmi SET mmi.DISCOUNT_COMPLETED = 'Failed', DISCOUNTS_END_TIMESTAMP=SYSTIMESTAMP WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;
  --
  --  END LOAD_MD_DISCOUNTS;
  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  --   procedure retrieve_discounts_not(p_policyRec  MIGR_GVAR.PolicyRecTyp, p_discount_type in varchar2)
  --
  --  IS
  --
  --    l_discount_id NUMBER;
  --    l_discount_value NUMBER;
  --    vsql varchar2(3000);
  --    TYPE sql_rec IS RECORD (
  --            ia_discount_type VARCHAR2(50)
  --            ,ia_discount_value number
  --            ,is_valid_to date
  --            ,ins_object_id  number
  --    );
  --    TYPE t_sql_type_tab IS TABLE OF sql_rec;
  --    v_sql_tab       t_sql_type_tab;
  --    i PLS_INTEGER;
  --    l_policyRec    MIGR_GVAR.PolicyRecTyp;
  --
  --
  --
  --  BEGIN
  --      l_policyRec := p_policyRec;
  --      l_policyRec.migrStep   := 'Get Discount_ID from INSIS';
  --      l_policyRec.migrArea   := 'MIGR_MD_DISCOUNTS.get_insis_discount_id';
  --      l_policyRec.migrRelTbl := '';
  --
  --      IF p_discount_type is NOT NULL THEN     -- MD_DISCOUNTS.txt discounts
  --          SELECT grd.DISCOUNT_ID
  --                INTO l_discount_id
  --               FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
  --               WHERE grd.POLICY_ID = l_policyRec.policy_id AND grd.DISCOUNT_TYPE = p_discount_type AND grd.INSURED_OBJ_ID IS NULL and grd.CLIENT_GROUP=0 /*AND NVL(grd.COVER_TYPE,'0')='0'*/ AND grd.ANNEX_ID=MIGR_GVAR.GV_ANNEX_ID ;
  --
  --          SELECT imd.IA_DISCOUNT
  --            INTO l_discount_value
  --            FROM IA_MD_DISCOUNTS imd
  --           WHERE imd.IA_POLICY_ID = l_policyRec.policy_id;
  --
  --          --use upload_discounts here
  --
  --       else
  --          vsql:= 'select a.ia_discount_type, a.ia_discount_value, a.is_valid_to, b.ins_object_id '
  --              || 'from ' || l_policyRec.ia_discountsTbl || ' a join ' ||l_policyRec.migrTbl ||' b on a.ia_idpl=b.policy_idpl '
  --              || ' where a.ia_idpl=' ||l_policyRec.policy_idpl
  --              || '   union all  '--policy_level
  --              || ' select a.ia_discount_type, a.ia_discount_value, a.is_valid_to, null '
  --              || ' from ia_gen_discounts_pol a '
  --              || ' where ia_idpl='|| l_policyRec.policy_idpl  ;
  --          EXECUTE IMMEDIATE vsql bulk COLLECT INTO  v_sql_tab;
  --
  --          FOR i IN 1 .. v_sql_tab.COUNT
  --          LOOP
  --
  --                IF v_sql_tab(i).ins_object_id IS NULL THEN
  --                       SELECT grd.DISCOUNT_ID
  --                          INTO l_discount_id
  --                          FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
  --                         WHERE grd.POLICY_ID = l_policyRec.policy_id AND grd.DISCOUNT_TYPE = v_sql_tab(i).IA_DISCOUNT_TYPE AND grd.INSURED_OBJ_ID IS NULL and grd.CLIENT_GROUP=0 /*AND NVL(grd.COVER_TYPE,'0')='0'*/ AND grd.ANNEX_ID=MIGR_GVAR.GV_ANNEX_ID ;
  --                ELSE
  --                        SELECT grd.DISCOUNT_ID
  --                          INTO l_discount_id
  --                          FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
  --                         WHERE grd.POLICY_ID = l_policyRec.policy_id AND grd.DISCOUNT_TYPE = v_sql_tab(i).IA_DISCOUNT_TYPE AND grd.INSURED_OBJ_ID =v_sql_tab(i).ins_object_id and grd.CLIENT_GROUP=0 /*AND NVL(grd.COVER_TYPE,'0')='0'*/ AND grd.ANNEX_ID=MIGR_GVAR.GV_ANNEX_ID ;
  --                END IF;
  --
  --                --use upload_discounts here
  --          END LOOP;
  --       END IF;
  --
  --
  --
  --  EXCEPTION
  --    WHEN OTHERS THEN
  --      l_policyRec.logMsg := 'ERR: ' || SQLERRM;
  --      MIGR_LOG.LOG_EXCEPTION(l_policyRec);
  --
  --  END retrieve_discounts_not;
  --
  --
  --
  -----------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------


  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------
  FUNCTION GET_INSIS_DISCOUNT_ID(p_policyRec        MIGR_GVAR.PolicyRecTyp,
                                 p_discount_type IN VARCHAR2,
                                 p_ins_object_id IN VARCHAR2)
    RETURN NUMBER
    IS
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      l_discount_id NUMBER;
    ---  l_LogRec         MIGR_GVAR.LogRecTyp;

    BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrArea := 'MIGR_MD_DISCOUNTS.GET_INSIS_DISCOUNT_ID';
      l_policyRec.migrStep := 'Fetch Discount_id from INSIS';
      l_policyRec.logMsg := '';
      l_policyRec.migrRelTbl := '';

      IF p_ins_object_id IS NULL
      THEN --policy_level
        SELECT grd.DISCOUNT_ID
          INTO l_discount_id
          FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
          WHERE grd.POLICY_ID = l_policyRec.policy_id
            AND grd.DISCOUNT_TYPE = p_discount_type
            AND grd.INSURED_OBJ_ID IS NULL
            AND grd.CLIENT_GROUP = 0 /*AND NVL(grd.COVER_TYPE,'0')='0'*/ AND grd.ANNEX_ID = MIGR_GVAR.GV_ANNEX_ID;
      ELSE                            --object-level
        SELECT grd.DISCOUNT_ID
          INTO l_discount_id
          FROM INSIS_GEN_V10.GEN_RISK_DISCOUNT grd
          WHERE grd.POLICY_ID = l_policyRec.policy_id
            AND grd.DISCOUNT_TYPE = p_discount_type
            AND grd.INSURED_OBJ_ID = p_ins_object_id
            AND grd.CLIENT_GROUP = 0 /*AND NVL(grd.COVER_TYPE,'0')='0'*/ AND grd.ANNEX_ID = MIGR_GVAR.GV_ANNEX_ID;
      END IF;

      RETURN l_discount_id;

    EXCEPTION
      WHEN no_data_found THEN l_policyRec.logMsg := 'Cannot find discount_id for policy: ' || l_policyRec.policy_id || ' and object_id: ' || p_ins_object_id;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN NULL;
      WHEN OTHERS THEN l_policyRec.logMsg := 'ERR: ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          RETURN NULL;
    END GET_INSIS_DISCOUNT_ID;


  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------
  -- MD DISCOUNTS FILE ROW COUNTER
  FUNCTION MD_DISCOUNTS_FILE_ROW_COUNTER(p_migrBatchId IN VARCHAR2)
    RETURN NUMBER
    IS
      l_LogRec    MIGR_GVAR.LogRecTyp;

      l_infile    utl_file.file_type;
      l_buffer    VARCHAR2(1024);
      l_cnt_rows  PLS_INTEGER := 0;
      l_dir       VARCHAR2(100);
      l_bolag_id  VARCHAR2(10);
      l_file_name VARCHAR2(30);
    BEGIN
      l_LogRec.migrArea := 'MIGR_MD_DISCOUNTS.MD_DISCOUNTS_FILE_ROW_COUNTER';
      l_LogRec.migrStep := 'MIGR_MD_DISCOUNTS.MD_DISCOUNTS_FILE_ROW_COUNTER';
      l_LogRec.mig_batch_id := p_migrBatchId;
      l_LogRec.logMsg := '';
      l_LogRec.migrRelTbl := '';

      l_bolag_id := SUBSTR(p_migrBatchId, 1, 2);
      l_dir := 'READ_DIR_M' || l_bolag_id;
      l_file_name := 'M' || l_bolag_id || '_MD_DISCOUNTS.txt';
      l_LogRec.logMsg := 'MIG_BATCH_ID: ' || p_migrBatchId || ', BOLAG_ID: ' || l_bolag_id || ', DIR: ' || l_dir || ', FILE_NAME: ' || l_file_name;

      -- open a file to read
      l_infile := utl_file.fopen(l_dir, l_file_name, 'r');

      -- check file is opened
      IF utl_file.is_open(l_infile)
      THEN

        -- loop lines in the file
        LOOP
          BEGIN
            utl_file.get_line(l_infile, l_buffer);
            IF SUBSTR(TRIM(l_buffer), 1, 5) <> 'BOLAG'
              AND LENGTHC(TRIM(l_buffer)) <> 0
            THEN
              l_cnt_rows := l_cnt_rows + 1;
            END IF;
          EXCEPTION
            WHEN no_data_found THEN EXIT;
          END;

        END LOOP;

      ELSE
        l_cnt_rows := NULL;

      END IF;

      utl_file.fclose(l_infile);

      --  DBMS_OUTPUT.PUT_LINE(l_cnt_rows);
      RETURN l_cnt_rows;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := 'ERR: ' || SQLERRM || ' - ' || l_LogRec.logMsg;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          RETURN NULL;
    END;

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------
  FUNCTION upload_discount(p_policyRec         MIGR_GVAR.PolicyRecTyp,
                           p_discount_id    IN NUMBER,
                           p_discount_value IN NUMBER,
                           p_valid_to       IN DATE)
    RETURN MIGR_GVAR.PolicyRecTyp
    IS
      l_policyRec   MIGR_GVAR.PolicyRecTyp;
      R_DISCOUNT    INSIS_GEN_V10.P_DISCOUNT_TYPE;
      L_IN_CONTEXT  SRVCONTEXT;
      L_OUT_CONTEXT SRVCONTEXT;
      L_RESULT      VARCHAR2(50);
      pio_err       SRVERR;
      l_evres       PLS_INTEGER;
      v_stmst       VARCHAR2(400);
      v_event       MIGR_SRV_EVENT_LIST.INSIS_EVENT_NAME % TYPE;
    --  l_LogRec         MIGR_GVAR.LogRecTyp;

    BEGIN
      l_policyRec := p_policyRec;
      l_policyRec.migrStep := 'Upload discount to INSIS';
      l_policyRec.migrArea := 'MIGR_MD_DISCOUNTS.UPLOAD_DISCOUNT';
      l_policyRec.migrRelTbl := '';
      l_policyRec.logMsg := '';

--      IF p_discount_id IS NOT NULL
--      THEN
--
--        IF MIGR_GVAR.GV_MIGRATION_METHOD = 'EVENT'
--        THEN
--
--          L_IN_CONTEXT := NULL;
--          L_OUT_CONTEXT := NULL;
--          L_RESULT := NULL;
--          pio_err := NULL;
--
--          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'DISCOUNT_ID', SRV_CONTEXT.INTEGERS_FORMAT, p_discount_id);
--          SRV_CONTEXT.SETCONTEXTATTRNUMBER(L_IN_CONTEXT, 'DISCOUNT_VALUE', SRV_CONTEXT.REAL_NUMBER_FORMAT, p_discount_value);
--          IF p_valid_to IS NOT NULL
--          THEN
--            SRV_CONTEXT.SETCONTEXTATTRDATE(L_IN_CONTEXT, 'EFFECTIVE_TO', SRV_CONTEXT.Date_Format, p_valid_to);
--          END IF;
--
--          v_event := MIGR_API_COMMON.GET_INSIS_EVENT('UPD_DISCOUNT');
--
--          v_stmst := '  begin MIGR_SYSTEM.CALL_EVENT(:p_event, :p_inContext,:p_debug , :p_outContext, :p_pioErr); end; ';
--          EXECUTE IMMEDIATE v_stmst
--          USING IN v_event, IN L_IN_CONTEXT, IN 'FALSE', OUT L_OUT_CONTEXT, IN OUT pio_err;
--
--          SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'PROCEDURE_RESULT', L_RESULT);
--
--          l_evres := MIGR_API_COMMON.GET_EVENT_RESULT(pio_err, L_RESULT);
--
--          IF l_evres = MIGR_GVAR.GV_EVRES_SUCCESS
--          THEN
--            l_policyRec.logMsg := 'Updated Discount succesfully for policy :' || l_policyRec.policy_id || ' and  discount_id: ' || p_discount_id || '-RESULT:' || L_RESULT;
--            MIGR_LOG.LOG_INFO(l_policyRec);
--
--          ELSIF l_evres = MIGR_GVAR.GV_EVRES_WARNING
--          THEN
--            l_policyRec.logMsg := 'Update Discounts returned with warning -RESULT:' || L_RESULT;
--            MIGR_LOG.LOG_WARNING_EVENT(l_policyRec, pio_err);
--
--          ELSE
--            l_policyRec.logMsg := 'Failed to Update Discounts-RESULT ' || L_RESULT;
--            MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
--
--            l_policyRec.logMsg := 'ERROR';
--            l_policyRec.continue_migr := FALSE;
--          END IF;
--        ELSE
--
--
--
--          R_DISCOUNT := NEW INSIS_GEN_V10.P_DISCOUNT_TYPE(p_discount_id);
--          --          R_DISCOUNT.INSURED_OBJ_ID    :=
--          --          R_DISCOUNT.COVER_TYPE        :=
--          --          R_DISCOUNT.POLICY_ID         := l_policyRec.policy_id;
--          --          R_DISCOUNT.ANNEX_ID          := MIGR_GVAR.GV_ANNEX_ID; -- ?
--          --          R_DISCOUNT.CLIENT_GROUP      :=
--          --          R_DISCOUNT.DISCOUNT_TYPE     :=
--          R_DISCOUNT.DISCOUNT_VALUE := p_discount_value;
--          --          R_DISCOUNT.ACCUMULATIVE_FLAG :=
--          --          R_DISCOUNT.APPLIED           :=
--          --          R_DISCOUNT.TARIFF_DISCOUNT   :=
--          --          R_DISCOUNT.DISCOUNT_ORDER    :=
--          --          R_DISCOUNT.LUMP_SUM_DISCOUNT :=
--          --          R_DISCOUNT.DISCOUNT_ID       :=
--          --          R_DISCOUNT.SEPARATE_ACCOUNT  :=
--          --          R_DISCOUNT.CORRECTION_AMOUNT :=
--          --          R_DISCOUNT.CALCULATION_MODE  :=
--          --          R_DISCOUNT.EFFECTIVE_FROM    :=
--          IF p_valid_to IS NOT NULL
--          THEN
--            R_DISCOUNT.EFFECTIVE_TO := p_valid_to;
--          END IF;
--
--          IF NOT R_DISCOUNT.UpdateDiscount(PIO_ERR)
--          THEN
--            MIGR_LOG.LOG_ERROR_EVENT(l_policyRec, pio_err);
--            l_policyRec.logMsg := 'ERROR';
--          END IF;
--
--        END IF;
--      ELSE
--        l_policyRec.logMsg := 'ERROR';
--      END IF;

      IF l_policyRec.logMsg = 'ERROR'
      THEN
        l_policyRec.logMsg := 'Failed to apply discount for policy: ' || l_policyRec.policy_id || ' with discount_id: ' || p_discount_id;
        MIGR_LOG.LOG_EXCEPTION(l_policyRec);
      END IF;


      RETURN l_policyRec;



    EXCEPTION


      WHEN OTHERS THEN l_policyRec.logMsg := 'ERR: ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_policyRec);
          --FA.20170301 Set migration flag to false
          l_policyRec.continue_migr := FALSE;
          RETURN l_policyRec;

    END upload_discount;

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RUN_DISCOUNTS(p_policyRec IN OUT MIGR_GVAR.PolicyRecTyp)
    IS
      l_discount_id    NUMBER;
      l_discount_value NUMBER;
      vsql             VARCHAR2(3000);

      TYPE sql_rec IS RECORD (
          ia_discount_type  VARCHAR2(50),
          ia_discount_value NUMBER,
          is_valid_to       DATE,
          ins_object_id     NUMBER,
          discount_id       NUMBER
        );

      TYPE t_sql_type_tab IS TABLE OF sql_rec;
      v_sql_tab        t_sql_type_tab;
      i                PLS_INTEGER;

    BEGIN

      p_policyRec.migrStep := 'Gather policy-level and object-level Discounts';
      p_policyRec.migrArea := 'MIGR_TST_PRC_MD_DISC.RUN_DISCOUNTS';
      p_policyRec.migrRelTbl := '';

      vsql := 'select a.ia_discount_type, a.ia_discount_value, a.ia_valid_to, b.ins_object_id, null '
      || 'from ' || p_policyRec.ia_discountsTbl || ' a join ' || p_policyRec.migrTbl || ' b on a.ia_idpl=b.policy_idpl '
      || ' where a.ia_idpl=' || p_policyRec.policy_idpl || ' and a.IA_OBJECT_ID=b.IA_OBJECT_ID'
      || '   union all  '--policy_level
      || ' select a.ia_discount_type, a.ia_discount_value, a.ia_valid_to, null, null '
      || ' from ia_gen_discounts_pol a '
      || ' where ia_idpl=' || p_policyRec.policy_idpl;
      EXECUTE IMMEDIATE vsql
        BULK COLLECT INTO v_sql_tab;

      FOR i IN 1 .. v_sql_tab.COUNT
      LOOP

        BEGIN
          v_sql_tab(i).discount_id := GET_INSIS_DISCOUNT_ID(p_policyRec, v_sql_tab(i).IA_DISCOUNT_TYPE, v_sql_tab(i).ins_object_id);
          --FA.20170301  : Check if discount id was returned prior to upload discounts
          IF v_sql_tab(i).discount_id IS NOT NULL
          THEN
            p_policyRec := UPLOAD_DISCOUNT(p_policyRec, v_sql_tab(i).discount_id, v_sql_tab(i).ia_discount_value, v_sql_tab(i).is_valid_to);

          ELSE
            p_policyRec.logMsg := 'INSIS Discount Id was not found for object: ' || v_sql_tab(i).ins_object_id || '  and discount type: ' || v_sql_tab(i).IA_DISCOUNT_TYPE;
            MIGR_LOG.LOG_ERROR(p_policyRec);
            p_policyRec.continue_migr := FALSE;
          END IF;

        EXCEPTION
          WHEN OTHERS THEN p_policyRec.continue_migr := FALSE;
              p_policyRec.logMsg := 'Exception: ' || SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(p_policyRec);
        END;

      --FA.commented 20170301-should be execuet only if have INSIS discount id  p_policyRec:= UPLOAD_DISCOUNt(l_policyRec, v_sql_tab(i).discount_id,v_sql_tab(i).ia_discount_value, v_sql_tab(i).is_valid_to);
      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN p_policyRec.logMsg := 'ERR: ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(p_policyRec);
          p_policyRec.continue_migr := FALSE;

    END RUN_DISCOUNTS;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE LOAD_MD_DISCOUNTS(p_migrBatchId IN  VARCHAR2,
                              LOAD_Status   OUT VARCHAR2)
    AS
      vSql            VARCHAR2(2000);
      l_LogRec        MIGR_GVAR.LogRecTyp;
      ex_SaRollback   EXCEPTION;
      l_policyRec     MIGR_GVAR.PolicyRecTyp;
      l_discount_type VARCHAR2(10);
      l_discount_id   NUMBER;
      l_insured_obj   VARCHAR2(50);

    BEGIN
      LOAD_Status := 'COMPLETE';
      l_LogRec.migrArea := 'MIGR_MD_DISCOUNTS.LOAD_MD_DISCOUNTS';
      l_LogRec.migrStep := 'Loading MD Discounts to INSIS area';
      l_LogRec.logMsg := 'Started MD Discounts loading';
      l_LogRec.mig_batch_id := p_migrBatchId;
      l_LogRec.migrRelTbl := 'IA_MD_DISCOUNTS';
      MIGR_LOG.LOG_INFO(l_LogRec);

      SELECT DISCOUNT_TYPE
        INTO l_discount_type
        FROM ETL_SETUP_INFO;

      FOR cRec IN (SELECT *
          FROM IA_MD_DISCOUNTS imd
          WHERE imd.MIG_BATCH_ID = p_migrBatchId
            AND NVL(imd.IA_DISCOUNT, '0') <> 0)
      LOOP
        l_policyRec.mig_batch_id := cRec.MIG_BATCH_ID;
        ---FA.20170411 Instead of using file's policy_id which is candidate for format transformatiom errors, use the MIGG policy idpl and retrieve the mapped INSIS policy id from migr_policy

        l_policyRec.policy_idpl := cRec.IA_IDPL;

        BEGIN

          SELECT POLICY_ID
            INTO l_policyRec.policy_id
            FROM MIGR_POLICY
            WHERE POLICY_IDPL = cRec.IA_IDPL;

          BEGIN

            l_discount_id := GET_INSIS_DISCOUNT_ID(l_policyRec, l_discount_type, NULL);

            --FA.20170301  : Check if discount id was returned prior to upload discounts
            IF l_discount_id IS NOT NULL
            THEN
              l_policyRec := UPLOAD_DISCOUNT(l_policyRec, l_discount_id, cRec.ia_discount, NULL);
            ELSE
              l_policyRec.logMsg := 'ERROR';
            END IF;

          EXCEPTION
            WHEN OTHERS THEN
                --fa 20170301
                l_policyRec.logMsg := 'Exception: ' || SQLERRM;
                MIGR_LOG.LOG_EXCEPTION(l_policyRec);
                l_policyRec.logMsg := 'ERROR';

          END;

          --FA.20170301 Commented   l_policyRec:= UPLOAD_DISCOUNT(l_policyRec, l_discount_id, cRec.ia_discount, null);
          -- UPDATE IA_POLICY -> MIG_FLAG FAILED DISCOUNTS!
          IF l_policyRec.logMsg = 'ERROR'
          THEN

            MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(l_policyRec.policy_idpl, MIGR_GVAR.GV_MIG_FLAG_FAILED_DISCOUNTS, l_policyRec.MIG_BATCH_ID);

          END IF;

        EXCEPTION
          WHEN NO_DATA_FOUND THEN l_policyRec.logMsg := 'Invalid MIGG policy number was found in the loaded file. Row is skipped. ' || SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_policyRec);

          WHEN OTHERS THEN l_policyRec.logMsg := 'Error occured while searching for the MIGG policy number:' || l_policyRec.policy_idpl || '. Row is skipped. ' || SQLERRM;
              MIGR_LOG.LOG_EXCEPTION(l_policyRec);
        END;

      END LOOP;

      DBMS_LOCK.SLEEP(120);

      UPDATE MIG_MIGRATION_INFO mmi
        SET mmi.DISCOUNT_COMPLETED = 'Finished', DISCOUNTS_END_TIMESTAMP = SYSTIMESTAMP ----FA.20170127 Only API should be able to turn status to Finished ,status ='Finished'
        WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;

      COMMIT;
      l_LogRec.logMsg := 'Finished MD Discounts loading';
      MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION
      WHEN OTHERS THEN LOAD_Status := 'INCOMPLETE';
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          UPDATE MIG_MIGRATION_INFO mmi
            SET mmi.DISCOUNT_COMPLETED = 'Failed', DISCOUNTS_END_TIMESTAMP = SYSTIMESTAMP
            WHERE mmi.MIGRATION_BATCH_ID = l_LogRec.mig_batch_id;

    END LOAD_MD_DISCOUNTS;

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --valex.2/3/17 - exports discounts view (V_MIGR_PREMIUMS) without INSIS_PREM_FINAL to a flat file
  PROCEDURE dump_table_to_csv(p_migrBatchId IN VARCHAR2,
                              p_tname       IN VARCHAR2,
                              p_dir         IN VARCHAR2,
                              p_filename    IN VARCHAR2)
    AS
      l_output      utl_file.file_type;
      l_theCursor   INTEGER DEFAULT dbms_sql.open_cursor;
      l_columnValue VARCHAR2(4000);
      l_status      INTEGER;
      l_query       VARCHAR2(1000);
      --  default 'select * from ' || p_tname || ' where MIG_BATCH_ID=''' ||p_migrBatchId || '''';
      l_colCnt      NUMBER  := 0;
      l_separator   VARCHAR2(1);
      l_descTbl     dbms_sql.desc_tab;
      l_LogRec      MIGR_GVAR.LogRecTyp;
      vsql          VARCHAR2(2000);

    BEGIN
      l_LogRec.migrStep := 'Create Discounts file';
      l_LogRec.mig_batch_id := p_migrBatchId;
      l_LogRec.migrArea := 'MIGR_MD_DISCOUNTS.DUMP_TABLE_TO_CSV';

      --valex.16/3/2017 - dynamic fetch of V_MIGR_PREMIUMS column list without INSIS_PREM_FINAL

      FOR c IN (SELECT COLUMN_NAME,
                       column_id
          FROM USER_TAB_COLS
          WHERE TABLE_NAME = p_tname
            AND column_name <> 'INSIS_PREM'
          ORDER BY column_id)
      LOOP
        vsql := vsql || CASE WHEN c.COLUMN_ID = 1 THEN NULL ELSE ',' END || '"' || c.COLUMN_NAME || '"';

      END LOOP;
      --valex.16/3/2017 - end
      l_query := 'select ' || vsql || ' from ' || p_tname || ' where MIG_BATCH_ID=''' || p_migrBatchId || '''';

      l_output := utl_file.fopen(p_dir, p_filename, 'w');


      dbms_sql.parse(l_theCursor, l_query, dbms_sql.native);
      dbms_sql.describe_columns(l_theCursor, l_colCnt, l_descTbl);

      FOR i IN 1 .. l_colCnt
      LOOP
        utl_file.put(l_output, l_separator || l_descTbl(i).col_name);
        dbms_sql.define_column(l_theCursor, i, l_columnValue, 4000);
        l_separator := '|';
      END LOOP;
      utl_file.new_line(l_output);

      l_status := dbms_sql.execute(l_theCursor);

      WHILE (dbms_sql.fetch_rows(l_theCursor) > 0)
        LOOP
          l_separator := '';
          FOR i IN 1 .. l_colCnt
          LOOP
            dbms_sql.column_value(l_theCursor, i, l_columnValue);
            utl_file.put(l_output, l_separator || l_columnValue);
            l_separator := '|';
          END LOOP;
          utl_file.new_line(l_output);
        END LOOP;
      dbms_sql.close_cursor(l_theCursor);
      utl_file.fclose(l_output);

      l_LogRec.logMsg := p_tname || ' data for batch: ' || p_migrBatchId || ' is loaded to ' || p_filename || ' in ' || p_dir;
      MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END dump_table_to_csv;
  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------
  --valex.3/3/17 - Create discounts file for applicable bolags and add email with relative attachment to the email queue
  PROCEDURE SEND_MD_DISCOUNTS_FILE
    AS
      l_dir    VARCHAR2(30);
      l_file   VARCHAR2(100);
      l_batch  VARCHAR2(50);
      l_LogRec MIGR_GVAR.LogRecTyp;
      v_time   VARCHAR2(50);

    BEGIN
      l_LogRec.migrArea := 'MIGR_MD_DISCOUNTS.SEND_MD_DISCOUNTS_FILE';
      l_LogRec.migrStep := 'Create discounts file and add email with relative attachment to the email queue';

      FOR c IN (SELECT a.migration_batch_id,
                       b.discounts_report_view,
                       c.bolag_name,
                       a.STATUS
          FROM MIG_MIGRATION_INFO a,
               etl_setup_info b,
               etl_bolag_info c
          WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC, MIGR_GVAR.GV_BATCH_STATUS_FINISHED)
            AND a.DISCOUNTS_FILE_CREATED = MIGR_GVAR.GV_STATUS_PENDING
            AND a.BOLAG_ID = c.BOLAG_ID)
      LOOP
        l_LogRec.mig_batch_id := c.MIGRATION_BATCH_ID;

        v_time := TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD@HH24-MI-SS');
        l_dir := 'READ_DIR_' || c.BOLAG_NAME || '_ARCHIVE'; -- valex.20/3/17 - discounts file will be created in ARCHIVE folder, in order phase 2 not to be triggered.
        l_file := c.BOLAG_NAME || '_MD_DISCOUNTS_' || v_time || '.txt';
        MIGR_MD_DISCOUNTS.DUMP_TABLE_TO_CSV(c.MIGRATION_BATCH_ID, c.DISCOUNTS_REPORT_VIEW, l_dir, l_file);

        IF c.STATUS = MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC
        THEN
          -- email with attachment here
          MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION(c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_MIGR_DISC_REPORT, l_file, l_dir);
        ELSE
          MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION(c.MIGRATION_BATCH_ID, MIGR_GVAR.GV_MSG_CODE_MIGR_FINAL_REPORT, l_file, l_dir);
        END IF;

        UPDATE MIG_MIGRATION_INFO
          SET DISCOUNTS_FILE_CREATED = MIGR_GVAR.GV_STATUS_FINISHED
          WHERE MIGRATION_BATCH_ID = c.MIGRATION_BATCH_ID;

      END LOOP;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END SEND_MD_DISCOUNTS_FILE;

  ---------------------------------------------------------------------------------------------------------------------------
  ---------------------------------------------------------------------------------------------------------------------------

  ------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------
  -- pl 20170612
  PROCEDURE DEFAULT_MD_DISCOUNTS_FILE(vBatchID IN VARCHAR2)
    AS
      l_dir_obj      NVARCHAR2(100);
      l_dir_arch_obj NVARCHAR2(100);
      l_source_file  NVARCHAR2(100);
      l_dest_file    NVARCHAR2(100);

      l_LogRec       MIGR_GVAR.LogRecTyp;
      l_count        NUMBER;
    BEGIN
      l_LogRec.mig_batch_id := vBatchID;
      l_LogRec.migrArea := 'MIGR_MD_DISCOUNTS.DEFAULT_MD_DISCOUNTS_FILE';
      l_LogRec.migrStep := 'MIGR_MD_DISCOUNTS.DEFAULT_MD_DISCOUNTS_FILE';
      l_LogRec.migrRelTbl := NULL;
      l_LogRec.migrRelKey := NULL;

      FOR c IN (SELECT *
          FROM (SELECT DISTINCT menl.MSG_REGISTRATION_TIMESTAMP,
                                menl.MSG_ATT_NAME,
                                menl.MSG_ATT_DIR--, SUBSTR(MSG_ATT_NAME, 1, LENGTH(MSG_ATT_NAME)-24), SUBSTR(MSG_ATT_DIR, 1, LENGTH(MSG_ATT_DIR)-8)
              FROM MIGR_EMAIL_NOTIFICATIONS_LOG menl
              WHERE 1 = 1
                AND menl.MSG_ATT_NAME IS NOT NULL
                AND menl.MIGRATION_BATCH_ID = vBatchID
              ORDER BY menl.MSG_REGISTRATION_TIMESTAMP DESC) A
          WHERE ROWNUM = 1)
      LOOP
        l_dir_obj := SUBSTR(c.MSG_ATT_DIR, 1, LENGTH(c.MSG_ATT_DIR) - 8);
        l_dir_arch_obj := c.MSG_ATT_DIR;

        l_source_file := c.MSG_ATT_NAME;
        l_dest_file := SUBSTR(c.MSG_ATT_NAME, 1, LENGTH(c.MSG_ATT_NAME) - 24) || '.txt';

        -- Copy MD_DISCOUNTS.txt from archive directory
        UTL_FILE.FCOPY(
        src_location => l_dir_arch_obj,
        src_filename => l_source_file,
        dest_location => l_dir_obj,
        dest_filename => l_dest_file
        );

        l_LogRec.logMsg := ' - ' || l_dir_arch_obj || '-' || l_source_file || '-' || l_dir_obj || '-' || l_dest_file;

      END LOOP;

      l_LogRec.logMsg := 'MD_DISCOUNTS.txt retrieved.' || l_LogRec.logMsg;
      MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := 'Could not retrieve MD_DISCOUNTS file - ' || SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          SELECT COUNT(1)
            INTO l_count
            FROM MIGR_EMAIL_NOTIFICATIONS_LOG
            WHERE MIGRATION_BATCH_ID = vBatchID
              AND MSG_CODE = MIGR_GVAR.GV_MSG_CODE_FAIL_GET_DEF_DISC;
          IF l_count = 0
          THEN
            MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION(vBatchID, MIGR_GVAR.GV_MSG_CODE_FAIL_GET_DEF_DISC);
          END IF;
    END DEFAULT_MD_DISCOUNTS_FILE;

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

END MIGR_TST_PRC_MD_DISC;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_TST_PRC_RESUME
  IS


  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- 1.delete batch and step specific rows from MIG_VOLUMETRIC_ANALYSIS
  -- 2.delete batch specific rows from SA_* tables

  PROCEDURE DELETE_SA(p_migration_batch_id IN  VARCHAR2,
                      SA_status            OUT VARCHAR2)
    AS


      l_file_name     NVARCHAR2(50);
      l_addtnl_fields VARCHAR2(10);
      l_Status        VARCHAR2(50);
      vsql            VARCHAR(1000);
      l_LogRec        MIGR_GVAR.LogRecTyp;

      CURSOR fetch_file_names IS
          SELECT DISTINCT (etd.TBLNAME),
                          NVL(etd.ADDTNL, 'N') AS ADDTNL
            FROM ETL_TBL_DEF etd
            WHERE NVL(etd.SA, 'N') = 'Y'
              AND NVL(etd.IS_ACTIVE, 'N') = 'Y';

    BEGIN

      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME_R.DELETE_SA';
      l_LogRec.mig_batch_id := p_migration_batch_id;

      --initialise LA MIG_FLAG
      FOR c IN (SELECT DEST_TABLE
          FROM ETL_ENGINE a,
               MIG_MIGRATION_INFO b
          WHERE 1 = 1
            AND MIGRATION_AREA = 'Landing'
            AND a.BOLAG_ID = b.BOLAG_ID
            AND b.MIGRATION_BATCH_ID = p_migration_batch_id)
      LOOP
        vsql:='update :dest_table set mig_flag=0 where mig_flag=1 AND MIG_BATCH_ID = :p_migr_batch';
          EXECUTE immediate vsql using c.DEST_TABLE,p_migration_batch_id;
      END LOOP;

      DELETE FROM MIG_VOLUMETRIC_ANALYSIS
        WHERE MIGRATION_BATCH_ID = p_migration_batch_id
          AND MIGRATION_AREA = 'Staging';

      --delete batch data from SA
      OPEN fetch_file_names;
      LOOP
        FETCH fetch_file_names INTO l_file_name, l_addtnl_fields;
        EXIT WHEN fetch_file_names % NOTFOUND;

        vsql := 'DELETE FROM  ' || ' SA_' || l_file_name || ' WHERE MIG_BATCH_ID = :p_migr_batch ';

        EXECUTE IMMEDIATE vsql
        USING p_migration_batch_id;
      END LOOP;
      CLOSE fetch_file_names;

      -- remove from SA_B area
      vsql := 'TRUNCATE  table SA_B_PRSN';
      EXECUTE IMMEDIATE vsql;

      DELETE FROM SA_B_ADDRESS
        WHERE MIG_BATCH_ID = p_migration_batch_id;
      SA_Status := 'COMPLETE';
      l_LogRec.logMsg := 'DELETE_SA ran successfully';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;



    EXCEPTION
      WHEN OTHERS THEN
          --DBMS_OUTPUT.PUT_LINE('DELETE_SA:' || SQLERRM());
          SA_Status := 'INCOMPLETE';
          l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END DELETE_SA;


  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- 1.delete batch and step specific rows from MIG_VOLUMETRIC_ANALYSIS, MIGR_IA_SA_LIST
  -- 2.delete batch specific rows from IA_* tables

  PROCEDURE DELETE_IA(p_migration_batch_id IN  VARCHAR2,
                      IA_status            OUT VARCHAR2)
    AS

      vSQL     VARCHAR2(2000);
      l_LogRec MIGR_GVAR.LogRecTyp;

    BEGIN
      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME_R.DELETE_IA';
      l_LogRec.mig_batch_id := p_migration_batch_id;

      --initialise SA tables MIG_FLAG, with respect to IA step
      FOR c IN (SELECT dest_table
          FROM ETL_ENGINE a,
               MIG_MIGRATION_INFO b
          WHERE 1 = 1
            AND a.MIGRATION_AREA = 'Staging'
            AND a.BOLAG_ID = b.BOLAG_ID
            AND b.MIGRATION_BATCH_ID = p_migration_batch_id)
      LOOP
         vsql:='update :dest_table set mig_flag=0 where mig_flag in (1,2) AND MIG_BATCH_ID = :p_migr_batch';
          EXECUTE immediate vSQL using c.DEST_TABLE,p_migration_batch_id;
      END LOOP;

      DELETE FROM MIG_VOLUMETRIC_ANALYSIS
        WHERE MIGRATION_BATCH_ID = p_migration_batch_id
          AND MIGRATION_AREA = 'Intermediate';

      vSQL := 'DELETE FROM MIGR_IA_SA_LIST WHERE MIG_BATCH_ID= :batch';
      EXECUTE IMMEDIATE vSQL
      USING p_migration_batch_id;

      --delete batch data from IA
      FOR tRec IN (SELECT DEST_TABLE

          FROM ETL_SA_IA
          WHERE MIGRATION_AREA = 'SA_IA'
            AND IS_ACTIVE = 'TRUE')
      LOOP

        vSQL := ' DELETE FROM ' || tRec.DEST_TABLE
        || ' WHERE MIG_BATCH_ID =:batch';

        EXECUTE IMMEDIATE vSQL
        USING p_migration_batch_id;


      END LOOP;
      IA_Status := 'COMPLETE';
      l_LogRec.logMsg := 'DELETE_IA ran successfully';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;

    EXCEPTION
      WHEN OTHERS THEN
          --DBMS_OUTPUT.PUT_LINE('DELETE_IA:' || SQLERRM());
          IA_Status := 'INCOMPLETE';
          l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END DELETE_IA;


  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- 1.delete batch and step specific rows from MIG_DETAIL_ERROR_LOG, MIG_VOLUMETRIC_ANALYSIS
  -- 2.delete batch specific rows from LA_* tables


  PROCEDURE DELETE_LA(p_migration_batch_id IN  VARCHAR2,
                      LA_Status            OUT VARCHAR2)
    AS
      vsql          VARCHAR(2100);
      l_file_name   NVARCHAR2(50);
      l_bolag_name  NVARCHAR2(50);
      l_tbl_cnt     PLS_INTEGER;
      l_addtnl_flds VARCHAR2(10);
      l_Status      VARCHAR2(50);
      l_LogRec      MIGR_GVAR.LogRecTyp;
      v_my_schema   VARCHAR2(50);



    BEGIN
      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME_R.DELETE_LA';
      l_LogRec.mig_batch_id := p_migration_batch_id;

      SELECT SYS_CONTEXT('userenv', 'current_schema')
        INTO v_my_schema
        FROM dual;

      DELETE FROM MIG_DETAIL_ERROR_LOG
        WHERE MIGRATION_BATCH_ID = p_migration_batch_id
          AND MIGRATION_AREA = 'Landing';
      DELETE FROM MIG_VOLUMETRIC_ANALYSIS
        WHERE MIGRATION_BATCH_ID = p_migration_batch_id
          AND MIGRATION_AREA = 'Landing';

      --delete batch data from LA
      FOR c IN (SELECT TO_CHAR(DEST_TABLE) AS DEST_TABLE
          FROM ETL_ENGINE a,
               MIG_MIGRATION_INFO b
          WHERE 1 = 1
            AND MIGRATION_AREA = 'Landing'
            AND a.BOLAG_ID = b.BOLAG_ID
            AND b.MIGRATION_BATCH_ID = p_migration_batch_id
          UNION ALL
        SELECT table_name AS DEST_TABLE
          FROM ALL_ALL_TABLES
          WHERE 1 = 1
            AND owner = v_my_schema
            AND REGEXP_LIKE(table_name, '^LA_M' || SUBSTR(p_migration_batch_id, 1, 2) || '(.*)_IOT$'))
      LOOP
        vsql := 'delete from ' || c.DEST_TABLE || ' where mig_batch_id =:p_mig_batch';
        EXECUTE IMMEDIATE vsql
        USING p_migration_batch_id;
      END LOOP;


      LA_Status := 'COMPLETE';
      l_LogRec.logMsg := 'DELETE_LA ran successfully';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;




    EXCEPTION

      WHEN OTHERS THEN
          --DBMS_OUTPUT.PUT_LINE('DELETE_LA:' || SQLERRM());
          l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          LA_Status := 'INCOMPLETE';

    END DELETE_LA;
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--FA.20180207 Overloaded this is called by process
  PROCEDURE RESUME_MAIN (P_BOLAG_ID IN NUMBER)
      as
      l_step VARCHAR2(100);
      l_status VARCHAR2(30):='INCOMPLETE';
      l_LogRec      MIGR_GVAR.LogRecTyp;
      resume_step_failed EXCEPTION;
      vsql VARCHAR2(200);
      v_queued_batch VARCHAR2(50);
      v_resume_batch PLS_INTEGER:=0;

    begin
     l_LogRec.migrArea := 'MIGR_TST_PRC_RESUME.RESUME_MAIN';
     l_LogRec.logMsg := 'RESUME started';
     MIGR_LOG.LOG_INFO(l_LogRec);

      vSQL := 'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
      EXECUTE IMMEDIATE vSQL;

        --FA. 20160824 ALTER SESSION param to minmize indirect redo log size of global temporary table undo
       vSQL := 'ALTER SESSION SET TEMP_UNDO_ENABLED = TRUE';
       EXECUTE IMMEDIATE vSQL;

     v_queued_batch := MIGR_TST_PRC_SIGNAL.GET_NEXT_QUEUED(P_BOLAG_ID);

      --find the step where migration stopped
      CHECK_PROCESS_STATUS(v_queued_batch, l_step);
      l_LogRec.logMsg := 'Step : ' || l_step ||  ' for batch:' ||v_queued_batch;
      MIGR_LOG.LOG_INFO(l_LogRec);

      IF NVL(l_step, ' ') <> ' ' THEN
         IF l_step <> 'FULL' THEN
           v_resume_batch:=1;
         END IF;

         IF l_Step <> 'Steps Completed' THEN
           --loop which executes all necessary steps till IA
             FOR c1 IN (SELECT *
                          FROM ETL_PROCESS_RESUME_CONFIG
                         WHERE ',' || EXECUTE_WHEN_STOPPED_IN || ',' LIKE '%,' || l_step || ',%'
                         ORDER BY ID
             )
             LOOP

                IF c1.PROCESS LIKE '%MIGR_LA_SA%' THEN
                  c1.PROCESS := REPLACE(c1.PROCESS, 'MIGR_LA_SA', 'MIGR_TST_PRC_LA_SA');
                  l_LogRec.logMsg := 'Step MIGR_TST_PRC_LA_SA';
                  MIGR_LOG.LOG_INFO(l_LogRec);
                ELSIF c1.PROCESS LIKE '%MIGR_IA%' THEN
                  c1.PROCESS := REPLACE(c1.PROCESS, 'MIGR_IA', 'MIGR_TST_PRC_IA');
                  l_LogRec.logMsg := 'Step MIGR_TST_PRC_IA';
                  MIGR_LOG.LOG_INFO(l_LogRec);
                ELSIF c1.PROCESS LIKE '%MIGR_MD_DISCOUNTS%' THEN
                  c1.PROCESS := REPLACE(c1.PROCESS, 'MIGR_MD_DISCOUNTS', 'MIGR_TST_PRC_MD_DISC');
                  l_LogRec.logMsg := 'Step MIGR_TST_PRC_MD_DISC';
                  MIGR_LOG.LOG_INFO(l_LogRec);
                ELSE
                  l_LogRec.logMsg := 'Step OK : ' || l_step;
                  MIGR_LOG.LOG_INFO(l_LogRec);
                END IF;

                 EXECUTE IMMEDIATE c1.PROCESS
                   USING IN v_queued_batch, OUT l_status;

                 IF l_status<>'COMPLETE' THEN
                    IF l_status=MIGR_GVAR.GV_MD_DISC_STATUS_FAILED_DISC THEN
                        -- Archive MD_DISCOUNTS file and UPDATE MIG_MIGRATION_INFO status as 'Wait_Discounts'
                        MIGR_ARCHIVE.ARCHIVE_MD_DISCOUNTS_FILE(v_queued_batch);

                        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( v_queued_batch, MIGR_GVAR.GV_MSG_CODE_MIGR_FAILED_DISC );

                        UPDATE MIG_MIGRATION_INFO mmi SET STATUS=MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC, END_TIMESTAMP = SYSTIMESTAMP WHERE  mmi.MIGRATION_BATCH_ID=v_queued_batch;

                        EXIT;
                    ELSE
                        UPDATE MIG_MIGRATION_INFO mmi SET STATUS=MIGR_GVAR.GV_BATCH_STATUS_FAILED, END_TIMESTAMP = SYSTIMESTAMP WHERE  mmi.MIGRATION_BATCH_ID=v_queued_batch;

                        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( v_queued_batch, MIGR_GVAR.GV_MSG_CODE_MIGR_FAILED );
                        EXIT;
                    END IF;
                 END IF;

             END LOOP;
         ELSE
            l_status := 'COMPLETE';
         END IF;

      ELSE
          l_LogRec.logMsg := 'ERROR: Step is null';
          MIGR_LOG.LOG_INFO(l_LogRec);
      END IF;


      if l_status='COMPLETE' and v_resume_batch=1 then


           vsql:='UPDATE MIG_MIGRATION_INFO mmi SET mmi.resume_process='''' WHERE  mmi.resume_process=''In Progress'' AND mmi.MIGRATION_BATCH_ID=:batch';
           EXECUTE IMMEDIATE vsql USING v_queued_batch;
--           vsql:='delete from  ETL_RESUME_BATCHES where  MIGRATION_BATCH_ID=:batch';
--           EXECUTE IMMEDIATE vsql USING v_queued_batch;
           COMMIT;
  --         l_LogRec.logMsg := 'RESUME finished';
  --         MIGR_LOG.LOG_INFO(l_LogRec);
      END IF;

    EXCEPTION
      WHEN OTHERS THEN
        l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);

  END RESUME_MAIN;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE RESUME_MAIN
    AS
      l_step             VARCHAR2(100);
      l_status           VARCHAR2(30) := 'INCOMPLETE';
      l_LogRec           MIGR_GVAR.LogRecTyp;
      resume_step_failed EXCEPTION;
      vsql               VARCHAR2(200);
      v_queued_batch     VARCHAR2(50);
      v_resume_batch     PLS_INTEGER  := 0;

    BEGIN

      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME_R.RESUME_MAIN';
      l_LogRec.logMsg := 'RESUME started';
      MIGR_LOG.LOG_INFO(l_LogRec);


      vSQL := 'ALTER SESSION SET NLS_NUMERIC_CHARACTERS = ''.,''';
      EXECUTE IMMEDIATE vSQL;

      --FA. 20160824 ALTER SESSION param to minmize indirect redo log size of global temporary table undo
      vSQL := 'ALTER SESSION SET TEMP_UNDO_ENABLED = TRUE';
      EXECUTE IMMEDIATE vSQL;


      v_queued_batch := MIGR_TST_PRC_SIGNAL.GET_NEXT_QUEUED();


      --     for c in (with cte AS (SELECT MIGRATION_BATCH_ID
      --                          from ETL_RESUME_BATCHES
      --                           union ALL
      --                          SELECT  v_queued_batch as MIGRATION_BATCH_ID
      --                          FROM DUAL)
      --               SELECT MIGRATION_BATCH_ID
      --               FROM cte
      --               WHERE 1=1
      --                and (MIGRATION_BATCH_ID IS NOT NULL) and (MIGRATION_BATCH_ID <> ' ')
      --
      --     )
      --     loop
      --find the step where migration stopped
      CHECK_PROCESS_STATUS(v_queued_batch, l_step);
      l_LogRec.logMsg := 'Step : ' || l_step;
      MIGR_LOG.LOG_INFO(l_LogRec);


      IF NVL(l_step, ' ') <> ' '
      THEN

        IF l_step <> 'FULL'
        THEN
          v_resume_batch := 1;
        END IF;

        IF l_Step <> 'Steps Completed'
        THEN
          --loop which executes all necessary steps till IA
          FOR c1 IN (SELECT *
              FROM ETL_PROCESS_RESUME_CONFIG
              WHERE ',' || EXECUTE_WHEN_STOPPED_IN || ',' LIKE '%,' || l_step || ',%'
              ORDER BY ID)
          LOOP

            IF c1.PROCESS LIKE '%MIGR_LA_SA%' THEN
              c1.PROCESS := REPLACE(c1.PROCESS, 'MIGR_LA_SA', 'MIGR_TST_PRC_LA_SA');
            ELSIF c1.PROCESS LIKE '%MIGR_IA%' THEN
              c1.PROCESS := REPLACE(c1.PROCESS, 'MIGR_IA', 'MIGR_TST_PRC_IA');
            ELSIF c1.PROCESS LIKE '%MIGR_MD_DISCOUNTS%' THEN
              c1.PROCESS := REPLACE(c1.PROCESS, 'MIGR_MD_DISCOUNTS', 'MIGR_TST_PRC_MD_DISC');
            ELSE
              l_LogRec.logMsg := 'Step OK : ' || l_step;
              MIGR_LOG.LOG_INFO(l_LogRec);
            END IF;

            --l_LogRec.logMsg := 'c1.PROCESS : '|| c1.PROCESS || v_queued_batch;
            --MIGR_LOG.LOG_ERROR(l_LogRec);

            EXECUTE IMMEDIATE c1.PROCESS
            USING IN v_queued_batch, OUT l_status;

            IF l_status <> 'COMPLETE'
            THEN
              IF l_status = MIGR_GVAR.GV_MD_DISC_STATUS_FAILED_DISC
              THEN
                -- Archive MD_DISCOUNTS file and UPDATE MIG_MIGRATION_INFO status as 'Wait_Discounts'
                MIGR_ARCHIVE.ARCHIVE_MD_DISCOUNTS_FILE(v_queued_batch);

                --   l_LogRec.logMsg := 'Failed step: ' || c1.PROCESS || ' ' || SQLERRM;
                ---   MIGR_LOG.LOG_ERROR(l_LogRec);
                MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION(v_queued_batch, MIGR_GVAR.GV_MSG_CODE_MIGR_FAILED_DISC);

                UPDATE MIG_MIGRATION_INFO mmi
                  SET STATUS = MIGR_GVAR.GV_BATCH_STATUS_WAIT_DISC, END_TIMESTAMP = SYSTIMESTAMP
                  WHERE mmi.MIGRATION_BATCH_ID = v_queued_batch;

                EXIT;
              ELSE
                UPDATE MIG_MIGRATION_INFO mmi
                  SET STATUS = MIGR_GVAR.GV_BATCH_STATUS_FAILED, END_TIMESTAMP = SYSTIMESTAMP
                  WHERE mmi.MIGRATION_BATCH_ID = v_queued_batch;
                --   l_LogRec.logMsg := 'Failed step: ' || c1.PROCESS || ' ' || SQLERRM;
                ---    MIGR_LOG.LOG_ERROR(l_LogRec);
                MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION(v_queued_batch, MIGR_GVAR.GV_MSG_CODE_MIGR_FAILED);
                EXIT;
              END IF;
            END IF;

          END LOOP;

        ELSE
          l_status := 'COMPLETE';
        END IF;

      ELSE
        l_LogRec.logMsg := 'ERROR: Step is null';
        MIGR_LOG.LOG_EXCEPTION(l_LogRec);
      END IF;
      --    end loop;



      IF l_status = 'COMPLETE'
        AND v_resume_batch = 1
      THEN


        vsql := 'UPDATE MIG_MIGRATION_INFO mmi SET mmi.resume_process='''' WHERE  mmi.resume_process=''In Progress'' AND mmi.MIGRATION_BATCH_ID=:batch';
        EXECUTE IMMEDIATE vsql
        USING v_queued_batch;
        --           vsql:='delete from  ETL_RESUME_BATCHES where  MIGRATION_BATCH_ID=:batch';
        --           EXECUTE IMMEDIATE vsql USING v_queued_batch;
        COMMIT;
      --         l_LogRec.logMsg := 'RESUME finished';
      --         MIGR_LOG.LOG_INFO(l_LogRec);
      END IF;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END RESUME_MAIN;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --FA.20180125 Check if subsequently to RAC node crash there jobs running in the node that did not crash and let them complete prior to any remediation action
  PROCEDURE CHECK_RAC_RUNNING_POLICIES
    IS
      v_jobsRunning NUMBER;
      l_LogRec      MIGR_GVAR.LogRecTyp;
    BEGIN
      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME_R.CHECK_RAC_RUNNING_POLICIES';
      l_LogRec.logMsg := 'Check if there are jobs running in the node that did not crash prior to any remediation action';
      MIGR_LOG.LOG_INFO(l_LogRec);
      v_jobsRunning := 1;

      WHILE v_jobsRunning > 0
        LOOP
          SELECT COUNT(1)
            INTO v_jobsRunning
            FROM IA_POLICY a
              JOIN USER_SCHEDULER_JOBS JOB
                ON A.IA_IDPL = SUBSTR(REGEXP_SUBSTR(job_action, '[^,]+', 1, 2), 3, 12)
            WHERE 1 = 1
              AND a.MIG_FLAG IN (MIGR_GVAR.GV_MIG_FLAG_RUNNING, MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS);

          l_LogRec.logMsg := 'Jobs Running in the node that didn''t crash:' || v_jobsRunning;
          MIGR_LOG.LOG_INFO(l_LogRec);
          DBMS_LOCK.SLEEP(15);
        END LOOP;


    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
    END;
  ----------------------------------------------------------------------------------------------------------------------------------------

  -- first action of MIGR_RUN_API. identifies RUNNING and RUNNING_DISCOUNTS policies right after a system resumption and re-initialises them. exception: Confirmed policies resumed in Phase 2 are manually converted

  PROCEDURE initialize_Running_policies
    AS
      vsql                 VARCHAR2(500);
      l_LogRec             MIGR_GVAR.LogRecTyp;
      v_running_found      PLS_INTEGER := 0;
      v_running_disc_found PLS_INTEGER := 0;
      l_policyRec          MIGR_GVAR.PolicyRecTyp;
      l_eventTimer         TIMESTAMP;
      l_beginTimer         TIMESTAMP WITH TIME ZONE;
      l_runPhase2          PLS_INTEGER;
    BEGIN
      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME_R.initialize_Running_policies';
      l_LogRec.logMsg := 'initialize_Running_policies started';
      MIGR_LOG.LOG_INFO(l_LogRec);
      l_beginTimer := NULL;

      ---- FA. 20180125 RAC addition: Pol Jobs are running in node A and node B->Node b jobs should be completed prior to initialize  the node A crashed jobs
      CHECK_RAC_RUNNING_POLICIES;
      -- for running idpls delete data in INSIS and relative MIGR_O tables (if exist)

      FOR c1 IN (SELECT a.IA_IDPL,
                        e.POLICY_ID,
                        c.MIGR_TBL,
                        a.MIG_BATCH_ID AS MIGRATION_BATCH_ID,
                        a.mig_mutual_id
          FROM IA_POLICY a
            ---- LEFT JOIN MIGR_POLICY b on a.IA_idpl=b.POLICY_idpl
            LEFT JOIN ETL_IA_INSRPRD_CONFIG c
              ON a.IA_PARENT_INSR_TYPE = c.INSR_TYPE
              LEFT JOIN INSIS_GEN_V10.POLICY e
                ON TO_CHAR(a.IA_POLICY_REF) = E.POLICY_REF
                AND a.IA_OFFICE_ID = E.OFFICE_ID
          WHERE 1 = 1
            AND a.mig_flag = MIGR_GVAR.GV_MIG_FLAG_RUNNING)
      LOOP
        v_running_found := 1;
        l_LogRec.migrRelKey := c1.IA_IDPL;
        l_LogRec.logMsg := 'About to delete MIGR data for IA_IDPL:''' || c1.IA_IDPL || ''' of batch:''' || c1.MIGRATION_BATCH_ID || '''';
        MIGR_LOG.LOG_INFO(l_LogRec);
        l_LogRec.mig_batch_id := c1.migration_batch_id;

        IF NVL(c1.policy_id, 0) <> 0
        THEN

          --delete in MIGR_O
          vsql := 'DELETE FROM ' || c1.MIGR_TBL || ' where policy_idpl=:idpl';
          EXECUTE IMMEDIATE vsql
          USING c1.IA_IDPL;

          -- delete in MIGR_POLICY
          vsql := 'DELETE FROM MIGR_POLICY where policy_idpl=:idpl';
          EXECUTE IMMEDIATE vsql
          USING c1.IA_IDPL;

          --cancel policy in INSIS
          MIGR_SYSTEM.CANCEL_INSIS_POLICY(c1.POLICY_ID, c1.mig_mutual_id);
        END IF;

        -- initialise mig_flag
        MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(c1.IA_IDPL, MIGR_GVAR.GV_MIG_FLAG_PENDING, c1.MIGRATION_BATCH_ID);
        l_LogRec.logMsg := 'IA_IDPL:''' || c1.IA_IDPL || ''' of batch:''' || c1.MIGRATION_BATCH_ID || ''' is reinitialised';
        MIGR_LOG.LOG_INFO(l_LogRec);

      END LOOP;

      IF v_running_found = 0
      THEN
        l_LogRec.logMsg := 'No RUNNING policies were found';
        MIGR_LOG.LOG_INFO(l_LogRec);
        --FA.20170808 If API Phase 1 will run normal and  not from resume phase store INSIS log level values
        --             FOR c IN   (   SELECT mmi.STATUS , mmi.MIGRATION_BATCH_ID FROM MIG_MIGRATION_INFO mmi ) LOOP
        --
        --                l_LogRec.logMsg := 'STATUS:'||c.STATUS || '  -MIGRATION_BATCH_ID '||c.MIGRATION_BATCH_ID;
        --                MIGR_LOG.LOG_INFO(l_LogRec);
        --
        --             END LOOP;
        SELECT COUNT(*)
          INTO l_runPhase2
          FROM MIG_MIGRATION_INFO mmi
          WHERE mmi.STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC, MIGR_GVAR.GV_BATCH_STATUS_QUEUED_DISC);

        --             l_LogRec.logMsg := 'l_runPhase2:'||l_runPhase2;
        --          MIGR_LOG.LOG_INFO(l_LogRec);
        IF l_runPhase2 > 0
        THEN
          MIGR_API_COMMON.STORE_INSIS_LOG_LEVEL;
        END IF;
      END IF;



      --PHASE 2

      FOR c IN (SELECT a.IA_IDPL,
                       E.POLICY_ID,
                       E.POLICY_STATE,
                       a.MIG_BATCH_ID,
                       a.MIG_FLAG,
                       E.POLICY_REF,
                       E.CLIENT_ID,
                       E.AGENT_ID,
                       a.IA_INSRPRD,
                       E.INSR_TYPE
          FROM IA_POLICY a
            LEFT JOIN INSIS_GEN_V10.POLICY E
              ON TO_CHAR(a.IA_POLICY_REF) = E.POLICY_REF
              AND a.IA_OFFICE_ID = E.OFFICE_ID
          WHERE 1 = 1
            AND a.mig_flag = MIGR_GVAR.GV_MIG_FLAG_RUNNING_DISCOUNTS)
      LOOP
        v_running_disc_found := 1;
        l_policyRec.policy_id := c.POLICY_ID;
        l_policyRec.mig_flag := c.MIG_FLAG;
        l_policyRec.continue_migr := TRUE;
        l_policyRec.policy_ref := c.POLICY_REF;
        l_policyRec.client_id := c.CLIENT_ID;
        l_policyRec.agent_id := c.AGENT_ID;
        l_policyRec.insrprd := c.IA_INSRPRD;
        l_policyRec.insr_type := c.INSR_TYPE;
        l_policyRec.policy_idpl := c.IA_IDPL;
        l_policyRec.policy_final_step := 'CONFIRMED';
        l_policyRec.mig_batch_id := C.MIG_BATCH_ID;
        --if policy is in status CONFIRMED, run only CONVERT_POLICY and LOG policy in MIGR_POLICY
        IF c.POLICY_STATE = '-2'
        THEN
          l_eventTimer := SYSTIMESTAMP;
          MIGR_TST_PRC_API_POLICY.CONVERT_APPLICATION(l_policyrec);
          l_policyrec.logMsg := 'CONVERTED: ' || MIGR_SYSTEM.FN_ELAPSEDMS(SYSTIMESTAMP, l_eventTimer);
          MIGR_LOG.LOG_EVENT_TIME(l_policyrec);

          MIGR_LOG.LOG_POLICY(l_policyRec, l_beginTimer, l_policyRec.policy_final_step);   --l_beginTimer is not meaningful here because is the policy is not fully migrated in one stream. value here is null
        --if policy is in status other than CONFIRMED, policy should rerun the whole phase 2
        ELSE
          MIGR_API_COMMON.UPDATE_IA_POLICY_MIG_FLAG(c.IA_IDPL, MIGR_GVAR.GV_MIG_FLAG_WAIT_DISCOUNTS, c.MIG_BATCH_ID);
        END IF;


      END LOOP;

      IF v_running_disc_found = 0
      THEN
        l_LogRec.logMsg := 'No RUNNING_DISCOUNTS policies were found';
        MIGR_LOG.LOG_INFO(l_LogRec);
        --FA.20170808 If API Phase 2 will run normal and  not from resume phase store INSIS log level values
        SELECT COUNT(*)
          INTO l_runPhase2
          FROM MIG_MIGRATION_INFO mmi
          WHERE mmi.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC;
        IF l_runPhase2 > 0
        THEN
          MIGR_API_COMMON.STORE_INSIS_LOG_LEVEL;
        END IF;
      END IF;

      COMMIT;


    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM || ' ' || vsql;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END initialize_Running_policies;



  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- identify the migration step where the batch has stopped

  PROCEDURE CHECK_PROCESS_STATUS(p_migration_batch_id IN  MIG_MIGRATION_INFO.MIGRATION_BATCH_ID % TYPE,
                                 resume_step          OUT VARCHAR2)
    AS
      l_status VARCHAR2(20);
      l_LogRec MIGR_GVAR.LogRecTyp;

    BEGIN
      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME_R.CHECK_PROCESS_STATUS';
      l_LogRec.mig_batch_id := p_migration_batch_id;

      --Check running batches
      FOR cor IN (SELECT *
          FROM MIG_MIGRATION_INFO
          WHERE STATUS IN (MIGR_GVAR.GV_BATCH_STATUS_RUNNING, MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC)
            AND MIGRATION_BATCH_ID = p_migration_batch_id)
      LOOP



        --found running batches
        --step 1 :identify last successful step   - delete all problematic data
        IF NVL(cor.RESUME_PROCESS, ' ') = ' '
          AND cor.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING
        THEN
          resume_step := 'FULL';

        ELSIF NVL(cor.RESUME_PROCESS, ' ') = ' '
          AND cor.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC
        THEN
          resume_step := 'FULL_DISCOUNTS';

        ELSIF cor.RESUME_PROCESS = 'In Progress'
          AND cor.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING
        THEN

          IF cor.LA_COMPLETED = 'Pending'
          THEN
            resume_step := 'LA';
          ELSIF cor.SA_COMPLETED = 'Pending'
          THEN
            resume_step := 'SA';
          ELSIF cor.RULES_COMPLETED = 'Pending'
          THEN
            resume_step := 'RULES';
          ELSIF cor.IA_COMPLETED = 'Pending'
          THEN
            resume_step := 'IA';
          END IF;

        --FA.20170404 Added check status for discounts completed step-if finished do not resume discounts steps
        ELSIF cor.RESUME_PROCESS = 'In Progress'
          AND cor.STATUS = MIGR_GVAR.GV_BATCH_STATUS_RUNNING_DISC
          AND COR.DISCOUNT_COMPLETED = 'Pending'
        THEN
          resume_step := 'RESUME_DISCOUNTS';

        -- FA.20170404 If aboev cases are not valid assume that all step has been completed
        ELSE
          resume_step := 'Steps Completed';

        END IF;

      END LOOP;
      l_LogRec.logMsg := 'Migration for batch: ''' || p_migration_batch_id || ''' will be resumed from ' || resume_step || ' step';
      MIGR_LOG.LOG_INFO(l_LogRec);

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END CHECK_PROCESS_STATUS;

  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  PROCEDURE DELETE_LA_to_IA_DISCOUNTS(p_migration_batch_id IN  VARCHAR2,
                                      Status               OUT VARCHAR2)
    AS
      vsql          VARCHAR(2100);
      l_file_name   NVARCHAR2(50);
      l_bolag_name  NVARCHAR2(50);
      l_tbl_cnt     PLS_INTEGER;
      l_addtnl_flds VARCHAR2(10);
      l_Status      VARCHAR2(50);
      l_LogRec      MIGR_GVAR.LogRecTyp;
      v_my_schema   VARCHAR2(50);



    BEGIN
      l_LogRec.migrArea := 'MIGR_PROCESS_RESUME_R.DELETE_LA_to_IA_DISCOUNTS';
      l_LogRec.mig_batch_id := p_migration_batch_id;

      SELECT SYS_CONTEXT('userenv', 'current_schema')
        INTO v_my_schema
        FROM dual;

      DELETE FROM MIG_DETAIL_ERROR_LOG
        WHERE MIGRATION_BATCH_ID = p_migration_batch_id
          AND RELATED_TABLE = 'MD_DISCOUNTS';
      DELETE FROM MIG_VOLUMETRIC_ANALYSIS
        WHERE MIGRATION_BATCH_ID = p_migration_batch_id
          AND TABLE_NAME = 'MD_DISCOUNTS';

      --delete batch data from LA, SA
      FOR c IN (SELECT TO_CHAR(DEST_TABLE) AS DEST_TABLE
          FROM ETL_ENGINE a,
               MIG_MIGRATION_INFO b
          WHERE 1 = 1
            AND MIGRATION_AREA IN ('Landing', 'Staging')
            AND a.BOLAG_ID = b.BOLAG_ID
            AND b.MIGRATION_BATCH_ID = p_migration_batch_id
            AND TBLNAME = 'MD_DISCOUNTS'
          UNION ALL
        SELECT table_name AS DEST_TABLE
          FROM ALL_ALL_TABLES
          WHERE 1 = 1
            AND owner = v_my_schema
            AND REGEXP_LIKE(table_name, '^LA_M' || SUBSTR(p_migration_batch_id, 1, 2) || '(.*)DISCOUNTS_IOT$')
          UNION ALL
        SELECT TO_CHAR(DEST_TABLE) AS DEST_TABLE
          FROM ETL_SA_IA
          WHERE MIGRATION_AREA = 'SA_IA'
            AND IS_ACTIVE = 'TRUE'
            AND STEP = 'MD_DISCOUNTS')
      LOOP
        vsql := 'delete from ' || c.DEST_TABLE || ' where mig_batch_id =:p_mig_batch';
        EXECUTE IMMEDIATE vsql
        USING p_migration_batch_id;
      END LOOP;


      Status := 'COMPLETE';
      l_LogRec.logMsg := 'DELETE_LA_to_IA_DISCOUNTS ran successfully';
      MIGR_LOG.LOG_INFO(l_LogRec);
      COMMIT;




    EXCEPTION

      WHEN OTHERS THEN
          --DBMS_OUTPUT.PUT_LINE('DELETE_LA:' || SQLERRM());
          l_LogRec.logMsg := SQLERRM || ' vsql: ' || vsql;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);
          Status := 'INCOMPLETE';

    END DELETE_LA_to_IA_DISCOUNTS;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGR_TST_PRC_RESUME;
/

CREATE OR REPLACE PACKAGE BODY                    MIGR_TST_PRC_SCHEDULED_JOBS
  AS

  --You must have the CREATE JOB privilege to create a job in your own schema
  --As soon as you enable a job, it is automatically run by the Scheduler at its next scheduled date and time.
  --By default, jobs are disabled when created and must be enabled with DBMS_SCHEDULER.ENABLE to run.
  --Jobs are set to be automatically dropped by default after they complete.
  --Setting the auto_drop attribute to FALSE causes the job to persist.
  --Note that repeating jobs are not auto-dropped unless the job end date passes, the maximum number of runs (max_runs) is reached, or the maximum number of failures is reached (max_failures).
  --After a job is created, it can be queried using the *_SCHEDULER_JOBS views.


  ---------------------------------------------------------------------------------------------------
  PROCEDURE CREATE_MIGR_JOBS(p_job_name        IN VARCHAR2,
                             p_job_action      IN VARCHAR2,
                             p_repeat_interval IN VARCHAR2,
                             p_start_date      IN TIMESTAMP,
                             p_end_date        IN TIMESTAMP)
    AS
    BEGIN

      DBMS_SCHEDULER.CREATE_JOB(
      JOB_NAME => p_job_name,
      JOB_TYPE => 'PLSQL_BLOCK',
      JOB_ACTION => p_job_action,
      START_DATE => p_start_date,
      REPEAT_INTERVAL => p_repeat_interval,
      END_DATE => p_end_date,
      AUTO_DROP => FALSE);


    END CREATE_MIGR_JOBS;

  -------------------------------------------------------------------
  -------------------------------------------------------------------

  PROCEDURE ENABLE_MIGR_JOB(p_job_name IN VARCHAR2)
    AS
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN


      DBMS_SCHEDULER.ENABLE(NAME => p_job_name);

         l_LogRec.logMsg := 'MIGR_RUN_PARALLEL_JOB has success';
             MIGR_LOG.LOG_INFO(l_LogRec) ;


    EXCEPTION
      WHEN OTHERS THEN

         l_LogRec.logMsg := 'MIGR_RUN_PARALLEL_JOB has failed';
             MIGR_LOG.LOG_INFO(l_LogRec) ;
          l_LogRec.mig_batch_id := '0-0';
          l_LogRec.migrArea := 'MIGR_TST_PRC_SCHEDULED_JOBS.ENABLE_MIGR_JOB';
          l_LogRec.migrStep := 'MIGR_TST_PRC_SCHEDULED_JOBS.ENABLE_MIGR_JOB';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);


    END ENABLE_MIGR_JOB;

  -------------------------------------------------------------------
  -------------------------------------------------------------------
  --If the job is running when the disable procedure is called, you get an error.
  --You can stop the running job as shown in the last example, or you can add force => true to the disable statement

  PROCEDURE DISABLE_MIGR_JOB(p_job_name IN VARCHAR2)
    AS
      l_logRec MIGR_GVAR.LogRecTyp;
    BEGIN
      DBMS_SCHEDULER.DISABLE(NAME => p_job_name);
    EXCEPTION
      WHEN OTHERS THEN
          l_LogRec.mig_batch_id := '0-0';
          l_LogRec.migrArea := 'MIGR_TST_PRC_SCHEDULED_JOBS.DISABLE_MIGR_JOB';
          l_LogRec.migrStep := 'MIGR_TST_PRC_SCHEDULED_JOBS.DISABLE_MIGR_JOB';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);


    END DISABLE_MIGR_JOB;
  -------------------------------------------------------------------
  -------------------------------------------------------------------

  PROCEDURE STOP_MIGR_RUNNING_JOB(p_job_name IN VARCHAR2)
    IS
      l_logRec MIGR_GVAR.LogRecTyp;
    BEGIN
      DBMS_SCHEDULER.STOP_JOB(JOB_NAME => p_job_name);

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-0';
          l_LogRec.migrArea := 'MIGR_TST_PRC_SCHEDULED_JOBS.STOP_MIGR_RUNNING_JOB';
          l_LogRec.migrStep := 'MIGR_TST_PRC_SCHEDULED_JOBS.STOP_MIGR_RUNNING_JOB';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END STOP_MIGR_RUNNING_JOB;

  -------------------------------------------------------------------
  -------------------------------------------------------------------

  --if a job is running when you try to drop it, you get an error.
  --You can stop the job, then drop it or set the force parameter to true.
  --Setting force to true causes the running job to be stopped, and then the job is dropped from the scheduler.
  PROCEDURE DROP_MIGR_JOB(p_job_name IN VARCHAR2)
    AS
      l_LogRec MIGR_GVAR.LogRecTyp;
    BEGIN
      DBMS_SCHEDULER.DROP_JOB(JOB_NAME => p_job_name);

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-0';
          l_LogRec.migrArea := 'MIGR_TST_PRC_SCHEDULED_JOBS.DROP_MIGR_JOB';
          l_LogRec.migrStep := 'MIGR_TST_PRC_SCHEDULED_JOBS.DROP_MIGR_JOB';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);


    END DROP_MIGR_JOB;
  -------------------------------------------------------------------
  -------------------------------------------------------------------
  PROCEDURE START_JOBS
    AS
      l_logRec MIGR_GVAR.LogRecTyp;
      JOB_NAME      VARCHAR2(50);
      JOB_ACTION    VARCHAR2(3000);
      JOB_INTERVAL  VARCHAR2(50);
      START_DATE    TIMESTAMP;
      END_DATE      TIMESTAMP;
      v_exists      NUMBER;
      v_exists1     NUMBER;
      v_exists2     NUMBER;
      v_runs        NUMBER;
      l_env         VARCHAR2(50);

    BEGIN

      SELECT START_DATE, END_DATE
        INTO START_DATE, END_DATE
      FROM ETL_JOB_CONFIGURATION
      FETCH first row only;

      SELECT UPPER(value) INTO l_env FROM V$PARAMETER WHERE name LIKE '%service_name%';

      JOB_NAME := 'MIGR_RUN_SIGNAL_JOB';
      JOB_INTERVAL := 'FREQ=MINUTELY;INTERVAL=1';

      JOB_ACTION := 'declare l_LogRec MIGR_GVAR.LogRecTyp; BEGIN  l_LogRec.logMsg := ''Error in job action of MIGR_RUN_SIGNAL_JOB''; MIGR_TST_PRC_SIGNAL.RUN_SIGNAL(''Y'');
                     exception when others then  MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                     END;';

      IF l_env LIKE 'INSISDB%' THEN
        DBMS_SCHEDULER.SET_ATTRIBUTE(name => JOB_NAME, attribute=>'INSTANCE_ID', value=>'1');
      END IF;

SELECT COUNT(*)
  INTO v_exists
  FROM USER_SCHEDULER_JOBS a
  WHERE a.job_name = JOB_NAME;
SELECT COUNT(*)
  INTO v_runs
  FROM USER_SCHEDULER_JOBS a
  WHERE a.job_name = JOB_NAME
    AND a.STATE = 'RUNNING';

SELECT COUNT(*)
  INTO v_exists1
  FROM USER_SCHEDULER_JOBS a
  WHERE a.job_name = 'MIGR_RUN_PARALLEL_JOB';
SELECT COUNT(*)
  INTO v_exists2
  FROM USER_SCHEDULER_JOBS a
  WHERE a.job_name = 'MIGR_RUN_API';

      IF v_exists=0 THEN
        CREATE_MIGR_JOBS(JOB_NAME, JOB_ACTION, JOB_INTERVAL, START_DATE, END_DATE);
      END IF;
      IF v_runs=0 THEN
        ENABLE_MIGR_JOB(JOB_NAME);
      END IF;

      JOB_NAME := 'MIGR_RUN_PARALLEL_JOB';
      JOB_INTERVAL := NULL;

      JOB_ACTION := 'declare l_LogRec MIGR_GVAR.LogRecTyp; BEGIN l_LogRec.logMsg := ''Error in job action of MIGR_RUN_PARALLEL_JOB''; MIGR_TST_PRC_SCHEDULED_JOBS.RUN_PARALLEL();
                     exception when others then MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                     END;';

      IF v_exists1=0 THEN
        CREATE_MIGR_JOBS(JOB_NAME, JOB_ACTION, JOB_INTERVAL, START_DATE, END_DATE);
      END IF;

      JOB_NAME := 'MIGR_RUN_API';
      JOB_INTERVAL := NULL;

      JOB_ACTION := 'declare l_LogRec  MIGR_GVAR.LogRecTyp;  BEGIN l_LogRec.logMsg := ''Error in job action of MIGR_RUN_API''; MIGR_TST_PRC_API.STATE_MACHINE_RUN_API();
                     exception when others then MIGR_LOG.LOG_EXCEPTION(l_LogRec);
                     END;';
      IF l_env LIKE 'INSISDB%' THEN
        DBMS_SCHEDULER.SET_ATTRIBUTE(name => JOB_NAME, attribute=>'INSTANCE_ID', value=>'2');
      END IF;

      IF v_exists2=0 THEN
        CREATE_MIGR_JOBS(JOB_NAME, JOB_ACTION, JOB_INTERVAL, START_DATE, END_DATE);
      END IF;

    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-0';
          l_LogRec.migrArea := 'MIGR_TST_PRC_SCHEDULED_JOBS.START_JOBS';
          l_LogRec.migrStep := 'MIGR_TST_PRC_SCHEDULED_JOBS.START_JOBS';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);

    END START_JOBS;
  -------------------------------------------------------------------
  -------------------------------------------------------------------

  --valex.10/1/2017 - spawn jobs for DISCOUNTS batches also
  PROCEDURE RUN_PARALLEL
    IS
       l_jobno         PLS_INTEGER;
      v_job_count     INTEGER;
      v_Transactional CHAR(1);
      v_job_name      VARCHAR2(100);
      vjob            INTEGER;
      v_interval      INTEGER;
      v_start_date    TIMESTAMP WITH TIME ZONE;
      v_running   NUMBER;
      v_available_jobs     NUMBER;
      v_max_available NUMBER;
      l_logRec MIGR_GVAR.LogRecTyp;
      l_env      VARCHAR2(50);
    BEGIN

      sELECT MIGG_JOB_TRANSACTIONAL,BATCH_PARALLEL_JOBS  INTO v_Transactional  ,v_max_available  FROM ETL_SETUP_INFO;
      vjob := 0;

      SELECT COUNT('X')  INTO v_job_count  FROM MIG_MIGRATION_INFO A  WHERE A.STATUS in ( 'Queued','Queued_Discounts');

       --FA.20160706 Always keep max xx running batches
      SELECT COUNT(*)  INTO v_running  FROM USER_SCHEDULER_JOBS   where JOB_NAME LIKE 'MIGRATE%';

      IF  v_max_available - v_running >0 THEN
         v_available_jobs:= v_max_available - v_running;

         IF   v_available_jobs >= v_job_count THEN
            v_available_jobs :=v_job_count;
         END IF;

         FOR I IN (SELECT BOLAG_ID, status
                      FROM MIG_MIGRATION_INFO
                      WHERE STATUS in ( 'Queued' ,'Queued_Discounts')
            )
            LOOP

               vjob := vjob + 1;

               IF v_available_jobs >=  vjob THEN
                   IF i.status='Queued' THEN v_job_name := 'MIGRATE_BOLAG_';
                   ELSE v_job_name := 'MIGRATE_BOLAG_DISC_';
                   END  IF;

                  SELECT UPPER(value) INTO l_env FROM V$PARAMETER WHERE name LIKE '%service_name%';

                   --FA.20151112 First check if job has already been created
                   FOR c IN (SELECT 'X'
                                     FROM DUAL
                                    WHERE 0=(SELECT COUNT(*)
                                      FROM USER_SCHEDULER_JOBS usj
                                      WHERE JOB_NAME = v_job_name || TO_CHAR(i.BOLAG_ID))
                   )
                   LOOP

                    IF l_env NOT LIKE 'INSISDB%' THEN

                      l_LogRec.logMsg := 'l_env: ' || l_env;
                      MIGR_LOG.LOG_INFO(l_LogRec);


                     DBMS_SCHEDULER.CREATE_JOB(job_name => v_job_name || TO_CHAR(i.BOLAG_ID),
                        JOB_TYPE=>'PLSQL_BLOCK' ,
                        JOB_ACTION=>  'declare '
                                   || '  l_LogRec MIGR_GVAR.LogRecTyp; '
                                   || 'BEGIN '
                                   || '  l_LogRec.logMsg := ''Error in job action of Migration Job'';'
                                   || ' MIGR_TST_PRC_RESUME.RESUME_MAIN('||i.BOLAG_ID||'); '
                                   || ' exception when others then   '
                                   || ' MIGR_LOG.LOG_EXCEPTION(l_LogRec); '
                                   || 'END; ' ,
                        START_DATE => systimestamp + INTERVAL '10' SECOND,
                        AUTO_DROP => TRUE,
                        ENABLED => TRUE
                      )   ;

                   ELSE

                      l_LogRec.logMsg := 'else l_env: ' || l_env;
                      MIGR_LOG.LOG_INFO(l_LogRec);

                      DBMS_SCHEDULER.CREATE_JOB(job_name => v_job_name || TO_CHAR(i.BOLAG_ID),
                        JOB_TYPE=>'PLSQL_BLOCK' ,
                        JOB_ACTION=>  'declare '
                                   || '  l_LogRec MIGR_GVAR.LogRecTyp; '
                                   || 'BEGIN '
                                   || '  l_LogRec.logMsg := ''Error in job action of Migration Job'';'
                                   || ' MIGR_TST_PRC_RESUME.RESUME_MAIN('||i.BOLAG_ID||'); '
                                   || ' exception when others then   '
                                   || ' MIGR_LOG.LOG_EXCEPTION(l_LogRec); '
                                   || 'END; ' ,
                        START_DATE => systimestamp + INTERVAL '10' SECOND,
                        AUTO_DROP => TRUE,
                        ENABLED => FALSE
                      )   ;

                      IF i.BOLAG_ID IN (27,29) THEN
                        DBMS_SCHEDULER.SET_ATTRIBUTE(name => v_job_name || TO_CHAR(i.BOLAG_ID), attribute=>'INSTANCE_ID', value=>'1');
                      ELSE
                        DBMS_SCHEDULER.SET_ATTRIBUTE(name => v_job_name || TO_CHAR(i.BOLAG_ID), attribute=>'INSTANCE_ID', value=>'2');
                      END IF;

                      ENABLE_MIGR_JOB(v_job_name || TO_CHAR(i.BOLAG_ID));

                   END IF;
                   END LOOP;
               END IF;

         END LOOP;

      END IF;
    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-0';
          l_LogRec.migrArea := 'MIGR_TST_PRC_SCHEDULED_JOBS.RUN_PARALLEL';
          l_LogRec.migrStep := 'MIGR_TST_PRC_SCHEDULED_JOBS.RUN_PARALLEL';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);


    END RUN_PARALLEL;

  -------------------------------------------------------------------
  -------------------------------------------------------------------
  --Always drop program if exists and create
  PROCEDURE CREATE_PROGRAM
    AS
      ---  vSQL VARCHAR2(2100);
      l_logRec MIGR_GVAR.LogRecTyp;
    BEGIN
      --- vSQL := 'NOT STARTED';
      FOR cRec IN (SELECT usp.PROGRAM_NAME,
                          usp.ENABLED
          FROM USER_SCHEDULER_PROGRAMS usp
          WHERE 1 = 1
            AND usp.PROGRAM_NAME = 'RUN_TRANSACTIONAL')
      LOOP
        -- IF CREC.ENABLED = 'TRUE'  THEN  vSQL := 'RUNNING';   ELSE   vSQL := 'DISABLED';    END IF;
        DBMS_SCHEDULER.DROP_PROGRAM('Run_Transactional');
      END LOOP;

      ---   IF vSQL = 'NOT STARTED'    THEN

      DBMS_SCHEDULER.create_program(
      program_name => 'Run_Transactional',
      program_action =>
      'declare '
      || '  l_LogRec      MIGR_GVAR.LogRecTyp; '
      || 'BEGIN '
      || '  l_LogRec.logMsg := ''Error in job action of Migration Job'';'
      || ' MIGR_TST_PRC_RESUME.RESUME_MAIN; '
      || ' exception when others then   '
      || ' MIGR_LOG.LOG_EXCEPTION(l_LogRec); '
      || 'END; ',
      program_type => 'plsql_block',
      enabled => TRUE);
    /* ELSIF vSQL = 'DISABLED'    THEN   DBMS_SCHEDULER.ENABLE('RUN_TRANSACTIONAL');
     ELSIF vSQL = 'RUNNING'     THEN     NULL;
     END IF;*/


    EXCEPTION
      WHEN OTHERS THEN l_LogRec.mig_batch_id := '0-0';
          l_LogRec.migrArea := 'MIGR_TST_PRC_SCHEDULED_JOBS.CREATE_PROGRAM';
          l_LogRec.migrStep := 'MIGR_TST_PRC_SCHEDULED_JOBS.CREATE_PROGRAM';
          l_LogRec.migrRelTbl := NULL;
          l_LogRec.migrRelKey := NULL;
          l_LogRec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_LogRec);


    END CREATE_PROGRAM;
-------------------------------------------------------------------------------------

END MIGR_TST_PRC_SCHEDULED_JOBS;
/

CREATE OR REPLACE PACKAGE BODY                    MIGRATE_CLIENTS
  AS

  /*
   USEFUL QUERIES:
  SELECT usj.OWNER, usj.JOB_NAME, usj.JOB_TYPE, usj.JOB_ACTION, usj.START_DATE, usj.END_DATE, usj.REPEAT_INTERVAL, usj.STATE FROM DBA_SCHEDULER_JOBS usj    WHERE usj.OWNER = 'INSIS_MIGR_EY' AND usj.JOB_NAME = 'MIGR_GET_CLIENT_JOB';
  SELECT * FROM USER_SCHEDULER_JOB_LOG usjl ORDER BY usjl.LOG_DATE DESC;
  SELECT * FROM USER_SCHEDULER_JOB_RUN_DETAILS usjrd ORDER BY LOG_ID DESC;
  DBMS_SCHEDULER.STOP_JOB(JOB_NAME => 'INSIS_MIGR_EY.MIGR_GET_CLIENT_JOB', FORCE => TRUE);
  EXEC DBMS_PARALLEL_EXECUTE.STOP_TASK( 'Parallel_Clients_Chunks_By_SQL' );
  EXEC DBMS_PARALLEL_EXECUTE.DROP_TASK( 'Parallel_Clients_Chunks_By_SQL' );

  */

  PROCEDURE GET_CLIENT(vGEGN IN VARCHAR2,p_batchId IN VARCHAR2)
    IS

      l_log_rec        MIGR_GVAR.LogRecTyp;
      L_IN_CONTEXT     SRVCONTEXT;
      L_OUT_CONTEXT    SRVCONTEXT;
      PIO_ERR          SRVERR;
      l_man_address_tb SRV_PEOPLE_DATA.gAddressTable % TYPE;
      vMAN_ID          VARCHAR2(50);
      vCLIENT_ID       VARCHAR2(50);
      vEXEC_ID         VARCHAR2(50);
      l_count          NUMBER;
      vSQL             VARCHAR2(4000);
      l_address        VARCHAR2(4000);
      V_ERRORS         NUMBER;
      v_timestamp      TIMESTAMP;
      v_errMsg         VARCHAR2(2000);
      v_migrated       VARCHAR(10);
      v_clients_timeout_mins    NUMBER;  --EZ 23/4/2019
      v_clients_timeout_errors  NUMBER;  --EZ 23/4/2019
    BEGIN
     l_log_rec.mig_batch_id := p_batchId;
      l_log_rec.migrArea     := 'MIGRATE_CLIENTS.GET_CLIENT';

      vSQL := '';
      L_IN_CONTEXT  := NULL;
      L_OUT_CONTEXT := NULL;
      PIO_ERR    := NULL;
      vMAN_ID    := NULL;
      vCLIENT_ID := NULL;
      vEXEC_ID   := NULL;
      v_errMsg   := NULL;
      INSIS_SYS_V10.SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PARTY_ID', '');
      INSIS_SYS_V10.SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'SOCIAL_SECURITY_NO', vGEGN);

      MIGR_SYSTEM.CALL_EVENT('GET_CLIENT_DETAILS', L_IN_CONTEXT, 'FALSE', L_OUT_CONTEXT, PIO_ERR, 'TRUE');

      IF PIO_ERR IS NOT NULL
      THEN

        FOR I IN PIO_ERR.FIRST .. PIO_ERR.LAST
        LOOP

          v_timestamp := SYSTIMESTAMP;
          v_errMsg    := v_errMsg || 'Type: ' || PIO_ERR(I).ERRTYPE || ' | MSG: ' || PIO_ERR(I).ERRMESSAGE;
          v_migrated  := 'N';
        END LOOP;
      ELSE

        INSIS_SYS_V10.SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'MAN_ID', vMAN_ID);
        INSIS_SYS_V10.SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'CLIENT_ID', vCLIENT_ID);

        IF vMAN_ID IS NULL
        THEN

          v_timestamp := SYSTIMESTAMP;
          v_errMsg    := v_errMsg || 'MAN_ID WAS NOT SET';
          v_migrated  := 'N';
        ELSE

          v_timestamp := SYSTIMESTAMP;

          L_IN_CONTEXT  := NULL;
          L_OUT_CONTEXT := NULL;
          PIO_ERR       := NULL;

          INSIS_SYS_V10.SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'PARTY_ID', '');
          INSIS_SYS_V10.SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'SOCIAL_SECURITY_NO', vGEGN);
          INSIS_SYS_V10.SRV_CONTEXT.SETCONTEXTATTRCHAR(L_IN_CONTEXT, 'MAN_ID', vMAN_ID);

          -- CALL EVENT -> 'GET_CONTACT_PREFERENCE_DETAILS_FROM_EPA'
          MIGR_SYSTEM.CALL_EVENT('GET_CONTACT_PREFERENCE_DETAILS_FROM_EPA', L_IN_CONTEXT, 'FALSE', L_OUT_CONTEXT, PIO_ERR, 'TRUE');

          IF NOT PIO_ERR IS NULL
          THEN
            FOR I IN PIO_ERR.FIRST .. PIO_ERR.LAST
            LOOP

              v_timestamp := SYSTIMESTAMP;
              v_errMsg    := v_errMsg || 'Type: ' || PIO_ERR(I).ERRTYPE || ' | MSG: ' || PIO_ERR(I).ERRMESSAGE;
              v_migrated  := 'N';
            END LOOP;
          ELSE

            INSIS_SYS_V10.SRV_CONTEXT.GETCONTEXTATTRCHAR(L_OUT_CONTEXT, 'EXECUTION_ID', vEXEC_ID);

            IF vEXEC_ID IS NULL
            THEN

              v_timestamp := SYSTIMESTAMP;
              v_errMsg    := v_errMsg || 'EXEC_ID WAS NOT SET';
              v_migrated  :='N';
            ELSE
              l_man_address_tb := INSIS_CUST.PPL_TYPES.GET_ADDRESSES_BY_PERSONID(vMAN_ID, NULL);

              IF l_man_address_tb.LAST > 0
              THEN

                l_count := l_man_address_tb.LAST;

                FOR i IN 1 .. l_count
                LOOP

                  IF l_man_address_tb(i).PRIMARY_FLAG = 'Y'
                  THEN
                    l_address := l_man_address_tb(i).ADDRESS_ID;
                    EXIT;
                  END IF;
                  l_address := l_man_address_tb(i).ADDRESS_ID;

                END LOOP;
              END IF;

                --FA.20170913 If no address is registered in INSIS mark client as failed to be succesfully migrated
                IF l_address is NULL then
                   v_migrated  :='N';
               ELSE
                   v_migrated  := 'Y';
              END IF;
              v_timestamp := SYSTIMESTAMP;

            END IF;

          END IF;

        END IF;

      END IF;

      UPDATE MIGR_CLIENT
         SET EXEC_ID = vEXEC_ID, TIMESTAMP = v_timestamp, MIGRATED = v_migrated, ADDRESS_ID = l_address, MAN_ID = vMAN_ID, CLIENT_ID = vCLIENT_ID, ERR_MSG = v_errMsg
       WHERE EGN = vGEGN;

      COMMIT;

--      --check if services return with errors the last 2 minutes and if 10 calls returned with errors drop task
--      SELECT COUNT('C')
--        INTO V_ERRORS
--        FROM MIGR_CLIENT
--       WHERE ERR_MSG <> 'PROCESSED'
--         AND TIMESTAMP BETWEEN SYSTIMESTAMP - 5 / (26 * 60) AND SYSTIMESTAMP;
--      IF V_ERRORS >= 1000
--      THEN
--        MIGRATE_CLIENTS.STOP_MIGRATION_PROCESS();
--      END IF;

--EZ 23/4/2019
--check if services return with errors the last x minutes and if y calls returned with errors drop task
--      SELECT clients_timeout_mins, clients_timeout_errors
--        INTO v_clients_timeout_mins, v_clients_timeout_errors
--        FROM ETL_SETUP_INFO;
--
--      IF  v_clients_timeout_mins IS NULL AND v_clients_timeout_errors IS NULL THEN
--          v_clients_timeout_mins:=5;         --minutes default
--          v_clients_timeout_errors:=1000;    --errors default
--      ELSIF  v_clients_timeout_mins IS NULL AND v_clients_timeout_errors IS NOT NULL THEN
--          v_clients_timeout_mins:=5;
--      ELSIF  v_clients_timeout_mins IS NOT NULL AND v_clients_timeout_errors IS NULL THEN
--          v_clients_timeout_errors:=1000;
--      END IF;
--        l_log_rec.logMsg :='Clients_timeout_mins: '||v_clients_timeout_mins||', Clients_timeout_errors: '||v_clients_timeout_errors ;
--        MIGR_LOG.LOG_INFO(l_log_rec);

      SELECT nvl(clients_timeout_mins,5) , nvl(clients_timeout_errors,1000)
        INTO v_clients_timeout_mins, v_clients_timeout_errors
        FROM ETL_SETUP_INFO;

      SELECT COUNT('C')
        INTO V_ERRORS
        FROM MIGR_CLIENT
       WHERE ERR_MSG IS NOT NULL
         AND TIMESTAMP BETWEEN SYSTIMESTAMP - v_clients_timeout_mins / (24 * 60) AND SYSTIMESTAMP;
      IF V_ERRORS >= v_clients_timeout_errors
      THEN
        l_log_rec.logMsg :='Aborting Client Migration due to multiple errors: '||V_ERRORS;
        MIGR_LOG.LOG_INFO(l_log_rec);
        MIGRATE_CLIENTS.STOP_MIGRATION_PROCESS();
      END IF;
 --EZ 23/4/2019 END

    EXCEPTION
      WHEN OTHERS THEN
         l_log_rec.logMsg := SQLERRM;
         MIGR_LOG.LOG_EXCEPTION(l_log_rec);

    END GET_CLIENT;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--  PROCEDURE STOP_MIGRATION_PROCESS
--    IS
--      l_log_rec MIGR_GVAR.LogRecTyp;
--    BEGIN
--      l_log_rec.mig_batch_id := '0-0';
--      l_log_rec.migrArea     := 'MIGRATE_CLIENTS.STOP_MIGRATION_PROCESS';
--
--      DBMS_PARALLEL_EXECUTE.DROP_TASK('RUN_CLIENTS_MIGR_PROCESS');
--
--    EXCEPTION
--      WHEN OTHERS THEN
--          l_log_rec.logMsg := SQLERRM;
--          MIGR_LOG.LOG_EXCEPTION(l_log_rec);
--
--    END;
--EZ 20190405
    PROCEDURE STOP_MIGRATION_PROCESS
      IS
        l_log_rec MIGR_GVAR.LogRecTyp;
        l_ct      PLS_INTEGER;

      BEGIN

        l_log_rec.mig_batch_id := '0-0';
        l_log_rec.migrArea     := 'MIGRATE_CLIENTS.STOP_MIGRATION_PROCESS';

    	-- stop job
       SELECT COUNT(*) INTO l_ct
         FROM USER_SCHEDULER_JOBS
       WHERE JOB_NAME = 'RUN_CLIENTS_MIGR_PROCESS';

       l_log_rec.logMsg:= 'Before count '||l_ct  ;
       MIGR_LOG.LOG_INFO(l_log_rec);

    	IF l_ct > 0 THEN

        DBMS_SCHEDULER.STOP_JOB(JOB_NAME => 'RUN_CLIENTS_MIGR_PROCESS', FORCE => TRUE);

    	 --Abort all Client Batches
        UPDATE MIG_MIGRATION_INFO set STATUS='Aborted_Clients'
    	   WHERE 1=1
          AND Migration_batch_ID like '00-0%'
       	  AND Status = 'Running_Clients';
        l_log_rec.logMsg:= 'Client Migration Aborted'  ;
       MIGR_LOG.LOG_INFO(l_log_rec);
    	END IF;

    EXCEPTION
      WHEN OTHERS THEN
        l_log_rec.logMsg := SQLERRM;
        MIGR_LOG.LOG_EXCEPTION(l_log_rec);
    END;
--EZ 20190405 END
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- +++ anb 2018-07-19 Get_next must pick up from p_batchID....

    PROCEDURE GET_NEXT_EGN (vNextEGN OUT MIGR_CLIENT.EGN % TYPE,p_batchId IN VARCHAR2)
      IS
      l_log_rec MIGR_GVAR.LogRecTyp;

    BEGIN
      l_log_rec.mig_batch_id :=p_batchId;
      l_log_rec.migrArea     := 'MIGRATE_CLIENTS.GET_NEXT_EGN';

      -- +++ anb 2018-07-19 Get_next must pick up from p_batchID....
      -- SELECT EGN INTO vNextEGN FROM MIGR_CLIENT WHERE NVL(MIGRATED, 'N') = 'N' AND TIMESTAMP IS NULL AND LENGTH(TRIM(EGN)) = 12 AND ROWNUM = 1;
      SELECT EGN INTO vNextEGN FROM MIGR_CLIENT WHERE NVL(MIGRATED, 'N') = 'N' AND TIMESTAMP IS NULL AND LENGTH(TRIM(EGN)) = 12
                                                      and MIG_BATCH_ID = p_batchId AND ROWNUM = 1;
      -- +++ end anb 2018-07-19

      l_log_rec.migrRelKey := vNextEGN;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
          vNextEGN := NULL;
      WHEN OTHERS THEN
          l_log_rec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_log_rec);

    END GET_NEXT_EGN;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    PROCEDURE WAIT_ANY_ALERT (vCOUNTER IN OUT PLS_INTEGER, vEXCEPTION_COUNTER IN OUT PLS_INTEGER,p_batchId IN VARCHAR2)
      IS
      l_log_rec          MIGR_GVAR.LogRecTyp;

      /* Alert Variables */
      vAlertName         VARCHAR2(30);
      vAlertMsg          VARCHAR2(250);
      vAlertStatus       VARCHAR2(1);
      -- vAlertCounter      PLS_INTEGER;
    BEGIN
        l_log_rec.mig_batch_id := p_batchId;
        l_log_rec.migrArea     := 'MIGRATE_CLIENTS.WAIT_ANY_ALERT';
        l_log_rec.migrRelTbl   := '';

        DBMS_ALERT.WAITANY(vAlertName, vAlertMsg, vAlertStatus, 600);
        -- vAlertMsg values returned: 0 - alert occurred, 1 - timeout occurred
        -- If alert occurred -> remove from alert list
        IF vAlertStatus = 0 THEN
            l_Log_Rec.migrRelTbl := 'CLIENT JOB'; l_Log_Rec.logMsg := 'About to REMOVE: ' || vAlertName || ' Running Jobs: ' || vCOUNTER; l_log_rec.migrRelKey := vAlertMsg; MIGR_LOG.LOG_INFO(l_Log_Rec);
            DBMS_ALERT.REMOVE(vAlertName);
            -- We have one job free, go start a new! JOB may still exist in scheduler for few more seconds
            vCOUNTER := vCOUNTER - 1;
        -- If timeout occurred Log and wait again
        ELSIF vAlertStatus = 1 THEN
            l_Log_Rec.migrRelTbl := 'CLIENT JOB'; l_Log_Rec.logMsg := 'ALERT_TIME_OUT: ' || vAlertName || ' Running Jobs: ' || vCOUNTER; l_log_rec.migrRelKey := vAlertMsg; MIGR_LOG.LOG_INFO(l_Log_Rec);
        END IF;

        COMMIT;

    EXCEPTION
        WHEN OTHERS THEN
              vEXCEPTION_COUNTER := vEXCEPTION_COUNTER + 1;
              l_Log_Rec.logMsg   := 'Exception No: ' || vEXCEPTION_COUNTER || ' | Alert Error - ' || SQLERRM; MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);
    END WAIT_ANY_ALERT;


  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- New 'State Machine' Get EPA Client
  PROCEDURE STATE_MACHINE_GET_EPA_CLIENT  (p_batchId IN VARCHAR2)
    IS

      l_log_rec          MIGR_GVAR.LogRecTyp;
      vLogRow            MIGR_PARALLEL_PROCESS_LOG % ROWTYPE;
      vNextEGN           MIGR_CLIENT.EGN % TYPE;
      vSQL               VARCHAR2(4000);
      vCOUNTER           PLS_INTEGER;
      vMAX_RESOURCES     PLS_INTEGER;
      vEXCEPTION_COUNTER PLS_INTEGER;

      Migrate_Client     BOOLEAN;
      TimeOutCleanUp     BOOLEAN;

      /* Job Variables */
      vJOB_NAME          VARCHAR2(30);
      vJOB_TYPE          VARCHAR2(15);
      vJOB_ACTION        VARCHAR2(250);

      vJOB_NAME_TMPL     VARCHAR2(30);
      vJOB_COUNTER       PLS_INTEGER;

      vAlertCounter      PLS_INTEGER;

      TOTAL_CLIENTS      PLS_INTEGER;
      l_failedClients    PLS_INTEGER;
      l_clients_report VARCHAR2(2000);
      vSTATE             VARCHAR2(30);
      vNEXT_STATE        VARCHAR2(30);
      vRESOURCES_NEEDED  PLS_INTEGER;
  BEGIN

        l_log_rec.migrArea     := 'MIGRATE_CLIENTS.STATE_MACHINE_GET_EPA_CLIENT';
        l_log_rec.migrRelTbl   := '';
        l_log_rec.mig_batch_id:=p_batchId;
         MIGR_LOG.LOG_INFO(l_log_rec) ;
        vSQL               := '';
        vCOUNTER           := 0;
        vRESOURCES_NEEDED  := 0;
        TOTAL_CLIENTS      := 0;
        vAlertCounter      := 0;
        vEXCEPTION_COUNTER := 0;

        vJOB_TYPE := 'PLSQL_BLOCK'; vJOB_NAME_TMPL := 'CL_'; vJOB_COUNTER := 0;

        -- dbms_alert init
        DBMS_ALERT.SET_DEFAULTS(1);  -- dbms_alert sensitivity - polling interval, in seconds, to sleep between polls
        DBMS_ALERT.REMOVEALL();      -- dbms_alert clean up

        Migrate_Client := TRUE;
        TimeOutCleanUp := TRUE;
        vSTATE         := 'GetEGN';

        -- SELECT COUNT(*) INTO TOTAL_CLIENTS FROM MIGR_CLIENT WHERE TIMESTAMP IS NULL AND LENGTH(TRIM(EGN)) = 12;
        SELECT COUNT(*) INTO TOTAL_CLIENTS FROM MIGR_CLIENT WHERE NVL(MIGRATED, 'N') = 'N' AND TIMESTAMP IS NULL AND LENGTH(TRIM(EGN)) = 12  AND MIG_BATCH_ID=''||p_batchId|| '';

        l_Log_Rec.logMsg := 'About to migrate ' || TOTAL_CLIENTS || ' client(s).';
        MIGR_LOG.LOG_INFO(l_Log_Rec);
       -- Start of Client migration!
       ---MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION ( '0-0', MIGR_GVAR.GV_MSG_CODE_MIGR_CLIENT_START );
        MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION (''||p_batchId||'', MIGR_GVAR.GV_MSG_CODE_MIGR_CLIENT_START );
        MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;

        WHILE Migrate_Client
        LOOP

            -- Check the PARALLEL_LEVEL field from ETL_SETUP_INFO
--  LM - 20180302 - Choose parallel level according to daily plan in ETL_PARALLEL_LEVEL_PER_TIME table - Start
--            SELECT NVL(PARALLEL_LEVEL, 0) INTO vMAX_RESOURCES FROM ETL_SETUP_INFO;
          SELECT
             CASE
                (SELECT PLAN FROM ETL_PARALLEL_LEVEL_PER_TIME eplpt
                      WHERE TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) >=eplpt.TIME_FROM
                        AND TRIM(TO_CHAR(SYSTIMESTAMP, 'HH24:MI:SS')) <= eplpt.TIME_TO)
              WHEN 'HIGH' THEN NVL(PARALLEL_LEVEL, 1)
              WHEN 'MID'  THEN NVL(MID_PARALLEL_LEVEL, 1)
              WHEN 'MIN'  THEN NVL(MIN_PARALLEL_LEVEL, 1)
              ELSE 1
             END AS NEW_PRL_LEVEL INTO vMAX_RESOURCES
            FROM ETL_SETUP_INFO;
--  LM - 20180302 - End

            IF vMAX_RESOURCES = 0 THEN
--                IF vSTATE = 'Exit_Migration' THEN
                    vRESOURCES_NEEDED := vMAX_RESOURCES;
                    vSTATE            := 'Flush_Queue';
                    vNEXT_STATE       := 'Exit_Migration';
--                END IF;
            END IF;

            CASE vSTATE
                 WHEN 'GetEGN' THEN
                                GET_NEXT_EGN(vNextEGN,p_batchId);
                                IF NOT vNextEGN IS NULL THEN
                                    vRESOURCES_NEEDED := vRESOURCES_NEEDED + 1;
                                    vSTATE := 'Check_Resources';
                                ELSE
                                    vRESOURCES_NEEDED := vMAX_RESOURCES;
                                    vSTATE            := 'Flush_Queue';
                                    vNEXT_STATE       := 'Exit_Migration';
                                END IF;

                 WHEN 'Check_Resources' THEN

                                IF vCOUNTER < vMAX_RESOURCES THEN

                                    vJOB_COUNTER := vJOB_COUNTER + 1;
                                    vJOB_NAME    := vJOB_NAME_TMPL || vJOB_COUNTER; -- vNextEGN;

                                    vJOB_ACTION  := 'BEGIN MIGRATE_CLIENTS.GET_CLIENT( ''' || vNextEGN || ''' ,''' || p_batchId || '''); DBMS_ALERT.SIGNAL( ''' || vJOB_NAME || ''', ''' || vNextEGN || ''' ); UPDATE MIGR_PARALLEL_PROCESS_LOG SET TIME_END = SYSTIMESTAMP WHERE KEY = ''' || vNextEGN || '''; COMMIT; END;';

                                    l_Log_Rec.migrRelKey := vNextEGN; l_Log_Rec.migrRelTbl := 'CLIENT JOB'; l_Log_Rec.logMsg := 'About to CREATE: ' || vJOB_NAME || ' Running Jobs: ' || vCOUNTER; MIGR_LOG.LOG_INFO(l_Log_Rec);

                                    -- Start a new job
                                    BEGIN
                                        -- Increase current running jobs + 1 and resources needed - 1
                                        vCOUNTER          := vCOUNTER + 1;
                                        vRESOURCES_NEEDED := vRESOURCES_NEEDED - 1;

                                        vSTATE := 'GetEGN';

                                        l_Log_Rec.migrRelTbl:='CLIENT JOB'; l_Log_Rec.logMsg := 'About to REGISTER: ' || vJOB_NAME; MIGR_LOG.LOG_INFO(l_Log_Rec);
                                        DBMS_ALERT.REGISTER(vJOB_NAME);

                                        l_Log_Rec.logMsg := 'UPDATE MIGR_CLIENT - ';
                                        UPDATE MIGR_CLIENT SET TIMESTAMP = SYSTIMESTAMP WHERE EGN = vNextEGN;

                                        l_Log_Rec.logMsg := 'INSERT INTO MIGR_PARALLEL_PROCESS_LOG - ';
                                        vLogRow.KEY := vNextEGN; vLogRow.TIME_START := SYSTIMESTAMP; vLogRow.TIME_END := NULL;
                                        INSERT INTO MIGR_PARALLEL_PROCESS_LOG VALUES vLogRow;

                                        COMMIT;

                                        l_Log_Rec.logMsg   := 'Scheduler - ';
                                        DBMS_SCHEDULER.CREATE_JOB(
                                          JOB_NAME        => vJOB_NAME,
                                          JOB_TYPE        => vJOB_TYPE,
                                          JOB_ACTION      => vJOB_ACTION,
                                          START_DATE      => NULL,        -- Schedule job will run as soon as it is enabled
                                          REPEAT_INTERVAL => NULL,        -- Schedule job will run only once
                                          ENABLED         => TRUE,
                                          AUTO_DROP       => TRUE
                                        );

                                        COMMIT;

                                    EXCEPTION
                                        WHEN OTHERS THEN
                                              vSTATE            := 'Check_Resources';
                                              vCOUNTER          := vCOUNTER - 1;
                                              vRESOURCES_NEEDED := vRESOURCES_NEEDED + 1;

                                              UPDATE MIGR_CLIENT SET TIMESTAMP = NULL WHERE EGN = vNextEGN;

                                              DELETE FROM MIGR_PARALLEL_PROCESS_LOG WHERE KEY = vNextEGN;

                                              FOR xx IN ( SELECT ai.NAME FROM SYS.DBMS_ALERT_INFO ai WHERE UPPER(ai.NAME) = UPPER(vJOB_NAME) )
                                              LOOP
                                                  l_Log_Rec.migrRelTbl := 'CLIENT JOB'; l_Log_Rec.logMsg := 'About to CLEAN UP Alert Info: ' || xx.NAME || ' Running Jobs: ' || vCOUNTER; MIGR_LOG.LOG_INFO(l_Log_Rec);
                                                  DBMS_ALERT.REMOVE(xx.NAME);
                                              END LOOP;

                                              vEXCEPTION_COUNTER := vEXCEPTION_COUNTER + 1; l_Log_Rec.logMsg := l_Log_Rec.logMsg || ' - ' || SQLERRM; l_log_rec.migrRelKey := NULL;
                                              MIGR_LOG.LOG_EXCEPTION(l_Log_Rec);
                                    END;

                                ELSE
                                    vSTATE      := 'Flush_Queue';
                                    vNEXT_STATE := 'Check_Resources';

                                END IF;

                 WHEN 'Flush_Queue' THEN
                                WHILE vRESOURCES_NEEDED > vMAX_RESOURCES - vCOUNTER
                                LOOP
                                    WAIT_ANY_ALERT(vCOUNTER, vEXCEPTION_COUNTER, p_batchId);
                                END LOOP;
                                vSTATE := vNEXT_STATE;

                 WHEN 'Exit_Migration' THEN
                                -- pl 20161114: Add a timeout-error clean up and rerun. Max number of attempts per client: 2!
                                IF TimeOutCleanUp = TRUE THEN
                                      l_Log_Rec.logMsg := 'About to CLEAN UP Clients TimeOut Errors.'; l_log_rec.migrRelKey := NULL; MIGR_LOG.LOG_INFO(l_Log_Rec);

                                      --
                                     ---- vSQL := 'UPDATE MIGR_CLIENT mc SET mc.MAN_ID = NULL, mc.CLIENT_ID = NULL, mc.ADDRESS_ID = NULL, mc.EXEC_ID = NULL, mc.ERR_MSG = NULL, mc.MIGRATED = ''N'', mc.TIMESTAMP = NULL WHERE NVL(mc.MIGRATED, ''N'') = ''N'''; -- OR NOT mc.ERR_MSG IS NULL';
                                      UPDATE MIGR_CLIENT mc
                                        SET mc.MAN_ID = NULL, mc.CLIENT_ID = NULL, mc.ADDRESS_ID = NULL, mc.EXEC_ID = NULL, mc.ERR_MSG = NULL, mc.MIGRATED = 'N', mc.TIMESTAMP = NULL
                                        WHERE NVL(mc.MIGRATED, 'N') = 'N' and mc.MIG_BATCH_ID=p_batchId;
                                     ---- EXECUTE IMMEDIATE vSQL;

                                      l_Log_Rec.logMsg := 'End of Clients TimeOut Errors CLEAN UP.'; MIGR_LOG.LOG_INFO(l_Log_Rec);

                                      -- Client error clean up!
                                      MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_NOTIFICATION (''||p_batchId||'', MIGR_GVAR.GV_MSG_CODE_MIGR_CL_CLEANUP );
                                      MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;
                                      TimeOutCleanUp := FALSE;

                                      vRESOURCES_NEEDED  := 0;
                                      vJOB_COUNTER       := 0;
                                      vJOB_NAME_TMPL     := vJOB_NAME_TMPL || 'ReRun_';
                                      vSTATE             := 'GetEGN';

                                ELSE
                                      Migrate_Client   := FALSE;
                                      l_Log_Rec.logMsg := 'End of Client Migration process.'; MIGR_LOG.LOG_INFO(l_Log_Rec);
                                      -- End of Client migration!
                                      --FA.20170615 Notify how many clients Fail.
                                      SELECT COUNT(*) INTO l_failedClients FROM MIGR_CLIENT WHERE MIGRATED = 'N' and MIG_BATCH_ID=p_batchId;
                                       IF l_failedClients >0 THEN
                                       l_clients_report :=  ' Total Processed Clients: ' ||TOTAL_CLIENTS ||  ' - Failed Clients: ' ||l_failedClients || '. MIGR_CLIENT table holds the detailed error messages.';
                                       ELSE
                                          l_clients_report := 'All clients were migrate succesfully' ;
                                       END IF;
                                         MIGR_EMAIL_NOTIFICATION.CREATE_EMAIL_WITH_DYNAMIC_MSG ( ''||p_batchId||'', MIGR_GVAR.GV_MSG_CODE_MIGR_CLIENT_END, l_clients_report );
                                         MIGR_EMAIL_NOTIFICATION.SERVICE_EMAIL_QUEUE;
                                      UPDATE MIG_MIGRATION_INFO mmi set STATUS =MIGR_GVAR.GV_BATCH_STATUS_FINISHED_CL, mmi.END_TIMESTAMP=SYSTIMESTAMP  where mmi.MIGRATION_BATCH_ID=p_batchId;
                                END IF;

                 ELSE
                                vRESOURCES_NEEDED := vMAX_RESOURCES;
                                vSTATE            := 'Flush_Queue';
                                vNEXT_STATE       := 'Exit_Migration';
                                l_Log_Rec.logMsg  := 'Client Migration process stopped.'; MIGR_LOG.LOG_INFO(l_Log_Rec);

            END CASE;

        END LOOP;


        -- Dont loop the SYS.DBMS_ALERT_INFO. Just REMOVEALL!
        DBMS_ALERT.REMOVEALL();

        COMMIT;

    EXCEPTION
      WHEN OTHERS THEN
        l_log_rec.logMsg := SQLERRM; l_log_rec.migrRelTbl := vSQL; l_log_rec.migrRelKey := NULL; MIGR_LOG.LOG_EXCEPTION(l_log_rec);

  END STATE_MACHINE_GET_EPA_CLIENT;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ---TRIGGER Job for client migration

  -- ++ anb 2018-08-03  !!!!!!!!!!!!!!!  WARNING !!!!!!!!!!!!!!!!!!!!! DBMS_SCHEDULER.CREATE_JOB() performs auto commit for the session !
  --                    The whole RUN_CLIENTS_MIGRATION_PROCESS() and LOAD_TO_MIGR_CLIENT() routines do NOT commit !!

  PROCEDURE RUN_CLIENTS_MIGRATION_PROCESS
    IS
      l_log_rec   MIGR_GVAR.LogRecTyp;
      l_newId     MIG_MIGRATION_INFO.ID%TYPE;
      l_batchId   MIG_MIGRATION_INFO.MIGRATION_BATCH_ID%TYPE;
     --l_batchId  VARCHAR2(50);
  BEGIN

      l_log_rec.migrArea     := 'MIGRATE_CLIENTS.RUN_CLIENTS_MIGRATION_PROCESS';
      l_log_rec.migrRelTbl   := '';
      MIGR_LOG.LOG_INFO(l_log_rec);

--      --FA.20170913 Create a batch id for clients runs
--     SELECT NVL(MAX(ID),0)+1 into l_newId FROM MIG_MIGRATION_INFO;
--
--     l_batchId := '00-0' || l_newId;
--
--     INSERT INTO MIG_MIGRATION_INFO (MIGRATION_BATCH_ID, START_TIMESTAMP, END_TIMESTAMP, STATUS,  ID, LA_COMPLETED,SA_COMPLETED,RULES_COMPLETED,IA_COMPLETED,DISCOUNT_COMPLETED,DATA_MOVED_TO_ARCHIVE,DISCOUNTS_FILE_CREATED,DISCOUNTS_TXT_ARCHIVED,COMPLETED_TXT_ARCHIVED
--      )
--      VALUES(  l_batchId  ,  SYSTIMESTAMP ,  NULL  ,MIGR_GVAR.GV_BATCH_STATUS_RUNNING_CL,   l_newId,'N/A','N/A','N/A','N/A','N/A','N/A','N/A','N/A','N/A');
--
--
--      l_log_rec.mig_batch_id :=  l_batchId ;
--      LOAD_TO_MIGR_CLIENT(l_batchId); --valex.1/3/2017 - merge EGNs to MIGR_CLIENT and log invalid and already found EGNs to MIG_DETAIL_ERROR_LOG

--++ EZ.20190405 Create a batch id for clients runs
     l_batchId :='00-0';
      For c in (
              With all_batch as (
                      Select Migration_batch_id from MIG_MIGRATION_INFO
                      where 1=1
                      and Migration_batch_ID like '00-0%'
                      and status in ('Running_Clients', 'Aborted_Clients')
                      order by START_TIMESTAMP
              )
              Select Migration_batch_id
                from all_batch
              Where 1=1
              and rownum=1
      )

      Loop
           l_batchId := c.Migration_batch_id;
           l_log_rec.logMsg:= 'Migration batch ID:'||l_batchId  ;
           MIGR_LOG.LOG_INFO(l_log_rec);

           EXIT;
      End loop; --Exit loop pick the oldest one

       If l_batchId = '00-0' then   -- no Aborted/Running Batches
         SELECT NVL(MAX(ID),0)+1 into l_newId FROM MIG_MIGRATION_INFO;
          l_batchId := '00-0'||l_newId;

         INSERT INTO MIG_MIGRATION_INFO (MIGRATION_BATCH_ID, START_TIMESTAMP, END_TIMESTAMP, STATUS,  ID, LA_COMPLETED,SA_COMPLETED,RULES_COMPLETED,IA_COMPLETED,DISCOUNT_COMPLETED,DATA_MOVED_TO_ARCHIVE,DISCOUNTS_FILE_CREATED,DISCOUNTS_TXT_ARCHIVED,COMPLETED_TXT_ARCHIVED
          )
          VALUES(  l_batchId  ,  SYSTIMESTAMP ,  NULL  ,MIGR_GVAR.GV_BATCH_STATUS_RUNNING_CL,   l_newId,'N/A','N/A','N/A','N/A','N/A','N/A','N/A','N/A','N/A');


          l_log_rec.mig_batch_id :=  l_batchId ;
          LOAD_TO_MIGR_CLIENT(l_batchId); --valex.1/3/2017 - merge EGNs to MIGR_CLIENT and log invalid and already found EGNs to MIG_DETAIL_ERROR_LOG
       ELSE
          UPDATE MIG_MIGRATION_INFO set STATUS='Running_Clients'
    	     WHERE 1=1
             AND Migration_batch_ID =l_batchId
    	       AND Status = 'Aborted_Clients';
       End if;
--++ EZ.20190405 Create a batch id for clients runs END

-- ++ anb 2018-08-03  !!!!!!!!!!!!!!!  WARNING !!!!!!!!!!!!!!!!!!!!! DBMS_SCHEDULER.CREATE_JOB() performs auto commit for the session !
      DBMS_SCHEDULER.CREATE_JOB(
         JOB_NAME        => 'RUN_CLIENTS_MIGR_PROCESS',
         JOB_TYPE        => 'PLSQL_BLOCK',
         JOB_ACTION      => 'BEGIN MIGRATE_CLIENTS.STATE_MACHINE_GET_EPA_CLIENT('''|| l_batchId  || '''); END;',
--         START_DATE      => TO_TIMESTAMP('28-10-2016 18:00:00', 'DD-MM-YYYY HH24:MI:SS'),
         START_DATE      => NULL,    -- Schedule job will run as soon as it is enabled
         REPEAT_INTERVAL => NULL,    -- Schedule job will run only once
         ENABLED         => TRUE,
         AUTO_DROP       => TRUE
      );

  EXCEPTION
      WHEN OTHERS THEN
          l_log_rec.logMsg := SQLERRM;
          MIGR_LOG.LOG_EXCEPTION(l_log_rec);

  END RUN_CLIENTS_MIGRATION_PROCESS;

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--valex.1/3/17 - this proc merges valid EGNs from CLIENT_LOAD to MIGR_CLIENT. Invalid ones and already existing are logged to MIG_DETAIL_ERROR_LOG

-- ++ anb 2018-08-03  !!!!!!!!!!!!!!!  WARNING !!!!!!!!!!!!!!!!!!!!! DBMS_SCHEDULER.CREATE_JOB() performs auto commit for the session !
  --                    The whole RUN_CLIENTS_MIGRATION_PROCESS() and LOAD_TO_MIGR_CLIENT() routines do NOT commit !!

procedure LOAD_TO_MIGR_CLIENT (p_batchId VARCHAR2)
as
  CURSOR KF is
      SELECT *
      FROM MIG_DETAIL_ERROR_LOG;
   TYPE KF_tab IS TABLE OF KF%ROWTYPE;
   KF_all_records   KF_tab:= KF_tab();

   l_LogRec           MIGR_GVAR.LogRecTyp;
   vCopy BOOLEAN:=FALSE;
   vDelete BOOLEAN:=FALSE;
   v_time varchar2(50):=to_char(systimestamp, 'yyyy-mm-dd@hh24-mi-ss');
   l_file VARCHAR2(500);

 BEGIN


   l_LogRec.migrArea := 'MIGRATE_CLIENTS.LOAD_TO_MIGR_CLIENT';
    l_LogRec.mig_batch_id:=  p_batchId;
  --valid and not existing already in MIGR_CLIENT egns are inserted
  --MERGE INTO migr_client t USING (select DISTINCT ssN,BOLAG_ID FROM CLIENT_LOAD WHERE  REGEXP_LIKE(ssN,'^(\d){12}$')) s
  --valex.8/3/17 - activate below to deduplicate client.txt EGNs while transposing potentially different bolag_ids (per EGN) under BOLAG_ID column. If so, BOLAG_ID has to be changed to varchar2 type
  MERGE INTO migr_client t USING (with x AS (select DISTINCT ssn,BOLAG_ID
                                                 FROM CLIENT_LOAD
                                                 WHERE  REGEXP_LIKE(ssn,'^(\d){12}$') )
                                      select ssn,LISTAGG(to_char(BOLAG_ID), ',') WITHIN GROUP (ORDER BY (BOLAG_ID)) AS BOLAG_ID
                                      from x
                                      group by ssn) s
  ON (t.egn=s.ssn)
  when NOT MATCHED THEN INSERT (EGN, bolag_id) VALUES (s.ssn, s.bolag_id);

  --invalid and already existing are logged to MIG_DETAIL_ERROR_LOG
  SELECT p_batchId as migration_batch_id
           , SYSTIMESTAMP AS ERROR_TIMESTAMP
           ,'Clients Loading'   AS MIGRATION_AREA
           ,'EXCEPTION' AS ERROR_TYPE
           ,CASE WHEN flag=1 then 'EGN already in MIGR_CLIENT' else 'EGN not in 12-digit format' end AS ERROR_MESSAGE
           ,'Loading client EGNs from CLIENT.txt to MIGR_CLIENT' AS MIGRATION_STEP
           ,'MIGR_CLIENT' AS RELATED_TABLE
            , ssn AS RELATED_KEY
  BULK COLLECT INTO KF_all_records
  FROM (select distinct a.SSN, 1 AS flag     --already existing
        from client_load a join migr_client b on a.ssn=b.EGN
            UNION ALL
        SELECT distinct a.SSN,2 as flag    --invalid
          FROM CLIENT_LOAD a
        WHERE not REGEXP_LIKE(a.SSN,'^(\d){12}$'));

   --FA.20170914 Update control table with batch info
   UPDATE MIGR_CLIENT mc SET mc.MIG_BATCH_ID=p_batchId where  mc.MIG_BATCH_ID is NULL;

  FORALL i IN KF_all_records.FIRST ..KF_all_records.COUNT
  INSERT  INTO MIG_DETAIL_ERROR_LOG VALUES KF_all_records(i);

     l_LogRec.logMsg := 'Clients are loaded';
     MIGR_LOG.LOG_INFO(l_logRec);

  --valex.17/3/17 - CLIENTS file is archived upon merge

  FOR c IN ( SELECT CLIENT_MIGG_DIR, CLIENT_MIGG_DIR_ARC, CLIENT_FILE_NAME, ARCHIVE_MODE
             FROM ETL_SETUP_INFO
  )
  loop
      l_file := SUBSTR(c.client_file_name,1,INSTR(c.client_file_name,'.')-1); -- Client file name without file extention
      l_file:= l_file||'_'||v_time||'.txt';
      CASE
        WHEN c.ARCHIVE_MODE = 'Copy' THEN
          vCopy := TRUE;
        WHEN c.ARCHIVE_MODE = 'Remove' THEN
          vCopy := TRUE;
          vDelete := TRUE;
        ELSE l_LogRec.logMsg := 'Incorrect archive mode parameter in ETL_SETUP_INFO';
          MIGR_LOG.LOG_ERROR(l_LogRec);

      END CASE;


      IF vCopy
      THEN
        -- Copy the file in the archive location
        UTL_FILE.FCOPY(
        src_location => 'READ_DIR_CLIENT',
        src_filename => c.CLIENT_FILE_NAME,
        dest_location => 'READ_DIR_CLIENT_ARC',
        dest_filename => l_file
        );
      END IF;

      IF vDelete
      THEN
        UTL_FILE.FREMOVE(
        location => 'READ_DIR_CLIENT',
        filename => c.CLIENT_FILE_NAME
        );
      END IF;

             --FA.20170914 Update archive status in mig_migration_info
      UPDATE MIG_MIGRATION_INFO mmi SET mmi.ARCHIVED=  MIGR_GVAR.GV_BATCH_STATUS_FINISHED WHERE mmi.MIGRATION_BATCH_ID=p_batchId;


      END LOOP;

  l_LogRec.logMsg := 'Clients file is archived';
  MIGR_LOG.LOG_INFO(l_logRec);

   --valex.17/3/17 - end

  EXCEPTION WHEN OTHERS THEN
     l_LogRec.logMsg := SQLERRM;
     MIGR_LOG.LOG_EXCEPTION(l_LogRec);
  end LOAD_TO_MIGR_CLIENT;
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

END MIGRATE_CLIENTS;
/

spool off;
exit;
